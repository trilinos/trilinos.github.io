<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Anasazi: Anasazi Eigensolver Framework</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Anasazi<span id="projectnumber">&#160;Version of the Day</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle"><div class="title">Anasazi Eigensolver Framework</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_anasazi_1_1_block_davidson.html">Anasazi::BlockDavidson&lt; ScalarType, MV, OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a Block Davidson iteration, a preconditioned iteration for solving linear Hermitian eigenproblems.  <a href="class_anasazi_1_1_block_davidson.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_anasazi_1_1_block_davidson_sol_mgr.html">Anasazi::BlockDavidsonSolMgr&lt; ScalarType, MV, OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_anasazi_1_1_block_davidson_sol_mgr.html" title="The BlockDavidsonSolMgr provides a powerful solver manager over the BlockDavidson eigensolver.">BlockDavidsonSolMgr</a> provides a powerful solver manager over the <a class="el" href="class_anasazi_1_1_block_davidson.html" title="This class implements a Block Davidson iteration, a preconditioned iteration for solving linear Hermi...">BlockDavidson</a> eigensolver.  <a href="class_anasazi_1_1_block_davidson_sol_mgr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_anasazi_1_1_block_krylov_schur.html">Anasazi::BlockKrylovSchur&lt; ScalarType, MV, OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the block Krylov-Schur iteration, for solving linear eigenvalue problems.  <a href="class_anasazi_1_1_block_krylov_schur.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_anasazi_1_1_block_krylov_schur_sol_mgr.html">Anasazi::BlockKrylovSchurSolMgr&lt; ScalarType, MV, OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_anasazi_1_1_block_krylov_schur_sol_mgr.html" title="The Anasazi::BlockKrylovSchurSolMgr provides a flexible solver manager over the BlockKrylovSchur eige...">Anasazi::BlockKrylovSchurSolMgr</a> provides a flexible solver manager over the <a class="el" href="class_anasazi_1_1_block_krylov_schur.html" title="This class implements the block Krylov-Schur iteration, for solving linear eigenvalue problems.">BlockKrylovSchur</a> eigensolver.  <a href="class_anasazi_1_1_block_krylov_schur_sol_mgr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_anasazi_1_1_generalized_davidson_sol_mgr.html">Anasazi::GeneralizedDavidsonSolMgr&lt; ScalarType, MV, OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver Manager for <a class="el" href="class_anasazi_1_1_generalized_davidson.html" title="Solves eigenvalue problem using generalized Davidson method.">GeneralizedDavidson</a>.  <a href="class_anasazi_1_1_generalized_davidson_sol_mgr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_anasazi_1_1_i_r_t_r.html">Anasazi::IRTR&lt; ScalarType, MV, OP &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_anasazi_1_1_l_o_b_p_c_g.html">Anasazi::LOBPCG&lt; ScalarType, MV, OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the Locally Optimal Block Preconditioned Conjugate Gradient (LOBPCG) iteration, a preconditioned iteration for solving linear Hermitian eigenproblems.  <a href="class_anasazi_1_1_l_o_b_p_c_g.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_anasazi_1_1_l_o_b_p_c_g_sol_mgr.html">Anasazi::LOBPCGSolMgr&lt; ScalarType, MV, OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">User interface for the <a class="el" href="class_anasazi_1_1_l_o_b_p_c_g.html" title="This class provides the Locally Optimal Block Preconditioned Conjugate Gradient (LOBPCG) iteration,...">LOBPCG</a> eigensolver.  <a href="class_anasazi_1_1_l_o_b_p_c_g_sol_mgr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_anasazi_1_1_randomized_sol_mgr.html">RandomizedSolMgr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_anasazi_1_1_randomized_sol_mgr.html" title="The Anasazi::RandomizedSolMgr approximates largest eigenvalues/eigenvectors by performing a simple Ra...">Anasazi::RandomizedSolMgr</a> approximates largest eigenvalues/eigenvectors by performing a simple Rayleigh-Ritz projection over a random block of vectors.  <a href="class_anasazi_1_1_randomized_sol_mgr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_anasazi_1_1_r_t_r_base.html">Anasazi::RTRBase&lt; ScalarType, MV, OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is an abstract base class for Implicit Riemannian Trust-Region based eigensolvers. The class provides the interfaces shared by the IRTR solvers (e.g., <a class="el" href="class_anasazi_1_1_r_t_r_base.html#aff1263a00aa7d6c489b5cea968edc3ea" title="Get the current state of the eigensolver.">getState()</a> and <a class="el" href="class_anasazi_1_1_r_t_r_base.html#a8b5f223b31d23f9d776d74a65a467fae" title="Initialize the solver with the initial vectors from the eigenproblem or random data.">initialize()</a>) as well as the shared implementations (e.g., inner products).  <a href="class_anasazi_1_1_r_t_r_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_anasazi_1_1_r_t_r_sol_mgr.html">Anasazi::RTRSolMgr&lt; ScalarType, MV, OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_anasazi_1_1_r_t_r_sol_mgr.html" title="The Anasazi::RTRSolMgr provides a simple solver manager over the RTR eigensolver. For more informatio...">Anasazi::RTRSolMgr</a> provides a simple solver manager over the RTR eigensolver. For more information, see the discussion for <a class="el" href="class_anasazi_1_1_r_t_r_base.html" title="This class is an abstract base class for Implicit Riemannian Trust-Region based eigensolvers....">RTRBase</a>.  <a href="class_anasazi_1_1_r_t_r_sol_mgr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_anasazi_1_1_simple_l_o_b_p_c_g_sol_mgr.html">Anasazi::SimpleLOBPCGSolMgr&lt; ScalarType, MV, OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_anasazi_1_1_simple_l_o_b_p_c_g_sol_mgr.html" title="The Anasazi::SimpleLOBPCGSolMgr provides a simple solver manager over the LOBPCG eigensolver.">Anasazi::SimpleLOBPCGSolMgr</a> provides a simple solver manager over the <a class="el" href="class_anasazi_1_1_l_o_b_p_c_g.html" title="This class provides the Locally Optimal Block Preconditioned Conjugate Gradient (LOBPCG) iteration,...">LOBPCG</a> eigensolver.  <a href="class_anasazi_1_1_simple_l_o_b_p_c_g_sol_mgr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_anasazi_1_1_s_i_r_t_r.html">Anasazi::SIRTR&lt; ScalarType, MV, OP &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_anasazi_1_1_experimental_1_1_trace_min.html">Anasazi::Experimental::TraceMin&lt; ScalarType, MV, OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a TraceMIN iteration, a preconditioned iteration for solving linear symmetric positive definite eigenproblems.  <a href="class_anasazi_1_1_experimental_1_1_trace_min.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_anasazi_1_1_experimental_1_1_trace_min_base.html">Anasazi::Experimental::TraceMinBase&lt; ScalarType, MV, OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an abstract base class for the trace minimization eigensolvers.  <a href="class_anasazi_1_1_experimental_1_1_trace_min_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_anasazi_1_1_experimental_1_1_trace_min_base_sol_mgr.html">Anasazi::Experimental::TraceMinBaseSolMgr&lt; ScalarType, MV, OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Anasazi::TraceMinBaseSolMgr provides an abstract base class for the <a class="el" href="class_anasazi_1_1_experimental_1_1_trace_min.html" title="This class implements a TraceMIN iteration, a preconditioned iteration for solving linear symmetric p...">TraceMin</a> series of solver managers.  <a href="class_anasazi_1_1_experimental_1_1_trace_min_base_sol_mgr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_anasazi_1_1_experimental_1_1_trace_min_davidson.html">Anasazi::Experimental::TraceMinDavidson&lt; ScalarType, MV, OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a TraceMin-Davidson iteration for solving symmetric generalized eigenvalue problems.  <a href="class_anasazi_1_1_experimental_1_1_trace_min_davidson.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_anasazi_1_1_experimental_1_1_trace_min_davidson_sol_mgr.html">Anasazi::Experimental::TraceMinDavidsonSolMgr&lt; ScalarType, MV, OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Anasazi::TraceMinDavidsonSolMgr provides a flexible solver manager over the <a class="el" href="class_anasazi_1_1_experimental_1_1_trace_min_davidson.html" title="This class implements a TraceMin-Davidson iteration for solving symmetric generalized eigenvalue prob...">TraceMinDavidson</a> eigensolver.  <a href="class_anasazi_1_1_experimental_1_1_trace_min_davidson_sol_mgr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_anasazi_1_1_experimental_1_1_trace_min_sol_mgr.html">Anasazi::Experimental::TraceMinSolMgr&lt; ScalarType, MV, OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Anasazi::TraceMinSolMgr provides a flexible solver manager over the <a class="el" href="class_anasazi_1_1_experimental_1_1_trace_min.html" title="This class implements a TraceMIN iteration, a preconditioned iteration for solving linear symmetric p...">TraceMin</a> eigensolver.  <a href="class_anasazi_1_1_experimental_1_1_trace_min_sol_mgr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Anasazi is a framework for developing large-scale iterative eigensolvers. When developing such a framework, or even a collection of different solvers, one will notice a large amount of overlap among different implementations. For example, two separate eigensolvers may utilize the same orthogonalization methods, whereas two different implementations of a particular eigensolver may utilize different orthogonalization routines. Dividing the different tasks associated with an iterative eigensolver into multiple routines enables increased code reuse and eases code maintenance. The question arises: how does one distill the essence of a particular eigensolver, with the end goal of separating this code from the supporting code?</p>
<p>To illustrate this dilemma, consider the block Davidson iteration. The essence of the algorithm can be distilled as follows: a preconditioner is applied to the current residual vectors, and the resulting vectors are used to expand a subspace from which the next eigenvector approximations (and their residuals) are computed. However, a multitude of choices abound in implementing this simple iteration: the size of the computed basis, whether and how the method is restarted, the convergence criterion for the algorithm, and the use of deflation (locking) mechanisms, etc.</p>
<p>Many of these decisions are separate from the actual iteration. Extracting the essential nature of an iteration results in a simpler piece of code to develop, debug and maintain. The Anasazi iterative eigensolver framework encourages this by providing three distinct entities to fulfill the roles needed by an eigensolver: <a class="el" href="class_anasazi_1_1_eigensolver.html" title="The Eigensolver is a templated virtual base class that defines the basic interface that any eigensolv...">Anasazi::Eigensolver</a>, <a class="el" href="class_anasazi_1_1_status_test.html" title="Common interface of stopping criteria for Anasazi&#39;s solvers.">Anasazi::StatusTest</a> and <a class="el" href="class_anasazi_1_1_solver_manager.html" title="The Anasazi::SolverManager is a templated virtual base class that defines the basic interface that an...">Anasazi::SolverManager</a>:</p>
<ul>
<li><a class="el" href="class_anasazi_1_1_eigensolver.html" title="The Eigensolver is a templated virtual base class that defines the basic interface that any eigensolv...">Anasazi::Eigensolver</a> implements the features necessary to describe an eigensolver iteration. The iteration state accessors (e.g., <a class="el" href="class_anasazi_1_1_block_davidson.html#a7cb77a6207a23f8f3026e935fa877ea6" title="Get access to the current state of the eigensolver.">Anasazi::BlockDavidson::getState()</a> and <a class="el" href="class_anasazi_1_1_block_davidson.html#a6ca111c23545705e8bf3120b3ac24659" title="Initialize the solver with the initial vectors from the eigenproblem or random data.">Anasazi::BlockDavidson::initialize()</a>) provide access to private member data, and the iteration occurs inside the <a class="el" href="class_anasazi_1_1_eigensolver.html#ae871bd1ab76b84edeea22dd04fcf3053" title="This method performs eigensolvers iterations until the status test indicates the need to stop or an e...">Anasazi::Eigensolver::iterate()</a> method.</li>
<li><a class="el" href="class_anasazi_1_1_status_test.html" title="Common interface of stopping criteria for Anasazi&#39;s solvers.">Anasazi::StatusTest</a> determines when an iteration is to be terminated. Inside the <a class="el" href="class_anasazi_1_1_eigensolver.html#ae871bd1ab76b84edeea22dd04fcf3053" title="This method performs eigensolvers iterations until the status test indicates the need to stop or an e...">Anasazi::Eigensolver::iterate()</a> method, the eigensolver queries a <a class="el" href="class_anasazi_1_1_status_test.html" title="Common interface of stopping criteria for Anasazi&#39;s solvers.">Anasazi::StatusTest</a> object in order to determine when to return from the <a class="el" href="class_anasazi_1_1_eigensolver.html#ae871bd1ab76b84edeea22dd04fcf3053" title="This method performs eigensolvers iterations until the status test indicates the need to stop or an e...">Anasazi::Eigensolver::iterate()</a> method.</li>
<li><a class="el" href="class_anasazi_1_1_solver_manager.html" title="The Anasazi::SolverManager is a templated virtual base class that defines the basic interface that an...">Anasazi::SolverManager</a> provides a simplified interface to a particular eigensolver. A solver manager implements specific features that are independent of the iteration, such as locking and restarting. Different <a class="el" href="class_anasazi_1_1_solver_manager.html" title="The Anasazi::SolverManager is a templated virtual base class that defines the basic interface that an...">Anasazi::SolverManager</a> classes may provide varying features and techniques, though they may encapsulate the same underlying eigensolver iteration. A <a class="el" href="class_anasazi_1_1_solver_manager.html" title="The Anasazi::SolverManager is a templated virtual base class that defines the basic interface that an...">Anasazi::SolverManager</a> is typically driven by a Teuchos::ParameterList, providing a powerful eigensolver via a very simple interface.</li>
</ul>
<p>Returning to the block Davidson example, let's examine how these different pieces come into play. The <a class="el" href="class_anasazi_1_1_block_davidson.html" title="This class implements a Block Davidson iteration, a preconditioned iteration for solving linear Hermi...">Anasazi::BlockDavidson</a> class contains both the state and mechanism of the block Davidson iteration. The state consists of the current test basis, the eigenvector estimates, the residual vectors, and other support data. The eigensolver iteration is described above, and is implemented inside the <a class="el" href="class_anasazi_1_1_block_davidson.html#a9f6d3aaa9a9934fc9a4f40f9dde44fc7" title="This method performs BlockDavidson iterations until the status test indicates the need to stop or an ...">Anasazi::BlockDavidson::iterate()</a> method. On a call to <a class="el" href="class_anasazi_1_1_block_davidson.html#a9f6d3aaa9a9934fc9a4f40f9dde44fc7" title="This method performs BlockDavidson iterations until the status test indicates the need to stop or an ...">Anasazi::BlockDavidson::iterate()</a>, the iteration persists until one of two things happens: either the basis becomes full or the <a class="el" href="class_anasazi_1_1_status_test.html" title="Common interface of stopping criteria for Anasazi&#39;s solvers.">Anasazi::StatusTest</a> provided to the solver indicates that the iteration should be terminated. This is summarized in the following code snippet:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_anasazi_1_1_block_davidson.html#a9f6d3aaa9a9934fc9a4f40f9dde44fc7">Anasazi::BlockDavidson::iterate</a>() </div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">while</span> (statustest.checkStatus (<span class="keyword">this</span>) != <a class="code hl_enumvalue" href="namespace_anasazi.html#aecc89d0f13b3e478065ad8d8b53788c2a37e4db41c154382c42a280dfb2eebad8">Anasazi::Passed</a> &amp;&amp; <a class="code hl_function" href="class_anasazi_1_1_block_davidson.html#a1774e36168c781366e5cf46155f25719">getCurSubspaceDim</a> () &lt; <a class="code hl_function" href="class_anasazi_1_1_block_davidson.html#ae1c3b14c062a94db00e60804ac1fb798">getMaxSubspaceDim</a> ()) {</div>
<div class="line">    <span class="comment">// ... perform block Davidson iterations ...</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_anasazi_1_1_block_davidson_html_a1774e36168c781366e5cf46155f25719"><div class="ttname"><a href="class_anasazi_1_1_block_davidson.html#a1774e36168c781366e5cf46155f25719">Anasazi::BlockDavidson::getCurSubspaceDim</a></div><div class="ttdeci">int getCurSubspaceDim() const</div><div class="ttdoc">Get the dimension of the search subspace used to generate the current eigenvectors and eigenvalues.</div><div class="ttdef"><b>Definition</b> <a href="_anasazi_block_davidson_8hpp_source.html#l00645">AnasaziBlockDavidson.hpp:645</a></div></div>
<div class="ttc" id="aclass_anasazi_1_1_block_davidson_html_a9f6d3aaa9a9934fc9a4f40f9dde44fc7"><div class="ttname"><a href="class_anasazi_1_1_block_davidson.html#a9f6d3aaa9a9934fc9a4f40f9dde44fc7">Anasazi::BlockDavidson::iterate</a></div><div class="ttdeci">void iterate()</div><div class="ttdoc">This method performs BlockDavidson iterations until the status test indicates the need to stop or an ...</div><div class="ttdef"><b>Definition</b> <a href="_anasazi_block_davidson_8hpp_source.html#l01245">AnasaziBlockDavidson.hpp:1245</a></div></div>
<div class="ttc" id="aclass_anasazi_1_1_block_davidson_html_ae1c3b14c062a94db00e60804ac1fb798"><div class="ttname"><a href="class_anasazi_1_1_block_davidson.html#ae1c3b14c062a94db00e60804ac1fb798">Anasazi::BlockDavidson::getMaxSubspaceDim</a></div><div class="ttdeci">int getMaxSubspaceDim() const</div><div class="ttdoc">Get the maximum dimension allocated for the search subspace. For BlockDavidson, this always returns n...</div><div class="ttdef"><b>Definition</b> <a href="_anasazi_block_davidson_8hpp_source.html#l00638">AnasaziBlockDavidson.hpp:638</a></div></div>
<div class="ttc" id="anamespace_anasazi_html_aecc89d0f13b3e478065ad8d8b53788c2a37e4db41c154382c42a280dfb2eebad8"><div class="ttname"><a href="namespace_anasazi.html#aecc89d0f13b3e478065ad8d8b53788c2a37e4db41c154382c42a280dfb2eebad8">Anasazi::Passed</a></div><div class="ttdeci">@ Passed</div><div class="ttdef"><b>Definition</b> <a href="_anasazi_types_8hpp_source.html#l00111">AnasaziTypes.hpp:111</a></div></div>
</div><!-- fragment --><p>The <a class="el" href="class_anasazi_1_1_status_test.html#a5a0243628e67e1306ae6a73b1a7e726f">Anasazi::StatusTest::checkStatus()</a> routine takes an <a class="el" href="class_anasazi_1_1_eigensolver.html" title="The Eigensolver is a templated virtual base class that defines the basic interface that any eigensolv...">Anasazi::Eigensolver</a> object as an argument. For a status test to examine the status of an arbitrary iteration, we must have some abstract interface defining the status of the iteration. This interface is defined by the <a class="el" href="class_anasazi_1_1_eigensolver.html" title="The Eigensolver is a templated virtual base class that defines the basic interface that any eigensolv...">Anasazi::Eigensolver</a> abstract base class, the class from which all eigensolvers in Anasazi derive. The following are some example of the methods provided by <a class="el" href="class_anasazi_1_1_eigensolver.html" title="The Eigensolver is a templated virtual base class that defines the basic interface that any eigensolv...">Anasazi::Eigensolver</a> for use by <a class="el" href="class_anasazi_1_1_status_test.html" title="Common interface of stopping criteria for Anasazi&#39;s solvers.">Anasazi::StatusTest</a> objects:</p>
<div class="fragment"><div class="line"><span class="comment">// Get the current residual norms</span></div>
<div class="line">std::vector&lt;MagnitudeType&gt; getResNorms ();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get the Ritz values from the previous iteration.</span></div>
<div class="line">std::vector&lt;Value&lt;ScalarType&gt; &gt; getRitzValues ();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get the current iteration count.</span></div>
<div class="line"><span class="keywordtype">int</span> getNumIters () <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// and many more!!!</span></div>
</div><!-- fragment --><p>The termination of <a class="el" href="class_anasazi_1_1_eigensolver.html#ae871bd1ab76b84edeea22dd04fcf3053" title="This method performs eigensolvers iterations until the status test indicates the need to stop or an e...">Anasazi::Eigensolver::iterate()</a> is partially controlled by the status test. In one example, a user wishing to limit the number of iterations might utilize <a class="el" href="class_anasazi_1_1_status_test_max_iters.html" title="A status test for testing the number of iterations.">Anasazi::StatusTestMaxIters</a>. In another example, a user wishing to halt <a class="el" href="class_anasazi_1_1_eigensolver.html#ae871bd1ab76b84edeea22dd04fcf3053" title="This method performs eigensolvers iterations until the status test indicates the need to stop or an e...">Anasazi::Eigensolver::iterate()</a> when the residual norms satisfy a certain tolerance might utilize <a class="el" href="class_anasazi_1_1_status_test_res_norm.html" title="A status test for testing the norm of the eigenvectors residuals.">Anasazi::StatusTestResNorm</a>. Arbitrary combinations of status tests can be created using a <a class="el" href="class_anasazi_1_1_status_test_combo.html" title="Status test for forming logical combinations of other status tests.">Anasazi::StatusTestCombo</a> class, so that the stopping criterion can now be affected without modifying the iteration. Furthermore, these decisions can be made at runtime. See <a class="el" href="class_anasazi_1_1_status_test.html" title="Common interface of stopping criteria for Anasazi&#39;s solvers.">Anasazi::StatusTest</a> for a list of status tests provided by <a class="el" href="namespace_anasazi.html" title="Namespace Anasazi contains the classes, structs, enums and utilities used by the Anasazi package.">Anasazi</a>.</p>
<p>Recalling again the block Davidson example, we know that after filling the allocated basis in the iterate() routine, the eigensolver must be restarted with a new subspace. A user wishing to perform a particular type of restarting needs access to the entire state of the eigensolver and must be able to set this state. Each of the Anasazi eigensolvers provides getState() and initialize() methods for retrieving and setting the internal state of the eigensolver. In the case of <a class="el" href="class_anasazi_1_1_block_davidson.html" title="This class implements a Block Davidson iteration, a preconditioned iteration for solving linear Hermi...">Anasazi::BlockDavidson</a>, this method can be used to access the current test basis, which can be used for performing a restart. The user may produce a new state for the eigensolver and then pass it to the eigensolver via the <a class="el" href="class_anasazi_1_1_block_davidson.html#a6ca111c23545705e8bf3120b3ac24659" title="Initialize the solver with the initial vectors from the eigenproblem or random data.">Anasazi::BlockDavidson::initialize()</a> method. In this way, the user has great flexibility in dictating the behavior of the algorithm.</p>
<p>However, the code for performing restarting and locking and similar features is tedious. Furthermore, much research has been conducted into robust and efficient methods for performing these operations. The <a class="el" href="class_anasazi_1_1_solver_manager.html" title="The Anasazi::SolverManager is a templated virtual base class that defines the basic interface that an...">Anasazi::SolverManager</a> exists as a way to encapsulate this functionality in an accessible package, suitable for use in other codes. The goal of a solver manager is to perform all of the communication with a particular eigensolver, providing advanced functionality, on behalf of the user. Algorithmic parameters of a particular solver manager are set via a Teuchos::ParameterList. The only other input provided to the solver manager is the <a class="el" href="class_anasazi_1_1_eigenproblem.html" title="This class defines the interface required by an eigensolver and status test class to compute solution...">Anasazi::Eigenproblem</a> to be solved. Consider the following example:</p>
<div class="fragment"><div class="line"><span class="comment">// create an eigenproblem</span></div>
<div class="line"><a class="code hl_class" href="class_anasazi_1_1_eigenproblem.html">Anasazi::Eigenproblem</a> prob = ...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// create a parameter list for the Anasazi::BlockDavidsonSolMgr solver manager</span></div>
<div class="line">Teuchos::ParameterList pl;</div>
<div class="line">pl.set(<span class="stringliteral">&quot;Block Size&quot;</span>,5);</div>
<div class="line">pl.set(<span class="stringliteral">&quot;Num Blocks&quot;</span>,10);</div>
<div class="line">pl.set(<span class="stringliteral">&quot;Maximum Restarts&quot;</span>,20);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// create a Block Davidson solver manager</span></div>
<div class="line"><a class="code hl_class" href="class_anasazi_1_1_block_davidson_sol_mgr.html">Anasazi::BlockDavidsonSolMgr</a> manager(prob,pl);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// solve the eigenproblem</span></div>
<div class="line"><a class="code hl_enumeration" href="namespace_anasazi.html#a823537bb3d658892d7388be67cf036a6">Anasazi::ReturnType</a> ret = manager.solve();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// retrieve the answer </span></div>
<div class="line"><a class="code hl_struct" href="struct_anasazi_1_1_eigensolution.html">Anasazi::Eigensolution</a> sltn = prob.<a class="code hl_function" href="class_anasazi_1_1_eigenproblem.html#ac0728ed105fd384b36223cbe01bb4bcb">getSolution</a>();</div>
<div class="ttc" id="aclass_anasazi_1_1_block_davidson_sol_mgr_html"><div class="ttname"><a href="class_anasazi_1_1_block_davidson_sol_mgr.html">Anasazi::BlockDavidsonSolMgr</a></div><div class="ttdoc">The BlockDavidsonSolMgr provides a powerful solver manager over the BlockDavidson eigensolver.</div><div class="ttdef"><b>Definition</b> <a href="_anasazi_block_davidson_sol_mgr_8hpp_source.html#l00089">AnasaziBlockDavidsonSolMgr.hpp:89</a></div></div>
<div class="ttc" id="aclass_anasazi_1_1_eigenproblem_html"><div class="ttname"><a href="class_anasazi_1_1_eigenproblem.html">Anasazi::Eigenproblem</a></div><div class="ttdoc">This class defines the interface required by an eigensolver and status test class to compute solution...</div><div class="ttdef"><b>Definition</b> <a href="_anasazi_eigenproblem_8hpp_source.html#l00032">AnasaziEigenproblem.hpp:32</a></div></div>
<div class="ttc" id="aclass_anasazi_1_1_eigenproblem_html_ac0728ed105fd384b36223cbe01bb4bcb"><div class="ttname"><a href="class_anasazi_1_1_eigenproblem.html#ac0728ed105fd384b36223cbe01bb4bcb">Anasazi::Eigenproblem::getSolution</a></div><div class="ttdeci">virtual const Eigensolution&lt; ScalarType, MV &gt; &amp; getSolution() const =0</div><div class="ttdoc">Get the solution to the eigenproblem.</div></div>
<div class="ttc" id="anamespace_anasazi_html_a823537bb3d658892d7388be67cf036a6"><div class="ttname"><a href="namespace_anasazi.html#a823537bb3d658892d7388be67cf036a6">Anasazi::ReturnType</a></div><div class="ttdeci">ReturnType</div><div class="ttdoc">Enumerated type used to pass back information from a solver manager.</div><div class="ttdef"><b>Definition</b> <a href="_anasazi_types_8hpp_source.html#l00088">AnasaziTypes.hpp:89</a></div></div>
<div class="ttc" id="astruct_anasazi_1_1_eigensolution_html"><div class="ttname"><a href="struct_anasazi_1_1_eigensolution.html">Anasazi::Eigensolution</a></div><div class="ttdoc">Struct for storing an eigenproblem solution.</div><div class="ttdef"><b>Definition</b> <a href="_anasazi_types_8hpp_source.html#l00058">AnasaziTypes.hpp:58</a></div></div>
</div><!-- fragment --><p>The <a class="el" href="class_anasazi_1_1_block_davidson_sol_mgr.html" title="The BlockDavidsonSolMgr provides a powerful solver manager over the BlockDavidson eigensolver.">Anasazi::BlockDavidsonSolMgr</a> solver manager is responsible for</p>
<ul>
<li>creating an <a class="el" href="class_anasazi_1_1_block_davidson.html" title="This class implements a Block Davidson iteration, a preconditioned iteration for solving linear Hermi...">Anasazi::BlockDavidson</a> eigensolver and initializing it;</li>
<li>creating status tests and other utility classes needed by the solver;</li>
<li>implementing restarting and locking mechanisms; and</li>
<li>putting the computed eigenpairs into the eigenproblem.</li>
</ul>
<p>The division between eigensolver and solver manager enables the following functionality in Anasazi:</p>
<ul>
<li>the partitioning of responsibility among the classes, resulting in simpler code and easier development, debugging, reuse and maintenance.</li>
<li>stratified levels of interaction: either custom, powerful low-level interaction with the eigensolver or convenient and simple interaction with a robust and flexible solver manager.</li>
<li>the flexibility to choose many implementation details through the choice of support classes provided to the eigensolver:<ul>
<li><a class="el" href="class_anasazi_1_1_status_test.html" title="Common interface of stopping criteria for Anasazi&#39;s solvers.">Anasazi::StatusTest</a></li>
<li><a class="el" href="class_anasazi_1_1_output_manager.html" title="Output managers remove the need for the eigensolver to know any information about the required output...">Anasazi::OutputManager</a></li>
<li><a class="el" href="class_anasazi_1_1_sort_manager.html" title="Anasazi&#39;s templated pure virtual class for managing the sorting of approximate eigenvalues computed b...">Anasazi::SortManager</a></li>
<li><a class="el" href="class_anasazi_1_1_ortho_manager.html" title="Anasazi&#39;s templated virtual class for providing routines for orthogonalization and orthonormalization...">Anasazi::OrthoManager</a> </li>
</ul>
</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
