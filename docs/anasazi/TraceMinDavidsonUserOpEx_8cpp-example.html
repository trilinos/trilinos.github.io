<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Anasazi: TraceMinDavidsonUserOpEx.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Anasazi<span id="projectnumber">&#160;Version of the Day</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">TraceMinDavidsonUserOpEx.cpp</div></div>
</div><!--header-->
<div class="contents">
<p>This is an example of how to use the TraceMinDavidsonSolMgr solver manager to solve a standard eigenvalue problem where the matrix is not explicitly available, using Tpetra data stuctures.</p>
<div class="fragment"><div class="line"><span class="comment">// @HEADER</span></div>
<div class="line"><span class="comment">// *****************************************************************************</span></div>
<div class="line"><span class="comment">//                 Anasazi: Block Eigensolvers Package</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Copyright 2004 NTESS and the Anasazi contributors.</span></div>
<div class="line"><span class="comment">// SPDX-License-Identifier: BSD-3-Clause</span></div>
<div class="line"><span class="comment">// *****************************************************************************</span></div>
<div class="line"><span class="comment">// @HEADER</span></div>
<div class="line"><span class="comment">//  This example demonstrates TraceMin-Davidson&#39;s ability to converge</span></div>
<div class="line"><span class="comment">//  without the matrix being explicitly stored</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Include autoconfigured header</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="AnasaziConfigDefs_8hpp.html">AnasaziConfigDefs.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Include header for TraceMin-Davidson solver</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="AnasaziTraceMinDavidsonSolMgr_8hpp.html">AnasaziTraceMinDavidsonSolMgr.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Include header to define basic eigenproblem Ax = \lambda*Bx</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="AnasaziBasicEigenproblem_8hpp.html">AnasaziBasicEigenproblem.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Include header to provide Anasazi with Tpetra adapters</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="AnasaziTpetraAdapter_8hpp.html">AnasaziTpetraAdapter.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="AnasaziOperator_8hpp.html">AnasaziOperator.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Include headers for Tpetra</span></div>
<div class="line"><span class="preprocessor">#include &quot;Tpetra_Core.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Tpetra_Version.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Tpetra_Map.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Tpetra_MultiVector.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Tpetra_Operator.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Include header for Teuchos serial dense matrix</span></div>
<div class="line"><span class="preprocessor">#include &quot;Teuchos_SerialDenseMatrix.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Include header for Teuchos array views</span></div>
<div class="line"><span class="preprocessor">#include &quot;Teuchos_ArrayViewDecl.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Include header for Teuchos parameter lists</span></div>
<div class="line"><span class="preprocessor">#include &quot;Teuchos_ParameterList.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// These statements tell the compiler where to look for cout, etc.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">using </span>Teuchos::rcp;</div>
<div class="line"><span class="keyword">using </span>Teuchos::RCP;</div>
<div class="line"><span class="keyword">using </span>std::cout;</div>
<div class="line"><span class="keyword">using </span>std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Specify types used in this example.</span></div>
<div class="line"><span class="comment">// Instead of constantly typing Tpetra::MultiVector&lt;Scalar,LocalOrdinal,GlobalOrdinal,Node&gt;,</span></div>
<div class="line"><span class="comment">// we can type TMV.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keywordtype">double</span>                                       Scalar;</div>
<div class="line"><span class="keyword">typedef</span> Tpetra::MultiVector&lt;Scalar&gt;                  TMV;</div>
<div class="line"><span class="keyword">typedef</span> Tpetra::Operator&lt;Scalar&gt;                     TOP;</div>
<div class="line"><span class="keyword">typedef</span> Tpetra::Map&lt;&gt;                                Map;</div>
<div class="line"><span class="keyword">typedef</span> Tpetra::Import&lt;&gt;                             Import;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> Teuchos::ScalarTraits&lt;Scalar&gt;::magnitudeType Magnitude;</div>
<div class="line"><span class="keyword">typedef</span> TMV::local_ordinal_type                       LocalOrdinal;</div>
<div class="line"><span class="keyword">typedef</span> TMV::global_ordinal_type                      GlobalOrdinal;</div>
<div class="line"><span class="keyword">typedef</span> TMV::node_type                                Node;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Define a class for our user-defined operator.</span></div>
<div class="line"><span class="comment">// In this case, it is the tridiagonal matrix [-1,2,-1].</span></div>
<div class="line"><span class="comment">// You may define it to be whatever you like.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// In general, Trilinos does NOT require the user to deal with MPI</span></div>
<div class="line"><span class="comment">// communication explicitly.  If you want to define your own operator</span></div>
<div class="line"><span class="comment">// though, there&#39;s no getting around it.  Fortunately, Trilinos makes</span></div>
<div class="line"><span class="comment">// this relatively straightforward with the use of Map and Import</span></div>
<div class="line"><span class="comment">// objects.  All you have to do is define your initial data</span></div>
<div class="line"><span class="comment">// distribution (which is a block row distribution here), and the data</span></div>
<div class="line"><span class="comment">// distribution you need to perform the operations of your</span></div>
<div class="line"><span class="comment">// matrix-vector multiply.  For instance, when performing a</span></div>
<div class="line"><span class="comment">// matrix-vector multiply with a tridiagonal matrix (with a block row</span></div>
<div class="line"><span class="comment">// distribution), each process needs to know the last element owned by</span></div>
<div class="line"><span class="comment">// the previous process and the first element owned by the next</span></div>
<div class="line"><span class="comment">// process.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// If you are only interested in running the code sequentially, you</span></div>
<div class="line"><span class="comment">// may safely ignore everything here regarding Map and Import objects.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">class </span>MyOp : <span class="keyword">public</span> <span class="keyword">virtual</span> TOP {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Constructor</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  MyOp (<span class="keyword">const</span> GlobalOrdinal n,</div>
<div class="line">        <span class="keyword">const</span> Teuchos::RCP&lt;<span class="keyword">const</span> Teuchos::Comm&lt;int&gt; &gt; comm)</div>
<div class="line">  {</div>
<div class="line">    TEUCHOS_TEST_FOR_EXCEPTION(</div>
<div class="line">      comm.is_null (), std::invalid_argument,</div>
<div class="line">      <span class="stringliteral">&quot;MyOp constructor: The input Comm object must be nonnull.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Construct a map for our block row distribution</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keyword">const</span> GlobalOrdinal indexBase = 0;</div>
<div class="line">    opMap_ = rcp (<span class="keyword">new</span> Map (n, indexBase, comm));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Get the rank of this process and the number of processes</span></div>
<div class="line">    <span class="comment">// We&#39;re going to have to do something special with the first and last processes</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    myRank_ = comm-&gt;getRank ();</div>
<div class="line">    numProcs_ = comm-&gt;getSize ();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Get the local number of rows</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    LocalOrdinal nlocal = opMap_-&gt;getLocalNumElements ();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Define the distribution that you need for the matvec.</span></div>
<div class="line">    <span class="comment">// When you define this for your own operator, it is helpful to draw pictures</span></div>
<div class="line">    <span class="comment">// on a sheet of paper to keep track of who needs to receive which elements.</span></div>
<div class="line">    <span class="comment">// Here, each process needs to receive one element from each of its neighbors.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// All processes but the first will receive one element from the previous process</span></div>
<div class="line">    <span class="keywordflow">if</span> (myRank_ &gt; 0) {</div>
<div class="line">      ++nlocal;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// All processes but the last will receive one element from the next process</span></div>
<div class="line">    <span class="keywordflow">if</span> (myRank_ &lt; numProcs_ - 1) {</div>
<div class="line">      ++nlocal;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Construct a list of columns where this process has nonzero elements</span></div>
<div class="line">    <span class="comment">// For our tridiagonal matrix, this is firstRowItOwns-1:lastRowItOwns+1</span></div>
<div class="line">    std::vector&lt;GlobalOrdinal&gt; indices;</div>
<div class="line">    indices.reserve (nlocal);</div>
<div class="line">    <span class="comment">// The first process is a special case...</span></div>
<div class="line">    <span class="keywordflow">if</span> (myRank_ &gt; 0) {</div>
<div class="line">      indices.push_back (opMap_-&gt;getMinGlobalIndex () - 1);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">for</span> (GlobalOrdinal i = opMap_-&gt;getMinGlobalIndex (); i &lt;= opMap_-&gt;getMaxGlobalIndex (); ++i) {</div>
<div class="line">      indices.push_back (i);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// So is the last process...</span></div>
<div class="line">    <span class="keywordflow">if</span> (myRank_ &lt; numProcs_ - 1) {</div>
<div class="line">      indices.push_back (opMap_-&gt;getMaxGlobalIndex () + 1);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Wrap our vector in an array view, which is like a pointer</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    Teuchos::ArrayView&lt;const GlobalOrdinal&gt; elementList (indices);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Make a map for handling the redistribution.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// There will be some redundancies (i.e. some of the elements will</span></div>
<div class="line">    <span class="comment">// be owned by multiple processes).  Those redundancies will help</span></div>
<div class="line">    <span class="comment">// express the communication pattern for the sparse mat-vec.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keyword">const</span> GlobalOrdinal numGlobalElements = n + 2*(numProcs_ - 1);</div>
<div class="line">    redistMap_ = rcp (<span class="keyword">new</span> Map (numGlobalElements, elementList, indexBase, comm));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Make an Import object that describes how data will be</span></div>
<div class="line">    <span class="comment">// redistributed.  It takes a Map describing who owns what</span></div>
<div class="line">    <span class="comment">// originally, and a Map that describes who you WANT to own what.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    importer_= rcp (<span class="keyword">new</span> Import (opMap_, redistMap_));</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// These functions are required since we inherit from Tpetra::Operator</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Destructor</span></div>
<div class="line">  <span class="keyword">virtual</span> ~MyOp() {};</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Returns the maps</span></div>
<div class="line">  RCP&lt;const Map&gt; getDomainMap()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> opMap_; };</div>
<div class="line">  RCP&lt;const Map&gt; getRangeMap()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> opMap_; };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Computes Y = alpha Op X + beta Y</span></div>
<div class="line">  <span class="comment">// TraceMin will never use alpha ~= 1 or beta ~= 0,</span></div>
<div class="line">  <span class="comment">// so we have ignored those options for simplicity.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="keywordtype">void</span></div>
<div class="line">  apply (<span class="keyword">const</span> TMV&amp; X,</div>
<div class="line">         TMV&amp; Y,</div>
<div class="line">         Teuchos::ETransp mode = Teuchos::NO_TRANS,</div>
<div class="line">         Scalar alpha = Teuchos::ScalarTraits&lt;Scalar&gt;::one (),</div>
<div class="line">         Scalar beta = Teuchos::ScalarTraits&lt;Scalar&gt;::zero ())<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keyword">typedef</span> Teuchos::ScalarTraits&lt;Scalar&gt; STS;</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Let&#39;s make sure alpha is 1 and beta is 0...</span></div>
<div class="line">    <span class="comment">// This will throw an exception if that is not the case.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    TEUCHOS_TEST_FOR_EXCEPTION(</div>
<div class="line">      alpha != STS::one() || beta != STS::zero(), std::logic_error,</div>
<div class="line">      <span class="stringliteral">&quot;MyOp::apply was given alpha != 1 or beta != 0. &quot;</span></div>
<div class="line">      <span class="stringliteral">&quot;These cases are not implemented.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Get the number of local rows</span></div>
<div class="line">    <span class="keyword">const</span> LocalOrdinal nlocRows = X.getLocalLength ();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Get the number of vectors</span></div>
<div class="line">    <span class="keywordtype">int</span> numVecs = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span> (X.getNumVectors ());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Make a temporary multivector for holding the redistributed</span></div>
<div class="line">    <span class="comment">// data.  You could also create this in the constructor and reuse</span></div>
<div class="line">    <span class="comment">// it across different apply() calls, but you would need to be</span></div>
<div class="line">    <span class="comment">// careful to reallocate if it has a different number of vectors</span></div>
<div class="line">    <span class="comment">// than X.  The number of vectors in X can vary across different</span></div>
<div class="line">    <span class="comment">// apply() calls.</span></div>
<div class="line">    RCP&lt;TMV&gt; redistData = rcp (<span class="keyword">new</span> TMV (redistMap_, numVecs));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Redistribute the data.</span></div>
<div class="line">    <span class="comment">// This will do all the necessary communication for you.</span></div>
<div class="line">    <span class="comment">// All processes now own enough data to do the matvec.</span></div>
<div class="line">    redistData-&gt;doImport (X, *importer_, Tpetra::INSERT);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Perform the matvec with the data we now locally own</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// For each column...</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = 0; c &lt; numVecs; ++c) {</div>
<div class="line">      <span class="comment">// Get a view of the desired column</span></div>
<div class="line">      Teuchos::ArrayRCP&lt;Scalar&gt; colView = redistData-&gt;getDataNonConst (c);</div>
<div class="line"> </div>
<div class="line">      LocalOrdinal offset;</div>
<div class="line">      <span class="comment">// Y[0,c] = -colView[0] + 2*colView[1] - colView[2] (using local indices)</span></div>
<div class="line">      <span class="keywordflow">if</span> (myRank_ &gt; 0) {</div>
<div class="line">        Y.replaceLocalValue (0, c, -colView[0] + 2*colView[1] - colView[2]);</div>
<div class="line">        offset = 0;</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// Y[0,c] = 2*colView[1] - colView[2] (using local indices)</span></div>
<div class="line">      <span class="keywordflow">else</span> {</div>
<div class="line">        Y.replaceLocalValue (0, c, 2*colView[0] - colView[1]);</div>
<div class="line">        offset = 1;</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Y[r,c] = -colView[r-offset] + 2*colView[r+1-offset] - colView[r+2-offset]</span></div>
<div class="line">      <span class="keywordflow">for</span> (LocalOrdinal r = 1; r &lt; nlocRows - 1; ++r) {</div>
<div class="line">        <span class="keyword">const</span> Scalar newVal =</div>
<div class="line">          -colView[r-offset] + 2*colView[r+1-offset] - colView[r+2-offset];</div>
<div class="line">        Y.replaceLocalValue (r, c, newVal);</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// Y[nlocRows-1,c] = -colView[nlocRows-1-offset] + 2*colView[nlocRows-offset]</span></div>
<div class="line">      <span class="comment">//                   - colView[nlocRows+1-offset]</span></div>
<div class="line">      <span class="keywordflow">if</span> (myRank_ &lt; numProcs_ - 1) {</div>
<div class="line">        <span class="keyword">const</span> Scalar newVal =</div>
<div class="line">          -colView[nlocRows-1-offset] + 2*colView[nlocRows-offset]</div>
<div class="line">          - colView[nlocRows+1-offset];</div>
<div class="line">        Y.replaceLocalValue (nlocRows-1, c, newVal);</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// Y[nlocRows-1,c] = -colView[nlocRows-1-offset] + 2*colView[nlocRows-offset]</span></div>
<div class="line">      <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keyword">const</span> Scalar newVal =</div>
<div class="line">          -colView[nlocRows-1-offset] + 2*colView[nlocRows-offset];</div>
<div class="line">        Y.replaceLocalValue (nlocRows-1, c, newVal);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  RCP&lt;const Map&gt; opMap_, redistMap_;</div>
<div class="line">  RCP&lt;const Import&gt; importer_;</div>
<div class="line">  <span class="keywordtype">int</span> myRank_, numProcs_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> <a id="_a0" name="_a0"></a><a class="code hl_class" href="classAnasazi_1_1Operator.html">Anasazi::MultiVecTraits&lt;Scalar, TMV&gt;</a> TMVT;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classAnasazi_1_1Operator.html">Anasazi::OperatorTraits&lt;Scalar, TMV, TOP&gt;</a> TOPT;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Initialize MPI.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  Tpetra::ScopeGuard tpetraScope (&amp;argc, &amp;argv);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Get the default communicator</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  RCP&lt;const Teuchos::Comm&lt;int&gt; &gt; comm = Tpetra::getDefaultComm ();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> myRank = comm-&gt;getRank ();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Get parameters from command-line processor</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  Scalar tol = 1e-5;</div>
<div class="line">  GlobalOrdinal n = 100;</div>
<div class="line">  <span class="keywordtype">int</span> nev = 1;</div>
<div class="line">  <span class="keywordtype">int</span> blockSize = 1;</div>
<div class="line">  <span class="keywordtype">bool</span> verbose = <span class="keyword">true</span>;</div>
<div class="line">  std::string whenToShift = <span class="stringliteral">&quot;Always&quot;</span>;</div>
<div class="line">  Teuchos::CommandLineProcessor cmdp (<span class="keyword">false</span>, <span class="keyword">true</span>);</div>
<div class="line">  cmdp.setOption (<span class="stringliteral">&quot;n&quot;</span>, &amp;n, <span class="stringliteral">&quot;Number of rows of our operator.&quot;</span>);</div>
<div class="line">  cmdp.setOption (<span class="stringliteral">&quot;tolerance&quot;</span>, &amp;tol, <span class="stringliteral">&quot;Relative residual used for solver.&quot;</span>);</div>
<div class="line">  cmdp.setOption (<span class="stringliteral">&quot;nev&quot;</span>, &amp;nev, <span class="stringliteral">&quot;Number of desired eigenpairs.&quot;</span>);</div>
<div class="line">  cmdp.setOption (<span class="stringliteral">&quot;blocksize&quot;</span>, &amp;blockSize, <span class="stringliteral">&quot;Number of vectors to add to the &quot;</span></div>
<div class="line">                  <span class="stringliteral">&quot;subspace at each iteration.&quot;</span>);</div>
<div class="line">  cmdp.setOption (<span class="stringliteral">&quot;verbose&quot;</span>,<span class="stringliteral">&quot;quiet&quot;</span>, &amp;verbose,</div>
<div class="line">                  <span class="stringliteral">&quot;Whether to print a lot of info or a little bit.&quot;</span>);</div>
<div class="line">  cmdp.setOption (<span class="stringliteral">&quot;whenToShift&quot;</span>, &amp;whenToShift, <span class="stringliteral">&quot;When to perform Ritz shifts. &quot;</span></div>
<div class="line">                  <span class="stringliteral">&quot;Options: Never, After Trace Levels, Always.&quot;</span>);</div>
<div class="line">  <span class="keywordflow">if</span> (cmdp.parse(argc,argv) != Teuchos::CommandLineProcessor::PARSE_SUCCESSFUL) {</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Construct the operator.</span></div>
<div class="line">  <span class="comment">// Note that the operator does not have to be an explicitly stored matrix.</span></div>
<div class="line">  <span class="comment">// Here, we are using our user-defined operator.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  RCP&lt;MyOp&gt; K = rcp (<span class="keyword">new</span> MyOp (n, comm));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// ************************************</span></div>
<div class="line">  <span class="comment">// Start the TraceMin-Davidson iteration</span></div>
<div class="line">  <span class="comment">// ************************************</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Variables used for the TraceMin-Davidson Method</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="keywordtype">int</span> verbosity;</div>
<div class="line">  <span class="keywordtype">int</span> numRestartBlocks = 2*nev/blockSize;</div>
<div class="line">  <span class="keywordtype">int</span> numBlocks = 10*nev/blockSize;</div>
<div class="line">  <span class="keywordflow">if</span> (verbose) {</div>
<div class="line">    verbosity = <a id="a1" name="a1"></a><a class="code hl_enumvalue" href="namespaceAnasazi.html#ac1cd930ca09987d38fe97bbb8c65507daa04bd73cdc419c447db8771af5d18f83">Anasazi::TimingDetails</a> + <a id="a2" name="a2"></a><a class="code hl_enumvalue" href="namespaceAnasazi.html#ac1cd930ca09987d38fe97bbb8c65507da607dca4dadb5511e7762faaab6e2ca16">Anasazi::IterationDetails</a> +</div>
<div class="line">      <a id="a3" name="a3"></a><a class="code hl_enumvalue" href="namespaceAnasazi.html#ac1cd930ca09987d38fe97bbb8c65507da2e2571549ff094918fb9b368fad7f1f9">Anasazi::Debug</a> + <a id="a4" name="a4"></a><a class="code hl_enumvalue" href="namespaceAnasazi.html#ac1cd930ca09987d38fe97bbb8c65507da8de60b694f69d925e2658c04c92d73dc">Anasazi::FinalSummary</a>;</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    verbosity = <a class="code hl_enumvalue" href="namespaceAnasazi.html#ac1cd930ca09987d38fe97bbb8c65507daa04bd73cdc419c447db8771af5d18f83">Anasazi::TimingDetails</a>;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Create parameter list to pass into solver</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  Teuchos::ParameterList MyPL;</div>
<div class="line">  <span class="comment">// How much information should the solver print?</span></div>
<div class="line">  MyPL.set (<span class="stringliteral">&quot;Verbosity&quot;</span>, verbosity);</div>
<div class="line">  <span class="comment">// Use projected MINRES to solve the saddle point problem</span></div>
<div class="line">  MyPL.set (<span class="stringliteral">&quot;Saddle Solver Type&quot;</span>, <span class="stringliteral">&quot;Projected Krylov&quot;</span>);</div>
<div class="line">  <span class="comment">// Add blockSize vectors to the basis per iteration</span></div>
<div class="line">  MyPL.set (<span class="stringliteral">&quot;Block Size&quot;</span>, blockSize);</div>
<div class="line">  <span class="comment">// How small do the residuals have to be for convergence?</span></div>
<div class="line">  MyPL.set (<span class="stringliteral">&quot;Convergence Tolerance&quot;</span>, tol);</div>
<div class="line">  <span class="comment">// When we restart, this is how many blocks we keep</span></div>
<div class="line">  MyPL.set (<span class="stringliteral">&quot;Num Restart Blocks&quot;</span>, numRestartBlocks);</div>
<div class="line">  <span class="comment">// Maximum number of blocks in the subspace</span></div>
<div class="line">  MyPL.set (<span class="stringliteral">&quot;Num Blocks&quot;</span>, numBlocks);</div>
<div class="line">  <span class="comment">// What triggers a Ritz shift?</span></div>
<div class="line">  MyPL.set (<span class="stringliteral">&quot;When To Shift&quot;</span>, whenToShift);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Create an initial vector to start the solver.  Note: This needs</span></div>
<div class="line">  <span class="comment">// to have the same number of columns as the block size.  We</span></div>
<div class="line">  <span class="comment">// initialize it with random entries.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  RCP&lt;TMV&gt; ivec = rcp (<span class="keyword">new</span> TMV (K-&gt;getDomainMap (), numRestartBlocks*blockSize));</div>
<div class="line">  TMVT::MvRandom (*ivec);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create the eigenproblem</span></div>
<div class="line">  RCP&lt;Anasazi::BasicEigenproblem&lt;Scalar,TMV,TOP&gt; &gt; MyProblem =</div>
<div class="line">    rcp (<span class="keyword">new</span> <a class="code hl_class" href="classAnasazi_1_1Operator.html">Anasazi::BasicEigenproblem&lt;Scalar,TMV,TOP&gt;</a> (K, ivec));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Inform the eigenproblem that the matrix pencil (K,M) is symmetric</span></div>
<div class="line">  MyProblem-&gt;setHermitian (<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set the number of eigenvalues requested</span></div>
<div class="line">  MyProblem-&gt;setNEV (nev);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Inform the eigenproblem that you are finished passing it information</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> setProblemCorrectly = MyProblem-&gt;setProblem ();</div>
<div class="line">  <span class="keywordflow">if</span> (! setProblemCorrectly) {</div>
<div class="line">    <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;Anasazi::BasicEigenproblem::setProblem() failed to set the &quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;problem correctly.&quot;</span> &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Initialize the TraceMin-Davidson solver</span></div>
<div class="line">  <span class="keyword">typedef</span> <a id="_a5" name="_a5"></a><a class="code hl_class" href="classAnasazi_1_1Experimental_1_1TraceMinDavidsonSolMgr.html">Anasazi::Experimental::TraceMinDavidsonSolMgr&lt;Scalar, TMV, TOP&gt;</a> solver_type;</div>
<div class="line">  solver_type MySolverMgr (MyProblem, MyPL);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Solve the problem to the specified tolerances</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <a class="code hl_enumeration" href="namespaceAnasazi.html#a823537bb3d658892d7388be67cf036a6">Anasazi::ReturnType</a> returnCode = MySolverMgr.solve();</div>
<div class="line">  <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Anasazi::EigensolverMgr::solve() returned &quot;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (returnCode != <a id="a6" name="a6"></a><a class="code hl_enumvalue" href="namespaceAnasazi.html#a823537bb3d658892d7388be67cf036a6a43d6b459d6ecd3f2d638063a61c58880">Anasazi::Converged</a>) {</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;unconverged.&quot;</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;converged.&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">    cout &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Get the eigenvalues and eigenvectors from the eigenproblem</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <a class="code hl_class" href="classAnasazi_1_1Operator.html">Anasazi::Eigensolution&lt;Scalar,TMV&gt;</a> sol = MyProblem-&gt;getSolution ();</div>
<div class="line">  std::vector&lt;Anasazi::Value&lt;Scalar&gt; &gt; evals = sol.Evals;</div>
<div class="line">  RCP&lt;TMV&gt; evecs = sol.Evecs;</div>
<div class="line">  <span class="keywordtype">int</span> numev = sol.numVecs;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Compute the residual, just as a precaution</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="keywordflow">if</span> (numev &gt; 0) {</div>
<div class="line">    Teuchos::SerialDenseMatrix&lt;int,Scalar&gt; T (numev, numev);</div>
<div class="line">    TMV tempvec (K-&gt;getDomainMap (), TMVT::GetNumberVecs (*evecs));</div>
<div class="line">    std::vector&lt;Scalar&gt; normR (sol.numVecs);</div>
<div class="line">    TMV Kvec (K-&gt;getRangeMap (), TMVT::GetNumberVecs (*evecs));</div>
<div class="line"> </div>
<div class="line">    TOPT::Apply (*K, *evecs, Kvec );</div>
<div class="line">    TMVT::MvTransMv (1.0, Kvec, *evecs, T);</div>
<div class="line">    TMVT::MvTimesMatAddMv (-1.0, *evecs, T, 1.0, Kvec);</div>
<div class="line">    TMVT::MvNorm (Kvec, normR);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">      cout.setf (std::ios_base::right, std::ios_base::adjustfield);</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;Actual Eigenvalues (obtained by Rayleigh quotient) : &quot;</span> &lt;&lt; endl;</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;------------------------------------------------------&quot;</span> &lt;&lt; endl;</div>
<div class="line">      cout &lt;&lt; std::setw(16) &lt;&lt; <span class="stringliteral">&quot;Real Part&quot;</span> &lt;&lt; std::setw(16) &lt;&lt; <span class="stringliteral">&quot;Error&quot;</span> &lt;&lt; endl;</div>
<div class="line">      cout&lt;&lt;<span class="stringliteral">&quot;------------------------------------------------------&quot;</span> &lt;&lt; endl;</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numev; ++i) {</div>
<div class="line">        cout &lt;&lt; std::setw(16) &lt;&lt; T(i,i) &lt;&lt; std::setw(16) &lt;&lt; normR[i]/T(i,i)</div>
<div class="line">             &lt;&lt; endl;</div>
<div class="line">      }</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;------------------------------------------------------&quot;</span> &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aAnasaziBasicEigenproblem_8hpp_html"><div class="ttname"><a href="AnasaziBasicEigenproblem_8hpp.html">AnasaziBasicEigenproblem.hpp</a></div><div class="ttdoc">Basic implementation of the Anasazi::Eigenproblem class.</div></div>
<div class="ttc" id="aAnasaziConfigDefs_8hpp_html"><div class="ttname"><a href="AnasaziConfigDefs_8hpp.html">AnasaziConfigDefs.hpp</a></div><div class="ttdoc">Anasazi header file which uses auto-configuration information to include necessary C++ headers.</div></div>
<div class="ttc" id="aAnasaziOperator_8hpp_html"><div class="ttname"><a href="AnasaziOperator_8hpp.html">AnasaziOperator.hpp</a></div><div class="ttdoc">Templated virtual class for creating operators that can interface with the Anasazi::OperatorTraits cl...</div></div>
<div class="ttc" id="aAnasaziTpetraAdapter_8hpp_html"><div class="ttname"><a href="AnasaziTpetraAdapter_8hpp.html">AnasaziTpetraAdapter.hpp</a></div><div class="ttdoc">Partial specialization of Anasazi::MultiVecTraits and Anasazi::OperatorTraits for Tpetra objects.</div></div>
<div class="ttc" id="aAnasaziTraceMinDavidsonSolMgr_8hpp_html"><div class="ttname"><a href="AnasaziTraceMinDavidsonSolMgr_8hpp.html">AnasaziTraceMinDavidsonSolMgr.hpp</a></div><div class="ttdoc">The Anasazi::TraceMinDavidsonSolMgr provides a solver manager for the TraceMinDavidson eigensolver wi...</div></div>
<div class="ttc" id="aclassAnasazi_1_1Experimental_1_1TraceMinDavidsonSolMgr_html"><div class="ttname"><a href="classAnasazi_1_1Experimental_1_1TraceMinDavidsonSolMgr.html">Anasazi::Experimental::TraceMinDavidsonSolMgr</a></div><div class="ttdoc">The Anasazi::TraceMinDavidsonSolMgr provides a flexible solver manager over the TraceMinDavidson eige...</div><div class="ttdef"><b>Definition</b> <a href="AnasaziTraceMinDavidsonSolMgr_8hpp_source.html#l00078">AnasaziTraceMinDavidsonSolMgr.hpp:78</a></div></div>
<div class="ttc" id="aclassAnasazi_1_1Operator_html"><div class="ttname"><a href="classAnasazi_1_1Operator.html">Anasazi::Operator</a></div><div class="ttdoc">Anasazi's templated virtual class for constructing an operator that can interface with the OperatorTr...</div><div class="ttdef"><b>Definition</b> <a href="AnasaziOperator_8hpp_source.html#l00035">AnasaziOperator.hpp:35</a></div></div>
<div class="ttc" id="anamespaceAnasazi_html_a823537bb3d658892d7388be67cf036a6"><div class="ttname"><a href="namespaceAnasazi.html#a823537bb3d658892d7388be67cf036a6">Anasazi::ReturnType</a></div><div class="ttdeci">ReturnType</div><div class="ttdoc">Enumerated type used to pass back information from a solver manager.</div><div class="ttdef"><b>Definition</b> <a href="AnasaziTypes_8hpp_source.html#l00088">AnasaziTypes.hpp:89</a></div></div>
<div class="ttc" id="anamespaceAnasazi_html_a823537bb3d658892d7388be67cf036a6a43d6b459d6ecd3f2d638063a61c58880"><div class="ttname"><a href="namespaceAnasazi.html#a823537bb3d658892d7388be67cf036a6a43d6b459d6ecd3f2d638063a61c58880">Anasazi::Converged</a></div><div class="ttdeci">@ Converged</div><div class="ttdef"><b>Definition</b> <a href="AnasaziTypes_8hpp_source.html#l00090">AnasaziTypes.hpp:90</a></div></div>
<div class="ttc" id="anamespaceAnasazi_html_ac1cd930ca09987d38fe97bbb8c65507da2e2571549ff094918fb9b368fad7f1f9"><div class="ttname"><a href="namespaceAnasazi.html#ac1cd930ca09987d38fe97bbb8c65507da2e2571549ff094918fb9b368fad7f1f9">Anasazi::Debug</a></div><div class="ttdeci">@ Debug</div><div class="ttdef"><b>Definition</b> <a href="AnasaziTypes_8hpp_source.html#l00139">AnasaziTypes.hpp:138</a></div></div>
<div class="ttc" id="anamespaceAnasazi_html_ac1cd930ca09987d38fe97bbb8c65507da607dca4dadb5511e7762faaab6e2ca16"><div class="ttname"><a href="namespaceAnasazi.html#ac1cd930ca09987d38fe97bbb8c65507da607dca4dadb5511e7762faaab6e2ca16">Anasazi::IterationDetails</a></div><div class="ttdeci">@ IterationDetails</div><div class="ttdef"><b>Definition</b> <a href="AnasaziTypes_8hpp_source.html#l00133">AnasaziTypes.hpp:133</a></div></div>
<div class="ttc" id="anamespaceAnasazi_html_ac1cd930ca09987d38fe97bbb8c65507da8de60b694f69d925e2658c04c92d73dc"><div class="ttname"><a href="namespaceAnasazi.html#ac1cd930ca09987d38fe97bbb8c65507da8de60b694f69d925e2658c04c92d73dc">Anasazi::FinalSummary</a></div><div class="ttdeci">@ FinalSummary</div><div class="ttdef"><b>Definition</b> <a href="AnasaziTypes_8hpp_source.html#l00135">AnasaziTypes.hpp:135</a></div></div>
<div class="ttc" id="anamespaceAnasazi_html_ac1cd930ca09987d38fe97bbb8c65507daa04bd73cdc419c447db8771af5d18f83"><div class="ttname"><a href="namespaceAnasazi.html#ac1cd930ca09987d38fe97bbb8c65507daa04bd73cdc419c447db8771af5d18f83">Anasazi::TimingDetails</a></div><div class="ttdeci">@ TimingDetails</div><div class="ttdef"><b>Definition</b> <a href="AnasaziTypes_8hpp_source.html#l00136">AnasaziTypes.hpp:136</a></div></div>
</div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
