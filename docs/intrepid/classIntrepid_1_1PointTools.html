<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Intrepid: Intrepid::PointTools Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Intrepid
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Intrepid</b></li><li class="navelem"><a class="el" href="classIntrepid_1_1PointTools.html">PointTools</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="classIntrepid_1_1PointTools-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Intrepid::PointTools Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Utility class that provides methods for calculating distributions of points on different cells.  
 <a href="classIntrepid_1_1PointTools.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Intrepid__PointTools_8hpp_source.html">Intrepid_PointTools.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae30fb50abe590300a63cf67f1c49ddf4" id="r_ae30fb50abe590300a63cf67f1c49ddf4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1PointTools.html#ae30fb50abe590300a63cf67f1c49ddf4">getLatticeSize</a> (const shards::CellTopology &amp;cellType, const int order, const int offset=0)</td></tr>
<tr class="memdesc:ae30fb50abe590300a63cf67f1c49ddf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of points in a lattice of a given order on a simplex (currently disabled for other cell types). If offset == 0, the lattice will include only include the vertex points if order == 1, and will include edge midpoints if order == 2, and so on. <br  />
 In particular, this is the dimension of polynomials of degree "order" on the given simplex. The offset argument is used to indicate that the layer of points on the boundary is omitted (if offset == 1). For greater offsets, more layers are omitteed.  <br /></td></tr>
<tr class="separator:ae30fb50abe590300a63cf67f1c49ddf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d596624a750152ec331b016d46796c8" id="r_a1d596624a750152ec331b016d46796c8"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayType &gt; </td></tr>
<tr class="memitem:a1d596624a750152ec331b016d46796c8"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1PointTools.html#a1d596624a750152ec331b016d46796c8">getLattice</a> (ArrayType &amp;pts, const shards::CellTopology &amp;cellType, const int order, const int offset=0, const EPointType pointType=POINTTYPE_EQUISPACED)</td></tr>
<tr class="memdesc:a1d596624a750152ec331b016d46796c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a lattice of points of a given order on a reference simplex (currently disabled for other cell types). The output array is (P,D), where.  <br /></td></tr>
<tr class="separator:a1d596624a750152ec331b016d46796c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419fd5d12db94424a0289ce29fae3fdc" id="r_a419fd5d12db94424a0289ce29fae3fdc"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayType &gt; </td></tr>
<tr class="memitem:a419fd5d12db94424a0289ce29fae3fdc"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1PointTools.html#a419fd5d12db94424a0289ce29fae3fdc">getGaussPoints</a> (ArrayType &amp;pts, const int order)</td></tr>
<tr class="separator:a419fd5d12db94424a0289ce29fae3fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a0150fd7e3a9cbf3fd882f899b39f2530" id="r_a0150fd7e3a9cbf3fd882f899b39f2530"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayTypeOut , class ArrayTypeIn1 , class ArrayTypeIn2 &gt; </td></tr>
<tr class="memitem:a0150fd7e3a9cbf3fd882f899b39f2530"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1PointTools.html#a0150fd7e3a9cbf3fd882f899b39f2530">cartToBaryTriangle</a> (ArrayTypeOut &amp;baryValues, const ArrayTypeIn1 &amp;cartValues, const ArrayTypeIn2 &amp;vertices)</td></tr>
<tr class="memdesc:a0150fd7e3a9cbf3fd882f899b39f2530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts Cartesian coordinates to barycentric coordinates on a batch of triangles. <br  />
 The input array cartValues is (C,P,2) The output array baryValues is (C,P,3). The input array vertices is (C,3,2), where.  <br /></td></tr>
<tr class="separator:a0150fd7e3a9cbf3fd882f899b39f2530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495ed2f5cce18bfc55e3f6fae730f04d" id="r_a495ed2f5cce18bfc55e3f6fae730f04d"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayTypeOut , class ArrayTypeIn1 , class ArrayTypeIn2 &gt; </td></tr>
<tr class="memitem:a495ed2f5cce18bfc55e3f6fae730f04d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1PointTools.html#a495ed2f5cce18bfc55e3f6fae730f04d">baryToCartTriangle</a> (ArrayTypeOut &amp;cartValues, const ArrayTypeIn1 &amp;baryValues, const ArrayTypeIn2 &amp;vertices)</td></tr>
<tr class="memdesc:a495ed2f5cce18bfc55e3f6fae730f04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts barycentric coordinates to Cartesian coordinates on a batch of triangles. <br  />
 The input array baryValues is (C,P,3) The output array cartValues is (C,P,2). The input array vertices is (C,3,2), where.  <br /></td></tr>
<tr class="separator:a495ed2f5cce18bfc55e3f6fae730f04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbda0d7d34140e944b62674b58182d71" id="r_acbda0d7d34140e944b62674b58182d71"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayTypeOut , class ArrayTypeIn1 , class ArrayTypeIn2 &gt; </td></tr>
<tr class="memitem:acbda0d7d34140e944b62674b58182d71"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1PointTools.html#acbda0d7d34140e944b62674b58182d71">cartToBaryTetrahedron</a> (ArrayTypeOut &amp;baryValues, const ArrayTypeIn1 &amp;cartValues, const ArrayTypeIn2 &amp;vertices)</td></tr>
<tr class="memdesc:acbda0d7d34140e944b62674b58182d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts Cartesian coordinates to barycentric coordinates on a batch of tetrahedra. <br  />
 The input array cartValues is (C,P,3) The output array baryValues is (C,P,4). The input array vertices is (C,4,3), where.  <br /></td></tr>
<tr class="separator:acbda0d7d34140e944b62674b58182d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf7f0e57908b676c4b9bd13a9d55e2d" id="r_a7bf7f0e57908b676c4b9bd13a9d55e2d"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayTypeOut , class ArrayTypeIn1 , class ArrayTypeIn2 &gt; </td></tr>
<tr class="memitem:a7bf7f0e57908b676c4b9bd13a9d55e2d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1PointTools.html#a7bf7f0e57908b676c4b9bd13a9d55e2d">baryToCartTetrahedron</a> (ArrayTypeOut &amp;cartValues, const ArrayTypeIn1 &amp;baryValues, const ArrayTypeIn2 &amp;vertices)</td></tr>
<tr class="memdesc:a7bf7f0e57908b676c4b9bd13a9d55e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts barycentric coordinates to Cartesian coordinates on a batch of tetrahedra. <br  />
 The input array baryValues is (C,P,4) The output array cartValues is (C,P,3). The input array vertices is (C,4,3), where.  <br /></td></tr>
<tr class="separator:a7bf7f0e57908b676c4b9bd13a9d55e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497007ffcc02b90098e82d475f9965df" id="r_a497007ffcc02b90098e82d475f9965df"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayType &gt; </td></tr>
<tr class="memitem:a497007ffcc02b90098e82d475f9965df"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1PointTools.html#a497007ffcc02b90098e82d475f9965df">getEquispacedLattice</a> (const shards::CellTopology &amp;cellType, ArrayType &amp;points, const int order, const int offset=0)</td></tr>
<tr class="memdesc:a497007ffcc02b90098e82d475f9965df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an equispaced lattice of a given order on a reference simplex (currently disabled for other cell types). The output array is (P,D), where.  <br /></td></tr>
<tr class="separator:a497007ffcc02b90098e82d475f9965df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca7ddbaa1cefd8ce5b39bb93d8e3442" id="r_a9ca7ddbaa1cefd8ce5b39bb93d8e3442"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayType &gt; </td></tr>
<tr class="memitem:a9ca7ddbaa1cefd8ce5b39bb93d8e3442"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1PointTools.html#a9ca7ddbaa1cefd8ce5b39bb93d8e3442">getWarpBlendLattice</a> (const shards::CellTopology &amp;cellType, ArrayType &amp;points, const int order, const int offset=0)</td></tr>
<tr class="memdesc:a9ca7ddbaa1cefd8ce5b39bb93d8e3442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a warped lattice (ala Warburton's warp-blend points of a given order on a reference simplex (currently disabled for other cell types). The output array is (P,D), where.  <br /></td></tr>
<tr class="separator:a9ca7ddbaa1cefd8ce5b39bb93d8e3442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0fbe03bf06849e6875361fdedcb874d" id="r_aa0fbe03bf06849e6875361fdedcb874d"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayType &gt; </td></tr>
<tr class="memitem:aa0fbe03bf06849e6875361fdedcb874d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1PointTools.html#aa0fbe03bf06849e6875361fdedcb874d">getEquispacedLatticeLine</a> (ArrayType &amp;points, const int order, const int offset=0)</td></tr>
<tr class="memdesc:aa0fbe03bf06849e6875361fdedcb874d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an equispaced lattice of a given order on the reference line [-1,1]. The output array is (P,1), where.  <br /></td></tr>
<tr class="separator:aa0fbe03bf06849e6875361fdedcb874d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e64ffe1fa62625cd23bb432e0fe568" id="r_a42e64ffe1fa62625cd23bb432e0fe568"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayType &gt; </td></tr>
<tr class="memitem:a42e64ffe1fa62625cd23bb432e0fe568"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1PointTools.html#a42e64ffe1fa62625cd23bb432e0fe568">getEquispacedLatticeTriangle</a> (ArrayType &amp;points, const int order, const int offset=0)</td></tr>
<tr class="memdesc:a42e64ffe1fa62625cd23bb432e0fe568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an equispaced lattice of a given order on the reference triangle. The output array is (P,2), where.  <br /></td></tr>
<tr class="separator:a42e64ffe1fa62625cd23bb432e0fe568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4cf910c62460a7d855601fbaada5f07" id="r_ac4cf910c62460a7d855601fbaada5f07"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayType &gt; </td></tr>
<tr class="memitem:ac4cf910c62460a7d855601fbaada5f07"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1PointTools.html#ac4cf910c62460a7d855601fbaada5f07">getEquispacedLatticeTetrahedron</a> (ArrayType &amp;points, const int order, const int offset=0)</td></tr>
<tr class="memdesc:ac4cf910c62460a7d855601fbaada5f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an equispaced lattice of a given order on the reference tetrahedron. The output array is (P,3), where.  <br /></td></tr>
<tr class="separator:ac4cf910c62460a7d855601fbaada5f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c89a0a1fa06ef2b8d039e70f424669" id="r_a99c89a0a1fa06ef2b8d039e70f424669"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayType &gt; </td></tr>
<tr class="memitem:a99c89a0a1fa06ef2b8d039e70f424669"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1PointTools.html#a99c89a0a1fa06ef2b8d039e70f424669">getWarpBlendLatticeLine</a> (ArrayType &amp;points, const int order, const int offset=0)</td></tr>
<tr class="memdesc:a99c89a0a1fa06ef2b8d039e70f424669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Gauss-Lobatto points of a given order on the reference line [-1,1]. The output array is (P,1), where.  <br /></td></tr>
<tr class="separator:a99c89a0a1fa06ef2b8d039e70f424669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d269d3c5b19d45e8cc93e562ac302ca" id="r_a1d269d3c5b19d45e8cc93e562ac302ca"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayType &gt; </td></tr>
<tr class="memitem:a1d269d3c5b19d45e8cc93e562ac302ca"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1PointTools.html#a1d269d3c5b19d45e8cc93e562ac302ca">warpFactor</a> (const int order, const ArrayType &amp;xnodes, const ArrayType &amp;xout, ArrayType &amp;warp)</td></tr>
<tr class="memdesc:a1d269d3c5b19d45e8cc93e562ac302ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">interpolates Warburton's warp function on the line  <br /></td></tr>
<tr class="separator:a1d269d3c5b19d45e8cc93e562ac302ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d167d3b78227faf5d44fc90223940be" id="r_a2d167d3b78227faf5d44fc90223940be"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayType &gt; </td></tr>
<tr class="memitem:a2d167d3b78227faf5d44fc90223940be"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1PointTools.html#a2d167d3b78227faf5d44fc90223940be">getWarpBlendLatticeTriangle</a> (ArrayType &amp;points, const int order, const int offset=0)</td></tr>
<tr class="memdesc:a2d167d3b78227faf5d44fc90223940be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Warburton's warp-blend points of a given order on the reference triangle. The output array is (P,2), where.  <br /></td></tr>
<tr class="separator:a2d167d3b78227faf5d44fc90223940be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18592e115f6fd8736743e4ba4a6ca164" id="r_a18592e115f6fd8736743e4ba4a6ca164"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayType &gt; </td></tr>
<tr class="memitem:a18592e115f6fd8736743e4ba4a6ca164"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1PointTools.html#a18592e115f6fd8736743e4ba4a6ca164">getWarpBlendLatticeTetrahedron</a> (ArrayType &amp;points, const int order, const int offset=0)</td></tr>
<tr class="memdesc:a18592e115f6fd8736743e4ba4a6ca164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Warburton's warp-blend points of a given order on the reference tetrahedron. The output array is (P,3), where.  <br /></td></tr>
<tr class="separator:a18592e115f6fd8736743e4ba4a6ca164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f0294f42c505e35e36586ac366f4d7" id="r_af7f0294f42c505e35e36586ac366f4d7"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayType &gt; </td></tr>
<tr class="memitem:af7f0294f42c505e35e36586ac366f4d7"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1PointTools.html#af7f0294f42c505e35e36586ac366f4d7">warpShiftFace3D</a> (const int order, const Scalar pval, const ArrayType &amp;L1, const ArrayType &amp;L2, const ArrayType &amp;L3, const ArrayType &amp;L4, ArrayType &amp;dxy)</td></tr>
<tr class="memdesc:af7f0294f42c505e35e36586ac366f4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used internally to compute the tetrahedral warp-blend points one each face.  <br /></td></tr>
<tr class="separator:af7f0294f42c505e35e36586ac366f4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8f4bf2dc861d484c034519fd4f458b" id="r_a7d8f4bf2dc861d484c034519fd4f458b"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayType &gt; </td></tr>
<tr class="memitem:a7d8f4bf2dc861d484c034519fd4f458b"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1PointTools.html#a7d8f4bf2dc861d484c034519fd4f458b">evalshift</a> (const int order, const Scalar pval, const ArrayType &amp;L1, const ArrayType &amp;L2, const ArrayType &amp;L3, ArrayType &amp;dxy)</td></tr>
<tr class="memdesc:a7d8f4bf2dc861d484c034519fd4f458b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used internally to evaluate the point shift for warp-blend points on faces of tets.  <br /></td></tr>
<tr class="separator:a7d8f4bf2dc861d484c034519fd4f458b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a54355382051578d73dace98194d7c9" id="r_a8a54355382051578d73dace98194d7c9"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayType &gt; </td></tr>
<tr class="memitem:a8a54355382051578d73dace98194d7c9"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1PointTools.html#a8a54355382051578d73dace98194d7c9">evalwarp</a> (ArrayType &amp;warp, const int order, const ArrayType &amp;xnodes, const ArrayType &amp;xout)</td></tr>
<tr class="memdesc:a8a54355382051578d73dace98194d7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used internally to compute the warp on edges of a triangle in warp-blend points.  <br /></td></tr>
<tr class="separator:a8a54355382051578d73dace98194d7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utility class that provides methods for calculating distributions of points on different cells. </p>
<p>Simplicial lattices in <a class="el" href="classIntrepid_1_1PointTools.html" title="Utility class that provides methods for calculating distributions of points on different cells.">PointTools</a> are sets of points with certain ordering properties. They are used for defining degrees of freedom for higher order finite elements.</p>
<p>Each lattice has an "order". In general, this is the same as the cardinality of the polynomial space of degree "order". In terms of binomial coefficients, this is binomial(order+d,order) for the simplex in d dimensions. On the line, the size is order+1. On the triangle and tetrahedron, there are (order+1)(order+2)/2 and (order+1)(order+2)(order+3)/6, respectively.</p>
<p>The points are ordered lexicographically from low to high in increasing spatial dimension. For example, the line lattice of order 3 looks like:</p>
<pre class="fragment">x--x--x--x
</pre><p>where "x" denotes a point location. These are ordered from left to right, so that the points are labeled:</p>
<pre class="fragment">0--1--2--3
</pre><p>The triangular lattice of order 3 is</p>
<pre class="fragment">x
|\
| \
x  x
|   \
|    \
x  x  x
|      \
|       \
x--x--x--x
</pre><p>The ordering starts in the bottom left and increases first from left to right. The ordering is</p>
<pre class="fragment">9
|\
| \
8  7
|   \
|    \
4  5  6
|      \
|       \
0--1--2--3
</pre><p>Tetrahedral lattices are similar but difficult to draw with ASCII art.</p>
<p>Each lattice also has an "offset", which indicates a number of layers of points on the bounary taken away. All of the lattices above have a 0 offest. In Intrepid, typically only offset = 0 or 1 will be used. The offset=1 case is used to generate sets of points properly inside a given simplex. These are used, for example, to construct points internal to an edge or face for H(curl) and H(div) finite elements.</p>
<p>For example, for a line lattice with order = 3 and offset = 1, the points will look like</p>
<pre class="fragment">---x--x---
</pre><p>and a triangle with order=3 and offset=1 will contain a single point</p>
<pre class="fragment">.
|\
| \
|  \
|   \
|    \
|  x  \
|      \
|       \
|--------\
</pre><p>When points on lattices with nonzero offset are numbered, the are numbered contiguously from 0, so that the line and triangle above are respectively</p>
<pre class="fragment">---0--1---
</pre><pre class="fragment">.
|\
| \
|  \
|   \
|    \
|  0  \
|      \
|       \
|--------\
</pre><p>Additionally, two types of point distributions are currently support. The points may be on an equispaced lattice, which is easy to compute but can lead to numerical ill-conditioning in finite element bases and stiffness matrices. Alternatively, the warp-blend points of Warburton are provided on each lattice (which are just the Gauss-Lobatto points on the line). </p>

<p class="definition">Definition at line <a class="el" href="Intrepid__PointTools_8hpp_source.html#l00195">195</a> of file <a class="el" href="Intrepid__PointTools_8hpp_source.html">Intrepid_PointTools.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a7bf7f0e57908b676c4b9bd13a9d55e2d" name="a7bf7f0e57908b676c4b9bd13a9d55e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf7f0e57908b676c4b9bd13a9d55e2d">&#9670;&#160;</a></span>baryToCartTetrahedron()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayTypeOut , class ArrayTypeIn1 , class ArrayTypeIn2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Intrepid::PointTools::baryToCartTetrahedron </td>
          <td>(</td>
          <td class="paramtype">ArrayTypeOut &amp;&#160;</td>
          <td class="paramname"><em>cartValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeIn1 &amp;&#160;</td>
          <td class="paramname"><em>baryValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeIn2 &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts barycentric coordinates to Cartesian coordinates on a batch of tetrahedra. <br  />
 The input array baryValues is (C,P,4) The output array cartValues is (C,P,3). The input array vertices is (C,4,3), where. </p>
<div class="fragment"><div class="line">C - num. integration domains</div>
<div class="line">P - number of points per cell</div>
<div class="line">D - is the spatial dimension</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baryValues</td><td>[out] - Output array of barycentric coords </td></tr>
    <tr><td class="paramname">cartValues</td><td>[in] - Input array of Cartesian coords </td></tr>
    <tr><td class="paramname">vertices</td><td>[out] - Vertices of each cell. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a495ed2f5cce18bfc55e3f6fae730f04d" name="a495ed2f5cce18bfc55e3f6fae730f04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495ed2f5cce18bfc55e3f6fae730f04d">&#9670;&#160;</a></span>baryToCartTriangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayTypeOut , class ArrayTypeIn1 , class ArrayTypeIn2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Intrepid::PointTools::baryToCartTriangle </td>
          <td>(</td>
          <td class="paramtype">ArrayTypeOut &amp;&#160;</td>
          <td class="paramname"><em>cartValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeIn1 &amp;&#160;</td>
          <td class="paramname"><em>baryValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeIn2 &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts barycentric coordinates to Cartesian coordinates on a batch of triangles. <br  />
 The input array baryValues is (C,P,3) The output array cartValues is (C,P,2). The input array vertices is (C,3,2), where. </p>
<div class="fragment"><div class="line">C - num. integration domains</div>
<div class="line">P - number of points per cell</div>
<div class="line">D - is the spatial dimension</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baryValues</td><td>[out] - Output array of barycentric coords </td></tr>
    <tr><td class="paramname">cartValues</td><td>[in] - Input array of Cartesian coords </td></tr>
    <tr><td class="paramname">vertices</td><td>[out] - Vertices of each cell. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbda0d7d34140e944b62674b58182d71" name="acbda0d7d34140e944b62674b58182d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbda0d7d34140e944b62674b58182d71">&#9670;&#160;</a></span>cartToBaryTetrahedron()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayTypeOut , class ArrayTypeIn1 , class ArrayTypeIn2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Intrepid::PointTools::cartToBaryTetrahedron </td>
          <td>(</td>
          <td class="paramtype">ArrayTypeOut &amp;&#160;</td>
          <td class="paramname"><em>baryValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeIn1 &amp;&#160;</td>
          <td class="paramname"><em>cartValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeIn2 &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts Cartesian coordinates to barycentric coordinates on a batch of tetrahedra. <br  />
 The input array cartValues is (C,P,3) The output array baryValues is (C,P,4). The input array vertices is (C,4,3), where. </p>
<div class="fragment"><div class="line">C - num. integration domains</div>
<div class="line">P - number of points per cell</div>
<div class="line">D - is the spatial dimension</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baryValues</td><td>[out] - Output array of barycentric coords </td></tr>
    <tr><td class="paramname">cartValues</td><td>[in] - Input array of Cartesian coords </td></tr>
    <tr><td class="paramname">vertices</td><td>[out] - Vertices of each cell. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0150fd7e3a9cbf3fd882f899b39f2530" name="a0150fd7e3a9cbf3fd882f899b39f2530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0150fd7e3a9cbf3fd882f899b39f2530">&#9670;&#160;</a></span>cartToBaryTriangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayTypeOut , class ArrayTypeIn1 , class ArrayTypeIn2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Intrepid::PointTools::cartToBaryTriangle </td>
          <td>(</td>
          <td class="paramtype">ArrayTypeOut &amp;&#160;</td>
          <td class="paramname"><em>baryValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeIn1 &amp;&#160;</td>
          <td class="paramname"><em>cartValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeIn2 &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts Cartesian coordinates to barycentric coordinates on a batch of triangles. <br  />
 The input array cartValues is (C,P,2) The output array baryValues is (C,P,3). The input array vertices is (C,3,2), where. </p>
<div class="fragment"><div class="line">C - num. integration domains</div>
<div class="line">P - number of points per cell</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baryValues</td><td>[out] - Output array of barycentric coords </td></tr>
    <tr><td class="paramname">cartValues</td><td>[in] - Input array of Cartesian coords </td></tr>
    <tr><td class="paramname">vertices</td><td>[out] - Vertices of each cell. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d8f4bf2dc861d484c034519fd4f458b" name="a7d8f4bf2dc861d484c034519fd4f458b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8f4bf2dc861d484c034519fd4f458b">&#9670;&#160;</a></span>evalshift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::PointTools::evalshift </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>pval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType &amp;&#160;</td>
          <td class="paramname"><em>L1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType &amp;&#160;</td>
          <td class="paramname"><em>L2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType &amp;&#160;</td>
          <td class="paramname"><em>L3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType &amp;&#160;</td>
          <td class="paramname"><em>dxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used internally to evaluate the point shift for warp-blend points on faces of tets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>[in] - the order of lattice </td></tr>
    <tr><td class="paramname">pval</td><td>[in] - the "alpha" term in the warping function </td></tr>
    <tr><td class="paramname">L1</td><td>[in] - the first barycentric coordinate of the input points </td></tr>
    <tr><td class="paramname">L2</td><td>[in] - the second barycentric coordinate of the input points </td></tr>
    <tr><td class="paramname">L3</td><td>[in] - the third barycentric coordinate of the input points </td></tr>
    <tr><td class="paramname">dxy</td><td>[out] - contains the amount to shift each point in the x and y direction </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html#l00487">487</a> of file <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html">Intrepid_PointToolsDef.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid__FieldContainerDef_8hpp_source.html#l01137">Intrepid::FieldContainer&lt; Scalar, ArrayTypeId &gt;::resize()</a>.</p>

</div>
</div>
<a id="a8a54355382051578d73dace98194d7c9" name="a8a54355382051578d73dace98194d7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a54355382051578d73dace98194d7c9">&#9670;&#160;</a></span>evalwarp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::PointTools::evalwarp </td>
          <td>(</td>
          <td class="paramtype">ArrayType &amp;&#160;</td>
          <td class="paramname"><em>warp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType &amp;&#160;</td>
          <td class="paramname"><em>xnodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType &amp;&#160;</td>
          <td class="paramname"><em>xout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used internally to compute the warp on edges of a triangle in warp-blend points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">warp</td><td>[out] - a 1d array containing the amount to move each point </td></tr>
    <tr><td class="paramname">order</td><td>[in] - the order of the lattice </td></tr>
    <tr><td class="paramname">xnodes</td><td>[in] - the points to warp to, typically the Gauss-Lobatto points </td></tr>
    <tr><td class="paramname">xout</td><td>[in] - the equispaced points on the edge </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html#l00566">566</a> of file <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html">Intrepid_PointToolsDef.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid__FieldContainerDef_8hpp_source.html#l00658">Intrepid::FieldContainer&lt; Scalar, ArrayTypeId &gt;::dimension()</a>, and <a class="el" href="Intrepid__FieldContainerDef_8hpp_source.html#l01374">Intrepid::FieldContainer&lt; Scalar, ArrayTypeId &gt;::initialize()</a>.</p>

</div>
</div>
<a id="a497007ffcc02b90098e82d475f9965df" name="a497007ffcc02b90098e82d475f9965df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497007ffcc02b90098e82d475f9965df">&#9670;&#160;</a></span>getEquispacedLattice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::PointTools::getEquispacedLattice </td>
          <td>(</td>
          <td class="paramtype">const shards::CellTopology &amp;&#160;</td>
          <td class="paramname"><em>cellType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an equispaced lattice of a given order on a reference simplex (currently disabled for other cell types). The output array is (P,D), where. </p>
<div class="fragment"><div class="line">P - number of points per cell</div>
<div class="line">D - is the spatial dimension</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>[out] - Output array of point coords </td></tr>
    <tr><td class="paramname">order</td><td>[in] - number of points per side, plus 1 </td></tr>
    <tr><td class="paramname">offset</td><td>[in] - Number of points on boundary to skip </td></tr>
    <tr><td class="paramname">cellType</td><td>[in] - type of reference cell (currently only supports the simplex) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html#l00093">93</a> of file <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html">Intrepid_PointToolsDef.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid__PointTools_8hpp_source.html#l00214">getLatticeSize()</a>.</p>

</div>
</div>
<a id="aa0fbe03bf06849e6875361fdedcb874d" name="aa0fbe03bf06849e6875361fdedcb874d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0fbe03bf06849e6875361fdedcb874d">&#9670;&#160;</a></span>getEquispacedLatticeLine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::PointTools::getEquispacedLatticeLine </td>
          <td>(</td>
          <td class="paramtype">ArrayType &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an equispaced lattice of a given order on the reference line [-1,1]. The output array is (P,1), where. </p>
<div class="fragment"><div class="line">P - number of points per cell</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>[out] - Output array of point coords </td></tr>
    <tr><td class="paramname">order</td><td>[in] - The lattice has order + 1 points, minus any skipped by offset </td></tr>
    <tr><td class="paramname">offset</td><td>[in] - Number of points on boundary to skip coming in per boundary </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html#l00179">179</a> of file <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html">Intrepid_PointToolsDef.hpp</a>.</p>

</div>
</div>
<a id="ac4cf910c62460a7d855601fbaada5f07" name="ac4cf910c62460a7d855601fbaada5f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4cf910c62460a7d855601fbaada5f07">&#9670;&#160;</a></span>getEquispacedLatticeTetrahedron()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::PointTools::getEquispacedLatticeTetrahedron </td>
          <td>(</td>
          <td class="paramtype">ArrayType &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an equispaced lattice of a given order on the reference tetrahedron. The output array is (P,3), where. </p>
<div class="fragment"><div class="line">P - number of points, which is </div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>[out] - Output array of point coords </td></tr>
    <tr><td class="paramname">order</td><td>[in] - The lattice has order + 1 points, minus any skipped by offset </td></tr>
    <tr><td class="paramname">offset</td><td>[in] - Number of points on boundary to skip coming in from boundary </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html#l00224">224</a> of file <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html">Intrepid_PointToolsDef.hpp</a>.</p>

</div>
</div>
<a id="a42e64ffe1fa62625cd23bb432e0fe568" name="a42e64ffe1fa62625cd23bb432e0fe568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e64ffe1fa62625cd23bb432e0fe568">&#9670;&#160;</a></span>getEquispacedLatticeTriangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::PointTools::getEquispacedLatticeTriangle </td>
          <td>(</td>
          <td class="paramtype">ArrayType &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an equispaced lattice of a given order on the reference triangle. The output array is (P,2), where. </p>
<div class="fragment"><div class="line">P - number of points, which is </div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>[out] - Output array of point coords </td></tr>
    <tr><td class="paramname">order</td><td>[in] - The lattice has order + 1 points, minus any skipped by offset </td></tr>
    <tr><td class="paramname">offset</td><td>[in] - Number of points on boundary to skip coming in from boundary </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html#l00201">201</a> of file <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html">Intrepid_PointToolsDef.hpp</a>.</p>

</div>
</div>
<a id="a419fd5d12db94424a0289ce29fae3fdc" name="a419fd5d12db94424a0289ce29fae3fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419fd5d12db94424a0289ce29fae3fdc">&#9670;&#160;</a></span>getGaussPoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::PointTools::getGaussPoints </td>
          <td>(</td>
          <td class="paramtype">ArrayType &amp;&#160;</td>
          <td class="paramname"><em>pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves the Gauss-Legendre points from PolyLib, but lets us do it in an arbitrary ArrayType. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pts</td><td>[out] - Output array of point coords (P,) </td></tr>
    <tr><td class="paramname">order</td><td>[out] - number of Gauss points - 1 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html#l00075">75</a> of file <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html">Intrepid_PointToolsDef.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid__PolylibDef_8hpp_source.html#l00113">Intrepid::IntrepidPolylib::zwgj()</a>.</p>

</div>
</div>
<a id="a1d596624a750152ec331b016d46796c8" name="a1d596624a750152ec331b016d46796c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d596624a750152ec331b016d46796c8">&#9670;&#160;</a></span>getLattice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::PointTools::getLattice </td>
          <td>(</td>
          <td class="paramtype">ArrayType &amp;&#160;</td>
          <td class="paramname"><em>pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology &amp;&#160;</td>
          <td class="paramname"><em>cellType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EPointType&#160;</td>
          <td class="paramname"><em>pointType</em> = <code>POINTTYPE_EQUISPACED</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a lattice of points of a given order on a reference simplex (currently disabled for other cell types). The output array is (P,D), where. </p>
<div class="fragment"><div class="line">P - number of points per cell</div>
<div class="line">D - is the spatial dimension</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pts</td><td>[out] - Output array of point coords </td></tr>
    <tr><td class="paramname">cellType</td><td>[in] - type of reference cell (currently only supports the simplex) </td></tr>
    <tr><td class="paramname">order</td><td>[in] - number of points per side, plus 1 </td></tr>
    <tr><td class="paramname">pointType</td><td>[in] - flag for point distribution. Currently equispaced and warp/blend points are supported </td></tr>
    <tr><td class="paramname">offset</td><td>[in] - Number of points on boundary to skip </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html#l00052">52</a> of file <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html">Intrepid_PointToolsDef.hpp</a>.</p>

</div>
</div>
<a id="ae30fb50abe590300a63cf67f1c49ddf4" name="ae30fb50abe590300a63cf67f1c49ddf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30fb50abe590300a63cf67f1c49ddf4">&#9670;&#160;</a></span>getLatticeSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Intrepid::PointTools::getLatticeSize </td>
          <td>(</td>
          <td class="paramtype">const shards::CellTopology &amp;&#160;</td>
          <td class="paramname"><em>cellType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of points in a lattice of a given order on a simplex (currently disabled for other cell types). If offset == 0, the lattice will include only include the vertex points if order == 1, and will include edge midpoints if order == 2, and so on. <br  />
 In particular, this is the dimension of polynomials of degree "order" on the given simplex. The offset argument is used to indicate that the layer of points on the boundary is omitted (if offset == 1). For greater offsets, more layers are omitteed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cellType</td><td>[in] - type of reference cell (currently only supports the simplex) </td></tr>
    <tr><td class="paramname">order</td><td>[in] - order of the lattice </td></tr>
    <tr><td class="paramname">offset</td><td>[in] - the number of boundary layers to omit </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__PointTools_8hpp_source.html#l00214">214</a> of file <a class="el" href="Intrepid__PointTools_8hpp_source.html">Intrepid_PointTools.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Intrepid__HCURL__TET__In__FEMDef_8hpp_source.html#l00053">Intrepid::Basis_HCURL_TET_In_FEM&lt; Scalar, ArrayScalar &gt;::Basis_HCURL_TET_In_FEM()</a>, <a class="el" href="Intrepid__HCURL__TRI__In__FEMDef_8hpp_source.html#l00053">Intrepid::Basis_HCURL_TRI_In_FEM&lt; Scalar, ArrayScalar &gt;::Basis_HCURL_TRI_In_FEM()</a>, <a class="el" href="Intrepid__HDIV__TET__In__FEMDef_8hpp_source.html#l00053">Intrepid::Basis_HDIV_TET_In_FEM&lt; Scalar, ArrayScalar &gt;::Basis_HDIV_TET_In_FEM()</a>, <a class="el" href="Intrepid__HDIV__TRI__In__FEMDef_8hpp_source.html#l00053">Intrepid::Basis_HDIV_TRI_In_FEM&lt; Scalar, ArrayScalar &gt;::Basis_HDIV_TRI_In_FEM()</a>, <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html#l00093">getEquispacedLattice()</a>, <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html#l00134">getWarpBlendLattice()</a>, <a class="el" href="Intrepid__HCURL__TET__In__FEMDef_8hpp_source.html#l00367">Intrepid::Basis_HCURL_TET_In_FEM&lt; Scalar, ArrayScalar &gt;::initializeTags()</a>, <a class="el" href="Intrepid__HGRAD__TET__Cn__FEMDef_8hpp_source.html#l00107">Intrepid::Basis_HGRAD_TET_Cn_FEM&lt; Scalar, ArrayScalar &gt;::initializeTags()</a>, and <a class="el" href="Discretization_2Basis_2HCURL__TET__In__FEM_2test__01_8cpp_source.html#l00065">main()</a>.</p>

</div>
</div>
<a id="a9ca7ddbaa1cefd8ce5b39bb93d8e3442" name="a9ca7ddbaa1cefd8ce5b39bb93d8e3442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca7ddbaa1cefd8ce5b39bb93d8e3442">&#9670;&#160;</a></span>getWarpBlendLattice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::PointTools::getWarpBlendLattice </td>
          <td>(</td>
          <td class="paramtype">const shards::CellTopology &amp;&#160;</td>
          <td class="paramname"><em>cellType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a warped lattice (ala Warburton's warp-blend points of a given order on a reference simplex (currently disabled for other cell types). The output array is (P,D), where. </p>
<div class="fragment"><div class="line">P - number of points per cell</div>
<div class="line">D - is the spatial dimension</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>[out] - Output array of point coords </td></tr>
    <tr><td class="paramname">order</td><td>[in] - number of points per side, plus 1 </td></tr>
    <tr><td class="paramname">offset</td><td>[in] - Number of points on boundary to skip </td></tr>
    <tr><td class="paramname">cellType</td><td>[in] - type of reference cell (currently only supports the simplex) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html#l00134">134</a> of file <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html">Intrepid_PointToolsDef.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid__PointTools_8hpp_source.html#l00214">getLatticeSize()</a>.</p>

</div>
</div>
<a id="a99c89a0a1fa06ef2b8d039e70f424669" name="a99c89a0a1fa06ef2b8d039e70f424669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c89a0a1fa06ef2b8d039e70f424669">&#9670;&#160;</a></span>getWarpBlendLatticeLine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::PointTools::getWarpBlendLatticeLine </td>
          <td>(</td>
          <td class="paramtype">ArrayType &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Gauss-Lobatto points of a given order on the reference line [-1,1]. The output array is (P,1), where. </p>
<div class="fragment"><div class="line">P - number of points</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>[out] - Output array of point coords </td></tr>
    <tr><td class="paramname">order</td><td>[in] - The lattice has order + 1 points, minus any skipped by offset </td></tr>
    <tr><td class="paramname">offset</td><td>[in] - Number of points on boundary to skip coming in per boundary </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html#l00250">250</a> of file <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html">Intrepid_PointToolsDef.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid__PolylibDef_8hpp_source.html#l00182">Intrepid::IntrepidPolylib::zwglj()</a>.</p>

</div>
</div>
<a id="a18592e115f6fd8736743e4ba4a6ca164" name="a18592e115f6fd8736743e4ba4a6ca164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18592e115f6fd8736743e4ba4a6ca164">&#9670;&#160;</a></span>getWarpBlendLatticeTetrahedron()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::PointTools::getWarpBlendLatticeTetrahedron </td>
          <td>(</td>
          <td class="paramtype">ArrayType &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns Warburton's warp-blend points of a given order on the reference tetrahedron. The output array is (P,3), where. </p>
<div class="fragment"><div class="line">P - number of points</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>[out] - Output array of point coords </td></tr>
    <tr><td class="paramname">order</td><td>[in] - The lattice has order + 1 points, minus any skipped by offset </td></tr>
    <tr><td class="paramname">offset</td><td>[in] - Number of points on boundary to skip coming in per boundary </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html#l00612">612</a> of file <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html">Intrepid_PointToolsDef.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid__FieldContainerDef_8hpp_source.html#l01374">Intrepid::FieldContainer&lt; Scalar, ArrayTypeId &gt;::initialize()</a>, <a class="el" href="Intrepid__CellToolsDef_8hpp_source.html#l01662">Intrepid::CellTools&lt; Scalar &gt;::mapToReferenceFrame()</a>, and <a class="el" href="Intrepid__FieldContainerDef_8hpp_source.html#l01137">Intrepid::FieldContainer&lt; Scalar, ArrayTypeId &gt;::resize()</a>.</p>

</div>
</div>
<a id="a2d167d3b78227faf5d44fc90223940be" name="a2d167d3b78227faf5d44fc90223940be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d167d3b78227faf5d44fc90223940be">&#9670;&#160;</a></span>getWarpBlendLatticeTriangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::PointTools::getWarpBlendLatticeTriangle </td>
          <td>(</td>
          <td class="paramtype">ArrayType &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns Warburton's warp-blend points of a given order on the reference triangle. The output array is (P,2), where. </p>
<div class="fragment"><div class="line">P - number of points</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>[out] - Output array of point coords </td></tr>
    <tr><td class="paramname">order</td><td>[in] - The lattice has order + 1 points, minus any skipped by offset </td></tr>
    <tr><td class="paramname">offset</td><td>[in] - Number of points on boundary to skip coming in per boundary </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html#l00332">332</a> of file <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html">Intrepid_PointToolsDef.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid__FieldContainerDef_8hpp_source.html#l00658">Intrepid::FieldContainer&lt; Scalar, ArrayTypeId &gt;::dimension()</a>, <a class="el" href="Intrepid__CellToolsDef_8hpp_source.html#l01662">Intrepid::CellTools&lt; Scalar &gt;::mapToReferenceFrame()</a>, and <a class="el" href="Intrepid__FieldContainerDef_8hpp_source.html#l01137">Intrepid::FieldContainer&lt; Scalar, ArrayTypeId &gt;::resize()</a>.</p>

</div>
</div>
<a id="a1d269d3c5b19d45e8cc93e562ac302ca" name="a1d269d3c5b19d45e8cc93e562ac302ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d269d3c5b19d45e8cc93e562ac302ca">&#9670;&#160;</a></span>warpFactor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::PointTools::warpFactor </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType &amp;&#160;</td>
          <td class="paramname"><em>xnodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType &amp;&#160;</td>
          <td class="paramname"><em>xout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType &amp;&#160;</td>
          <td class="paramname"><em>warp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>interpolates Warburton's warp function on the line </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>[in] - The polynomial order </td></tr>
    <tr><td class="paramname">xnodes</td><td>[in] - vector of node locations to interpolate </td></tr>
    <tr><td class="paramname">xout</td><td>[in] - warpfunction at xout, +/- 1 roots deflated </td></tr>
    <tr><td class="paramname">warp</td><td>[out] - the amount to warp each point </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html#l00272">272</a> of file <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html">Intrepid_PointToolsDef.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid__FieldContainerDef_8hpp_source.html#l00658">Intrepid::FieldContainer&lt; Scalar, ArrayTypeId &gt;::dimension()</a>, <a class="el" href="Intrepid__FieldContainerDef_8hpp_source.html#l01374">Intrepid::FieldContainer&lt; Scalar, ArrayTypeId &gt;::initialize()</a>, and <a class="el" href="Intrepid__FieldContainerDef_8hpp_source.html#l01137">Intrepid::FieldContainer&lt; Scalar, ArrayTypeId &gt;::resize()</a>.</p>

</div>
</div>
<a id="af7f0294f42c505e35e36586ac366f4d7" name="af7f0294f42c505e35e36586ac366f4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f0294f42c505e35e36586ac366f4d7">&#9670;&#160;</a></span>warpShiftFace3D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::PointTools::warpShiftFace3D </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>pval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType &amp;&#160;</td>
          <td class="paramname"><em>L1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType &amp;&#160;</td>
          <td class="paramname"><em>L2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType &amp;&#160;</td>
          <td class="paramname"><em>L3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType &amp;&#160;</td>
          <td class="paramname"><em>L4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType &amp;&#160;</td>
          <td class="paramname"><em>dxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used internally to compute the tetrahedral warp-blend points one each face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>[in] - the order of lattice </td></tr>
    <tr><td class="paramname">pval</td><td>[in] - the "alpha" term in the warping function </td></tr>
    <tr><td class="paramname">L1</td><td>[in] - the first barycentric coordinate of the input points </td></tr>
    <tr><td class="paramname">L2</td><td>[in] - the second barycentric coordinate of the input points </td></tr>
    <tr><td class="paramname">L3</td><td>[in] - the third barycentric coordinate of the input points </td></tr>
    <tr><td class="paramname">L4</td><td>[in] - the fourth barycentric coordinate of the input points </td></tr>
    <tr><td class="paramname">dxy</td><td>[out] - contains the amount to shift each point in the x and y direction </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html#l00474">474</a> of file <a class="el" href="Intrepid__PointToolsDef_8hpp_source.html">Intrepid_PointToolsDef.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/trilinos.github.io/trilinos.github.io/Trilinos/packages/intrepid/src/Shared/<a class="el" href="Intrepid__PointTools_8hpp_source.html">Intrepid_PointTools.hpp</a></li>
<li>/home/runner/work/trilinos.github.io/trilinos.github.io/Trilinos/packages/intrepid/src/Shared/<a class="el" href="Intrepid__PointToolsDef_8hpp_source.html">Intrepid_PointToolsDef.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
