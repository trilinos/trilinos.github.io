<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Intrepid: Intrepid::FunctionSpaceTools Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Intrepid
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Intrepid</b></li><li class="navelem"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html">FunctionSpaceTools</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classIntrepid_1_1FunctionSpaceTools-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Intrepid::FunctionSpaceTools Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Defines expert-level interfaces for the evaluation of functions and operators in physical space (supported for FE, FV, and FD methods) and FE reference space; in addition, provides several function transformation utilities.  
 <a href="classIntrepid_1_1FunctionSpaceTools.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Intrepid__FunctionSpaceTools_8hpp_source.html">Intrepid_FunctionSpaceTools.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIntrepid_1_1FunctionSpaceTools_1_1integrateTempSpec.html">integrateTempSpec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIntrepid_1_1FunctionSpaceTools_1_1tensorMultiplyDataDataTempSpec.html">tensorMultiplyDataDataTempSpec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIntrepid_1_1FunctionSpaceTools_1_1tensorMultiplyDataDataTempSpec_3_01Scalar_00_01ArrayOutD4cdbd9252b278eb5018f63e0f283cc56.html">tensorMultiplyDataDataTempSpec&lt; Scalar, ArrayOutData, ArrayInDataLeft, ArrayInDataRight, 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIntrepid_1_1FunctionSpaceTools_1_1tensorMultiplyDataDataTempSpec_3_01Scalar_00_01ArrayOutD074af65e92e04f5062d1565e80e0c7d9.html">tensorMultiplyDataDataTempSpec&lt; Scalar, ArrayOutData, ArrayInDataLeft, ArrayInDataRight, 4 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIntrepid_1_1FunctionSpaceTools_1_1tensorMultiplyDataDataTempSpec_3_01Scalar_00_01ArrayOutD2910d81626956cfe19f41919299bb94c.html">tensorMultiplyDataDataTempSpec&lt; Scalar, ArrayOutData, ArrayInDataLeft, ArrayInDataRight,-1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a20482ce96c48b4b06aa3bedb3ef9b20b" id="r_a20482ce96c48b4b06aa3bedb3ef9b20b"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayTypeOut , class ArrayTypeIn &gt; </td></tr>
<tr class="memitem:a20482ce96c48b4b06aa3bedb3ef9b20b"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#a20482ce96c48b4b06aa3bedb3ef9b20b">HGRADtransformVALUE</a> (ArrayTypeOut &amp;outVals, const ArrayTypeIn &amp;inVals)</td></tr>
<tr class="memdesc:a20482ce96c48b4b06aa3bedb3ef9b20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation of a (scalar) value field in the H-grad space, defined at points on a reference cell, stored in the user-provided container <em><b>inVals</b></em> and indexed by (F,P), into the output container <em><b>outVals</b></em>, defined on cells in physical space and indexed by (C,F,P).  <br /></td></tr>
<tr class="separator:a20482ce96c48b4b06aa3bedb3ef9b20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e09812bd7911caa65f792afb387fed" id="r_a80e09812bd7911caa65f792afb387fed"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayTypeOut , class ArrayTypeJac , class ArrayTypeIn &gt; </td></tr>
<tr class="memitem:a80e09812bd7911caa65f792afb387fed"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#a80e09812bd7911caa65f792afb387fed">HGRADtransformGRAD</a> (ArrayTypeOut &amp;outVals, const ArrayTypeJac &amp;jacobianInverse, const ArrayTypeIn &amp;inVals, const char transpose='T')</td></tr>
<tr class="memdesc:a80e09812bd7911caa65f792afb387fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation of a gradient field in the H-grad space, defined at points on a reference cell, stored in the user-provided container <em><b>inVals</b></em> and indexed by (F,P,D), into the output container <em><b>outVals</b></em>, defined on cells in physical space and indexed by (C,F,P,D).  <br /></td></tr>
<tr class="separator:a80e09812bd7911caa65f792afb387fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c79ab919fe41f9da4b7b7c63d5c867" id="r_a35c79ab919fe41f9da4b7b7c63d5c867"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayTypeOut , class ArrayTypeJac , class ArrayTypeIn &gt; </td></tr>
<tr class="memitem:a35c79ab919fe41f9da4b7b7c63d5c867"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#a35c79ab919fe41f9da4b7b7c63d5c867">HCURLtransformVALUE</a> (ArrayTypeOut &amp;outVals, const ArrayTypeJac &amp;jacobianInverse, const ArrayTypeIn &amp;inVals, const char transpose='T')</td></tr>
<tr class="memdesc:a35c79ab919fe41f9da4b7b7c63d5c867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation of a (vector) value field in the H-curl space, defined at points on a reference cell, stored in the user-provided container <em><b>inVals</b></em> and indexed by (F,P,D), into the output container <em><b>outVals</b></em>, defined on cells in physical space and indexed by (C,F,P,D).  <br /></td></tr>
<tr class="separator:a35c79ab919fe41f9da4b7b7c63d5c867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6a9cc34cf0b19175639225781e9d7b" id="r_aec6a9cc34cf0b19175639225781e9d7b"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayTypeOut , class ArrayTypeJac , class ArrayTypeDet , class ArrayTypeIn &gt; </td></tr>
<tr class="memitem:aec6a9cc34cf0b19175639225781e9d7b"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#aec6a9cc34cf0b19175639225781e9d7b">HCURLtransformCURL</a> (ArrayTypeOut &amp;outVals, const ArrayTypeJac &amp;jacobian, const ArrayTypeDet &amp;jacobianDet, const ArrayTypeIn &amp;inVals, const char transpose='N')</td></tr>
<tr class="memdesc:aec6a9cc34cf0b19175639225781e9d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation of a curl field in the H-curl space, defined at points on a reference cell, stored in the user-provided container <em><b>inVals</b></em> and indexed by (F,P,D), into the output container <em><b>outVals</b></em>, defined on cells in physical space and indexed by (C,F,P,D).  <br /></td></tr>
<tr class="separator:aec6a9cc34cf0b19175639225781e9d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92933a7158b1a61371cc892a61ee4c0" id="r_af92933a7158b1a61371cc892a61ee4c0"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayTypeOut , class ArrayTypeJac , class ArrayTypeDet , class ArrayTypeIn &gt; </td></tr>
<tr class="memitem:af92933a7158b1a61371cc892a61ee4c0"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#af92933a7158b1a61371cc892a61ee4c0">HDIVtransformVALUE</a> (ArrayTypeOut &amp;outVals, const ArrayTypeJac &amp;jacobian, const ArrayTypeDet &amp;jacobianDet, const ArrayTypeIn &amp;inVals, const char transpose='N')</td></tr>
<tr class="memdesc:af92933a7158b1a61371cc892a61ee4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation of a (vector) value field in the H-div space, defined at points on a reference cell, stored in the user-provided container <em><b>inVals</b></em> and indexed by (F,P,D), into the output container <em><b>outVals</b></em>, defined on cells in physical space and indexed by (C,F,P,D).  <br /></td></tr>
<tr class="separator:af92933a7158b1a61371cc892a61ee4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab078baa28ad28d019584db556a7fdd" id="r_a0ab078baa28ad28d019584db556a7fdd"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayTypeOut , class ArrayTypeDet , class ArrayTypeIn &gt; </td></tr>
<tr class="memitem:a0ab078baa28ad28d019584db556a7fdd"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#a0ab078baa28ad28d019584db556a7fdd">HDIVtransformDIV</a> (ArrayTypeOut &amp;outVals, const ArrayTypeDet &amp;jacobianDet, const ArrayTypeIn &amp;inVals)</td></tr>
<tr class="memdesc:a0ab078baa28ad28d019584db556a7fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation of a divergence field in the H-div space, defined at points on a reference cell, stored in the user-provided container <em><b>inVals</b></em> and indexed by (F,P), into the output container <em><b>outVals</b></em>, defined on cells in physical space and indexed by (C,F,P).  <br /></td></tr>
<tr class="separator:a0ab078baa28ad28d019584db556a7fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3170d65efd4bfb10ba6c7e8613edc703" id="r_a3170d65efd4bfb10ba6c7e8613edc703"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayTypeOut , class ArrayTypeDet , class ArrayTypeIn &gt; </td></tr>
<tr class="memitem:a3170d65efd4bfb10ba6c7e8613edc703"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#a3170d65efd4bfb10ba6c7e8613edc703">HVOLtransformVALUE</a> (ArrayTypeOut &amp;outVals, const ArrayTypeDet &amp;jacobianDet, const ArrayTypeIn &amp;inVals)</td></tr>
<tr class="memdesc:a3170d65efd4bfb10ba6c7e8613edc703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation of a (scalar) value field in the H-vol space, defined at points on a reference cell, stored in the user-provided container <em><b>inVals</b></em> and indexed by (F,P), into the output container <em><b>outVals</b></em>, defined on cells in physical space and indexed by (C,F,P).  <br /></td></tr>
<tr class="separator:a3170d65efd4bfb10ba6c7e8613edc703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06be52995a74de7a322ccfb2577a3483" id="r_a06be52995a74de7a322ccfb2577a3483"><td class="memTemplParams" colspan="2">template&lt;class Scalar &gt; </td></tr>
<tr class="memitem:a06be52995a74de7a322ccfb2577a3483"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#a06be52995a74de7a322ccfb2577a3483">integrate</a> (<a class="el" href="classIntrepid_1_1FieldContainer.html">Intrepid::FieldContainer</a>&lt; Scalar &gt; &amp;outputValues, const <a class="el" href="classIntrepid_1_1FieldContainer.html">Intrepid::FieldContainer</a>&lt; Scalar &gt; &amp;leftValues, const <a class="el" href="classIntrepid_1_1FieldContainer.html">Intrepid::FieldContainer</a>&lt; Scalar &gt; &amp;rightValues, const ECompEngine compEngine, const bool sumInto=false)</td></tr>
<tr class="memdesc:a06be52995a74de7a322ccfb2577a3483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contracts <em><b>leftValues</b></em> and <em><b>rightValues</b></em> arrays on the point and possibly space dimensions and stores the result in <em><b>outputValues</b></em>; this is a generic, high-level integration routine that calls either <a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#abbbc0102f5f0effe5d5feb5a0dd610cf" title="Contracts the point (and space) dimensions P (and D1 and D2) of two rank-3, 4, or 5 containers with d...">FunctionSpaceTools::operatorIntegral</a>, or <a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#ad22cf40200ce1db4ff6658b1b95c2c50" title="Contracts the point (and space) dimensions P (and D1 and D2) of a rank-3, 4, or 5 container and a ran...">FunctionSpaceTools::functionalIntegral</a>, or <a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#ae23e64fb1c915530e3f0c4b5feb8727c" title="Contracts the point (and space) dimensions P (and D1 and D2) of two rank-2, 3, or 4 containers with d...">FunctionSpaceTools::dataIntegral</a> methods, depending on the rank of the <em><b>outputValues</b></em> array.  <br /></td></tr>
<tr class="separator:a06be52995a74de7a322ccfb2577a3483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959e85fc5a065de83a28ab1724b509fc" id="r_a959e85fc5a065de83a28ab1724b509fc"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayOut , class ArrayInLeft , class ArrayInRight &gt; </td></tr>
<tr class="memitem:a959e85fc5a065de83a28ab1724b509fc"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#a959e85fc5a065de83a28ab1724b509fc">integrate</a> (ArrayOut &amp;outputValues, const ArrayInLeft &amp;leftValues, const ArrayInRight &amp;rightValues, const ECompEngine compEngine, const bool sumInto=false)</td></tr>
<tr class="separator:a959e85fc5a065de83a28ab1724b509fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbc0102f5f0effe5d5feb5a0dd610cf" id="r_abbbc0102f5f0effe5d5feb5a0dd610cf"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayOutFields , class ArrayInFieldsLeft , class ArrayInFieldsRight &gt; </td></tr>
<tr class="memitem:abbbc0102f5f0effe5d5feb5a0dd610cf"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#abbbc0102f5f0effe5d5feb5a0dd610cf">operatorIntegral</a> (ArrayOutFields &amp;outputFields, const ArrayInFieldsLeft &amp;leftFields, const ArrayInFieldsRight &amp;rightFields, const ECompEngine compEngine, const bool sumInto=false)</td></tr>
<tr class="memdesc:abbbc0102f5f0effe5d5feb5a0dd610cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contracts the point (and space) dimensions P (and D1 and D2) of two rank-3, 4, or 5 containers with dimensions (C,L,P) and (C,R,P), or (C,L,P,D1) and (C,R,P,D1), or (C,L,P,D1,D2) and (C,R,P,D1,D2), and returns the result in a rank-3 container with dimensions (C,L,R).  <br /></td></tr>
<tr class="separator:abbbc0102f5f0effe5d5feb5a0dd610cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22cf40200ce1db4ff6658b1b95c2c50" id="r_ad22cf40200ce1db4ff6658b1b95c2c50"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayOutFields , class ArrayInData , class ArrayInFields &gt; </td></tr>
<tr class="memitem:ad22cf40200ce1db4ff6658b1b95c2c50"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#ad22cf40200ce1db4ff6658b1b95c2c50">functionalIntegral</a> (ArrayOutFields &amp;outputFields, const ArrayInData &amp;inputData, const ArrayInFields &amp;inputFields, const ECompEngine compEngine, const bool sumInto=false)</td></tr>
<tr class="memdesc:ad22cf40200ce1db4ff6658b1b95c2c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contracts the point (and space) dimensions P (and D1 and D2) of a rank-3, 4, or 5 container and a rank-2, 3, or 4 container, respectively, with dimensions (C,F,P) and (C,P), or (C,F,P,D1) and (C,P,D1), or (C,F,P,D1,D2) and (C,P,D1,D2), respectively, and returns the result in a rank-2 container with dimensions (C,F).  <br /></td></tr>
<tr class="separator:ad22cf40200ce1db4ff6658b1b95c2c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23e64fb1c915530e3f0c4b5feb8727c" id="r_ae23e64fb1c915530e3f0c4b5feb8727c"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayOutData , class ArrayInDataLeft , class ArrayInDataRight &gt; </td></tr>
<tr class="memitem:ae23e64fb1c915530e3f0c4b5feb8727c"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#ae23e64fb1c915530e3f0c4b5feb8727c">dataIntegral</a> (ArrayOutData &amp;outputData, const ArrayInDataLeft &amp;inputDataLeft, const ArrayInDataRight &amp;inputDataRight, const ECompEngine compEngine, const bool sumInto=false)</td></tr>
<tr class="memdesc:ae23e64fb1c915530e3f0c4b5feb8727c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contracts the point (and space) dimensions P (and D1 and D2) of two rank-2, 3, or 4 containers with dimensions (C,P), or (C,P,D1), or (C,P,D1,D2), respectively, and returns the result in a rank-1 container with dimensions (C).  <br /></td></tr>
<tr class="separator:ae23e64fb1c915530e3f0c4b5feb8727c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88aa764489ab4e79cfdd9e4994d1e458" id="r_a88aa764489ab4e79cfdd9e4994d1e458"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayOut , class ArrayDet , class ArrayWeights &gt; </td></tr>
<tr class="memitem:a88aa764489ab4e79cfdd9e4994d1e458"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#a88aa764489ab4e79cfdd9e4994d1e458">computeCellMeasure</a> (ArrayOut &amp;outVals, const ArrayDet &amp;inDet, const ArrayWeights &amp;inWeights)</td></tr>
<tr class="memdesc:a88aa764489ab4e79cfdd9e4994d1e458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weighted integration measures <em><b>outVals</b></em> with dimensions (C,P) used for the computation of cell integrals, by multiplying absolute values of the user-provided cell Jacobian determinants <em><b>inDet</b></em> with dimensions (C,P) with the user-provided integration weights <em><b>inWeights</b></em> with dimensions (P).  <br /></td></tr>
<tr class="separator:a88aa764489ab4e79cfdd9e4994d1e458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01407227e9f58d6432f933e0e4d5f1ec" id="r_a01407227e9f58d6432f933e0e4d5f1ec"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayOut , class ArrayJac , class ArrayWeights &gt; </td></tr>
<tr class="memitem:a01407227e9f58d6432f933e0e4d5f1ec"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#a01407227e9f58d6432f933e0e4d5f1ec">computeFaceMeasure</a> (ArrayOut &amp;outVals, const ArrayJac &amp;inJac, const ArrayWeights &amp;inWeights, const int whichFace, const shards::CellTopology &amp;parentCell)</td></tr>
<tr class="memdesc:a01407227e9f58d6432f933e0e4d5f1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weighted integration measures <em><b>outVals</b></em> with dimensions (C,P) used for the computation of face integrals, based on the provided cell Jacobian array <em><b>inJac</b></em> with dimensions (C,P,D,D) and the provided integration weights <em><b>inWeights</b></em> with dimensions (P).  <br /></td></tr>
<tr class="separator:a01407227e9f58d6432f933e0e4d5f1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21e68a1d026a67ffd86825b4405835e" id="r_ae21e68a1d026a67ffd86825b4405835e"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayOut , class ArrayJac , class ArrayWeights &gt; </td></tr>
<tr class="memitem:ae21e68a1d026a67ffd86825b4405835e"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#ae21e68a1d026a67ffd86825b4405835e">computeEdgeMeasure</a> (ArrayOut &amp;outVals, const ArrayJac &amp;inJac, const ArrayWeights &amp;inWeights, const int whichEdge, const shards::CellTopology &amp;parentCell)</td></tr>
<tr class="memdesc:ae21e68a1d026a67ffd86825b4405835e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weighted integration measures <em><b>outVals</b></em> with dimensions (C,P) used for the computation of edge integrals, based on the provided cell Jacobian array <em><b>inJac</b></em> with dimensions (C,P,D,D) and the provided integration weights <em><b>inWeights</b></em> with dimensions (P).  <br /></td></tr>
<tr class="separator:ae21e68a1d026a67ffd86825b4405835e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2e517d104db7107bb3b97cdd687b37" id="r_a6b2e517d104db7107bb3b97cdd687b37"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayTypeOut , class ArrayTypeMeasure , class ArrayTypeIn &gt; </td></tr>
<tr class="memitem:a6b2e517d104db7107bb3b97cdd687b37"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#a6b2e517d104db7107bb3b97cdd687b37">multiplyMeasure</a> (ArrayTypeOut &amp;outVals, const ArrayTypeMeasure &amp;inMeasure, const ArrayTypeIn &amp;inVals)</td></tr>
<tr class="memdesc:a6b2e517d104db7107bb3b97cdd687b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies fields <em><b>inVals</b></em> by weighted measures <em><b>inMeasure</b></em> and returns the field array <em><b>outVals</b></em>; this is a simple redirection to the call <a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#a345f956ddf08c481ebc3e69509302392" title="Scalar multiplication of data and fields; please read the description below.">FunctionSpaceTools::scalarMultiplyDataField</a>.  <br /></td></tr>
<tr class="separator:a6b2e517d104db7107bb3b97cdd687b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345f956ddf08c481ebc3e69509302392" id="r_a345f956ddf08c481ebc3e69509302392"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayOutFields , class ArrayInData , class ArrayInFields &gt; </td></tr>
<tr class="memitem:a345f956ddf08c481ebc3e69509302392"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#a345f956ddf08c481ebc3e69509302392">scalarMultiplyDataField</a> (ArrayOutFields &amp;outputFields, ArrayInData &amp;inputData, ArrayInFields &amp;inputFields, const bool reciprocal=false)</td></tr>
<tr class="memdesc:a345f956ddf08c481ebc3e69509302392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiplication of data and fields; please read the description below.  <br /></td></tr>
<tr class="separator:a345f956ddf08c481ebc3e69509302392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4545b6a57509402e1ef384f1903b24ad" id="r_a4545b6a57509402e1ef384f1903b24ad"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayOutData , class ArrayInDataLeft , class ArrayInDataRight &gt; </td></tr>
<tr class="memitem:a4545b6a57509402e1ef384f1903b24ad"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#a4545b6a57509402e1ef384f1903b24ad">scalarMultiplyDataData</a> (ArrayOutData &amp;outputData, ArrayInDataLeft &amp;inputDataLeft, ArrayInDataRight &amp;inputDataRight, const bool reciprocal=false)</td></tr>
<tr class="memdesc:a4545b6a57509402e1ef384f1903b24ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiplication of data and data; please read the description below.  <br /></td></tr>
<tr class="separator:a4545b6a57509402e1ef384f1903b24ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f74d9e6c6c19c342c101f41b3899fba" id="r_a4f74d9e6c6c19c342c101f41b3899fba"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayOutFields , class ArrayInData , class ArrayInFields &gt; </td></tr>
<tr class="memitem:a4f74d9e6c6c19c342c101f41b3899fba"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#a4f74d9e6c6c19c342c101f41b3899fba">dotMultiplyDataField</a> (ArrayOutFields &amp;outputFields, const ArrayInData &amp;inputData, const ArrayInFields &amp;inputFields)</td></tr>
<tr class="memdesc:a4f74d9e6c6c19c342c101f41b3899fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product of data and fields; please read the description below.  <br /></td></tr>
<tr class="separator:a4f74d9e6c6c19c342c101f41b3899fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af743faa14c628e374e5a54cbb7f8ee" id="r_a5af743faa14c628e374e5a54cbb7f8ee"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayOutData , class ArrayInDataLeft , class ArrayInDataRight &gt; </td></tr>
<tr class="memitem:a5af743faa14c628e374e5a54cbb7f8ee"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#a5af743faa14c628e374e5a54cbb7f8ee">dotMultiplyDataData</a> (ArrayOutData &amp;outputData, const ArrayInDataLeft &amp;inputDataLeft, const ArrayInDataRight &amp;inputDataRight)</td></tr>
<tr class="memdesc:a5af743faa14c628e374e5a54cbb7f8ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product of data and data; please read the description below.  <br /></td></tr>
<tr class="separator:a5af743faa14c628e374e5a54cbb7f8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048776f734e3aa80e9a6cd199fa6874d" id="r_a048776f734e3aa80e9a6cd199fa6874d"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayOutFields , class ArrayInData , class ArrayInFields &gt; </td></tr>
<tr class="memitem:a048776f734e3aa80e9a6cd199fa6874d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#a048776f734e3aa80e9a6cd199fa6874d">vectorMultiplyDataField</a> (ArrayOutFields &amp;outputFields, const ArrayInData &amp;inputData, const ArrayInFields &amp;inputFields)</td></tr>
<tr class="memdesc:a048776f734e3aa80e9a6cd199fa6874d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross or outer product of data and fields; please read the description below.  <br /></td></tr>
<tr class="separator:a048776f734e3aa80e9a6cd199fa6874d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748d81ba4f7fe9019ffbfc51c146904d" id="r_a748d81ba4f7fe9019ffbfc51c146904d"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayOutData , class ArrayInDataLeft , class ArrayInDataRight &gt; </td></tr>
<tr class="memitem:a748d81ba4f7fe9019ffbfc51c146904d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#a748d81ba4f7fe9019ffbfc51c146904d">vectorMultiplyDataData</a> (ArrayOutData &amp;outputData, const ArrayInDataLeft &amp;inputDataLeft, const ArrayInDataRight &amp;inputDataRight)</td></tr>
<tr class="memdesc:a748d81ba4f7fe9019ffbfc51c146904d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross or outer product of data and data; please read the description below.  <br /></td></tr>
<tr class="separator:a748d81ba4f7fe9019ffbfc51c146904d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2dd693fe53ea58a56a674284c99e79" id="r_aec2dd693fe53ea58a56a674284c99e79"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayOutFields , class ArrayInData , class ArrayInFields &gt; </td></tr>
<tr class="memitem:aec2dd693fe53ea58a56a674284c99e79"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#aec2dd693fe53ea58a56a674284c99e79">tensorMultiplyDataField</a> (ArrayOutFields &amp;outputFields, const ArrayInData &amp;inputData, const ArrayInFields &amp;inputFields, const char transpose='N')</td></tr>
<tr class="memdesc:aec2dd693fe53ea58a56a674284c99e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix-vector or matrix-matrix product of data and fields; please read the description below.  <br /></td></tr>
<tr class="separator:aec2dd693fe53ea58a56a674284c99e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aabba1d8d8a0d9dea04c4f26fd2ff78" id="r_a2aabba1d8d8a0d9dea04c4f26fd2ff78"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayOutData , class ArrayInDataLeft , class ArrayInDataRight &gt; </td></tr>
<tr class="memitem:a2aabba1d8d8a0d9dea04c4f26fd2ff78"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#a2aabba1d8d8a0d9dea04c4f26fd2ff78">tensorMultiplyDataData</a> (ArrayOutData &amp;outputData, const ArrayInDataLeft &amp;inputDataLeft, const ArrayInDataRight &amp;inputDataRight, const char transpose='N')</td></tr>
<tr class="memdesc:a2aabba1d8d8a0d9dea04c4f26fd2ff78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix-vector or matrix-matrix product of data and data; please read the description below.  <br /></td></tr>
<tr class="separator:a2aabba1d8d8a0d9dea04c4f26fd2ff78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7091e8f6fc0bf4cd9e621ce888dfc7a7" id="r_a7091e8f6fc0bf4cd9e621ce888dfc7a7"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayTypeInOut , class ArrayTypeSign &gt; </td></tr>
<tr class="memitem:a7091e8f6fc0bf4cd9e621ce888dfc7a7"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#a7091e8f6fc0bf4cd9e621ce888dfc7a7">applyLeftFieldSigns</a> (ArrayTypeInOut &amp;inoutOperator, const ArrayTypeSign &amp;fieldSigns)</td></tr>
<tr class="memdesc:a7091e8f6fc0bf4cd9e621ce888dfc7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies left (row) signs, stored in the user-provided container <em><b>fieldSigns</b></em> and indexed by (C,L), to the operator <em><b>inoutOperator</b></em> indexed by (C,L,R).  <br /></td></tr>
<tr class="separator:a7091e8f6fc0bf4cd9e621ce888dfc7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448a2aacc500464013bccab75276981b" id="r_a448a2aacc500464013bccab75276981b"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayTypeInOut , class ArrayTypeSign &gt; </td></tr>
<tr class="memitem:a448a2aacc500464013bccab75276981b"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#a448a2aacc500464013bccab75276981b">applyRightFieldSigns</a> (ArrayTypeInOut &amp;inoutOperator, const ArrayTypeSign &amp;fieldSigns)</td></tr>
<tr class="memdesc:a448a2aacc500464013bccab75276981b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies right (column) signs, stored in the user-provided container <em><b>fieldSigns</b></em> and indexed by (C,R), to the operator <em><b>inoutOperator</b></em> indexed by (C,L,R).  <br /></td></tr>
<tr class="separator:a448a2aacc500464013bccab75276981b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab7225afd6c6dddeeb9ed21ebbbb6a0" id="r_a9ab7225afd6c6dddeeb9ed21ebbbb6a0"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayTypeInOut , class ArrayTypeSign &gt; </td></tr>
<tr class="memitem:a9ab7225afd6c6dddeeb9ed21ebbbb6a0"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#a9ab7225afd6c6dddeeb9ed21ebbbb6a0">applyFieldSigns</a> (ArrayTypeInOut &amp;inoutFunction, const ArrayTypeSign &amp;fieldSigns)</td></tr>
<tr class="memdesc:a9ab7225afd6c6dddeeb9ed21ebbbb6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies field signs, stored in the user-provided container <em><b>fieldSigns</b></em> and indexed by (C,F), to the function <em><b>inoutFunction</b></em> indexed by (C,F), (C,F,P), (C,F,P,D1) or (C,F,P,D1,D2).  <br /></td></tr>
<tr class="separator:a9ab7225afd6c6dddeeb9ed21ebbbb6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5418b9f70affa9a9d3bacb9343ba94b2" id="r_a5418b9f70affa9a9d3bacb9343ba94b2"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class ArrayOutPointVals , class ArrayInCoeffs , class ArrayInFields &gt; </td></tr>
<tr class="memitem:a5418b9f70affa9a9d3bacb9343ba94b2"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#a5418b9f70affa9a9d3bacb9343ba94b2">evaluate</a> (ArrayOutPointVals &amp;outPointVals, const ArrayInCoeffs &amp;inCoeffs, const ArrayInFields &amp;inFields)</td></tr>
<tr class="memdesc:a5418b9f70affa9a9d3bacb9343ba94b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes point values <em><b>outPointVals</b></em> of a discrete function specified by the basis <em><b>inFields</b></em> and coefficients <em><b>inCoeffs</b></em>.  <br /></td></tr>
<tr class="separator:a5418b9f70affa9a9d3bacb9343ba94b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines expert-level interfaces for the evaluation of functions and operators in physical space (supported for FE, FV, and FD methods) and FE reference space; in addition, provides several function transformation utilities. </p>

<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceTools_8hpp_source.html#l00069">69</a> of file <a class="el" href="Intrepid__FunctionSpaceTools_8hpp_source.html">Intrepid_FunctionSpaceTools.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a9ab7225afd6c6dddeeb9ed21ebbbb6a0" name="a9ab7225afd6c6dddeeb9ed21ebbbb6a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab7225afd6c6dddeeb9ed21ebbbb6a0">&#9670;&#160;</a></span>applyFieldSigns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayTypeInOut , class ArrayTypeSign &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::applyFieldSigns </td>
          <td>(</td>
          <td class="paramtype">ArrayTypeInOut &amp;&#160;</td>
          <td class="paramname"><em>inoutFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeSign &amp;&#160;</td>
          <td class="paramname"><em>fieldSigns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies field signs, stored in the user-provided container <em><b>fieldSigns</b></em> and indexed by (C,F), to the function <em><b>inoutFunction</b></em> indexed by (C,F), (C,F,P), (C,F,P,D1) or (C,F,P,D1,D2). </p>
<p>Returns  </p><p class="formulaDsp">
<picture><source srcset="form_283_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[    
       \mbox{inoutFunction}(c,f,*) = \mbox{fieldSigns}(c,f)*\mbox{inoutFunction}(c,f,*)
\]" src="form_283.png"/></picture>
</p>
<p> See Section <a class="el" href="function_space_tools_page.html#sec_pullbacks">Pullbacks</a> for discussion of field signs.</p>
<div class="fragment"><div class="line">C    - num. integration domains</div>
<div class="line">F    - num. fields</div>
<div class="line">P    - num. integration points</div>
<div class="line">D1   - spatial dimension</div>
<div class="line">D2   - spatial dimension</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inoutFunction</td><td>[in/out] - Input / output function array. </td></tr>
    <tr><td class="paramname">fieldSigns</td><td>[in] - Right field signs. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l01636">1636</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

</div>
</div>
<a id="a7091e8f6fc0bf4cd9e621ce888dfc7a7" name="a7091e8f6fc0bf4cd9e621ce888dfc7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7091e8f6fc0bf4cd9e621ce888dfc7a7">&#9670;&#160;</a></span>applyLeftFieldSigns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayTypeInOut , class ArrayTypeSign &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::applyLeftFieldSigns </td>
          <td>(</td>
          <td class="paramtype">ArrayTypeInOut &amp;&#160;</td>
          <td class="paramname"><em>inoutOperator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeSign &amp;&#160;</td>
          <td class="paramname"><em>fieldSigns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies left (row) signs, stored in the user-provided container <em><b>fieldSigns</b></em> and indexed by (C,L), to the operator <em><b>inoutOperator</b></em> indexed by (C,L,R). </p>
<p>Mathematically, this method computes the matrix-matrix product  </p><p class="formulaDsp">
<picture><source srcset="form_278_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
       \mathbf{K}^{c} = \mbox{diag}(\sigma^c_0,\ldots,\sigma^c_{L-1}) \mathbf{K}^c 
\]" src="form_278.png"/></picture>
</p>
<p> where <picture><source srcset="form_279_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\mathbf{K}^{c} \in \mathbf{R}^{L\times R}$" src="form_279.png"/></picture> is array of matrices indexed by cell number <em>c</em> and stored in the rank-3 array <em>inoutOperator</em>, and <picture><source srcset="form_280_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\sigma^c_l\}_{l=0}^{L-1}$" src="form_280.png"/></picture> is array of left field signs indexed by cell number <em>c</em> and stored in the rank-2 container <em>fieldSigns</em>; <br  />
 see Section <a class="el" href="function_space_tools_page.html#sec_pullbacks">Pullbacks</a> for discussion of field signs. This operation is required for operators generated by <em>HCURL</em> and <em>HDIV-conforming</em> vector-valued finite element basis functions; see Sections <a class="el" href="function_space_tools_page.html#sec_pullbacks">Pullbacks</a> and Section <a class="el" href="function_space_tools_page.html#sec_ops">Evaluation of finite element operators and functionals</a> for applications of this method.</p>
<div class="fragment"><div class="line">C    - num. integration domains</div>
<div class="line">L    - num. left fields</div>
<div class="line">R    - num. right fields</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inoutOperator</td><td>[in/out] - Input / output operator array. </td></tr>
    <tr><td class="paramname">fieldSigns</td><td>[in] - Left field signs. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l01585">1585</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

</div>
</div>
<a id="a448a2aacc500464013bccab75276981b" name="a448a2aacc500464013bccab75276981b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448a2aacc500464013bccab75276981b">&#9670;&#160;</a></span>applyRightFieldSigns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayTypeInOut , class ArrayTypeSign &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::applyRightFieldSigns </td>
          <td>(</td>
          <td class="paramtype">ArrayTypeInOut &amp;&#160;</td>
          <td class="paramname"><em>inoutOperator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeSign &amp;&#160;</td>
          <td class="paramname"><em>fieldSigns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies right (column) signs, stored in the user-provided container <em><b>fieldSigns</b></em> and indexed by (C,R), to the operator <em><b>inoutOperator</b></em> indexed by (C,L,R). </p>
<p>Mathematically, this method computes the matrix-matrix product  </p><p class="formulaDsp">
<picture><source srcset="form_281_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
       \mathbf{K}^{c} = \mathbf{K}^c \mbox{diag}(\sigma^c_0,\ldots,\sigma^c_{R-1})
\]" src="form_281.png"/></picture>
</p>
<p> where <picture><source srcset="form_279_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\mathbf{K}^{c} \in \mathbf{R}^{L\times R}$" src="form_279.png"/></picture> is array of matrices indexed by cell number <em>c</em> and stored in the rank-3 container <em>inoutOperator</em>, and <picture><source srcset="form_282_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\sigma^c_r\}_{r=0}^{R-1}$" src="form_282.png"/></picture> is array of right field signs indexed by cell number <em>c</em> and stored in the rank-2 container <em>fieldSigns</em>; <br  />
 see Section <a class="el" href="function_space_tools_page.html#sec_pullbacks">Pullbacks</a> for discussion of field signs. This operation is required for operators generated by <em>HCURL</em> and <em>HDIV-conforming</em> vector-valued finite element basis functions; see Sections <a class="el" href="function_space_tools_page.html#sec_pullbacks">Pullbacks</a> and Section <a class="el" href="function_space_tools_page.html#sec_ops">Evaluation of finite element operators and functionals</a> for applications of this method.</p>
<div class="fragment"><div class="line">C    - num. integration domains</div>
<div class="line">L    - num. left fields</div>
<div class="line">R    - num. right fields</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inoutOperator</td><td>[in/out] - Input / output operator array. </td></tr>
    <tr><td class="paramname">fieldSigns</td><td>[in] - Right field signs. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l01610">1610</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

</div>
</div>
<a id="a88aa764489ab4e79cfdd9e4994d1e458" name="a88aa764489ab4e79cfdd9e4994d1e458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88aa764489ab4e79cfdd9e4994d1e458">&#9670;&#160;</a></span>computeCellMeasure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayOut , class ArrayDet , class ArrayWeights &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::computeCellMeasure </td>
          <td>(</td>
          <td class="paramtype">ArrayOut &amp;&#160;</td>
          <td class="paramname"><em>outVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayDet &amp;&#160;</td>
          <td class="paramname"><em>inDet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayWeights &amp;&#160;</td>
          <td class="paramname"><em>inWeights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the weighted integration measures <em><b>outVals</b></em> with dimensions (C,P) used for the computation of cell integrals, by multiplying absolute values of the user-provided cell Jacobian determinants <em><b>inDet</b></em> with dimensions (C,P) with the user-provided integration weights <em><b>inWeights</b></em> with dimensions (P). </p>
<p>Returns a rank-2 array (C, P) array such that  </p><p class="formulaDsp">
<picture><source srcset="form_270_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
         \mbox{outVals}(c,p)   = |\mbox{det}(DF_{c}(\widehat{x}_p))|\omega_{p} \,,
  \]" src="form_270.png"/></picture>
</p>
<p> where <picture><source srcset="form_271_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{(\widehat{x}_p,\omega_p)\}$" src="form_271.png"/></picture> is a cubature rule defined on a reference cell (a set of integration points and their associated weights; see <a class="el" href="classIntrepid_1_1Cubature.html#a1ecbd7e4fdb95d0451ac490d7cec1840" title="Returns cubature points and weights (return arrays must be pre-sized/pre-allocated).">Intrepid::Cubature::getCubature</a> for getting cubature rules on reference cells). </p><dl class="section warning"><dt>Warning</dt><dd>The user is responsible for providing input arrays with consistent data: the determinants in <em><b>inDet</b></em> should be evaluated at integration points on the <b>reference cell</b> corresponding to the weights in <em><b>inWeights</b></em>.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>See Intrepid::CellTools::setJacobian for computation of <em>DF</em> and <a class="el" href="classIntrepid_1_1CellTools.html#a631bd0233254ee7de3699f40a094a4be" title="Computes the determinant of the Jacobian matrix DF of the reference-to-physical frame map F.">Intrepid::CellTools::setJacobianDet</a> for computation of its determinant.</dd></dl>
<div class="fragment"><div class="line">C - num. integration domains                     dim0 in all containers</div>
<div class="line">P - num. integration points                      dim1 in all containers</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outVals</td><td>[out] - Output array with weighted cell measures. </td></tr>
    <tr><td class="paramname">inDet</td><td>[in] - Input array containing determinants of cell Jacobians. </td></tr>
    <tr><td class="paramname">inWeights</td><td>[in] - Input integration weights. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l01337">1337</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

</div>
</div>
<a id="ae21e68a1d026a67ffd86825b4405835e" name="ae21e68a1d026a67ffd86825b4405835e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21e68a1d026a67ffd86825b4405835e">&#9670;&#160;</a></span>computeEdgeMeasure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayOut , class ArrayJac , class ArrayWeights &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::computeEdgeMeasure </td>
          <td>(</td>
          <td class="paramtype">ArrayOut &amp;&#160;</td>
          <td class="paramname"><em>outVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayJac &amp;&#160;</td>
          <td class="paramname"><em>inJac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayWeights &amp;&#160;</td>
          <td class="paramname"><em>inWeights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>whichEdge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology &amp;&#160;</td>
          <td class="paramname"><em>parentCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the weighted integration measures <em><b>outVals</b></em> with dimensions (C,P) used for the computation of edge integrals, based on the provided cell Jacobian array <em><b>inJac</b></em> with dimensions (C,P,D,D) and the provided integration weights <em><b>inWeights</b></em> with dimensions (P). </p>
<p>Returns a rank-2 array (C, P) array such that  </p><p class="formulaDsp">
<picture><source srcset="form_275_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
         \mbox{outVals}(c,p)   = 
              \left\|\frac{d \Phi_c(\widehat{x}_p)}{d s}\right\|\omega_{p} \,,
\]" src="form_275.png"/></picture>
</p>
<p> where: </p><ul>
<li><picture><source srcset="form_271_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{(\widehat{x}_p,\omega_p)\}$" src="form_271.png"/></picture> is a cubature rule defined on <b>reference</b> <b>edge</b> <picture><source srcset="form_276_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\widehat{\mathcal{E}}$" src="form_276.png"/></picture>, with ordinal <em>whichEdge</em> relative to the specified parent reference cell; </li>
<li><picture><source srcset="form_277_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \Phi_c : R \mapsto \mathcal{E} $" src="form_277.png"/></picture> is parameterization of the physical edge corresponding to <picture><source srcset="form_276_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\widehat{\mathcal{E}}$" src="form_276.png"/></picture>; see Section <a class="el" href="cell_tools_page.html#sec_cell_topology_subcell_map">Parametrization of physical 1- and 2-subcells</a>.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>The user is responsible for providing input arrays with consistent data: the Jacobians in <em><b>inJac</b></em> should be evaluated at integration points on the <b>reference edge</b> corresponding to the weights in <em><b>inWeights</b></em>.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="classIntrepid_1_1Cubature.html" title="Defines the base class for cubature (integration) rules in Intrepid.">Cubature</a> rules on reference edges are defined by a two-step process: <ul>
<li>A cubature rule is defined on the parametrization domain <em>R</em> = [-1,1] of the edge. </li>
<li>The points are mapped to a reference edge using <a class="el" href="classIntrepid_1_1CellTools.html#a2b89294beb0bd73d9a27d9d77e0deb2c" title="Computes parameterization maps of 1- and 2-subcells of reference cells.">Intrepid::CellTools::mapToReferenceSubcell</a></li>
</ul>
</dd>
<dd>
See Intrepid::CellTools::setJacobian for computation of <em>DF</em> and <a class="el" href="classIntrepid_1_1CellTools.html#a631bd0233254ee7de3699f40a094a4be" title="Computes the determinant of the Jacobian matrix DF of the reference-to-physical frame map F.">Intrepid::CellTools::setJacobianDet</a> for computation of its determinant.</dd></dl>
<div class="fragment"><div class="line">C - num. integration domains                     dim0 in all input containers</div>
<div class="line">P - num. integration points                      dim1 in all input containers</div>
<div class="line">D - spatial dimension                            dim2 and dim3 in Jacobian container</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outVals</td><td>[out] - Output array with weighted edge measures. </td></tr>
    <tr><td class="paramname">inJac</td><td>[in] - Input array containing cell Jacobians. </td></tr>
    <tr><td class="paramname">inWeights</td><td>[in] - Input integration weights. </td></tr>
    <tr><td class="paramname">whichEdge</td><td>[in] - Index of the edge subcell relative to the parent cell; defines the domain of integration. </td></tr>
    <tr><td class="paramname">parentCell</td><td>[in] - Parent cell topology. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l01389">1389</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid__CellToolsDef_8hpp_source.html#l02239">Intrepid::CellTools&lt; Scalar &gt;::getPhysicalEdgeTangents()</a>, and <a class="el" href="Intrepid__RealSpaceToolsDef_8hpp_source.html#l00139">Intrepid::RealSpaceTools&lt; Scalar &gt;::vectorNorm()</a>.</p>

</div>
</div>
<a id="a01407227e9f58d6432f933e0e4d5f1ec" name="a01407227e9f58d6432f933e0e4d5f1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01407227e9f58d6432f933e0e4d5f1ec">&#9670;&#160;</a></span>computeFaceMeasure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayOut , class ArrayJac , class ArrayWeights &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::computeFaceMeasure </td>
          <td>(</td>
          <td class="paramtype">ArrayOut &amp;&#160;</td>
          <td class="paramname"><em>outVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayJac &amp;&#160;</td>
          <td class="paramname"><em>inJac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayWeights &amp;&#160;</td>
          <td class="paramname"><em>inWeights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>whichFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology &amp;&#160;</td>
          <td class="paramname"><em>parentCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the weighted integration measures <em><b>outVals</b></em> with dimensions (C,P) used for the computation of face integrals, based on the provided cell Jacobian array <em><b>inJac</b></em> with dimensions (C,P,D,D) and the provided integration weights <em><b>inWeights</b></em> with dimensions (P). </p>
<p>Returns a rank-2 array (C, P) array such that  </p><p class="formulaDsp">
<picture><source srcset="form_272_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
         \mbox{outVals}(c,p)   = 
          \left\|\frac{\partial\Phi_c(\widehat{x}_p)}{\partial u}\times 
                 \frac{\partial\Phi_c(\widehat{x}_p)}{\partial v}\right\|\omega_{p} \,,
\]" src="form_272.png"/></picture>
</p>
<p> where: </p><ul>
<li><picture><source srcset="form_271_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{(\widehat{x}_p,\omega_p)\}$" src="form_271.png"/></picture> is a cubature rule defined on <b>reference</b> <b>face</b> <picture><source srcset="form_273_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\widehat{\mathcal{F}}$" src="form_273.png"/></picture>, with ordinal <em>whichFace</em> relative to the specified parent reference cell; </li>
<li><picture><source srcset="form_274_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \Phi_c : R \mapsto \mathcal{F} $" src="form_274.png"/></picture> is parameterization of the physical face corresponding to <picture><source srcset="form_273_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\widehat{\mathcal{F}}$" src="form_273.png"/></picture>; see Section <a class="el" href="cell_tools_page.html#sec_cell_topology_subcell_map">Parametrization of physical 1- and 2-subcells</a>.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>The user is responsible for providing input arrays with consistent data: the Jacobians in <em><b>inJac</b></em> should be evaluated at integration points on the <b>reference face</b> corresponding to the weights in <em><b>inWeights</b></em>.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="classIntrepid_1_1Cubature.html" title="Defines the base class for cubature (integration) rules in Intrepid.">Cubature</a> rules on reference faces are defined by a two-step process: <ul>
<li>A cubature rule is defined on the parametrization domain <em>R</em> of the face (<em>R</em> is the standard 2-simplex {(0,0),(1,0),(0,1)} or the standard 2-cube [-1,1] X [-1,1]). </li>
<li>The points are mapped to a reference face using <a class="el" href="classIntrepid_1_1CellTools.html#a2b89294beb0bd73d9a27d9d77e0deb2c" title="Computes parameterization maps of 1- and 2-subcells of reference cells.">Intrepid::CellTools::mapToReferenceSubcell</a></li>
</ul>
</dd>
<dd>
See Intrepid::CellTools::setJacobian for computation of <em>DF</em> and <a class="el" href="classIntrepid_1_1CellTools.html#a631bd0233254ee7de3699f40a094a4be" title="Computes the determinant of the Jacobian matrix DF of the reference-to-physical frame map F.">Intrepid::CellTools::setJacobianDet</a> for computation of its determinant.</dd></dl>
<div class="fragment"><div class="line">C - num. integration domains                     dim0 in all input containers</div>
<div class="line">P - num. integration points                      dim1 in all input containers</div>
<div class="line">D - spatial dimension                            dim2 and dim3 in Jacobian container</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outVals</td><td>[out] - Output array with weighted face measures. </td></tr>
    <tr><td class="paramname">inJac</td><td>[in] - Input array containing cell Jacobians. </td></tr>
    <tr><td class="paramname">inWeights</td><td>[in] - Input integration weights. </td></tr>
    <tr><td class="paramname">whichFace</td><td>[in] - Index of the face subcell relative to the parent cell; defines the domain of integration. </td></tr>
    <tr><td class="paramname">parentCell</td><td>[in] - Parent cell topology. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l01360">1360</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid__CellToolsDef_8hpp_source.html#l02388">Intrepid::CellTools&lt; Scalar &gt;::getPhysicalFaceNormals()</a>, and <a class="el" href="Intrepid__RealSpaceToolsDef_8hpp_source.html#l00139">Intrepid::RealSpaceTools&lt; Scalar &gt;::vectorNorm()</a>.</p>

</div>
</div>
<a id="ae23e64fb1c915530e3f0c4b5feb8727c" name="ae23e64fb1c915530e3f0c4b5feb8727c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23e64fb1c915530e3f0c4b5feb8727c">&#9670;&#160;</a></span>dataIntegral()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayOutData , class ArrayInDataLeft , class ArrayInDataRight &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::dataIntegral </td>
          <td>(</td>
          <td class="paramtype">ArrayOutData &amp;&#160;</td>
          <td class="paramname"><em>outputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayInDataLeft &amp;&#160;</td>
          <td class="paramname"><em>inputDataLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayInDataRight &amp;&#160;</td>
          <td class="paramname"><em>inputDataRight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ECompEngine&#160;</td>
          <td class="paramname"><em>compEngine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>sumInto</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contracts the point (and space) dimensions P (and D1 and D2) of two rank-2, 3, or 4 containers with dimensions (C,P), or (C,P,D1), or (C,P,D1,D2), respectively, and returns the result in a rank-1 container with dimensions (C). </p>
<div class="fragment"><div class="line">C - num. integration domains                     dim0 in both input containers</div>
<div class="line">P - num. integration points                      dim1 in both input containers</div>
<div class="line">D1 - first spatial (tensor) dimension index      dim2 in both input containers</div>
<div class="line">D2 - second spatial (tensor) dimension index     dim3 in both input containers</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputData</td><td>[out] - Output data array. </td></tr>
    <tr><td class="paramname">inputDataLeft</td><td>[in] - Left data input array. </td></tr>
    <tr><td class="paramname">inputDataRight</td><td>[in] - Right data input array. </td></tr>
    <tr><td class="paramname">compEngine</td><td>[in] - Computational engine. </td></tr>
    <tr><td class="paramname">sumInto</td><td>[in] - If TRUE, sum into given output array, otherwise overwrite it. Default: FALSE. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l01307">1307</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

</div>
</div>
<a id="a5af743faa14c628e374e5a54cbb7f8ee" name="a5af743faa14c628e374e5a54cbb7f8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af743faa14c628e374e5a54cbb7f8ee">&#9670;&#160;</a></span>dotMultiplyDataData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayOutData , class ArrayInDataLeft , class ArrayInDataRight &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::dotMultiplyDataData </td>
          <td>(</td>
          <td class="paramtype">ArrayOutData &amp;&#160;</td>
          <td class="paramname"><em>outputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayInDataLeft &amp;&#160;</td>
          <td class="paramname"><em>inputDataLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayInDataRight &amp;&#160;</td>
          <td class="paramname"><em>inputDataRight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dot product of data and data; please read the description below. </p>
<pre class="fragment">   There are two use cases:
   \li
   dot product of a rank-2, 3 or 4 container \a &lt;b&gt;inputDataRight&lt;/b&gt; with dimensions (C,P)
   (C,P,D1) or (C,P,D1,D2), representing the values of a scalar, vector or a
   tensor set of data, by the values in a rank-2, 3 or 4 container \a &lt;b&gt;inputDataLeft&lt;/b&gt; indexed by
   (C,P), (C,P,D1), or (C,P,D1,D2) representing the values of scalar, vector or
   tensor data, OR
   \li
   dot product of a rank-2, 3 or 4 container \a &lt;b&gt;inputDataRight&lt;/b&gt; with dimensions (P),
   (P,D1) or (P,D1,D2), representing the values of scalar, vector or tensor
   data, by the values in a rank-2 container \a &lt;b&gt;inputDataLeft&lt;/b&gt; indexed by (C,P), (C,P,D1) or
   (C,P,D1,D2), representing the values of scalar, vector, or tensor data;
   the output value container \a &lt;b&gt;outputData&lt;/b&gt; is indexed by (C,P),
   regardless of which of the two use cases is considered.

   For input fields containers without a dimension index, this operation reduces to
   scalar multiplication.
</pre> <div class="fragment"><div class="line">C  - num. integration domains</div>
<div class="line">P  - num. integration points</div>
<div class="line">D1 - first spatial (tensor) dimension index</div>
<div class="line">D2 - second spatial (tensor) dimension index</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputData</td><td>[out] - Output (dot product) data array. </td></tr>
    <tr><td class="paramname">inputDataLeft</td><td>[in] - Left input data array. </td></tr>
    <tr><td class="paramname">inputDataRight</td><td>[in] - Right input data array. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l01461">1461</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

</div>
</div>
<a id="a4f74d9e6c6c19c342c101f41b3899fba" name="a4f74d9e6c6c19c342c101f41b3899fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f74d9e6c6c19c342c101f41b3899fba">&#9670;&#160;</a></span>dotMultiplyDataField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayOutFields , class ArrayInData , class ArrayInFields &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::dotMultiplyDataField </td>
          <td>(</td>
          <td class="paramtype">ArrayOutFields &amp;&#160;</td>
          <td class="paramname"><em>outputFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayInData &amp;&#160;</td>
          <td class="paramname"><em>inputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayInFields &amp;&#160;</td>
          <td class="paramname"><em>inputFields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dot product of data and fields; please read the description below. </p>
<pre class="fragment">   There are two use cases:
   \li
   dot product of a rank-3, 4 or 5 container \a &lt;b&gt;inputFields&lt;/b&gt; with dimensions (C,F,P)
   (C,F,P,D1) or (C,F,P,D1,D2), representing the values of a set of scalar, vector
   or tensor fields, by the values in a rank-2, 3 or 4 container \a &lt;b&gt;inputData&lt;/b&gt; indexed by
   (C,P), (C,P,D1), or (C,P,D1,D2) representing the values of scalar, vector or
   tensor data, OR
   \li
   dot product of a rank-2, 3 or 4 container \a &lt;b&gt;inputFields&lt;/b&gt; with dimensions (F,P),
   (F,P,D1) or (F,P,D1,D2), representing the values of a scalar, vector or tensor
   field, by the values in a rank-2 container \a &lt;b&gt;inputData&lt;/b&gt; indexed by (C,P), (C,P,D1) or
   (C,P,D1,D2), representing the values of scalar, vector or tensor data;
   the output value container \a &lt;b&gt;outputFields&lt;/b&gt; is indexed by (C,F,P),
   regardless of which of the two use cases is considered.

   For input fields containers without a dimension index, this operation reduces to
   scalar multiplication.
</pre> <div class="fragment"><div class="line">C  - num. integration domains</div>
<div class="line">F  - num. fields</div>
<div class="line">P  - num. integration points</div>
<div class="line">D1 - first spatial (tensor) dimension index</div>
<div class="line">D2 - second spatial (tensor) dimension index</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputFields</td><td>[out] - Output (dot product) fields array. </td></tr>
    <tr><td class="paramname">inputData</td><td>[in] - Data array. </td></tr>
    <tr><td class="paramname">inputFields</td><td>[in] - Input fields array. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l01451">1451</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

</div>
</div>
<a id="a5418b9f70affa9a9d3bacb9343ba94b2" name="a5418b9f70affa9a9d3bacb9343ba94b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5418b9f70affa9a9d3bacb9343ba94b2">&#9670;&#160;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayOutPointVals , class ArrayInCoeffs , class ArrayInFields &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::evaluate </td>
          <td>(</td>
          <td class="paramtype">ArrayOutPointVals &amp;&#160;</td>
          <td class="paramname"><em>outPointVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayInCoeffs &amp;&#160;</td>
          <td class="paramname"><em>inCoeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayInFields &amp;&#160;</td>
          <td class="paramname"><em>inFields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes point values <em><b>outPointVals</b></em> of a discrete function specified by the basis <em><b>inFields</b></em> and coefficients <em><b>inCoeffs</b></em>. </p>
<p>The array <em><b>inFields</b></em> with dimensions (C,F,P), (C,F,P,D1), or (C,F,P,D1,D2) represents the signed, transformed field (basis) values at points in REFERENCE frame; the <em><b>outPointVals</b></em> array with dimensions (C,P), (C,P,D1), or (C,P,D1,D2), respectively, represents values of a discrete function at points in PHYSICAL frame. The array <em><b>inCoeffs</b></em> dimensioned (C,F) supplies the coefficients for the field (basis) array.</p>
<p>Returns rank-2,3 or 4 array such that  </p><p class="formulaDsp">
<picture><source srcset="form_284_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
       outPointValues(c,p,*) = \sum_{f=0}^{F-1} \sigma_{c,f} u_{c,f}(x_p)
\]" src="form_284.png"/></picture>
</p>
<p> where <picture><source srcset="form_285_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{u_{c,f}\}_{f=0}^{F-1} $" src="form_285.png"/></picture> is scalar, vector or tensor valued finite element basis defined on physical cell <picture><source srcset="form_10_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\mathcal{C}$" src="form_10.png"/></picture> and <picture><source srcset="form_286_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\sigma_{c,f}\}_{f=0}^{F-1} $" src="form_286.png"/></picture> are the field signs of the basis functions; see Section <a class="el" href="function_space_tools_page.html#sec_pullbacks">Pullbacks</a>. This method implements the last step in a four step process; please see Section <a class="el" href="function_space_tools_page.html#sec_evaluate">Evaluation of finite element fields</a> for details about the first three steps that prepare the necessary data for this method.</p>
<div class="fragment"><div class="line">C    - num. integration domains</div>
<div class="line">F    - num. fields</div>
<div class="line">P    - num. integration points</div>
<div class="line">D1   - spatial dimension</div>
<div class="line">D2   - spatial dimension</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outPointVals</td><td>[out] - Output point values of a discrete function. </td></tr>
    <tr><td class="paramname">inCoeffs</td><td>[in] - Coefficients associated with the fields (basis) array. </td></tr>
    <tr><td class="paramname">inFields</td><td>[in] - Field (basis) values. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l01729">1729</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

</div>
</div>
<a id="ad22cf40200ce1db4ff6658b1b95c2c50" name="ad22cf40200ce1db4ff6658b1b95c2c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22cf40200ce1db4ff6658b1b95c2c50">&#9670;&#160;</a></span>functionalIntegral()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayOutFields , class ArrayInData , class ArrayInFields &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::functionalIntegral </td>
          <td>(</td>
          <td class="paramtype">ArrayOutFields &amp;&#160;</td>
          <td class="paramname"><em>outputFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayInData &amp;&#160;</td>
          <td class="paramname"><em>inputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayInFields &amp;&#160;</td>
          <td class="paramname"><em>inputFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ECompEngine&#160;</td>
          <td class="paramname"><em>compEngine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>sumInto</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contracts the point (and space) dimensions P (and D1 and D2) of a rank-3, 4, or 5 container and a rank-2, 3, or 4 container, respectively, with dimensions (C,F,P) and (C,P), or (C,F,P,D1) and (C,P,D1), or (C,F,P,D1,D2) and (C,P,D1,D2), respectively, and returns the result in a rank-2 container with dimensions (C,F). </p>
<p>For a fixed index "C", (C,F) represents a (column) vector of length F. </p><div class="fragment"><div class="line">C  - num. integration domains                       dim0 in both input containers</div>
<div class="line">F  - num. fields                                    dim1 in fields input container</div>
<div class="line">P  - num. integration points                        dim2 in fields input container and dim1 in tensor data container</div>
<div class="line">D1 - first spatial (tensor) dimension index         dim3 in fields input container and dim2 in tensor data container</div>
<div class="line">D2 - second spatial (tensor) dimension index        dim4 in fields input container and dim3 in tensor data container</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputFields</td><td>[out] - Output fields array. </td></tr>
    <tr><td class="paramname">inputData</td><td>[in] - Data array. </td></tr>
    <tr><td class="paramname">inputFields</td><td>[in] - Input fields array. </td></tr>
    <tr><td class="paramname">compEngine</td><td>[in] - Computational engine. </td></tr>
    <tr><td class="paramname">sumInto</td><td>[in] - If TRUE, sum into given output array, otherwise overwrite it. Default: FALSE. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l01277">1277</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

</div>
</div>
<a id="aec6a9cc34cf0b19175639225781e9d7b" name="aec6a9cc34cf0b19175639225781e9d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6a9cc34cf0b19175639225781e9d7b">&#9670;&#160;</a></span>HCURLtransformCURL()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayTypeOut , class ArrayTypeJac , class ArrayTypeDet , class ArrayTypeIn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::HCURLtransformCURL </td>
          <td>(</td>
          <td class="paramtype">ArrayTypeOut &amp;&#160;</td>
          <td class="paramname"><em>outVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeJac &amp;&#160;</td>
          <td class="paramname"><em>jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeDet &amp;&#160;</td>
          <td class="paramname"><em>jacobianDet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeIn &amp;&#160;</td>
          <td class="paramname"><em>inVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>'N'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transformation of a curl field in the H-curl space, defined at points on a reference cell, stored in the user-provided container <em><b>inVals</b></em> and indexed by (F,P,D), into the output container <em><b>outVals</b></em>, defined on cells in physical space and indexed by (C,F,P,D). </p>
<p>Computes pullback of curls of <em>HCURL</em> functions <picture><source srcset="form_260_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\Phi^*(\widehat{\bf u}_f) = \left(J^{-1}_{c} DF_{c}\cdot\nabla\times\widehat{\bf u}_f\right)\circ F^{-1}_{c}$" src="form_260.png"/></picture> for points in one or more physical cells that are images of a given set of points in the reference cell:  </p><p class="formulaDsp">
<picture><source srcset="form_248_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
         \{ x_{c,p} \}_{p=0}^P = \{ F_{c} (\widehat{x}_p) \}_{p=0}^{P}\qquad 0\le c &lt; C \,.
  \]" src="form_248.png"/></picture>
</p>
<p> In this case <picture><source srcset="form_249_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F^{-1}_{c}(x_{c,p}) = \widehat{x}_p $" src="form_249.png"/></picture> and the user-provided container should contain the curls of the vector function set <picture><source srcset="form_257_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\widehat{\bf u}_f\}_{f=0}^{F}$" src="form_257.png"/></picture> at the reference points:  </p><p class="formulaDsp">
<picture><source srcset="form_261_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
         inVals(f,p,*) = \nabla\times\widehat{\bf u}_f(\widehat{x}_p) \,.
  \]" src="form_261.png"/></picture>
</p>
<p> The method returns <br  />
  </p><p class="formulaDsp">
<picture><source srcset="form_262_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
         outVals(c,f,p,*) 
            = \left(J^{-1}_{c} DF_{c}\cdot\nabla\times\widehat{\bf u}_f\right)\circ F^{-1}_{c}(x_{c,p}) 
            = J^{-1}_{c}(\widehat{x}_p) DF_{c}(\widehat{x}_p)\cdot\nabla\times\widehat{\bf u}_f(\widehat{x}_p)
          \qquad 0\le c &lt; C \,.
  \]" src="form_262.png"/></picture>
</p>
<p> See Section <a class="el" href="function_space_tools_page.html#sec_pullbacks">Pullbacks</a> for more details about pullbacks.</p>
<div class="fragment"><div class="line">|------|----------------------|--------------------------------------------------|</div>
<div class="line">|      |         Index        |                   Dimension                      |</div>
<div class="line">|------|----------------------|--------------------------------------------------|</div>
<div class="line">|   C  |         cell         |  0 &lt;= C &lt; num. integration domains               |</div>
<div class="line">|   F  |         field        |  0 &lt;= F &lt; dim. of the basis                      |</div>
<div class="line">|   P  |         point        |  0 &lt;= P &lt; num. integration points                |</div>
<div class="line">|   D  |         space dim    |  0 &lt;= D &lt; spatial dimension                      |</div>
<div class="line">|------|----------------------|--------------------------------------------------|</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l00081">81</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

</div>
</div>
<a id="a35c79ab919fe41f9da4b7b7c63d5c867" name="a35c79ab919fe41f9da4b7b7c63d5c867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c79ab919fe41f9da4b7b7c63d5c867">&#9670;&#160;</a></span>HCURLtransformVALUE()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayTypeOut , class ArrayTypeJac , class ArrayTypeIn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::HCURLtransformVALUE </td>
          <td>(</td>
          <td class="paramtype">ArrayTypeOut &amp;&#160;</td>
          <td class="paramname"><em>outVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeJac &amp;&#160;</td>
          <td class="paramname"><em>jacobianInverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeIn &amp;&#160;</td>
          <td class="paramname"><em>inVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>'T'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transformation of a (vector) value field in the H-curl space, defined at points on a reference cell, stored in the user-provided container <em><b>inVals</b></em> and indexed by (F,P,D), into the output container <em><b>outVals</b></em>, defined on cells in physical space and indexed by (C,F,P,D). </p>
<p>Computes pullback of <em>HCURL</em> functions <picture><source srcset="form_256_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\Phi^*(\widehat{\bf u}_f) = \left((DF_c)^{-{\sf T}}\cdot\widehat{\bf u}_f\right)\circ F^{-1}_{c}$" src="form_256.png"/></picture> for points in one or more physical cells that are images of a given set of points in the reference cell:  </p><p class="formulaDsp">
<picture><source srcset="form_248_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
         \{ x_{c,p} \}_{p=0}^P = \{ F_{c} (\widehat{x}_p) \}_{p=0}^{P}\qquad 0\le c &lt; C \,.
  \]" src="form_248.png"/></picture>
</p>
<p> In this case <picture><source srcset="form_249_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F^{-1}_{c}(x_{c,p}) = \widehat{x}_p $" src="form_249.png"/></picture> and the user-provided container should contain the values of the vector function set <picture><source srcset="form_257_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\widehat{\bf u}_f\}_{f=0}^{F}$" src="form_257.png"/></picture> at the reference points:  </p><p class="formulaDsp">
<picture><source srcset="form_258_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
         inVals(f,p,*) = \widehat{\bf u}_f(\widehat{x}_p) \,.
  \]" src="form_258.png"/></picture>
</p>
<p> The method returns <br  />
  </p><p class="formulaDsp">
<picture><source srcset="form_259_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
          outVals(c,f,p,*) 
            = \left((DF_c)^{-{\sf T}}\cdot\widehat{\bf u}_f\right)\circ F^{-1}_{c}(x_{c,p}) 
            = (DF_c)^{-{\sf T}}(\widehat{x}_p)\cdot\widehat{\bf u}_f(\widehat{x}_p) \qquad 0\le c &lt; C \,.
  \]" src="form_259.png"/></picture>
</p>
<p> See Section <a class="el" href="function_space_tools_page.html#sec_pullbacks">Pullbacks</a> for more details about pullbacks. </p><div class="fragment"><div class="line">|------|----------------------|--------------------------------------------------|</div>
<div class="line">|      |         Index        |                   Dimension                      |</div>
<div class="line">|------|----------------------|--------------------------------------------------|</div>
<div class="line">|   C  |         cell         |  0 &lt;= C &lt; num. integration domains               |</div>
<div class="line">|   F  |         field        |  0 &lt;= F &lt; dim. of native basis                   |</div>
<div class="line">|   P  |         point        |  0 &lt;= P &lt; num. integration points                |</div>
<div class="line">|   D  |         space dim    |  0 &lt;= D &lt; spatial dimension                      |</div>
<div class="line">|------|----------------------|--------------------------------------------------|</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l00071">71</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

</div>
</div>
<a id="a0ab078baa28ad28d019584db556a7fdd" name="a0ab078baa28ad28d019584db556a7fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab078baa28ad28d019584db556a7fdd">&#9670;&#160;</a></span>HDIVtransformDIV()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayTypeOut , class ArrayTypeDet , class ArrayTypeIn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::HDIVtransformDIV </td>
          <td>(</td>
          <td class="paramtype">ArrayTypeOut &amp;&#160;</td>
          <td class="paramname"><em>outVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeDet &amp;&#160;</td>
          <td class="paramname"><em>jacobianDet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeIn &amp;&#160;</td>
          <td class="paramname"><em>inVals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transformation of a divergence field in the H-div space, defined at points on a reference cell, stored in the user-provided container <em><b>inVals</b></em> and indexed by (F,P), into the output container <em><b>outVals</b></em>, defined on cells in physical space and indexed by (C,F,P). </p>
<p>Computes pullback of the divergence of <em>HDIV</em> functions <picture><source srcset="form_265_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\Phi^*(\widehat{\bf u}_f) = \left(J^{-1}_{c}\nabla\cdot\widehat{\bf u}_{f}\right) \circ F^{-1}_{c} $" src="form_265.png"/></picture> for points in one or more physical cells that are images of a given set of points in the reference cell:  </p><p class="formulaDsp">
<picture><source srcset="form_248_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
         \{ x_{c,p} \}_{p=0}^P = \{ F_{c} (\widehat{x}_p) \}_{p=0}^{P}\qquad 0\le c &lt; C \,.
  \]" src="form_248.png"/></picture>
</p>
<p> In this case <picture><source srcset="form_249_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F^{-1}_{c}(x_{c,p}) = \widehat{x}_p $" src="form_249.png"/></picture> and the user-provided container should contain the divergencies of the vector function set <picture><source srcset="form_257_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\widehat{\bf u}_f\}_{f=0}^{F}$" src="form_257.png"/></picture> at the reference points:  </p><p class="formulaDsp">
<picture><source srcset="form_266_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
         inVals(f,p) = \nabla\cdot\widehat{\bf u}_f(\widehat{x}_p) \,.
  \]" src="form_266.png"/></picture>
</p>
<p> The method returns <br  />
  </p><p class="formulaDsp">
<picture><source srcset="form_267_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
         outVals(c,f,p,*) 
            = \left(J^{-1}_{c}\nabla\cdot\widehat{\bf u}_{f}\right) \circ F^{-1}_{c} (x_{c,p}) 
            = J^{-1}_{c}(\widehat{x}_p) \nabla\cdot\widehat{\bf u}_{f} (\widehat{x}_p)
            \qquad 0\le c &lt; C \,.
  \]" src="form_267.png"/></picture>
</p>
<p> See Section <a class="el" href="function_space_tools_page.html#sec_pullbacks">Pullbacks</a> for more details about pullbacks.</p>
<div class="fragment"><div class="line">|------|----------------------|--------------------------------------------------|</div>
<div class="line">|      |         Index        |                   Dimension                      |</div>
<div class="line">|------|----------------------|--------------------------------------------------|</div>
<div class="line">|   C  |         cell         |  0 &lt;= C &lt; num. integration domains               |</div>
<div class="line">|   F  |         field        |  0 &lt;= F &lt; dim. of the basis                      |</div>
<div class="line">|   P  |         point        |  0 &lt;= P &lt; num. integration points                |</div>
<div class="line">|------|----------------------|--------------------------------------------------|</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l00105">105</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

</div>
</div>
<a id="af92933a7158b1a61371cc892a61ee4c0" name="af92933a7158b1a61371cc892a61ee4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92933a7158b1a61371cc892a61ee4c0">&#9670;&#160;</a></span>HDIVtransformVALUE()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayTypeOut , class ArrayTypeJac , class ArrayTypeDet , class ArrayTypeIn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::HDIVtransformVALUE </td>
          <td>(</td>
          <td class="paramtype">ArrayTypeOut &amp;&#160;</td>
          <td class="paramname"><em>outVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeJac &amp;&#160;</td>
          <td class="paramname"><em>jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeDet &amp;&#160;</td>
          <td class="paramname"><em>jacobianDet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeIn &amp;&#160;</td>
          <td class="paramname"><em>inVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>'N'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transformation of a (vector) value field in the H-div space, defined at points on a reference cell, stored in the user-provided container <em><b>inVals</b></em> and indexed by (F,P,D), into the output container <em><b>outVals</b></em>, defined on cells in physical space and indexed by (C,F,P,D). </p>
<p>Computes pullback of <em>HDIV</em> functions <picture><source srcset="form_263_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\Phi^*(\widehat{\bf u}_f) = \left(J^{-1}_{c} DF_{c}\cdot\widehat{\bf u}_f\right)\circ F^{-1}_{c} $" src="form_263.png"/></picture> for points in one or more physical cells that are images of a given set of points in the reference cell:  </p><p class="formulaDsp">
<picture><source srcset="form_248_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
         \{ x_{c,p} \}_{p=0}^P = \{ F_{c} (\widehat{x}_p) \}_{p=0}^{P}\qquad 0\le c &lt; C \,.
  \]" src="form_248.png"/></picture>
</p>
<p> In this case <picture><source srcset="form_249_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F^{-1}_{c}(x_{c,p}) = \widehat{x}_p $" src="form_249.png"/></picture> and the user-provided container should contain the values of the vector function set <picture><source srcset="form_257_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\widehat{\bf u}_f\}_{f=0}^{F}$" src="form_257.png"/></picture> at the reference points:  </p><p class="formulaDsp">
<picture><source srcset="form_258_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
         inVals(f,p,*) = \widehat{\bf u}_f(\widehat{x}_p) \,.
  \]" src="form_258.png"/></picture>
</p>
<p> The method returns <br  />
  </p><p class="formulaDsp">
<picture><source srcset="form_264_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
         outVals(c,f,p,*) 
          = \left(J^{-1}_{c} DF_{c}\cdot \widehat{\bf u}_f\right)\circ F^{-1}_{c}(x_{c,p}) 
          = J^{-1}_{c}(\widehat{x}_p) DF_{c}(\widehat{x}_p)\cdot\widehat{\bf u}_f(\widehat{x}_p)
          \qquad 0\le c &lt; C \,.
  \]" src="form_264.png"/></picture>
</p>
<p> See Section <a class="el" href="function_space_tools_page.html#sec_pullbacks">Pullbacks</a> for more details about pullbacks.</p>
<div class="fragment"><div class="line">|------|----------------------|--------------------------------------------------|</div>
<div class="line">|      |         Index        |                   Dimension                      |</div>
<div class="line">|------|----------------------|--------------------------------------------------|</div>
<div class="line">|   C  |         cell         |  0 &lt;= C &lt; num. integration domains               |</div>
<div class="line">|   F  |         field        |  0 &lt;= F &lt; dim. of the basis                      |</div>
<div class="line">|   P  |         point        |  0 &lt;= P &lt; num. integration points                |</div>
<div class="line">|   D  |         space dim    |  0 &lt;= D &lt; spatial dimension                      |</div>
<div class="line">|------|----------------------|--------------------------------------------------|</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l00093">93</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

</div>
</div>
<a id="a80e09812bd7911caa65f792afb387fed" name="a80e09812bd7911caa65f792afb387fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e09812bd7911caa65f792afb387fed">&#9670;&#160;</a></span>HGRADtransformGRAD()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayTypeOut , class ArrayTypeJac , class ArrayTypeIn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::HGRADtransformGRAD </td>
          <td>(</td>
          <td class="paramtype">ArrayTypeOut &amp;&#160;</td>
          <td class="paramname"><em>outVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeJac &amp;&#160;</td>
          <td class="paramname"><em>jacobianInverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeIn &amp;&#160;</td>
          <td class="paramname"><em>inVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>'T'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transformation of a gradient field in the H-grad space, defined at points on a reference cell, stored in the user-provided container <em><b>inVals</b></em> and indexed by (F,P,D), into the output container <em><b>outVals</b></em>, defined on cells in physical space and indexed by (C,F,P,D). </p>
<p>Computes pullback of gradients of <em>HGRAD</em> functions <picture><source srcset="form_253_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\Phi^*(\nabla\widehat{u}_f) = \left((DF_c)^{-{\sf T}}\cdot\nabla\widehat{u}_f\right)\circ F^{-1}_{c}$" src="form_253.png"/></picture> for points in one or more physical cells that are images of a given set of points in the reference cell:  </p><p class="formulaDsp">
<picture><source srcset="form_248_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
         \{ x_{c,p} \}_{p=0}^P = \{ F_{c} (\widehat{x}_p) \}_{p=0}^{P}\qquad 0\le c &lt; C \,.
  \]" src="form_248.png"/></picture>
</p>
<p> In this case <picture><source srcset="form_249_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F^{-1}_{c}(x_{c,p}) = \widehat{x}_p $" src="form_249.png"/></picture> and the user-provided container should contain the gradients of the function set <picture><source srcset="form_250_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\widehat{u}_f\}_{f=0}^{F}$" src="form_250.png"/></picture> at the reference points:  </p><p class="formulaDsp">
<picture><source srcset="form_254_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
         inVals(f,p,*) = \nabla\widehat{u}_f(\widehat{x}_p) \,.
  \]" src="form_254.png"/></picture>
</p>
<p> The method returns <br  />
  </p><p class="formulaDsp">
<picture><source srcset="form_255_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
         outVals(c,f,p,*) 
              = \left((DF_c)^{-{\sf T}}\cdot\nabla\widehat{u}_f\right)\circ F^{-1}_{c}(x_{c,p}) 
              = (DF_c)^{-{\sf T}}(\widehat{x}_p)\cdot\nabla\widehat{u}_f(\widehat{x}_p) \qquad 0\le c &lt; C \,.
  \]" src="form_255.png"/></picture>
</p>
<p> See Section <a class="el" href="function_space_tools_page.html#sec_pullbacks">Pullbacks</a> for more details about pullbacks.</p>
<div class="fragment"><div class="line">|------|----------------------|--------------------------------------------------|</div>
<div class="line">|      |         Index        |                   Dimension                      |</div>
<div class="line">|------|----------------------|--------------------------------------------------|</div>
<div class="line">|   C  |         cell         |  0 &lt;= C &lt; num. integration domains               |</div>
<div class="line">|   F  |         field        |  0 &lt;= F &lt; dim. of the basis                      |</div>
<div class="line">|   P  |         point        |  0 &lt;= P &lt; num. integration points                |</div>
<div class="line">|   D  |         space dim    |  0 &lt;= D &lt; spatial dimension                      |</div>
<div class="line">|------|----------------------|--------------------------------------------------|</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l00061">61</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

</div>
</div>
<a id="a20482ce96c48b4b06aa3bedb3ef9b20b" name="a20482ce96c48b4b06aa3bedb3ef9b20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20482ce96c48b4b06aa3bedb3ef9b20b">&#9670;&#160;</a></span>HGRADtransformVALUE()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayTypeOut , class ArrayTypeIn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::HGRADtransformVALUE </td>
          <td>(</td>
          <td class="paramtype">ArrayTypeOut &amp;&#160;</td>
          <td class="paramname"><em>outVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeIn &amp;&#160;</td>
          <td class="paramname"><em>inVals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transformation of a (scalar) value field in the H-grad space, defined at points on a reference cell, stored in the user-provided container <em><b>inVals</b></em> and indexed by (F,P), into the output container <em><b>outVals</b></em>, defined on cells in physical space and indexed by (C,F,P). </p>
<p>Computes pullback of <em>HGRAD</em> functions <picture><source srcset="form_247_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\Phi^*(\widehat{u}_f) = \widehat{u}_f\circ F^{-1}_{c} $" src="form_247.png"/></picture> for points in one or more physical cells that are images of a given set of points in the reference cell:  </p><p class="formulaDsp">
<picture><source srcset="form_248_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
         \{ x_{c,p} \}_{p=0}^P = \{ F_{c} (\widehat{x}_p) \}_{p=0}^{P}\qquad 0\le c &lt; C \,.
  \]" src="form_248.png"/></picture>
</p>
<p> In this case <picture><source srcset="form_249_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F^{-1}_{c}(x_{c,p}) = \widehat{x}_p $" src="form_249.png"/></picture> and the user-provided container should contain the values of the function set <picture><source srcset="form_250_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\widehat{u}_f\}_{f=0}^{F}$" src="form_250.png"/></picture> at the reference points:  </p><p class="formulaDsp">
<picture><source srcset="form_251_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
         inVals(f,p) = \widehat{u}_f(\widehat{x}_p) \,.
  \]" src="form_251.png"/></picture>
</p>
<p> The method returns <br  />
  </p><p class="formulaDsp">
<picture><source srcset="form_252_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
         outVals(c,f,p) 
            = \widehat{u}_f\circ F^{-1}_{c}(x_{c,p}) 
            = \widehat{u}_f(\widehat{x}_p) =  inVals(f,p) \qquad 0\le c &lt; C \,,
  \]" src="form_252.png"/></picture>
</p>
<p> i.e., it simply replicates the values in the user-provided container to every cell. See Section <a class="el" href="function_space_tools_page.html#sec_pullbacks">Pullbacks</a> for more details about pullbacks.</p>
<div class="fragment"><div class="line">|------|----------------------|--------------------------------------------------|</div>
<div class="line">|      |         Index        |                   Dimension                      |</div>
<div class="line">|------|----------------------|--------------------------------------------------|</div>
<div class="line">|   C  |         cell         |  0 &lt;= C &lt; num. integration domains               |</div>
<div class="line">|   F  |         field        |  0 &lt;= F &lt; dim. of the basis                      |</div>
<div class="line">|   P  |         point        |  0 &lt;= P &lt; num. integration points                |</div>
<div class="line">|------|----------------------|--------------------------------------------------|</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l00053">53</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

</div>
</div>
<a id="a3170d65efd4bfb10ba6c7e8613edc703" name="a3170d65efd4bfb10ba6c7e8613edc703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3170d65efd4bfb10ba6c7e8613edc703">&#9670;&#160;</a></span>HVOLtransformVALUE()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayTypeOut , class ArrayTypeDet , class ArrayTypeIn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::HVOLtransformVALUE </td>
          <td>(</td>
          <td class="paramtype">ArrayTypeOut &amp;&#160;</td>
          <td class="paramname"><em>outVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeDet &amp;&#160;</td>
          <td class="paramname"><em>jacobianDet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeIn &amp;&#160;</td>
          <td class="paramname"><em>inVals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transformation of a (scalar) value field in the H-vol space, defined at points on a reference cell, stored in the user-provided container <em><b>inVals</b></em> and indexed by (F,P), into the output container <em><b>outVals</b></em>, defined on cells in physical space and indexed by (C,F,P). </p>
<p>Computes pullback of <em>HVOL</em> functions <picture><source srcset="form_268_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\Phi^*(\widehat{u}_f) = \left(J^{-1}_{c}\widehat{u}_{f}\right) \circ F^{-1}_{c} $" src="form_268.png"/></picture> for points in one or more physical cells that are images of a given set of points in the reference cell:  </p><p class="formulaDsp">
<picture><source srcset="form_248_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
         \{ x_{c,p} \}_{p=0}^P = \{ F_{c} (\widehat{x}_p) \}_{p=0}^{P}\qquad 0\le c &lt; C \,.
  \]" src="form_248.png"/></picture>
</p>
<p> In this case <picture><source srcset="form_249_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F^{-1}_{c}(x_{c,p}) = \widehat{x}_p $" src="form_249.png"/></picture> and the user-provided container should contain the values of the functions in the set <picture><source srcset="form_257_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\widehat{\bf u}_f\}_{f=0}^{F}$" src="form_257.png"/></picture> at the reference points:  </p><p class="formulaDsp">
<picture><source srcset="form_251_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
         inVals(f,p) = \widehat{u}_f(\widehat{x}_p) \,.
  \]" src="form_251.png"/></picture>
</p>
<p> The method returns <br  />
  </p><p class="formulaDsp">
<picture><source srcset="form_269_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
         outVals(c,f,p,*) 
            = \left(J^{-1}_{c}\widehat{u}_{f}\right) \circ F^{-1}_{c} (x_{c,p}) 
            = J^{-1}_{c}(\widehat{x}_p) \widehat{u}_{f} (\widehat{x}_p)
            \qquad 0\le c &lt; C \,.
  \]" src="form_269.png"/></picture>
</p>
<p> See Section <a class="el" href="function_space_tools_page.html#sec_pullbacks">Pullbacks</a> for more details about pullbacks.</p>
<div class="fragment"><div class="line">|------|----------------------|--------------------------------------------------|</div>
<div class="line">|      |         Index        |                   Dimension                      |</div>
<div class="line">|------|----------------------|--------------------------------------------------|</div>
<div class="line">|   C  |         cell         |  0 &lt;= C &lt; num. integration domains               |</div>
<div class="line">|   F  |         field        |  0 &lt;= F &lt; dim. of the basis                      |</div>
<div class="line">|   P  |         point        |  0 &lt;= P &lt; num. integration points                |</div>
<div class="line">|------|----------------------|--------------------------------------------------|</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l00114">114</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

</div>
</div>
<a id="a959e85fc5a065de83a28ab1724b509fc" name="a959e85fc5a065de83a28ab1724b509fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a959e85fc5a065de83a28ab1724b509fc">&#9670;&#160;</a></span>integrate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayOut , class ArrayInLeft , class ArrayInRight &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::integrate </td>
          <td>(</td>
          <td class="paramtype">ArrayOut &amp;&#160;</td>
          <td class="paramname"><em>outputValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayInLeft &amp;&#160;</td>
          <td class="paramname"><em>leftValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayInRight &amp;&#160;</td>
          <td class="paramname"><em>rightValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ECompEngine&#160;</td>
          <td class="paramname"><em>compEngine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>sumInto</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l01215">1215</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

</div>
</div>
<a id="a06be52995a74de7a322ccfb2577a3483" name="a06be52995a74de7a322ccfb2577a3483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06be52995a74de7a322ccfb2577a3483">&#9670;&#160;</a></span>integrate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::integrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntrepid_1_1FieldContainer.html">Intrepid::FieldContainer</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntrepid_1_1FieldContainer.html">Intrepid::FieldContainer</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>leftValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntrepid_1_1FieldContainer.html">Intrepid::FieldContainer</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>rightValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ECompEngine&#160;</td>
          <td class="paramname"><em>compEngine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>sumInto</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contracts <em><b>leftValues</b></em> and <em><b>rightValues</b></em> arrays on the point and possibly space dimensions and stores the result in <em><b>outputValues</b></em>; this is a generic, high-level integration routine that calls either <a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#abbbc0102f5f0effe5d5feb5a0dd610cf" title="Contracts the point (and space) dimensions P (and D1 and D2) of two rank-3, 4, or 5 containers with d...">FunctionSpaceTools::operatorIntegral</a>, or <a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#ad22cf40200ce1db4ff6658b1b95c2c50" title="Contracts the point (and space) dimensions P (and D1 and D2) of a rank-3, 4, or 5 container and a ran...">FunctionSpaceTools::functionalIntegral</a>, or <a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#ae23e64fb1c915530e3f0c4b5feb8727c" title="Contracts the point (and space) dimensions P (and D1 and D2) of two rank-2, 3, or 4 containers with d...">FunctionSpaceTools::dataIntegral</a> methods, depending on the rank of the <em><b>outputValues</b></em> array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputValues</td><td>[out] - Output array. </td></tr>
    <tr><td class="paramname">leftValues</td><td>[in] - Left input array. </td></tr>
    <tr><td class="paramname">rightValues</td><td>[in] - Right input array. </td></tr>
    <tr><td class="paramname">compEngine</td><td>[in] - Computational engine. </td></tr>
    <tr><td class="paramname">sumInto</td><td>[in] - If TRUE, sum into given output array, otherwise overwrite it. Default: FALSE. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l00122">122</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid__FieldContainerDef_8hpp_source.html#l00658">Intrepid::FieldContainer&lt; Scalar, ArrayTypeId &gt;::dimension()</a>, <a class="el" href="Intrepid__Types_8hpp_source.html#l00572">Intrepid::isValidCompEngine()</a>, and <a class="el" href="Intrepid__FieldContainerDef_8hpp_source.html#l00594">Intrepid::FieldContainer&lt; Scalar, ArrayTypeId &gt;::rank()</a>.</p>

</div>
</div>
<a id="a6b2e517d104db7107bb3b97cdd687b37" name="a6b2e517d104db7107bb3b97cdd687b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2e517d104db7107bb3b97cdd687b37">&#9670;&#160;</a></span>multiplyMeasure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayTypeOut , class ArrayTypeMeasure , class ArrayTypeIn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::multiplyMeasure </td>
          <td>(</td>
          <td class="paramtype">ArrayTypeOut &amp;&#160;</td>
          <td class="paramname"><em>outVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeMeasure &amp;&#160;</td>
          <td class="paramname"><em>inMeasure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypeIn &amp;&#160;</td>
          <td class="paramname"><em>inVals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies fields <em><b>inVals</b></em> by weighted measures <em><b>inMeasure</b></em> and returns the field array <em><b>outVals</b></em>; this is a simple redirection to the call <a class="el" href="classIntrepid_1_1FunctionSpaceTools.html#a345f956ddf08c481ebc3e69509302392" title="Scalar multiplication of data and fields; please read the description below.">FunctionSpaceTools::scalarMultiplyDataField</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outVals</td><td>[out] - Output array with scaled field values. </td></tr>
    <tr><td class="paramname">inMeasure</td><td>[in] - Input array containing weighted measures. </td></tr>
    <tr><td class="paramname">inVals</td><td>[in] - Input fields. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l01419">1419</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

</div>
</div>
<a id="abbbc0102f5f0effe5d5feb5a0dd610cf" name="abbbc0102f5f0effe5d5feb5a0dd610cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbbc0102f5f0effe5d5feb5a0dd610cf">&#9670;&#160;</a></span>operatorIntegral()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayOutFields , class ArrayInFieldsLeft , class ArrayInFieldsRight &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::operatorIntegral </td>
          <td>(</td>
          <td class="paramtype">ArrayOutFields &amp;&#160;</td>
          <td class="paramname"><em>outputFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayInFieldsLeft &amp;&#160;</td>
          <td class="paramname"><em>leftFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayInFieldsRight &amp;&#160;</td>
          <td class="paramname"><em>rightFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ECompEngine&#160;</td>
          <td class="paramname"><em>compEngine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>sumInto</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contracts the point (and space) dimensions P (and D1 and D2) of two rank-3, 4, or 5 containers with dimensions (C,L,P) and (C,R,P), or (C,L,P,D1) and (C,R,P,D1), or (C,L,P,D1,D2) and (C,R,P,D1,D2), and returns the result in a rank-3 container with dimensions (C,L,R). </p>
<p>For a fixed index "C", (C,L,R) represents a rectangular L X R matrix where L and R may be different. </p><div class="fragment"><div class="line">C - num. integration domains       dim0 in both input containers</div>
<div class="line">L - num. <span class="stringliteral">&quot;left&quot;</span> fields             dim1 in <span class="stringliteral">&quot;left&quot;</span> container</div>
<div class="line">R - num. <span class="stringliteral">&quot;right&quot;</span> fields            dim1 in <span class="stringliteral">&quot;right&quot;</span> container</div>
<div class="line">P - num. integration points        dim2 in both input containers</div>
<div class="line">D1- vector (1st tensor) dimension  dim3 in both input containers</div>
<div class="line">D2- 2nd tensor dimension           dim4 in both input containers</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputFields</td><td>[out] - Output array. </td></tr>
    <tr><td class="paramname">leftFields</td><td>[in] - Left input array. </td></tr>
    <tr><td class="paramname">rightFields</td><td>[in] - Right input array. </td></tr>
    <tr><td class="paramname">compEngine</td><td>[in] - Computational engine. </td></tr>
    <tr><td class="paramname">sumInto</td><td>[in] - If TRUE, sum into given output array, otherwise overwrite it. Default: FALSE. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l01246">1246</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

</div>
</div>
<a id="a4545b6a57509402e1ef384f1903b24ad" name="a4545b6a57509402e1ef384f1903b24ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4545b6a57509402e1ef384f1903b24ad">&#9670;&#160;</a></span>scalarMultiplyDataData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayOutData , class ArrayInDataLeft , class ArrayInDataRight &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::scalarMultiplyDataData </td>
          <td>(</td>
          <td class="paramtype">ArrayOutData &amp;&#160;</td>
          <td class="paramname"><em>outputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayInDataLeft &amp;&#160;</td>
          <td class="paramname"><em>inputDataLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayInDataRight &amp;&#160;</td>
          <td class="paramname"><em>inputDataRight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>reciprocal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar multiplication of data and data; please read the description below. </p>
<pre class="fragment">   There are two use cases:
   \li
   multiplies a rank-2, 3, or 4 container \a &lt;b&gt;inputDataRight&lt;/b&gt; with dimensions (C,P),
   (C,P,D1) or (C,P,D1,D2), representing the values of a set of scalar, vector
   or tensor data, by the values in a rank-2 container \a &lt;b&gt;inputDataLeft&lt;/b&gt; indexed by (C,P),
   representing the values of scalar data, OR
   \li
   multiplies a rank-1, 2, or 3 container \a &lt;b&gt;inputDataRight&lt;/b&gt; with dimensions (P),
   (P,D1) or (P,D1,D2), representing the values of scalar, vector or
   tensor data, by the values in a rank-2 container \a &lt;b&gt;inputDataLeft&lt;/b&gt; indexed by (C,P),
   representing the values of scalar data;
   the output value container \a &lt;b&gt;outputData&lt;/b&gt; is indexed by (C,P), (C,P,D1) or (C,P,D1,D2),
   regardless of which of the two use cases is considered.
</pre> <div class="fragment"><div class="line">C  - num. integration domains</div>
<div class="line">P  - num. integration points</div>
<div class="line">D1 - first spatial (tensor) dimension index</div>
<div class="line">D2 - second spatial (tensor) dimension index</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The arguments <em><b>inputDataLeft</b></em>, <em><b>inputDataRight</b></em> can be changed! This enables in-place multiplication.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputData</td><td>[out] - Output data array. </td></tr>
    <tr><td class="paramname">inputDataLeft</td><td>[in] - Left (multiplying) data array. </td></tr>
    <tr><td class="paramname">inputDataRight</td><td>[in] - Right (being multiplied) data array. </td></tr>
    <tr><td class="paramname">reciprocal</td><td>[in] - If TRUE, <b>divides</b> input fields by the data (instead of multiplying). Default: FALSE. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l01440">1440</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

</div>
</div>
<a id="a345f956ddf08c481ebc3e69509302392" name="a345f956ddf08c481ebc3e69509302392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345f956ddf08c481ebc3e69509302392">&#9670;&#160;</a></span>scalarMultiplyDataField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayOutFields , class ArrayInData , class ArrayInFields &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::scalarMultiplyDataField </td>
          <td>(</td>
          <td class="paramtype">ArrayOutFields &amp;&#160;</td>
          <td class="paramname"><em>outputFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayInData &amp;&#160;</td>
          <td class="paramname"><em>inputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayInFields &amp;&#160;</td>
          <td class="paramname"><em>inputFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>reciprocal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar multiplication of data and fields; please read the description below. </p>
<pre class="fragment">   There are two use cases:
   \li
   multiplies a rank-3, 4, or 5 container \a &lt;b&gt;inputFields&lt;/b&gt; with dimensions (C,F,P),
   (C,F,P,D1) or (C,F,P,D1,D2), representing the values of a set of scalar, vector
   or tensor fields, by the values in a rank-2 container \a &lt;b&gt;inputData&lt;/b&gt; indexed by (C,P),
   representing the values of scalar data, OR
   \li
   multiplies a rank-2, 3, or 4 container \a &lt;b&gt;inputFields&lt;/b&gt; with dimensions (F,P),
   (F,P,D1) or (F,P,D1,D2), representing the values of a scalar, vector or a
   tensor field, by the values in a rank-2 container \a &lt;b&gt;inputData&lt;/b&gt; indexed by (C,P),
   representing the values of scalar data;
   the output value container \a &lt;b&gt;outputFields&lt;/b&gt; is indexed by (C,F,P), (C,F,P,D1)
   or (C,F,P,D1,D2), regardless of which of the two use cases is considered.
</pre> <div class="fragment"><div class="line">C  - num. integration domains</div>
<div class="line">F  - num. fields</div>
<div class="line">P  - num. integration points</div>
<div class="line">D1 - first spatial (tensor) dimension index</div>
<div class="line">D2 - second spatial (tensor) dimension index</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The argument <em><b>inputFields</b></em> can be changed! This enables in-place multiplication.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputFields</td><td>[out] - Output (product) fields array. </td></tr>
    <tr><td class="paramname">inputData</td><td>[in] - Data (multiplying) array. </td></tr>
    <tr><td class="paramname">inputFields</td><td>[in] - Input (being multiplied) fields array. </td></tr>
    <tr><td class="paramname">reciprocal</td><td>[in] - If TRUE, <b>divides</b> input fields by the data (instead of multiplying). Default: FALSE. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l01429">1429</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

</div>
</div>
<a id="a2aabba1d8d8a0d9dea04c4f26fd2ff78" name="a2aabba1d8d8a0d9dea04c4f26fd2ff78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aabba1d8d8a0d9dea04c4f26fd2ff78">&#9670;&#160;</a></span>tensorMultiplyDataData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayOutData , class ArrayInDataLeft , class ArrayInDataRight &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::tensorMultiplyDataData </td>
          <td>(</td>
          <td class="paramtype">ArrayOutData &amp;&#160;</td>
          <td class="paramname"><em>outputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayInDataLeft &amp;&#160;</td>
          <td class="paramname"><em>inputDataLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayInDataRight &amp;&#160;</td>
          <td class="paramname"><em>inputDataRight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>'N'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix-vector or matrix-matrix product of data and data; please read the description below. </p>
<pre class="fragment">   There are four use cases:
   \li
   matrix-vector product of a rank-3 container \a &lt;b&gt;inputDataRight&lt;/b&gt; with dimensions (C,P,D),
   representing the values of a set of vector data, on the left by the values in a rank-2, 3, or 4
   container \a &lt;b&gt;inputDataLeft&lt;/b&gt; indexed by (C,P), (C,P,D) or (C,P,D,D), respectively,
   representing the values of tensor data, OR
   \li
   matrix-vector product of a rank-2 container \a &lt;b&gt;inputDataRight&lt;/b&gt; with dimensions (P,D),
   representing the values of vector data, on the left by the values in a rank-2, 3, or 4
   container \a &lt;b&gt;inputDataLeft&lt;/b&gt; indexed by (C,P), (C,P,D) or (C,P,D,D), respectively,
   representing the values of tensor data, OR
   \li
   matrix-matrix product of a rank-4 container \a &lt;b&gt;inputDataRight&lt;/b&gt; with dimensions (C,P,D,D),
   representing the values of a set of tensor data, on the left by the values in a rank-2, 3, or 4
   container \a &lt;b&gt;inputDataLeft&lt;/b&gt; indexed by (C,P), (C,P,D) or (C,P,D,D), respectively,
   representing the values of tensor data, OR
   \li
   matrix-matrix product of a rank-3 container \a &lt;b&gt;inputDataRight&lt;/b&gt; with dimensions (P,D,D),
   representing the values of tensor data, on the left by the values in a rank-2, 3, or 4
   container \a &lt;b&gt;inputDataLeft&lt;/b&gt; indexed by (C,P), (C,P,D) or (C,P,D,D), respectively,
   representing the values of tensor data;
   for matrix-vector products, the output value container \a &lt;b&gt;outputData&lt;/b&gt;
   is indexed by (C,P,D);
   for matrix-matrix products, the output value container \a &lt;b&gt;outputData&lt;/b&gt;
   is indexed by (C,P,D1,D2).
</pre> <dl class="section remark"><dt>Remarks</dt><dd>The rank of <b>inputDataLeft</b> implicitly defines the type of tensor data: <ul>
<li>rank = 2 corresponds to a constant diagonal tensor <picture><source srcset="form_121_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ diag(a,\ldots,a) $" src="form_121.png"/></picture> </li>
<li>rank = 3 corresponds to a nonconstant diagonal tensor <picture><source srcset="form_122_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ diag(a_1,\ldots,a_d) $" src="form_122.png"/></picture> </li>
<li>rank = 4 corresponds to a full tensor <picture><source srcset="form_123_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \{a_{ij}\}$" src="form_123.png"/></picture></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is assumed that all tensors are square!</dd>
<dd>
The method is defined for spatial dimensions D = 1, 2, 3</dd></dl>
<div class="fragment"><div class="line">C    - num. integration domains</div>
<div class="line">P    - num. integration points</div>
<div class="line">D    - spatial dimension</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputData</td><td>[out] - Output (matrix-vector product) data array. </td></tr>
    <tr><td class="paramname">inputDataLeft</td><td>[in] - Left input data array. </td></tr>
    <tr><td class="paramname">inputDataRight</td><td>[in] - Right input data array. </td></tr>
    <tr><td class="paramname">transpose</td><td>[in] - If 'T', use transposed tensor; if 'N', no transpose. Default: 'N'. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l01577">1577</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

</div>
</div>
<a id="aec2dd693fe53ea58a56a674284c99e79" name="aec2dd693fe53ea58a56a674284c99e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec2dd693fe53ea58a56a674284c99e79">&#9670;&#160;</a></span>tensorMultiplyDataField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayOutFields , class ArrayInData , class ArrayInFields &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::tensorMultiplyDataField </td>
          <td>(</td>
          <td class="paramtype">ArrayOutFields &amp;&#160;</td>
          <td class="paramname"><em>outputFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayInData &amp;&#160;</td>
          <td class="paramname"><em>inputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayInFields &amp;&#160;</td>
          <td class="paramname"><em>inputFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>'N'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix-vector or matrix-matrix product of data and fields; please read the description below. </p>
<pre class="fragment">   There are four use cases:
   \li
   matrix-vector product of a rank-4 container \a &lt;b&gt;inputFields&lt;/b&gt; with dimensions (C,F,P,D),
   representing the values of a set of vector fields, on the left by the values in a rank-2, 3, or 4
   container \a &lt;b&gt;inputData&lt;/b&gt; indexed by (C,P), (C,P,D) or (C,P,D,D), respectively,
   representing the values of tensor data, OR
   \li
   matrix-vector product of a rank-3 container \a &lt;b&gt;inputFields&lt;/b&gt; with dimensions (F,P,D),
   representing the values of a vector field, on the left by the values in a rank-2, 3, or 4
   container \a &lt;b&gt;inputData&lt;/b&gt; indexed by (C,P), (C,P,D) or (C,P,D,D), respectively,
   representing the values of tensor data, OR
   \li
   matrix-matrix product of a rank-5 container \a &lt;b&gt;inputFields&lt;/b&gt; with dimensions (C,F,P,D,D),
   representing the values of a set of tensor fields, on the left by the values in a rank-2, 3, or 4
   container \a &lt;b&gt;inputData&lt;/b&gt; indexed by (C,P), (C,P,D) or (C,P,D,D), respectively,
   representing the values of tensor data, OR
   \li
   matrix-matrix product of a rank-4 container \a &lt;b&gt;inputFields&lt;/b&gt; with dimensions (F,P,D,D),
   representing the values of a tensor field, on the left by the values in a rank-2, 3, or 4
   container \a &lt;b&gt;inputData&lt;/b&gt; indexed by (C,P), (C,P,D) or (C,P,D,D), respectively,
   representing the values of tensor data;
   for matrix-vector products, the output value container \a &lt;b&gt;outputFields&lt;/b&gt; is
   indexed by (C,F,P,D);
   for matrix-matrix products the output value container \a &lt;b&gt;outputFields&lt;/b&gt; is
   indexed by (C,F,P,D,D).
</pre> <dl class="section remark"><dt>Remarks</dt><dd>The rank of <em><b>inputData</b></em> implicitly defines the type of tensor data: <ul>
<li>rank = 2 corresponds to a constant diagonal tensor <picture><source srcset="form_121_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ diag(a,\ldots,a) $" src="form_121.png"/></picture> </li>
<li>rank = 3 corresponds to a nonconstant diagonal tensor <picture><source srcset="form_122_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ diag(a_1,\ldots,a_d) $" src="form_122.png"/></picture> </li>
<li>rank = 4 corresponds to a full tensor <picture><source srcset="form_123_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \{a_{ij}\}$" src="form_123.png"/></picture></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is assumed that all tensors are square!</dd>
<dd>
The method is defined for spatial dimensions D = 1, 2, 3</dd></dl>
<div class="fragment"><div class="line">C    - num. integration domains</div>
<div class="line">F    - num. fields</div>
<div class="line">P    - num. integration points</div>
<div class="line">D    - spatial dimension</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputFields</td><td>[out] - Output (matrix-vector or matrix-matrix product) fields array. </td></tr>
    <tr><td class="paramname">inputData</td><td>[in] - Data array. </td></tr>
    <tr><td class="paramname">inputFields</td><td>[in] - Input fields array. </td></tr>
    <tr><td class="paramname">transpose</td><td>[in] - If 'T', use transposed left data tensor; if 'N', no transpose. Default: 'N'. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l01517">1517</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

</div>
</div>
<a id="a748d81ba4f7fe9019ffbfc51c146904d" name="a748d81ba4f7fe9019ffbfc51c146904d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748d81ba4f7fe9019ffbfc51c146904d">&#9670;&#160;</a></span>vectorMultiplyDataData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayOutData , class ArrayInDataLeft , class ArrayInDataRight &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::vectorMultiplyDataData </td>
          <td>(</td>
          <td class="paramtype">ArrayOutData &amp;&#160;</td>
          <td class="paramname"><em>outputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayInDataLeft &amp;&#160;</td>
          <td class="paramname"><em>inputDataLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayInDataRight &amp;&#160;</td>
          <td class="paramname"><em>inputDataRight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cross or outer product of data and data; please read the description below. </p>
<pre class="fragment">   There are four use cases:
   \li
   cross product of a rank-3 container \a &lt;b&gt;inputDataRight&lt;/b&gt; with dimensions (C,P,D),
   representing the values of a set of vector data, on the left by the values in a rank-3
   container \a &lt;b&gt;inputDataLeft&lt;/b&gt; indexed by (C,P,D) representing the values of vector data, OR
   \li
   cross product of a rank-2 container \a &lt;b&gt;inputDataRight&lt;/b&gt; with dimensions (P,D),
   representing the values of vector data, on the left by the values in a rank-3 container
   \a &lt;b&gt;inputDataLeft&lt;/b&gt; indexed by (C,P,D), representing the values of vector data, OR
   \li
   outer product of a rank-3 container \a &lt;b&gt;inputDataRight&lt;/b&gt; with dimensions (C,P,D),
   representing the values of a set of vector data, on the left by the values in a rank-3
   container \a &lt;b&gt;inputDataLeft&lt;/b&gt; indexed by (C,P,D) representing the values of vector data, OR
   \li
   outer product of a rank-2 container \a &lt;b&gt;inputDataRight&lt;/b&gt; with dimensions (P,D),
   representing the values of vector data, on the left by the values in a rank-3 container
   \a &lt;b&gt;inputDataLeft&lt;/b&gt; indexed by (C,P,D), representing the values of vector data;
   for cross products, the output value container \a &lt;b&gt;outputData&lt;/b&gt; is indexed by
   (C,P,D) in 3D (vector output) and by (C,P) in 2D (scalar output);
   for outer products, the output value container \a &lt;b&gt;outputData&lt;/b&gt; is indexed by (C,P,D,D).
</pre> <div class="fragment"><div class="line">C  - num. integration domains</div>
<div class="line">P  - num. integration points</div>
<div class="line">D  - spatial dimension, must be 2 or 3</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputData</td><td>[out] - Output (cross or outer product) data array. </td></tr>
    <tr><td class="paramname">inputDataLeft</td><td>[in] - Left input data array. </td></tr>
    <tr><td class="paramname">inputDataRight</td><td>[in] - Right input data array. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l01494">1494</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

</div>
</div>
<a id="a048776f734e3aa80e9a6cd199fa6874d" name="a048776f734e3aa80e9a6cd199fa6874d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048776f734e3aa80e9a6cd199fa6874d">&#9670;&#160;</a></span>vectorMultiplyDataField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class ArrayOutFields , class ArrayInData , class ArrayInFields &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Intrepid::FunctionSpaceTools::vectorMultiplyDataField </td>
          <td>(</td>
          <td class="paramtype">ArrayOutFields &amp;&#160;</td>
          <td class="paramname"><em>outputFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayInData &amp;&#160;</td>
          <td class="paramname"><em>inputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayInFields &amp;&#160;</td>
          <td class="paramname"><em>inputFields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cross or outer product of data and fields; please read the description below. </p>
<pre class="fragment">   There are four use cases:
   \li
   cross product of a rank-4 container \a &lt;b&gt;inputFields&lt;/b&gt; with dimensions (C,F,P,D),
   representing the values of a set of vector fields, on the left by the values in a rank-3
   container \a &lt;b&gt;inputData&lt;/b&gt; indexed by (C,P,D), representing the values of vector data, OR
   \li
   cross product of a rank-3 container \a &lt;b&gt;inputFields&lt;/b&gt; with dimensions (F,P,D),
   representing the values of a vector field, on the left by the values in a rank-3 container
   \a &lt;b&gt;inputData&lt;/b&gt; indexed by (C,P,D), representing the values of vector data, OR
   \li
   outer product of a rank-4 container \a &lt;b&gt;inputFields&lt;/b&gt; with dimensions (C,F,P,D),
   representing the values of a set of vector fields, on the left by the values in a rank-3
   container \a &lt;b&gt;inputData&lt;/b&gt; indexed by (C,P,D), representing the values of vector data, OR
   \li
   outer product of a rank-3 container \a &lt;b&gt;inputFields&lt;/b&gt; with dimensions (F,P,D),
   representing the values of a vector field, on the left by the values in a rank-3 container
   \a &lt;b&gt;inputData&lt;/b&gt; indexed by (C,P,D), representing the values of vector data;
   for cross products, the output value container \a &lt;b&gt;outputFields&lt;/b&gt; is indexed by
   (C,F,P,D) in 3D (vector output) and by (C,F,P) in 2D (scalar output);
   for outer products, the output value container \a &lt;b&gt;outputFields&lt;/b&gt; is indexed by (C,F,P,D,D).
</pre> <div class="fragment"><div class="line">C  - num. integration domains</div>
<div class="line">F  - num. fields</div>
<div class="line">P  - num. integration points</div>
<div class="line">D  - spatial dimension, must be 2 or 3</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputFields</td><td>[out] - Output (cross or outer product) fields array. </td></tr>
    <tr><td class="paramname">inputData</td><td>[in] - Data array. </td></tr>
    <tr><td class="paramname">inputFields</td><td>[in] - Input fields array. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html#l01471">1471</a> of file <a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/trilinos.github.io/trilinos.github.io/Trilinos/packages/intrepid/src/Discretization/FunctionSpaceTools/<a class="el" href="Intrepid__FunctionSpaceTools_8hpp_source.html">Intrepid_FunctionSpaceTools.hpp</a></li>
<li>/home/runner/work/trilinos.github.io/trilinos.github.io/Trilinos/packages/intrepid/src/Discretization/FunctionSpaceTools/<a class="el" href="Intrepid__FunctionSpaceToolsDef_8hpp_source.html">Intrepid_FunctionSpaceToolsDef.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
