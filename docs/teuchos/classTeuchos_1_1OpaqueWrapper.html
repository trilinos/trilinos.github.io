<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Teuchos - Trilinos Tools Package: Teuchos::OpaqueWrapper&lt; Opaque &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Teuchos - Trilinos Tools Package<span id="projectnumber">&#160;Version of the Day</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceTeuchos.html">Teuchos</a></li><li class="navelem"><a class="el" href="classTeuchos_1_1OpaqueWrapper.html">OpaqueWrapper</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#related">Related Symbols</a> &#124;
<a href="classTeuchos_1_1OpaqueWrapper-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Teuchos::OpaqueWrapper&lt; Opaque &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__teuchos__mem__mng__grp.html">Teuchos Memory Management Utilities</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Base class for wrapped opaque objects.  
 <a href="classTeuchos_1_1OpaqueWrapper.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Teuchos__OpaqueWrapper_8hpp_source.html">Teuchos_OpaqueWrapper.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Teuchos::OpaqueWrapper&lt; Opaque &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classTeuchos_1_1OpaqueWrapper.png" usemap="#Teuchos::OpaqueWrapper_3C_20Opaque_20_3E_map" alt=""/>
  <map id="Teuchos::OpaqueWrapper_3C_20Opaque_20_3E_map" name="Teuchos::OpaqueWrapper_3C_20Opaque_20_3E_map">
<area href="classTeuchos_1_1OpaqueWrapperWithFree.html" title="Subclass for wrapped opaque objects with a free function." alt="Teuchos::OpaqueWrapperWithFree&lt; Opaque, OpaqueFree &gt;" shape="rect" coords="0,56,358,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2d6ab7d91ff5767b66c87703a007440b" id="r_a2d6ab7d91ff5767b66c87703a007440b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1OpaqueWrapper.html#a2d6ab7d91ff5767b66c87703a007440b">OpaqueWrapper</a> (<a class="el" href="classTeuchos_1_1RCP.html">Opaque</a> <a class="el" href="classTeuchos_1_1RCP.html">opaque</a>)</td></tr>
<tr class="memdesc:a2d6ab7d91ff5767b66c87703a007440b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that accepts and wraps a raw handle.  <br /></td></tr>
<tr class="separator:a2d6ab7d91ff5767b66c87703a007440b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836462bea569e1b541b9de5dd0183604" id="r_a836462bea569e1b541b9de5dd0183604"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1OpaqueWrapper.html#a836462bea569e1b541b9de5dd0183604">operator Opaque</a> () <a class="el" href="classTeuchos_1_1RCP.html">const</a></td></tr>
<tr class="memdesc:a836462bea569e1b541b9de5dd0183604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit type conversion from wrapper to raw handle.  <br /></td></tr>
<tr class="separator:a836462bea569e1b541b9de5dd0183604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd3435ad90b8fab2dca200cb789ad17" id="r_a1bd3435ad90b8fab2dca200cb789ad17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">Opaque</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1OpaqueWrapper.html#a1bd3435ad90b8fab2dca200cb789ad17">operator()</a> () <a class="el" href="classTeuchos_1_1RCP.html">const</a></td></tr>
<tr class="memdesc:a1bd3435ad90b8fab2dca200cb789ad17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit type conversion from wrapper to raw handle.  <br /></td></tr>
<tr class="separator:a1bd3435ad90b8fab2dca200cb789ad17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab13132cdb97c3d9ba0f0cde1c225c037" id="r_ab13132cdb97c3d9ba0f0cde1c225c037"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">Opaque</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1OpaqueWrapper.html#ab13132cdb97c3d9ba0f0cde1c225c037">opaque_</a></td></tr>
<tr class="memdesc:ab13132cdb97c3d9ba0f0cde1c225c037"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual handle.  <br /></td></tr>
<tr class="separator:ab13132cdb97c3d9ba0f0cde1c225c037"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:a8770e064ea0d612c9cbbe84463186c5c" id="r_a8770e064ea0d612c9cbbe84463186c5c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Opaque</a> &gt; </td></tr>
<tr class="memitem:a8770e064ea0d612c9cbbe84463186c5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1OpaqueWrapper.html">OpaqueWrapper</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">Opaque</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1OpaqueWrapper.html#a8770e064ea0d612c9cbbe84463186c5c">opaqueWrapper</a> (<a class="el" href="classTeuchos_1_1RCP.html">Opaque</a> <a class="el" href="classTeuchos_1_1RCP.html">opaque</a>)</td></tr>
<tr class="memdesc:a8770e064ea0d612c9cbbe84463186c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <code><a class="el" href="classTeuchos_1_1OpaqueWrapper.html" title="Base class for wrapped opaque objects.">OpaqueWrapper</a></code> object without a free function.  <br /></td></tr>
<tr class="separator:a8770e064ea0d612c9cbbe84463186c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f32abac0b3105156d4da619f78d542" id="r_ae2f32abac0b3105156d4da619f78d542"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Opaque</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">OpaqueFree</a> &gt; </td></tr>
<tr class="memitem:ae2f32abac0b3105156d4da619f78d542"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1OpaqueWrapper.html">OpaqueWrapper</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">Opaque</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1OpaqueWrapper.html#ae2f32abac0b3105156d4da619f78d542">opaqueWrapper</a> (<a class="el" href="classTeuchos_1_1RCP.html">Opaque</a> <a class="el" href="classTeuchos_1_1RCP.html">opaque</a>, <a class="el" href="classTeuchos_1_1RCP.html">OpaqueFree</a> <a class="el" href="classTeuchos_1_1RCP.html">opaqueFree</a>)</td></tr>
<tr class="memdesc:ae2f32abac0b3105156d4da619f78d542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <code><a class="el" href="classTeuchos_1_1OpaqueWrapper.html" title="Base class for wrapped opaque objects.">OpaqueWrapper</a></code> object with a free function.  <br /></td></tr>
<tr class="separator:ae2f32abac0b3105156d4da619f78d542"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Opaque</a>&gt;<br />
class Teuchos::OpaqueWrapper&lt; Opaque &gt;</div><p>Base class for wrapped opaque objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Opaque</td><td>Type of the opaque object (a.k.a. handle).</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Teuchos_OpaqueWrapper_Summary"></a>
Summary</h1>
<p>If you want to create an <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> to an opaque handle (an instance of a type like MPI_Comm), use the <a class="el" href="classTeuchos_1_1OpaqueWrapper.html#a8770e064ea0d612c9cbbe84463186c5c" title="Create a new OpaqueWrapper object without a free function.">opaqueWrapper()</a> nonmember template function. If that opaque handle needs to be freed after all references to it go away, then supply a "free" function to <a class="el" href="classTeuchos_1_1OpaqueWrapper.html#a8770e064ea0d612c9cbbe84463186c5c" title="Create a new OpaqueWrapper object without a free function.">opaqueWrapper()</a>. The type returned by <a class="el" href="classTeuchos_1_1OpaqueWrapper.html#a8770e064ea0d612c9cbbe84463186c5c" title="Create a new OpaqueWrapper object without a free function.">opaqueWrapper()</a> is <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a>&lt;OpaqueWrapper&lt;T&gt; &gt;</code>, an <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> (reference-counted "smart" pointer) to a wrapper of the opaque handle type T. Users are not allowed to construct an <a class="el" href="classTeuchos_1_1OpaqueWrapper.html" title="Base class for wrapped opaque objects.">OpaqueWrapper</a> object explicitly. You must use the <a class="el" href="classTeuchos_1_1OpaqueWrapper.html#a8770e064ea0d612c9cbbe84463186c5c" title="Create a new OpaqueWrapper object without a free function.">opaqueWrapper()</a> nonmember function to do so.</p>
<h1><a class="anchor" id="Teuchos_OpaqueWrapper_Prereq"></a>
Prerequisites</h1>
<p>In order to understand this documentation, you must first have learned how to use <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> (<a class="el" href="namespaceTeuchos.html" title="The Teuchos namespace contains all of the classes, structs and enums used by Teuchos,...">Teuchos</a>' reference-counted "smart" pointer class) to manage dynamically allocated memory and other resources. It also helps to be familiar with MPI (the Message Passing Interface for distributed-memory parallel programming), but this is not required.</p>
<h1><a class="anchor" id="Teuchos_OpaqueWrapper_Handles"></a>
What are opaque handles?</h1>
<p>Many different software libraries use the <em>opaque handle</em> (a.k.a. opaque object) idiom to hide the internals of a data structure from users. This standard technique allows users to treat an instance of a data structure as a handle. Users may pass the handle around as if it were a simple value type (like int), and must call nonmember functions in order to create, operate on, use, or destroy instances of the data structure. The MPI (Message Passing Interface) standard is full of examples of the opaque handle idiom, including MPI_Comm (for communicators), MPI_Datatype (for standard and custom data types), and MPI_Op (for standard and custom reduction operations).</p>
<p>In general, opaque handles (corresponding to the Opaque template parameter) must be <em>assignable</em>. This means that copy construction and assignment (operator=) must be syntactically correct for instances of Opaque. This is certainly true of MPI's opaque handle types.</p>
<p>Opaque handles are a useful technique, but they interfere with correct use of reference-counted "smart" pointer types such as <a class="el" href="namespaceTeuchos.html" title="The Teuchos namespace contains all of the classes, structs and enums used by Teuchos,...">Teuchos</a>' <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> or std::shared_ptr. We will explain below why this is the case. The <a class="el" href="classTeuchos_1_1OpaqueWrapper.html" title="Base class for wrapped opaque objects.">OpaqueWrapper</a> base class allows opaque handles to be wrapped by a real object, whose address you can take. This is needed in order to wrap an opaque object in a <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a>, for example.</p>
<h1><a class="anchor" id="Teuchos_OpaqueWrapper_Special"></a>
Why do opaque handles need special treatment?</h1>
<p>The <a class="el" href="classTeuchos_1_1OpaqueWrapper.html" title="Base class for wrapped opaque objects.">OpaqueWrapper</a> class was motivated by MPI's common use of the opaque handle idiom. For MPI, passing MPI_Comm, MPI_Datatype, and MPI_Op objects around by handles hides implementation details from the user. Handles also make it easier to access MPI functionality from Fortran, so that C, C++, and Fortran can all share the same handle mechanism. In fact, some MPI implementations (such as MPICH, at least historically if not currently) simply implement these handles all as integers. (As the MPI standard's advice to implementers suggests, such an implementation would likely maintain a table for each MPI process that maps the integer value to a pointer to the corresponding object.) For example, MPI_Comm might be a typedef to int, and MPI_COMM_WORLD might be a C preprocessor macro for a literal integer value:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span> <a class="code hl_class" href="classTeuchos_1_1RCP.html">MPI_Comm</a>;</div>
<div class="line"><span class="preprocessor">#define MPI_COMM_WORLD 42</span></div>
<div class="ttc" id="aclassTeuchos_1_1RCP_html"><div class="ttname"><a href="classTeuchos_1_1RCP.html">Teuchos::RCP</a></div><div class="ttdoc">Smart reference counting pointer class for automatic garbage collection.</div><div class="ttdef"><b>Definition</b> <a href="Teuchos__RCPDecl_8hpp_source.html#l00397">Teuchos_RCPDecl.hpp:397</a></div></div>
</div><!-- fragment --><p>In this case, the expression <code>rcp(&amp;MPI_COMM_WORLD)</code> would not even compile, since one cannot take the address of an integer literal such as 42. (Remember that preprocessor macros get replaced with their values before the C++ compiler does its work.) To make this expression compile, one might try the following:</p>
<div class="fragment"><div class="line"><span class="comment">// THIS FUNCTION IS WRONG.  IT MAY SEGFAULT.</span></div>
<div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">Teuchos::RCP&lt;MPI_Comm&gt;</a> <a class="code hl_class" href="classTeuchos_1_1RCP.html">getMpiCommPtr</a>()</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_class" href="classTeuchos_1_1RCP.html">MPI_Comm</a> <a class="code hl_class" href="classTeuchos_1_1RCP.html">comm</a> = <a class="code hl_class" href="classTeuchos_1_1RCP.html">MPI_COMM_WORLD</a>;</div>
<div class="line">  <span class="comment">// WRONG!!!  comm is a stack variable!</span></div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceTeuchos.html#a39378f1892f1d484eb697574a8a8c5af">Teuchos::rcp</a> (&amp;<a class="code hl_class" href="classTeuchos_1_1RCP.html">comm</a>, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceTeuchos_html_a39378f1892f1d484eb697574a8a8c5af"><div class="ttname"><a href="namespaceTeuchos.html#a39378f1892f1d484eb697574a8a8c5af">Teuchos::rcp</a></div><div class="ttdeci">TEUCHOS_DEPRECATED RCP&lt; T &gt; rcp(T *p, Dealloc_T dealloc, bool owns_mem)</div><div class="ttdoc">Deprecated.</div><div class="ttdef"><b>Definition</b> <a href="Teuchos__RCPDecl_8hpp_source.html#l01234">Teuchos_RCPDecl.hpp:1234</a></div></div>
</div><!-- fragment --><p>Using the returned communicator would result in undefined behavior, which in practice might be a segfault, memory corruption, or MPI getting severely confused. This is because the stack variable <code>comm</code>, which may be just an integer, disappears at the end of the function. Its address would no longer point to valid memory after the function returns.</p>
<p>The following code is syntactically correct, but may leak memory:</p>
<div class="fragment"><div class="line"><span class="comment">// THIS CODE LEAKS MEMORY FOR GENERAL MPI_Comm OBJECTS.</span></div>
<div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">Teuchos::RCP&lt;MPI_Comm&gt;</a> <a class="code hl_class" href="classTeuchos_1_1RCP.html">getMpiCommPtr</a> (<a class="code hl_class" href="classTeuchos_1_1RCP.html">MPI_Comm</a> <a class="code hl_class" href="classTeuchos_1_1RCP.html">comm</a>)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_class" href="classTeuchos_1_1RCP.html">MPI_Comm</a> *<a class="code hl_class" href="classTeuchos_1_1RCP.html">pComm</a> = <span class="keyword">new</span> <a class="code hl_class" href="classTeuchos_1_1RCP.html">MPI_Comm</a> (<a class="code hl_class" href="classTeuchos_1_1RCP.html">comm</a>);</div>
<div class="line">  <span class="comment">// Works for comm==MPI_COMM_WORLD or MPI_COMM_SELF;</span></div>
<div class="line">  <span class="comment">// leaks memory for user-created MPI_Comm objects.</span></div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceTeuchos.html#a39378f1892f1d484eb697574a8a8c5af">Teuchos::rcp</a> (<a class="code hl_class" href="classTeuchos_1_1RCP.html">pComm</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The above implementation of getMpiCommPtr() is correct only for the standard MPI_Comm objects provided by MPI, like MPI_COMM_WORLD and MPI_COMM_SELF. It is <em>not</em> correct, and in fact may leak memory, for custom MPI_Comm objects that the user creates by calling functions like MPI_Comm_split(). This is because user-created MPI_Comm objects must be freed by MPI_Comm_free(). Other kinds of opaque objects, like MPI_Datatype and MPI_Op, have their own free functions. Thus, even if opaque handles have the type integer, they really behave like pointers or references. Some of them can and should be freed at the end of their useful lives; others must not. (Compare std::ostream; std::cout should never be closed by typical user code, but an output file should be closed.)</p>
<h1><a class="anchor" id="Teuchos_OpaqueWrapper_How"></a>
How to use OpaqueWrapper</h1>
<p>We fix this problem by providing the <a class="el" href="classTeuchos_1_1OpaqueWrapper.html" title="Base class for wrapped opaque objects.">OpaqueWrapper</a> template base class and the <a class="el" href="classTeuchos_1_1OpaqueWrapper.html#a8770e064ea0d612c9cbbe84463186c5c" title="Create a new OpaqueWrapper object without a free function.">opaqueWrapper()</a> nonmember template function. Use this function to wrap an opaque handle (like an MPI_Comm) in an <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a>. This ensures that the <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> does the right thing in case the handle must be freed. For example, to wrap MPI_COMM_WORLD in a <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a>, just do this:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;OpaqueWrapper&lt;MPI_Comm&gt;</a> &gt; <a class="code hl_class" href="classTeuchos_1_1RCP.html">comm</a> = <a class="code hl_function" href="classTeuchos_1_1OpaqueWrapper.html#a8770e064ea0d612c9cbbe84463186c5c">opaqueWrapper</a> (<a class="code hl_class" href="classTeuchos_1_1RCP.html">MPI_COMM_WORLD</a>);</div>
<div class="ttc" id="aclassTeuchos_1_1OpaqueWrapper_html_a8770e064ea0d612c9cbbe84463186c5c"><div class="ttname"><a href="classTeuchos_1_1OpaqueWrapper.html#a8770e064ea0d612c9cbbe84463186c5c">Teuchos::OpaqueWrapper::opaqueWrapper</a></div><div class="ttdeci">RCP&lt; OpaqueWrapper&lt; Opaque &gt; &gt; opaqueWrapper(Opaque opaque)</div><div class="ttdoc">Create a new OpaqueWrapper object without a free function.</div><div class="ttdef"><b>Definition</b> <a href="Teuchos__OpaqueWrapper_8hpp_source.html#l00322">Teuchos_OpaqueWrapper.hpp:322</a></div></div>
</div><!-- fragment --><p>If you instead want to create a custom MPI_Comm using a function like MPI_Comm_split(), then you may wrap it in an <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> as follows (please see discussion later about MPI_Comm_free()):</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">MPI_Comm</a> <a class="code hl_class" href="classTeuchos_1_1RCP.html">rawComm</a>;</div>
<div class="line"><span class="comment">// We omit all arguments but the last of MPI_Comm_split, for clarity.</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_class" href="classTeuchos_1_1RCP.html">errCode</a> = <a class="code hl_class" href="classTeuchos_1_1RCP.html">MPI_Comm_split</a> (..., &amp;<a class="code hl_class" href="classTeuchos_1_1RCP.html">rawComm</a>);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_class" href="classTeuchos_1_1RCP.html">errCode</a> != <a class="code hl_class" href="classTeuchos_1_1RCP.html">MPI_SUCCESS</a>) {</div>
<div class="line">  <span class="comment">// ... Handle the error ...</span></div>
<div class="line">}</div>
<div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;OpaqueWrapper&lt;MPI_Comm&gt;</a> &gt; <a class="code hl_class" href="classTeuchos_1_1RCP.html">comm</a> = <a class="code hl_function" href="classTeuchos_1_1OpaqueWrapper.html#a8770e064ea0d612c9cbbe84463186c5c">opaqueWrapper</a> (<a class="code hl_class" href="classTeuchos_1_1RCP.html">rawComm</a>, <a class="code hl_class" href="classTeuchos_1_1RCP.html">MPI_Comm_free</a>);</div>
</div><!-- fragment --><p>The optional second argument to <a class="el" href="classTeuchos_1_1OpaqueWrapper.html#a8770e064ea0d612c9cbbe84463186c5c" title="Create a new OpaqueWrapper object without a free function.">opaqueWrapper()</a> is a "free" function. It has type OpaqueFree which is a template parameter. If the free function is provided, then when the <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a>'s reference count goes to zero, that function is called to "free" the handle. If opaqueFree is a free function, then the following must be syntactically valid, where <code>opaque</code> has type <code>Opaque</code>:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">opaqueFree</a> (&amp;<a class="code hl_class" href="classTeuchos_1_1RCP.html">opaque</a>);</div>
</div><!-- fragment --><p>The function's return value, if any, is ignored. Furthermore, the OpaqueFree type must be copy constructible. (A function pointer is trivally copy constructible.)</p>
<p>Users are responsible for knowing whether to provide a free function to <a class="el" href="classTeuchos_1_1OpaqueWrapper.html#a8770e064ea0d612c9cbbe84463186c5c" title="Create a new OpaqueWrapper object without a free function.">opaqueWrapper()</a>. In this case, because we created an MPI_Comm dynamically using a communicator "constructor" function, the MPI_Comm must be "freed" after use. <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> will automatically call the "free" function once the reference count of <code>comm</code> reaches zero.</p>
<dl class="section note"><dt>Note</dt><dd>The above example is only correct if the reference count of <code>comm</code> will go to zero before MPI_Finalize is called. This is because it's not valid to call MPI_Comm_free after MPI_Finalize has been called. The details::safeCommFree function checks whether MPI_Finalize has been called (via MPI_Finalized) before calling MPI_Comm_free; you may use this function as the free function if you are concerned about this. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Teuchos__OpaqueWrapper_8hpp_source.html#l00208">208</a> of file <a class="el" href="Teuchos__OpaqueWrapper_8hpp_source.html">Teuchos_OpaqueWrapper.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2d6ab7d91ff5767b66c87703a007440b" name="a2d6ab7d91ff5767b66c87703a007440b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6ab7d91ff5767b66c87703a007440b">&#9670;&#160;</a></span>OpaqueWrapper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Opaque</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1OpaqueWrapper.html">Teuchos::OpaqueWrapper</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">Opaque</a> &gt;::OpaqueWrapper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">Opaque</a>&#160;</td>
          <td class="paramname"><em>opaque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that accepts and wraps a raw handle. </p>
<p>Users typically never have to invoke the constructor explicitly. The <a class="el" href="classTeuchos_1_1OpaqueWrapper.html#a8770e064ea0d612c9cbbe84463186c5c" title="Create a new OpaqueWrapper object without a free function.">opaqueWrapper()</a> nonmember template function does this for them. </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__OpaqueWrapper_8hpp_source.html#l00214">214</a> of file <a class="el" href="Teuchos__OpaqueWrapper_8hpp_source.html">Teuchos_OpaqueWrapper.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a836462bea569e1b541b9de5dd0183604" name="a836462bea569e1b541b9de5dd0183604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836462bea569e1b541b9de5dd0183604">&#9670;&#160;</a></span>operator Opaque()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Opaque</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1OpaqueWrapper.html">Teuchos::OpaqueWrapper</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">Opaque</a> &gt;::operator <a class="el" href="classTeuchos_1_1RCP.html">Opaque</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implicit type conversion from wrapper to raw handle. </p>
<p>Users typically never have to convert directly from an <a class="el" href="classTeuchos_1_1OpaqueWrapper.html" title="Base class for wrapped opaque objects.">OpaqueWrapper</a> to the raw handle that it wraps. For example, if you have an <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a>&lt;OpaqueHandle&lt;T&gt; &gt;</code>, just deferencing the <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> will return the raw handle via this implicit type conversion operator: </p><div class="fragment"><div class="line"><span class="comment">// We omit the right-hand side of this assignment, for simplicity.</span></div>
<div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;OpaqueWrapper&lt;T&gt;</a> &gt; <a class="code hl_class" href="classTeuchos_1_1RCP.html">wrapped</a> = ...;</div>
<div class="line"><span class="comment">// RCP&#39;s operator* returns OpaqueWrapper&lt;T&gt;&amp;.</span></div>
<div class="line"><span class="comment">// In turn, the operator below automatically converts to T.</span></div>
<div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">T</a> <a class="code hl_class" href="classTeuchos_1_1RCP.html">raw</a> = *<a class="code hl_class" href="classTeuchos_1_1RCP.html">wrapped</a>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Teuchos__OpaqueWrapper_8hpp_source.html#l00231">231</a> of file <a class="el" href="Teuchos__OpaqueWrapper_8hpp_source.html">Teuchos_OpaqueWrapper.hpp</a>.</p>

</div>
</div>
<a id="a1bd3435ad90b8fab2dca200cb789ad17" name="a1bd3435ad90b8fab2dca200cb789ad17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd3435ad90b8fab2dca200cb789ad17">&#9670;&#160;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Opaque</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Opaque</a> <a class="el" href="classTeuchos_1_1OpaqueWrapper.html">Teuchos::OpaqueWrapper</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">Opaque</a> &gt;::operator() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicit type conversion from wrapper to raw handle. </p>
<p>Users typically never have to convert directly from an <a class="el" href="classTeuchos_1_1OpaqueWrapper.html" title="Base class for wrapped opaque objects.">OpaqueWrapper</a> to the raw handle that it wraps. However, in case they do, we provide this operator. </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__OpaqueWrapper_8hpp_source.html#l00238">238</a> of file <a class="el" href="Teuchos__OpaqueWrapper_8hpp_source.html">Teuchos_OpaqueWrapper.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a8770e064ea0d612c9cbbe84463186c5c" name="a8770e064ea0d612c9cbbe84463186c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8770e064ea0d612c9cbbe84463186c5c">&#9670;&#160;</a></span>opaqueWrapper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Opaque</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1OpaqueWrapper.html">OpaqueWrapper</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">Opaque</a> &gt; &gt; opaqueWrapper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">Opaque</a>&#160;</td>
          <td class="paramname"><em>opaque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new <code><a class="el" href="classTeuchos_1_1OpaqueWrapper.html" title="Base class for wrapped opaque objects.">OpaqueWrapper</a></code> object without a free function. </p>
<p>See the documentation of <a class="el" href="classTeuchos_1_1OpaqueWrapper.html" title="Base class for wrapped opaque objects.">OpaqueWrapper</a> for a detailed explanation of why and how to use this function. </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__OpaqueWrapper_8hpp_source.html#l00322">322</a> of file <a class="el" href="Teuchos__OpaqueWrapper_8hpp_source.html">Teuchos_OpaqueWrapper.hpp</a>.</p>

</div>
</div>
<a id="ae2f32abac0b3105156d4da619f78d542" name="ae2f32abac0b3105156d4da619f78d542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f32abac0b3105156d4da619f78d542">&#9670;&#160;</a></span>opaqueWrapper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Opaque</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">OpaqueFree</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1OpaqueWrapper.html">OpaqueWrapper</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">Opaque</a> &gt; &gt; opaqueWrapper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">Opaque</a>&#160;</td>
          <td class="paramname"><em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">OpaqueFree</a>&#160;</td>
          <td class="paramname"><em>opaqueFree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new <code><a class="el" href="classTeuchos_1_1OpaqueWrapper.html" title="Base class for wrapped opaque objects.">OpaqueWrapper</a></code> object with a free function. </p>
<p>See the documentation of <a class="el" href="classTeuchos_1_1OpaqueWrapper.html" title="Base class for wrapped opaque objects.">OpaqueWrapper</a> for a detailed explanation of why and how to use this function. </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__OpaqueWrapper_8hpp_source.html#l00338">338</a> of file <a class="el" href="Teuchos__OpaqueWrapper_8hpp_source.html">Teuchos_OpaqueWrapper.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab13132cdb97c3d9ba0f0cde1c225c037" name="ab13132cdb97c3d9ba0f0cde1c225c037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13132cdb97c3d9ba0f0cde1c225c037">&#9670;&#160;</a></span>opaque_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Opaque</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Opaque</a> <a class="el" href="classTeuchos_1_1OpaqueWrapper.html">Teuchos::OpaqueWrapper</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">Opaque</a> &gt;::opaque_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The actual handle. </p>
<p>This is protected and not private so that <a class="el" href="classTeuchos_1_1OpaqueWrapperWithFree.html" title="Subclass for wrapped opaque objects with a free function.">OpaqueWrapperWithFree</a> can access it. In general, one should avoid using protected data, but it would be silly to add member functions just for this simple use case. </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__OpaqueWrapper_8hpp_source.html#l00247">247</a> of file <a class="el" href="Teuchos__OpaqueWrapper_8hpp_source.html">Teuchos_OpaqueWrapper.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Teuchos__OpaqueWrapper_8hpp_source.html">Teuchos_OpaqueWrapper.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 9 2025 20:59:57 for Teuchos - Trilinos Tools Package by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
