<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Teuchos - Trilinos Tools Package: Teuchos::RCP&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Teuchos - Trilinos Tools Package<span id="projectnumber">&#160;Version of the Day</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceTeuchos.html">Teuchos</a></li><li class="navelem"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#related">Related Symbols</a> &#124;
<a href="classTeuchos_1_1RCP-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Teuchos::RCP&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__teuchos__mem__mng__grp.html">Teuchos Memory Management Utilities</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Smart reference counting pointer class for automatic garbage collection.  
 <a href="classTeuchos_1_1RCP.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Teuchos__RCPDecl_8hpp_source.html">Teuchos_RCPDecl.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5718fa8c455b445078632723c8666480" id="r_a5718fa8c455b445078632723c8666480"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">typedef</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a5718fa8c455b445078632723c8666480">element_type</a></td></tr>
<tr class="separator:a5718fa8c455b445078632723c8666480"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors/destructors/initializers.</div></td></tr>
<tr class="memitem:a6df5f0ec485e775f8d35bfdd2dbb0eac" id="r_a6df5f0ec485e775f8d35bfdd2dbb0eac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a6df5f0ec485e775f8d35bfdd2dbb0eac">RCP</a> (<a class="el" href="classTeuchos_1_1RCP.html#ae62facd370a837a6e56086869977621b">ENull</a> <a class="el" href="classTeuchos_1_1RCP.html">null_arg</a>=null)</td></tr>
<tr class="memdesc:a6df5f0ec485e775f8d35bfdd2dbb0eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize <code>RCP&lt;T&gt;</code> to NULL.  <br /></td></tr>
<tr class="separator:a6df5f0ec485e775f8d35bfdd2dbb0eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5aaa0a0ee98f43a178e28ca5ade6b1" id="r_aca5aaa0a0ee98f43a178e28ca5ade6b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#aca5aaa0a0ee98f43a178e28ca5ade6b1">RCP</a> (<a class="el" href="classTeuchos_1_1RCP.html">T</a> *<a class="el" href="classTeuchos_1_1RCP.html">p</a>, <a class="el" href="classTeuchos_1_1RCP.html">bool</a> <a class="el" href="classTeuchos_1_1RCP.html#ac9058e219d0e5dbda24924f62c3cccc2">has_ownership</a>=<a class="el" href="classTeuchos_1_1RCP.html">true</a>)</td></tr>
<tr class="memdesc:aca5aaa0a0ee98f43a178e28ca5ade6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a raw pointer.  <br /></td></tr>
<tr class="separator:aca5aaa0a0ee98f43a178e28ca5ade6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7153f6d53b495afd4c1a4a45d9710d4" id="r_ab7153f6d53b495afd4c1a4a45d9710d4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> &gt; </td></tr>
<tr class="memitem:ab7153f6d53b495afd4c1a4a45d9710d4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ab7153f6d53b495afd4c1a4a45d9710d4">RCP</a> (<a class="el" href="classTeuchos_1_1RCP.html">T</a> *<a class="el" href="classTeuchos_1_1RCP.html">p</a>, <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> <a class="el" href="classTeuchos_1_1RCP.html">dealloc</a>, <a class="el" href="classTeuchos_1_1RCP.html">bool</a> <a class="el" href="classTeuchos_1_1RCP.html#ac9058e219d0e5dbda24924f62c3cccc2">has_ownership</a>)</td></tr>
<tr class="memdesc:ab7153f6d53b495afd4c1a4a45d9710d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a raw pointer and a custom deallocator.  <br /></td></tr>
<tr class="separator:ab7153f6d53b495afd4c1a4a45d9710d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8711f68aa09dcaf4756aa19949d2d44a" id="r_a8711f68aa09dcaf4756aa19949d2d44a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a8711f68aa09dcaf4756aa19949d2d44a">RCP</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">r_ptr</a>)</td></tr>
<tr class="memdesc:a8711f68aa09dcaf4756aa19949d2d44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize from another <code>RCP&lt;T&gt;</code> object.  <br /></td></tr>
<tr class="separator:a8711f68aa09dcaf4756aa19949d2d44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89325891e0fa583a128c578f8955d279" id="r_a89325891e0fa583a128c578f8955d279"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a89325891e0fa583a128c578f8955d279">RCP</a> (<a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&amp;<a class="el" href="classTeuchos_1_1RCP.html">r_ptr</a>)</td></tr>
<tr class="memdesc:a89325891e0fa583a128c578f8955d279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:a89325891e0fa583a128c578f8955d279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c3e448a0ec56fe6176508c43e51c66" id="r_ab1c3e448a0ec56fe6176508c43e51c66"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; </td></tr>
<tr class="memitem:ab1c3e448a0ec56fe6176508c43e51c66"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ab1c3e448a0ec56fe6176508c43e51c66">RCP</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">r_ptr</a>)</td></tr>
<tr class="memdesc:ab1c3e448a0ec56fe6176508c43e51c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize from another <code>RCP&lt;T2&gt;</code> object (implicit conversion only).  <br /></td></tr>
<tr class="separator:ab1c3e448a0ec56fe6176508c43e51c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a159e4ea1dc469b000652089b2b0f27" id="r_a5a159e4ea1dc469b000652089b2b0f27"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; </td></tr>
<tr class="memitem:a5a159e4ea1dc469b000652089b2b0f27"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a5a159e4ea1dc469b000652089b2b0f27">RCP</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">r_ptr</a>, <a class="el" href="classTeuchos_1_1RCP.html">T</a> *<a class="el" href="classTeuchos_1_1RCP.html#a84fb567279e17b54997201f24191c583">ptr</a>)</td></tr>
<tr class="memdesc:a5a159e4ea1dc469b000652089b2b0f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aliasing constructor: Construct using the ownership of a <code>RCP&lt;T2&gt;</code> and from a raw pointer.  <br /></td></tr>
<tr class="separator:a5a159e4ea1dc469b000652089b2b0f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c1a9a58e67a6d0a3fbdbb86bf8701b" id="r_a32c1a9a58e67a6d0a3fbdbb86bf8701b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a32c1a9a58e67a6d0a3fbdbb86bf8701b">~RCP</a> ()</td></tr>
<tr class="memdesc:a32c1a9a58e67a6d0a3fbdbb86bf8701b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a reference to a dynamically allocated object and possibly deletes the object if owned.  <br /></td></tr>
<tr class="separator:a32c1a9a58e67a6d0a3fbdbb86bf8701b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3bf10956b92aeebe3bf42a37d7d05f" id="r_aed3bf10956b92aeebe3bf42a37d7d05f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#aed3bf10956b92aeebe3bf42a37d7d05f">operator=</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">r_ptr</a>)</td></tr>
<tr class="memdesc:aed3bf10956b92aeebe3bf42a37d7d05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the pointer to the referenced object and increment the reference count.  <br /></td></tr>
<tr class="separator:aed3bf10956b92aeebe3bf42a37d7d05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0a16203a2ec8933311964767f852bd" id="r_a6a0a16203a2ec8933311964767f852bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a6a0a16203a2ec8933311964767f852bd">operator=</a> (<a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&amp;<a class="el" href="classTeuchos_1_1RCP.html">r_ptr</a>)</td></tr>
<tr class="memdesc:a6a0a16203a2ec8933311964767f852bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assign.  <br /></td></tr>
<tr class="separator:a6a0a16203a2ec8933311964767f852bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6fd39aa3520c4b4c7a1ca733ff07f9" id="r_a9f6fd39aa3520c4b4c7a1ca733ff07f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a9f6fd39aa3520c4b4c7a1ca733ff07f9">operator=</a> (<a class="el" href="classTeuchos_1_1RCP.html#ae62facd370a837a6e56086869977621b">ENull</a>)</td></tr>
<tr class="memdesc:a9f6fd39aa3520c4b4c7a1ca733ff07f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign to null.  <br /></td></tr>
<tr class="separator:a9f6fd39aa3520c4b4c7a1ca733ff07f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680e6550b670c49798365a8db5f9b468" id="r_a680e6550b670c49798365a8db5f9b468"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a680e6550b670c49798365a8db5f9b468">swap</a> (<a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">r_ptr</a>)</td></tr>
<tr class="memdesc:a680e6550b670c49798365a8db5f9b468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents with some other <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> object.  <br /></td></tr>
<tr class="separator:a680e6550b670c49798365a8db5f9b468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Object/Pointer Access Functions</div></td></tr>
<tr class="memitem:a8033d79aee37a9378d73f70eb025b05d" id="r_a8033d79aee37a9378d73f70eb025b05d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a8033d79aee37a9378d73f70eb025b05d">is_null</a> () <a class="el" href="classTeuchos_1_1RCP.html">const</a></td></tr>
<tr class="memdesc:a8033d79aee37a9378d73f70eb025b05d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the underlying pointer is null.  <br /></td></tr>
<tr class="separator:a8033d79aee37a9378d73f70eb025b05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad40c7bb5f3d9b81a479559569e58152" id="r_aad40c7bb5f3d9b81a479559569e58152"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#aad40c7bb5f3d9b81a479559569e58152">operator-&gt;</a> () <a class="el" href="classTeuchos_1_1RCP.html">const</a></td></tr>
<tr class="memdesc:aad40c7bb5f3d9b81a479559569e58152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer (<code>-&gt;</code>) access to members of underlying object.  <br /></td></tr>
<tr class="separator:aad40c7bb5f3d9b81a479559569e58152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa5e904799194e9365f78ba8c365551" id="r_affa5e904799194e9365f78ba8c365551"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">T</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#affa5e904799194e9365f78ba8c365551">operator*</a> () <a class="el" href="classTeuchos_1_1RCP.html">const</a></td></tr>
<tr class="memdesc:affa5e904799194e9365f78ba8c365551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference the underlying object.  <br /></td></tr>
<tr class="separator:affa5e904799194e9365f78ba8c365551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc36a705efd91e655fef2521641c26b4" id="r_adc36a705efd91e655fef2521641c26b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4">get</a> () <a class="el" href="classTeuchos_1_1RCP.html">const</a></td></tr>
<tr class="memdesc:adc36a705efd91e655fef2521641c26b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw C++ pointer to the underlying object.  <br /></td></tr>
<tr class="separator:adc36a705efd91e655fef2521641c26b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847d59cfc4f76d8f9428ceafb8e71f45" id="r_a847d59cfc4f76d8f9428ceafb8e71f45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a847d59cfc4f76d8f9428ceafb8e71f45">getRawPtr</a> () <a class="el" href="classTeuchos_1_1RCP.html">const</a></td></tr>
<tr class="memdesc:a847d59cfc4f76d8f9428ceafb8e71f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw C++ pointer to the underlying object.  <br /></td></tr>
<tr class="separator:a847d59cfc4f76d8f9428ceafb8e71f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fb567279e17b54997201f24191c583" id="r_a84fb567279e17b54997201f24191c583"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a84fb567279e17b54997201f24191c583">ptr</a> () <a class="el" href="classTeuchos_1_1RCP.html">const</a></td></tr>
<tr class="memdesc:a84fb567279e17b54997201f24191c583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a safer wrapper raw C++ pointer to the underlying object.  <br /></td></tr>
<tr class="separator:a84fb567279e17b54997201f24191c583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe791e2c2a4d2ab610ed77f7804e1bb8" id="r_afe791e2c2a4d2ab610ed77f7804e1bb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#afe791e2c2a4d2ab610ed77f7804e1bb8">operator()</a> () <a class="el" href="classTeuchos_1_1RCP.html">const</a></td></tr>
<tr class="memdesc:afe791e2c2a4d2ab610ed77f7804e1bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for <a class="el" href="classTeuchos_1_1RCP.html#a84fb567279e17b54997201f24191c583" title="Get a safer wrapper raw C++ pointer to the underlying object.">ptr()</a>.  <br /></td></tr>
<tr class="separator:afe791e2c2a4d2ab610ed77f7804e1bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964f14cf8c5542f5511862de1fd01213" id="r_a964f14cf8c5542f5511862de1fd01213"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a964f14cf8c5542f5511862de1fd01213">operator bool</a> () <a class="el" href="classTeuchos_1_1RCP.html">const</a></td></tr>
<tr class="memdesc:a964f14cf8c5542f5511862de1fd01213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> stores a non-null pointer.  <br /></td></tr>
<tr class="separator:a964f14cf8c5542f5511862de1fd01213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a2165565e37dc1d2c602ad2a4f49ef" id="r_a00a2165565e37dc1d2c602ad2a4f49ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a00a2165565e37dc1d2c602ad2a4f49ef">getConst</a> () <a class="el" href="classTeuchos_1_1RCP.html">const</a></td></tr>
<tr class="memdesc:a00a2165565e37dc1d2c602ad2a4f49ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an RCP&lt;const T&gt; version of *this.  <br /></td></tr>
<tr class="separator:a00a2165565e37dc1d2c602ad2a4f49ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reference counting</div></td></tr>
<tr class="memitem:add364fcaa0bf4e35168eabb9d29acf28" id="r_add364fcaa0bf4e35168eabb9d29acf28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__teuchos__mem__mng__grp.html#ga24eff8f12d227acf5e40935b75541c49">ERCPStrength</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#add364fcaa0bf4e35168eabb9d29acf28">strength</a> () <a class="el" href="classTeuchos_1_1RCP.html">const</a></td></tr>
<tr class="memdesc:add364fcaa0bf4e35168eabb9d29acf28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strength of the pointer.  <br /></td></tr>
<tr class="separator:add364fcaa0bf4e35168eabb9d29acf28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab586661a3c2f17a3feea0403d118bb85" id="r_ab586661a3c2f17a3feea0403d118bb85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ab586661a3c2f17a3feea0403d118bb85">is_valid_ptr</a> () <a class="el" href="classTeuchos_1_1RCP.html">const</a></td></tr>
<tr class="memdesc:ab586661a3c2f17a3feea0403d118bb85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if the underlying object pointer is still valid or not.  <br /></td></tr>
<tr class="separator:ab586661a3c2f17a3feea0403d118bb85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc10ad498cf3fa84050e7488dc0e9db5" id="r_afc10ad498cf3fa84050e7488dc0e9db5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#afc10ad498cf3fa84050e7488dc0e9db5">strong_count</a> () <a class="el" href="classTeuchos_1_1RCP.html">const</a></td></tr>
<tr class="memdesc:afc10ad498cf3fa84050e7488dc0e9db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of active <code>RCP&lt;&gt;</code> objects that have a "strong" reference to the underlying reference-counted object.  <br /></td></tr>
<tr class="separator:afc10ad498cf3fa84050e7488dc0e9db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae499752fc726cd6fc49ca9e8b11e2702" id="r_ae499752fc726cd6fc49ca9e8b11e2702"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ae499752fc726cd6fc49ca9e8b11e2702">weak_count</a> () <a class="el" href="classTeuchos_1_1RCP.html">const</a></td></tr>
<tr class="memdesc:ae499752fc726cd6fc49ca9e8b11e2702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of active <code>RCP&lt;&gt;</code> objects that have a "weak" reference to the underlying reference-counted object.  <br /></td></tr>
<tr class="separator:ae499752fc726cd6fc49ca9e8b11e2702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c1af341245dcc7822ff7e3d34b732e" id="r_af3c1af341245dcc7822ff7e3d34b732e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#af3c1af341245dcc7822ff7e3d34b732e">total_count</a> () <a class="el" href="classTeuchos_1_1RCP.html">const</a></td></tr>
<tr class="memdesc:af3c1af341245dcc7822ff7e3d34b732e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total count (<a class="el" href="classTeuchos_1_1RCP.html#afc10ad498cf3fa84050e7488dc0e9db5" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> + <a class="el" href="classTeuchos_1_1RCP.html#ae499752fc726cd6fc49ca9e8b11e2702" title="Return the number of active RCP&lt;&gt; objects that have a &quot;weak&quot; reference to the underlying reference-co...">weak_count()</a>).  <br /></td></tr>
<tr class="separator:af3c1af341245dcc7822ff7e3d34b732e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8c9e61ac5f074a375478598f08ba05" id="r_a2d8c9e61ac5f074a375478598f08ba05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a2d8c9e61ac5f074a375478598f08ba05">set_has_ownership</a> ()</td></tr>
<tr class="memdesc:a2d8c9e61ac5f074a375478598f08ba05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give <code>this</code> and other <code>RCP&lt;&gt;</code> objects ownership of the referenced object <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a></code>.  <br /></td></tr>
<tr class="separator:a2d8c9e61ac5f074a375478598f08ba05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9058e219d0e5dbda24924f62c3cccc2" id="r_ac9058e219d0e5dbda24924f62c3cccc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ac9058e219d0e5dbda24924f62c3cccc2">has_ownership</a> () <a class="el" href="classTeuchos_1_1RCP.html">const</a></td></tr>
<tr class="memdesc:ac9058e219d0e5dbda24924f62c3cccc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>this</code> has ownership of object pointed to by <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a></code> in order to delete it.  <br /></td></tr>
<tr class="separator:ac9058e219d0e5dbda24924f62c3cccc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281058a75338ef844e6db99353bd6bfd" id="r_a281058a75338ef844e6db99353bd6bfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a281058a75338ef844e6db99353bd6bfd">release</a> ()</td></tr>
<tr class="memdesc:a281058a75338ef844e6db99353bd6bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the ownership of the underlying dynamically allocated object.  <br /></td></tr>
<tr class="separator:a281058a75338ef844e6db99353bd6bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0683495e10ff684c34ee09d89448ab24" id="r_a0683495e10ff684c34ee09d89448ab24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a0683495e10ff684c34ee09d89448ab24">create_weak</a> () <a class="el" href="classTeuchos_1_1RCP.html">const</a></td></tr>
<tr class="memdesc:a0683495e10ff684c34ee09d89448ab24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new weak <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> object from another (strong) <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> object.  <br /></td></tr>
<tr class="separator:a0683495e10ff684c34ee09d89448ab24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f68b7bcf51d6deb859b84cb1dde9c2" id="r_ab9f68b7bcf51d6deb859b84cb1dde9c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ab9f68b7bcf51d6deb859b84cb1dde9c2">create_strong</a> () <a class="el" href="classTeuchos_1_1RCP.html">const</a></td></tr>
<tr class="memdesc:ab9f68b7bcf51d6deb859b84cb1dde9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new strong <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> object from another (weak) <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> object.  <br /></td></tr>
<tr class="separator:ab9f68b7bcf51d6deb859b84cb1dde9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4862af20278d5c411275847df72a3e5c" id="r_a4862af20278d5c411275847df72a3e5c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; </td></tr>
<tr class="memitem:a4862af20278d5c411275847df72a3e5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a4862af20278d5c411275847df72a3e5c">shares_resource</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">r_ptr</a>) <a class="el" href="classTeuchos_1_1RCP.html">const</a></td></tr>
<tr class="memdesc:a4862af20278d5c411275847df72a3e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the smart pointers share the same underlying reference-counted object.  <br /></td></tr>
<tr class="separator:a4862af20278d5c411275847df72a3e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assertions</div></td></tr>
<tr class="memitem:a97ef3d773570ad6b55c35d92ad77b8a1" id="r_a97ef3d773570ad6b55c35d92ad77b8a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a97ef3d773570ad6b55c35d92ad77b8a1">assert_not_null</a> () <a class="el" href="classTeuchos_1_1RCP.html">const</a></td></tr>
<tr class="memdesc:a97ef3d773570ad6b55c35d92ad77b8a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class.">NullReferenceError</a></code> if <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a>==NULL</code>, otherwise returns reference to <code>*this</code>.  <br /></td></tr>
<tr class="separator:a97ef3d773570ad6b55c35d92ad77b8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db391ed541eeedfa657724aa3e06d6c" id="r_a3db391ed541eeedfa657724aa3e06d6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a3db391ed541eeedfa657724aa3e06d6c">assert_valid_ptr</a> () <a class="el" href="classTeuchos_1_1RCP.html">const</a></td></tr>
<tr class="memdesc:a3db391ed541eeedfa657724aa3e06d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the object pointer is non-null, assert that it is still valid.  <br /></td></tr>
<tr class="separator:a3db391ed541eeedfa657724aa3e06d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6708feb234d34aacc5b0626827058b" id="r_aec6708feb234d34aacc5b0626827058b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#aec6708feb234d34aacc5b0626827058b">debug_assert_not_null</a> () <a class="el" href="classTeuchos_1_1RCP.html">const</a></td></tr>
<tr class="memdesc:aec6708feb234d34aacc5b0626827058b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code><a class="el" href="classTeuchos_1_1RCP.html#a97ef3d773570ad6b55c35d92ad77b8a1" title="Throws NullReferenceError if this-&gt;get()==NULL, otherwise returns reference to *this.">assert_not_null()</a></code> in a debug build.  <br /></td></tr>
<tr class="separator:aec6708feb234d34aacc5b0626827058b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fde36a6ca00b06c269827a104891caa" id="r_a9fde36a6ca00b06c269827a104891caa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a9fde36a6ca00b06c269827a104891caa">debug_assert_valid_ptr</a> () <a class="el" href="classTeuchos_1_1RCP.html">const</a></td></tr>
<tr class="memdesc:a9fde36a6ca00b06c269827a104891caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code><a class="el" href="classTeuchos_1_1RCP.html#a3db391ed541eeedfa657724aa3e06d6c" title="If the object pointer is non-null, assert that it is still valid.">assert_valid_ptr()</a></code> in a debug build.  <br /></td></tr>
<tr class="separator:a9fde36a6ca00b06c269827a104891caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:ae62facd370a837a6e56086869977621b" id="r_ae62facd370a837a6e56086869977621b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ae62facd370a837a6e56086869977621b">ENull</a> </td></tr>
<tr class="memdesc:ae62facd370a837a6e56086869977621b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to initialize a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> object to NULL using an implicit conversion!  <a href="classTeuchos_1_1RCP.html#ae62facd370a837a6e56086869977621b">More...</a><br /></td></tr>
<tr class="separator:ae62facd370a837a6e56086869977621b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b52dbfe95890c138f922a4d4e475efd" id="r_a6b52dbfe95890c138f922a4d4e475efd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">typename</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </td></tr>
<tr class="memitem:a6b52dbfe95890c138f922a4d4e475efd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a6b52dbfe95890c138f922a4d4e475efd">rcpFromPtr</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html#a84fb567279e17b54997201f24191c583">ptr</a>)</td></tr>
<tr class="memdesc:a6b52dbfe95890c138f922a4d4e475efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an RCP&lt;T&gt; from a Ptr&lt;T&gt; object.  <br /></td></tr>
<tr class="separator:a6b52dbfe95890c138f922a4d4e475efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd9e80180eec6cf6e3038505d3dc7a4" id="r_a7fd9e80180eec6cf6e3038505d3dc7a4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </td></tr>
<tr class="memitem:a7fd9e80180eec6cf6e3038505d3dc7a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> boost::shared_ptr&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">sptr</a>)</td></tr>
<tr class="memdesc:a7fd9e80180eec6cf6e3038505d3dc7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion function that takes in a <code>boost::shared_ptr</code> object and spits out a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">Teuchos::RCP</a></code> object.  <br /></td></tr>
<tr class="separator:a7fd9e80180eec6cf6e3038505d3dc7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e779bd6873303e722f91b21ec558b93" id="r_a6e779bd6873303e722f91b21ec558b93"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </td></tr>
<tr class="memitem:a6e779bd6873303e722f91b21ec558b93"><td class="memTemplItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a6e779bd6873303e722f91b21ec558b93">shared_pointer</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>)</td></tr>
<tr class="memdesc:a6e779bd6873303e722f91b21ec558b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion function that takes in a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">Teuchos::RCP</a></code> object and spits out a <code>boost::shared_ptr</code> object.  <br /></td></tr>
<tr class="separator:a6e779bd6873303e722f91b21ec558b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c212dad5228ed3adb1b7b376b37edc" id="r_a18c212dad5228ed3adb1b7b376b37edc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </td></tr>
<tr class="memitem:a18c212dad5228ed3adb1b7b376b37edc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a18c212dad5228ed3adb1b7b376b37edc">rcp</a> (<a class="el" href="classTeuchos_1_1RCP.html">T</a> *<a class="el" href="classTeuchos_1_1RCP.html">p</a>, <a class="el" href="classTeuchos_1_1RCP.html">bool</a> <a class="el" href="classTeuchos_1_1RCP.html">owns_mem</a>=<a class="el" href="classTeuchos_1_1RCP.html">true</a>)</td></tr>
<tr class="memdesc:a18c212dad5228ed3adb1b7b376b37edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> object properly typed.  <br /></td></tr>
<tr class="separator:a18c212dad5228ed3adb1b7b376b37edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6441ac96ec5797f7b487e4c851aebe" id="r_a0c6441ac96ec5797f7b487e4c851aebe"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> &gt; </td></tr>
<tr class="memitem:a0c6441ac96ec5797f7b487e4c851aebe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a0c6441ac96ec5797f7b487e4c851aebe">rcpWithDealloc</a> (<a class="el" href="classTeuchos_1_1RCP.html">T</a> *<a class="el" href="classTeuchos_1_1RCP.html">p</a>, <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> <a class="el" href="classTeuchos_1_1RCP.html">dealloc</a>, <a class="el" href="classTeuchos_1_1RCP.html">bool</a> <a class="el" href="classTeuchos_1_1RCP.html">owns_mem</a>=<a class="el" href="classTeuchos_1_1RCP.html">true</a>)</td></tr>
<tr class="memdesc:a0c6441ac96ec5797f7b487e4c851aebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize from a raw pointer with a deallocation policy.  <br /></td></tr>
<tr class="separator:a0c6441ac96ec5797f7b487e4c851aebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ff146d10e16f667ef0ce4523a5eef7" id="r_a69ff146d10e16f667ef0ce4523a5eef7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> &gt; </td></tr>
<tr class="memitem:a69ff146d10e16f667ef0ce4523a5eef7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a69ff146d10e16f667ef0ce4523a5eef7">rcpWithDeallocUndef</a> (<a class="el" href="classTeuchos_1_1RCP.html">T</a> *<a class="el" href="classTeuchos_1_1RCP.html">p</a>, <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> <a class="el" href="classTeuchos_1_1RCP.html">dealloc</a>, <a class="el" href="classTeuchos_1_1RCP.html">bool</a> <a class="el" href="classTeuchos_1_1RCP.html">owns_mem</a>=<a class="el" href="classTeuchos_1_1RCP.html">true</a>)</td></tr>
<tr class="memdesc:a69ff146d10e16f667ef0ce4523a5eef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize from a raw pointer with a deallocation policy for an undefined type.  <br /></td></tr>
<tr class="separator:a69ff146d10e16f667ef0ce4523a5eef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c754d72d6d232c97e38bc359ab6ef82" id="r_a6c754d72d6d232c97e38bc359ab6ef82"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </td></tr>
<tr class="memitem:a6c754d72d6d232c97e38bc359ab6ef82"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a6c754d72d6d232c97e38bc359ab6ef82">rcpFromRef</a> (<a class="el" href="classTeuchos_1_1RCP.html">T</a> &amp;<a class="el" href="classTeuchos_1_1RCP.html">r</a>)</td></tr>
<tr class="memdesc:a6c754d72d6d232c97e38bc359ab6ef82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a non-owning weak <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> object from a raw object reference for a defined type.  <br /></td></tr>
<tr class="separator:a6c754d72d6d232c97e38bc359ab6ef82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823eee3138de3b23dab97b3f37e197f3" id="r_a823eee3138de3b23dab97b3f37e197f3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </td></tr>
<tr class="memitem:a823eee3138de3b23dab97b3f37e197f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a823eee3138de3b23dab97b3f37e197f3">rcpFromUndefRef</a> (<a class="el" href="classTeuchos_1_1RCP.html">T</a> &amp;<a class="el" href="classTeuchos_1_1RCP.html">r</a>)</td></tr>
<tr class="memdesc:a823eee3138de3b23dab97b3f37e197f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a non-owning weak <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> object from a raw object reference for an undefined type.  <br /></td></tr>
<tr class="separator:a823eee3138de3b23dab97b3f37e197f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02148aef172f7b2c0fb2de29cb01b91a" id="r_a02148aef172f7b2c0fb2de29cb01b91a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> &gt; </td></tr>
<tr class="memitem:a02148aef172f7b2c0fb2de29cb01b91a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a02148aef172f7b2c0fb2de29cb01b91a">rcpWithEmbeddedObjPreDestroy</a> (<a class="el" href="classTeuchos_1_1RCP.html">T</a> *<a class="el" href="classTeuchos_1_1RCP.html">p</a>, <a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> &amp;<a class="el" href="classTeuchos_1_1RCP.html">embedded</a>, <a class="el" href="classTeuchos_1_1RCP.html">bool</a> <a class="el" href="classTeuchos_1_1RCP.html">owns_mem</a>=<a class="el" href="classTeuchos_1_1RCP.html">true</a>)</td></tr>
<tr class="memdesc:a02148aef172f7b2c0fb2de29cb01b91a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> with and also put in an embedded object.  <br /></td></tr>
<tr class="separator:a02148aef172f7b2c0fb2de29cb01b91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8272eea6a27f1fce6c30fc5d568f2de7" id="r_a8272eea6a27f1fce6c30fc5d568f2de7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> &gt; </td></tr>
<tr class="memitem:a8272eea6a27f1fce6c30fc5d568f2de7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a8272eea6a27f1fce6c30fc5d568f2de7">rcpWithEmbeddedObjPostDestroy</a> (<a class="el" href="classTeuchos_1_1RCP.html">T</a> *<a class="el" href="classTeuchos_1_1RCP.html">p</a>, <a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> &amp;<a class="el" href="classTeuchos_1_1RCP.html">embedded</a>, <a class="el" href="classTeuchos_1_1RCP.html">bool</a> <a class="el" href="classTeuchos_1_1RCP.html">owns_mem</a>=<a class="el" href="classTeuchos_1_1RCP.html">true</a>)</td></tr>
<tr class="memdesc:a8272eea6a27f1fce6c30fc5d568f2de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> with and also put in an embedded object.  <br /></td></tr>
<tr class="separator:a8272eea6a27f1fce6c30fc5d568f2de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506210a123b6e1747d910f037065bd73" id="r_a506210a123b6e1747d910f037065bd73"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> &gt; </td></tr>
<tr class="memitem:a506210a123b6e1747d910f037065bd73"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a506210a123b6e1747d910f037065bd73">rcpWithEmbeddedObj</a> (<a class="el" href="classTeuchos_1_1RCP.html">T</a> *<a class="el" href="classTeuchos_1_1RCP.html">p</a>, <a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> &amp;<a class="el" href="classTeuchos_1_1RCP.html">embedded</a>, <a class="el" href="classTeuchos_1_1RCP.html">bool</a> <a class="el" href="classTeuchos_1_1RCP.html">owns_mem</a>=<a class="el" href="classTeuchos_1_1RCP.html">true</a>)</td></tr>
<tr class="memdesc:a506210a123b6e1747d910f037065bd73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> with and also put in an embedded object.  <br /></td></tr>
<tr class="separator:a506210a123b6e1747d910f037065bd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa6bdcd39bac7dd5c12c3e0f49eba25" id="r_abaa6bdcd39bac7dd5c12c3e0f49eba25"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">ParentT</a> &gt; </td></tr>
<tr class="memitem:abaa6bdcd39bac7dd5c12c3e0f49eba25"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#abaa6bdcd39bac7dd5c12c3e0f49eba25">rcpWithInvertedObjOwnership</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">child</a>, <a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">ParentT</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">parent</a>)</td></tr>
<tr class="memdesc:abaa6bdcd39bac7dd5c12c3e0f49eba25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> that inverts the ownership of parent and child.  <br /></td></tr>
<tr class="separator:abaa6bdcd39bac7dd5c12c3e0f49eba25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07a807743d25c57754a1988645ba791" id="r_ae07a807743d25c57754a1988645ba791"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </td></tr>
<tr class="memitem:ae07a807743d25c57754a1988645ba791"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ae07a807743d25c57754a1988645ba791">rcpCloneNode</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p</a>)</td></tr>
<tr class="memdesc:ae07a807743d25c57754a1988645ba791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> object with a new <a class="el" href="classTeuchos_1_1RCPNode.html" title="Node class to keep track of address and the reference count for a reference-counted utility class and...">RCPNode</a> with memory pointing to the initial node.  <br /></td></tr>
<tr class="separator:ae07a807743d25c57754a1988645ba791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f5c533ebfe9dcb44310780b97a349f" id="r_a10f5c533ebfe9dcb44310780b97a349f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </td></tr>
<tr class="memitem:a10f5c533ebfe9dcb44310780b97a349f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a10f5c533ebfe9dcb44310780b97a349f">is_null</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p</a>)</td></tr>
<tr class="memdesc:a10f5c533ebfe9dcb44310780b97a349f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>p.get()==NULL</code>.  <br /></td></tr>
<tr class="separator:a10f5c533ebfe9dcb44310780b97a349f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad792756b35ab5a2fa8c1d1d608763aec" id="r_ad792756b35ab5a2fa8c1d1d608763aec"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </td></tr>
<tr class="memitem:ad792756b35ab5a2fa8c1d1d608763aec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ad792756b35ab5a2fa8c1d1d608763aec">nonnull</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p</a>)</td></tr>
<tr class="memdesc:ad792756b35ab5a2fa8c1d1d608763aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>p.get()!=NULL</code>.  <br /></td></tr>
<tr class="separator:ad792756b35ab5a2fa8c1d1d608763aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab9d7e0e5480ec8b455e38de0eee49e" id="r_afab9d7e0e5480ec8b455e38de0eee49e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </td></tr>
<tr class="memitem:afab9d7e0e5480ec8b455e38de0eee49e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#afab9d7e0e5480ec8b455e38de0eee49e">operator==</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p</a>, <a class="el" href="classTeuchos_1_1RCP.html#ae62facd370a837a6e56086869977621b">ENull</a>)</td></tr>
<tr class="memdesc:afab9d7e0e5480ec8b455e38de0eee49e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>p.get()==NULL</code>.  <br /></td></tr>
<tr class="separator:afab9d7e0e5480ec8b455e38de0eee49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4081b5c4ac5b9d630a695755a72771cc" id="r_a4081b5c4ac5b9d630a695755a72771cc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </td></tr>
<tr class="memitem:a4081b5c4ac5b9d630a695755a72771cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a4081b5c4ac5b9d630a695755a72771cc">operator!=</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p</a>, <a class="el" href="classTeuchos_1_1RCP.html#ae62facd370a837a6e56086869977621b">ENull</a>)</td></tr>
<tr class="memdesc:a4081b5c4ac5b9d630a695755a72771cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>p.get()!=NULL</code>.  <br /></td></tr>
<tr class="separator:a4081b5c4ac5b9d630a695755a72771cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bddcdcdc506ddab9d82990bcb48f059" id="r_a0bddcdcdc506ddab9d82990bcb48f059"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; </td></tr>
<tr class="memitem:a0bddcdcdc506ddab9d82990bcb48f059"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a0bddcdcdc506ddab9d82990bcb48f059">operator==</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p1</a>, <a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p2</a>)</td></tr>
<tr class="memdesc:a0bddcdcdc506ddab9d82990bcb48f059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if two <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> objects point to the same referenced-counted object and have the same node.  <br /></td></tr>
<tr class="separator:a0bddcdcdc506ddab9d82990bcb48f059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58080d40b950da5009ceb8e33ce9d1c" id="r_ad58080d40b950da5009ceb8e33ce9d1c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; </td></tr>
<tr class="memitem:ad58080d40b950da5009ceb8e33ce9d1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ad58080d40b950da5009ceb8e33ce9d1c">operator!=</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p1</a>, <a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p2</a>)</td></tr>
<tr class="memdesc:ad58080d40b950da5009ceb8e33ce9d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if two <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> objects do not point to the same referenced-counted object and have the same node.  <br /></td></tr>
<tr class="separator:ad58080d40b950da5009ceb8e33ce9d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fc9f719ee13e5d961dcf47053883b4" id="r_a61fc9f719ee13e5d961dcf47053883b4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &gt; </td></tr>
<tr class="memitem:a61fc9f719ee13e5d961dcf47053883b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a61fc9f719ee13e5d961dcf47053883b4">rcp_implicit_cast</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p1</a>)</td></tr>
<tr class="memdesc:a61fc9f719ee13e5d961dcf47053883b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit cast of underlying <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> type from <code>T1*</code> to <code>T2*</code>.  <br /></td></tr>
<tr class="separator:a61fc9f719ee13e5d961dcf47053883b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c369381869737e67be8cab843b18076" id="r_a1c369381869737e67be8cab843b18076"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &gt; </td></tr>
<tr class="memitem:a1c369381869737e67be8cab843b18076"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a1c369381869737e67be8cab843b18076">rcp_static_cast</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p1</a>)</td></tr>
<tr class="memdesc:a1c369381869737e67be8cab843b18076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static cast of underlying <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> type from <code>T1*</code> to <code>T2*</code>.  <br /></td></tr>
<tr class="separator:a1c369381869737e67be8cab843b18076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6931e6c2f74c9fa9467e5dc91c6cd983" id="r_a6931e6c2f74c9fa9467e5dc91c6cd983"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &gt; </td></tr>
<tr class="memitem:a6931e6c2f74c9fa9467e5dc91c6cd983"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a6931e6c2f74c9fa9467e5dc91c6cd983">rcp_const_cast</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p1</a>)</td></tr>
<tr class="memdesc:a6931e6c2f74c9fa9467e5dc91c6cd983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant cast of underlying <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> type from <code>T1*</code> to <code>T2*</code>.  <br /></td></tr>
<tr class="separator:a6931e6c2f74c9fa9467e5dc91c6cd983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1580c807c6df3fdbcb953687b4ff60c7" id="r_a1580c807c6df3fdbcb953687b4ff60c7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &gt; </td></tr>
<tr class="memitem:a1580c807c6df3fdbcb953687b4ff60c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a1580c807c6df3fdbcb953687b4ff60c7">rcp_dynamic_cast</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p1</a>, <a class="el" href="classTeuchos_1_1RCP.html">bool</a> <a class="el" href="classTeuchos_1_1RCP.html">throw_on_fail</a>=<a class="el" href="classTeuchos_1_1RCP.html">false</a>)</td></tr>
<tr class="memdesc:a1580c807c6df3fdbcb953687b4ff60c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast of underlying <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> type from <code>T1*</code> to <code>T2*</code>.  <br /></td></tr>
<tr class="separator:a1580c807c6df3fdbcb953687b4ff60c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd19618c28d1cbc6959f346cee07a7f" id="r_addd19618c28d1cbc6959f346cee07a7f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; </td></tr>
<tr class="memitem:addd19618c28d1cbc6959f346cee07a7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#addd19618c28d1cbc6959f346cee07a7f">set_extra_data</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &amp;extra_data, <a class="el" href="classTeuchos_1_1RCP.html">const</a> std::string &amp;name, <a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p</a>, <a class="el" href="group__teuchos__mem__mng__grp.html#gacd85ba81c085fde11a3ccc0dfb6f0c5e">EPrePostDestruction</a> destroy_when=POST_DESTROY, <a class="el" href="classTeuchos_1_1RCP.html">bool</a> <a class="el" href="classTeuchos_1_1RCP.html">force_unique</a>=<a class="el" href="classTeuchos_1_1RCP.html">true</a>)</td></tr>
<tr class="memdesc:addd19618c28d1cbc6959f346cee07a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set extra data associated with a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> object.  <br /></td></tr>
<tr class="separator:addd19618c28d1cbc6959f346cee07a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f7cd634c8250ff0515bd55c5f3cde6" id="r_ab7f7cd634c8250ff0515bd55c5f3cde6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; </td></tr>
<tr class="memitem:ab7f7cd634c8250ff0515bd55c5f3cde6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ab7f7cd634c8250ff0515bd55c5f3cde6">get_extra_data</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p</a>, <a class="el" href="classTeuchos_1_1RCP.html">const</a> std::string &amp;name)</td></tr>
<tr class="memdesc:ab7f7cd634c8250ff0515bd55c5f3cde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to extra data associated with a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> object.  <br /></td></tr>
<tr class="separator:ab7f7cd634c8250ff0515bd55c5f3cde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8978c29ca24e96cb61185507a0419dac" id="r_a8978c29ca24e96cb61185507a0419dac"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; </td></tr>
<tr class="memitem:a8978c29ca24e96cb61185507a0419dac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">T1</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a8978c29ca24e96cb61185507a0419dac">get_nonconst_extra_data</a> (<a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p</a>, <a class="el" href="classTeuchos_1_1RCP.html">const</a> std::string &amp;name)</td></tr>
<tr class="memdesc:a8978c29ca24e96cb61185507a0419dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a non-const reference to extra data associated with a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> object.  <br /></td></tr>
<tr class="separator:a8978c29ca24e96cb61185507a0419dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac70269754b423e8e76d2e75b3dfbf96" id="r_aac70269754b423e8e76d2e75b3dfbf96"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; </td></tr>
<tr class="memitem:aac70269754b423e8e76d2e75b3dfbf96"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#aac70269754b423e8e76d2e75b3dfbf96">get_optional_extra_data</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p</a>, <a class="el" href="classTeuchos_1_1RCP.html">const</a> std::string &amp;name)</td></tr>
<tr class="memdesc:aac70269754b423e8e76d2e75b3dfbf96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to const extra data (if it exists) associated with a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> object.  <br /></td></tr>
<tr class="separator:aac70269754b423e8e76d2e75b3dfbf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b838cf99afd0bb5f2ebc94ab8d73b59" id="r_a7b838cf99afd0bb5f2ebc94ab8d73b59"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; </td></tr>
<tr class="memitem:a7b838cf99afd0bb5f2ebc94ab8d73b59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a7b838cf99afd0bb5f2ebc94ab8d73b59">get_optional_nonconst_extra_data</a> (<a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p</a>, <a class="el" href="classTeuchos_1_1RCP.html">const</a> std::string &amp;name)</td></tr>
<tr class="memdesc:a7b838cf99afd0bb5f2ebc94ab8d73b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to non-const extra data (if it exists) associated with a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> object.  <br /></td></tr>
<tr class="separator:a7b838cf99afd0bb5f2ebc94ab8d73b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a1b34d2efe42b0a0fb4e20c1089f89" id="r_a62a1b34d2efe42b0a0fb4e20c1089f89"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </td></tr>
<tr class="memitem:a62a1b34d2efe42b0a0fb4e20c1089f89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a62a1b34d2efe42b0a0fb4e20c1089f89">get_dealloc</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p</a>)</td></tr>
<tr class="memdesc:a62a1b34d2efe42b0a0fb4e20c1089f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <code>const</code> reference to the underlying deallocator object.  <br /></td></tr>
<tr class="separator:a62a1b34d2efe42b0a0fb4e20c1089f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67483a8eaf4d6a5f234e7bd6c971b009" id="r_a67483a8eaf4d6a5f234e7bd6c971b009"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </td></tr>
<tr class="memitem:a67483a8eaf4d6a5f234e7bd6c971b009"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a67483a8eaf4d6a5f234e7bd6c971b009">get_nonconst_dealloc</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p</a>)</td></tr>
<tr class="memdesc:a67483a8eaf4d6a5f234e7bd6c971b009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a non-<code>const</code> reference to the underlying deallocator object.  <br /></td></tr>
<tr class="separator:a67483a8eaf4d6a5f234e7bd6c971b009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7868e0bffe12f3a8c82daa61cd4cefb" id="r_ac7868e0bffe12f3a8c82daa61cd4cefb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </td></tr>
<tr class="memitem:ac7868e0bffe12f3a8c82daa61cd4cefb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ac7868e0bffe12f3a8c82daa61cd4cefb">get_optional_dealloc</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p</a>)</td></tr>
<tr class="memdesc:ac7868e0bffe12f3a8c82daa61cd4cefb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the underlying <code>const</code> deallocator object if it exists.  <br /></td></tr>
<tr class="separator:ac7868e0bffe12f3a8c82daa61cd4cefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a73590cabeeb6ac3556981e068bd5d" id="r_a40a73590cabeeb6ac3556981e068bd5d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </td></tr>
<tr class="memitem:a40a73590cabeeb6ac3556981e068bd5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a40a73590cabeeb6ac3556981e068bd5d">get_optional_nonconst_dealloc</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p</a>)</td></tr>
<tr class="memdesc:a40a73590cabeeb6ac3556981e068bd5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the underlying non-<code>const</code> deallocator object if it exists.  <br /></td></tr>
<tr class="separator:a40a73590cabeeb6ac3556981e068bd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9ce82fd86820b298f9c3847d585708" id="r_afd9ce82fd86820b298f9c3847d585708"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">TOrig</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </td></tr>
<tr class="memitem:afd9ce82fd86820b298f9c3847d585708"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#afd9ce82fd86820b298f9c3847d585708">getEmbeddedObj</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p</a>)</td></tr>
<tr class="memdesc:afd9ce82fd86820b298f9c3847d585708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to an embedded object that was set by calling <code><a class="el" href="classTeuchos_1_1RCP.html#a02148aef172f7b2c0fb2de29cb01b91a" title="Create an RCP with and also put in an embedded object.">rcpWithEmbeddedObjPreDestroy()</a></code>, <code>rcpWithEmbeddedObjPostDestory()</code>, or <code><a class="el" href="classTeuchos_1_1RCP.html#a506210a123b6e1747d910f037065bd73" title="Create an RCP with and also put in an embedded object.">rcpWithEmbeddedObj()</a></code>.  <br /></td></tr>
<tr class="separator:afd9ce82fd86820b298f9c3847d585708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dfd3a9f656d730dea2902f08a765811" id="r_a5dfd3a9f656d730dea2902f08a765811"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">TOrig</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </td></tr>
<tr class="memitem:a5dfd3a9f656d730dea2902f08a765811"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a5dfd3a9f656d730dea2902f08a765811">getNonconstEmbeddedObj</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p</a>)</td></tr>
<tr class="memdesc:a5dfd3a9f656d730dea2902f08a765811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a non-const reference to an embedded object that was set by calling <code><a class="el" href="classTeuchos_1_1RCP.html#a02148aef172f7b2c0fb2de29cb01b91a" title="Create an RCP with and also put in an embedded object.">rcpWithEmbeddedObjPreDestroy()</a></code>, <code>rcpWithEmbeddedObjPostDestory()</code>, or <code><a class="el" href="classTeuchos_1_1RCP.html#a506210a123b6e1747d910f037065bd73" title="Create an RCP with and also put in an embedded object.">rcpWithEmbeddedObj()</a></code>.  <br /></td></tr>
<tr class="separator:a5dfd3a9f656d730dea2902f08a765811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35995646037935daf4f98375cbb7ae3" id="r_ae35995646037935daf4f98375cbb7ae3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">TOrig</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </td></tr>
<tr class="memitem:ae35995646037935daf4f98375cbb7ae3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ae35995646037935daf4f98375cbb7ae3">getOptionalEmbeddedObj</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p</a>)</td></tr>
<tr class="memdesc:ae35995646037935daf4f98375cbb7ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an optional <a class="el" href="classTeuchos_1_1Ptr.html" title="Simple wrapper class for raw pointers to single objects where no persisting relationship exists.">Ptr</a> to a const embedded object if it was set by calling <code><a class="el" href="classTeuchos_1_1RCP.html#a02148aef172f7b2c0fb2de29cb01b91a" title="Create an RCP with and also put in an embedded object.">rcpWithEmbeddedObjPreDestroy()</a></code>, <code>rcpWithEmbeddedObjPostDestory()</code>, or <code><a class="el" href="classTeuchos_1_1RCP.html#a506210a123b6e1747d910f037065bd73" title="Create an RCP with and also put in an embedded object.">rcpWithEmbeddedObj()</a></code>.  <br /></td></tr>
<tr class="separator:ae35995646037935daf4f98375cbb7ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcb0b191b4d3f13cd7e2c139dcc4d8e" id="r_a1fcb0b191b4d3f13cd7e2c139dcc4d8e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">TOrig</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </td></tr>
<tr class="memitem:a1fcb0b191b4d3f13cd7e2c139dcc4d8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a1fcb0b191b4d3f13cd7e2c139dcc4d8e">getOptionalNonconstEmbeddedObj</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p</a>)</td></tr>
<tr class="memdesc:a1fcb0b191b4d3f13cd7e2c139dcc4d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an optional <a class="el" href="classTeuchos_1_1Ptr.html" title="Simple wrapper class for raw pointers to single objects where no persisting relationship exists.">Ptr</a> to a non-const embedded object if it was set by calling <code><a class="el" href="classTeuchos_1_1RCP.html#a02148aef172f7b2c0fb2de29cb01b91a" title="Create an RCP with and also put in an embedded object.">rcpWithEmbeddedObjPreDestroy()</a></code>, <code>rcpWithEmbeddedObjPostDestory()</code>, or <code><a class="el" href="classTeuchos_1_1RCP.html#a506210a123b6e1747d910f037065bd73" title="Create an RCP with and also put in an embedded object.">rcpWithEmbeddedObj()</a></code>.  <br /></td></tr>
<tr class="separator:a1fcb0b191b4d3f13cd7e2c139dcc4d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92c7a8fc60f4741319ee31a12a6d75b" id="r_aa92c7a8fc60f4741319ee31a12a6d75b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </td></tr>
<tr class="memitem:aa92c7a8fc60f4741319ee31a12a6d75b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#aa92c7a8fc60f4741319ee31a12a6d75b">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">p</a>)</td></tr>
<tr class="memdesc:aa92c7a8fc60f4741319ee31a12a6d75b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream inserter.  <br /></td></tr>
<tr class="separator:aa92c7a8fc60f4741319ee31a12a6d75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0275ec050540d0f809454692c62aeb46" id="r_a0275ec050540d0f809454692c62aeb46"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </td></tr>
<tr class="memitem:a0275ec050540d0f809454692c62aeb46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a0275ec050540d0f809454692c62aeb46">rcp</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> std::shared_ptr&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html">sptr</a>)</td></tr>
<tr class="memdesc:a0275ec050540d0f809454692c62aeb46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion function that takes in a <code>std::shared_ptr</code> object and spits out a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">Teuchos::RCP</a></code> object.  <br /></td></tr>
<tr class="separator:a0275ec050540d0f809454692c62aeb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38863b03f6f86e507045452a8186c86a" id="r_a38863b03f6f86e507045452a8186c86a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </td></tr>
<tr class="memitem:a38863b03f6f86e507045452a8186c86a"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a38863b03f6f86e507045452a8186c86a">get_shared_ptr</a> (<a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>)</td></tr>
<tr class="memdesc:a38863b03f6f86e507045452a8186c86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion function that takes in a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">Teuchos::RCP</a></code> object and spits out a <code>std::shared_ptr</code> object.  <br /></td></tr>
<tr class="separator:a38863b03f6f86e507045452a8186c86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">boost::shared_ptr compatiblity funtions.</h2></td></tr>
<tr class="memitem:a2cb055f53bb8d7c624cdaa771e410dc1" id="r_a2cb055f53bb8d7c624cdaa771e410dc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a2cb055f53bb8d7c624cdaa771e410dc1">reset</a> ()</td></tr>
<tr class="memdesc:a2cb055f53bb8d7c624cdaa771e410dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset to null.  <br /></td></tr>
<tr class="separator:a2cb055f53bb8d7c624cdaa771e410dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a4649f01205b3e7c9906ccbb87628b" id="r_a76a4649f01205b3e7c9906ccbb87628b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; </td></tr>
<tr class="memitem:a76a4649f01205b3e7c9906ccbb87628b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a76a4649f01205b3e7c9906ccbb87628b">reset</a> (<a class="el" href="classTeuchos_1_1RCP.html">T2</a> *<a class="el" href="classTeuchos_1_1RCP.html">p</a>, <a class="el" href="classTeuchos_1_1RCP.html">bool</a> <a class="el" href="classTeuchos_1_1RCP.html#ac9058e219d0e5dbda24924f62c3cccc2">has_ownership</a>=<a class="el" href="classTeuchos_1_1RCP.html">true</a>)</td></tr>
<tr class="memdesc:a76a4649f01205b3e7c9906ccbb87628b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the raw pointer with default ownership to delete.  <br /></td></tr>
<tr class="separator:a76a4649f01205b3e7c9906ccbb87628b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e9fabd5a8558882ea4a14dde9f82df" id="r_aa3e9fabd5a8558882ea4a14dde9f82df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#aa3e9fabd5a8558882ea4a14dde9f82df">RCP</a> (<a class="el" href="classTeuchos_1_1RCP.html">T</a> *<a class="el" href="classTeuchos_1_1RCP.html">p</a>, ERCPWeakNoDealloc)</td></tr>
<tr class="memdesc:aa3e9fabd5a8558882ea4a14dde9f82df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a non-owning <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> from a raw pointer to a type that <em>is</em> defined.  <br /></td></tr>
<tr class="separator:aa3e9fabd5a8558882ea4a14dde9f82df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16286f0170a5ae6c7c2327ab12c681cc" id="r_a16286f0170a5ae6c7c2327ab12c681cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a16286f0170a5ae6c7c2327ab12c681cc">RCP</a> (<a class="el" href="classTeuchos_1_1RCP.html">T</a> *<a class="el" href="classTeuchos_1_1RCP.html">p</a>, ERCPUndefinedWeakNoDealloc)</td></tr>
<tr class="memdesc:a16286f0170a5ae6c7c2327ab12c681cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a non-owning <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> from a raw pointer to a type that is <em>not</em> defined.  <br /></td></tr>
<tr class="separator:a16286f0170a5ae6c7c2327ab12c681cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9388b91f32514229024f6a108d64529" id="r_ae9388b91f32514229024f6a108d64529"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> &gt; </td></tr>
<tr class="memitem:ae9388b91f32514229024f6a108d64529"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ae9388b91f32514229024f6a108d64529">RCP</a> (<a class="el" href="classTeuchos_1_1RCP.html">T</a> *<a class="el" href="classTeuchos_1_1RCP.html">p</a>, <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> <a class="el" href="classTeuchos_1_1RCP.html">dealloc</a>, ERCPUndefinedWithDealloc, <a class="el" href="classTeuchos_1_1RCP.html">bool</a> <a class="el" href="classTeuchos_1_1RCP.html#ac9058e219d0e5dbda24924f62c3cccc2">has_ownership</a>=<a class="el" href="classTeuchos_1_1RCP.html">true</a>)</td></tr>
<tr class="memdesc:ae9388b91f32514229024f6a108d64529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a raw pointer and a custom deallocator for an undefined type.  <br /></td></tr>
<tr class="separator:ae9388b91f32514229024f6a108d64529"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="classTeuchos_1_1RCP.html#a6df5f0ec485e775f8d35bfdd2dbb0eac">class</a> <a class="el" href="classTeuchos_1_1RCP.html#a6df5f0ec485e775f8d35bfdd2dbb0eac">T</a>&gt;<br />
class Teuchos::RCP&lt; T &gt;</div><p>Smart reference counting pointer class for automatic garbage collection. </p>
<p>For a carefully written discussion about what this class is and basic details on how to use it see the <a href="../../../teuchos/doc/html/RefCountPtrBeginnersGuideSAND.pdf">beginners guide</a>.</p>
<p><b>Quickstart for <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code></b></p>
<p>Here we present a short, but fairly comprehensive, quick-start for the use of <code>RCP&lt;&gt;</code>. The use cases described here should cover the overwhelming majority of the use instances of <code>RCP&lt;&gt;</code> in a typical program.</p>
<p>The following class hierarchy will be used in the C++ examples given below.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_class" href="classTeuchos_1_1RCP.html">A</a> { <span class="keyword">public</span>: <span class="keyword">virtual</span> <a class="code hl_class" href="classTeuchos_1_1RCP.html">~A</a>(){} <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code hl_class" href="classTeuchos_1_1RCP.html">f</a>(){} };</div>
<div class="line"><span class="keyword">class </span>B1 : <span class="keyword">virtual</span> <span class="keyword">public</span> A {};</div>
<div class="line"><span class="keyword">class </span>B2 : <span class="keyword">virtual</span> <span class="keyword">public</span> A {};</div>
<div class="line"><span class="keyword">class </span>C : <span class="keyword">virtual</span> <span class="keyword">public</span> B1, <span class="keyword">virtual</span> <span class="keyword">public</span> B2 {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>D {};</div>
<div class="line"><span class="keyword">class </span>E : <span class="keyword">public</span> D {};</div>
<div class="ttc" id="aclassTeuchos_1_1RCP_html"><div class="ttname"><a href="classTeuchos_1_1RCP.html">Teuchos::RCP</a></div><div class="ttdoc">Smart reference counting pointer class for automatic garbage collection.</div><div class="ttdef"><b>Definition</b> <a href="Teuchos__RCPDecl_8hpp_source.html#l00397">Teuchos_RCPDecl.hpp:397</a></div></div>
</div><!-- fragment --><p>All of the following code examples used in this quickstart are assumed to be in the namespace <code><a class="el" href="namespaceTeuchos.html" title="The Teuchos namespace contains all of the classes, structs and enums used by Teuchos,...">Teuchos</a></code> or have appropriate <code>using <a class="el" href="namespaceTeuchos.html" title="The Teuchos namespace contains all of the classes, structs and enums used by Teuchos,...">Teuchos</a>::...</code> declarations. This removes the need to explicitly use <code><a class="el" href="namespaceTeuchos.html" title="The Teuchos namespace contains all of the classes, structs and enums used by Teuchos,...">Teuchos</a>::</code> to qualify classes, functions and other declarations from the <code><a class="el" href="namespaceTeuchos.html" title="The Teuchos namespace contains all of the classes, structs and enums used by Teuchos,...">Teuchos</a></code> namespace. Note that some of the runtime checks are denoted as "debug runtime checked" which means that checking will only be performed in a debug build (that is one where the macro <code>TEUCHOS_DEBUG</code> is defined at compile time).</p>
<ol>
<li>
<p class="startli"><b>Creation of <code>RCP&lt;&gt;</code> objects</b></p>
<ol>
<li>
<p class="startli"><b>Creating an <code>RCP&lt;&gt;</code> object using <code>new</code></b></p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;C&gt;</a> <a class="code hl_class" href="classTeuchos_1_1RCP.html">c_ptr</a> = <a class="code hl_function" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> C);</div>
<div class="ttc" id="aclassTeuchos_1_1RCP_html_a7fd9e80180eec6cf6e3038505d3dc7a4"><div class="ttname"><a href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">Teuchos::RCP::rcp</a></div><div class="ttdeci">RCP&lt; T &gt; rcp(const boost::shared_ptr&lt; T &gt; &amp;sptr)</div><div class="ttdoc">Conversion function that takes in a boost::shared_ptr object and spits out a Teuchos::RCP object.</div></div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Creating a <code>RCP&lt;&gt;</code> object equipped with a specialized deallocator function</b> : <code><a class="el" href="classTeuchos_1_1DeallocFunctorDelete.html" title="Deallocator subclass that Allows any functor object (including a function pointer) to be used to free...">Teuchos::DeallocFunctorDelete</a></code></p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="classTeuchos_1_1RCP.html">someDeallocFunction</a>(C* <a class="code hl_class" href="classTeuchos_1_1RCP.html">c_ptr</a>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;C&gt;</a> <a class="code hl_class" href="classTeuchos_1_1RCP.html">c_ptr</a> = <a class="code hl_function" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> <a class="code hl_class" href="classTeuchos_1_1RCP.html">deallocFunctorDelete&lt;C&gt;</a>(<a class="code hl_class" href="classTeuchos_1_1RCP.html">someDeallocFunction</a>),<span class="keyword">true</span>);</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Initializing a <code>RCP&lt;&gt;</code> object to NULL</b></p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;C&gt;</a> <a class="code hl_class" href="classTeuchos_1_1RCP.html">c_ptr</a>;</div>
</div><!-- fragment --><p class="interli">or</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;C&gt;</a> <a class="code hl_class" href="classTeuchos_1_1RCP.html">c_ptr</a> = null;</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Initializing a <code>RCP&lt;&gt;</code> object to an object \underline{not} allocated with <code>new</code></b></p>
<div class="fragment"><div class="line">C <a class="code hl_class" href="classTeuchos_1_1RCP.html">c</a>;</div>
<div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;C&gt;</a> <a class="code hl_class" href="classTeuchos_1_1RCP.html">c_ptr</a> = <a class="code hl_function" href="classTeuchos_1_1RCP.html#a6c754d72d6d232c97e38bc359ab6ef82">rcpFromRef</a>(<a class="code hl_class" href="classTeuchos_1_1RCP.html">c</a>);</div>
<div class="ttc" id="aclassTeuchos_1_1RCP_html_a6c754d72d6d232c97e38bc359ab6ef82"><div class="ttname"><a href="classTeuchos_1_1RCP.html#a6c754d72d6d232c97e38bc359ab6ef82">Teuchos::RCP::rcpFromRef</a></div><div class="ttdeci">RCP&lt; T &gt; rcpFromRef(T &amp;r)</div><div class="ttdoc">Return a non-owning weak RCP object from a raw object reference for a defined type.</div></div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Copy constructor (implicit casting)</b></p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;C&gt;</a>       <a class="code hl_class" href="classTeuchos_1_1RCP.html">c_ptr</a>  = <a class="code hl_function" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> C); <span class="comment">// No cast</span></div>
<div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;A&gt;</a>       <a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr</a>  = <a class="code hl_class" href="classTeuchos_1_1RCP.html">c_ptr</a>;      <span class="comment">// Cast to base class</span></div>
<div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;const A&gt;</a> <a class="code hl_class" href="classTeuchos_1_1RCP.html">ca_ptr</a> = <a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr</a>;      <span class="comment">// Cast from non-const to const</span></div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Representing constantness and non-constantness</b></p>
<ol>
<li>
<p class="startli"><b>Non-constant pointer to non-constant object</b> </p><div class="fragment"><div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;C&gt;</a> <a class="code hl_class" href="classTeuchos_1_1RCP.html">c_ptr</a>;</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Constant pointer to non-constant object</b> </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;C&gt;</a> <a class="code hl_class" href="classTeuchos_1_1RCP.html">c_ptr</a>;</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Non-Constant pointer to constant object</b> </p><div class="fragment"><div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;const C&gt;</a> <a class="code hl_class" href="classTeuchos_1_1RCP.html">c_ptr</a>;</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Constant pointer to constant object</b> </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;const C&gt;</a> <a class="code hl_class" href="classTeuchos_1_1RCP.html">c_ptr</a>;</div>
</div><!-- fragment --><p class="endli"></p>
</li>
</ol>
<p class="endli"></p>
</li>
</ol>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Reinitialization of <code>RCP&lt;&gt;</code> objects (using assignment operator)</b></p>
<ol>
<li>
<p class="startli"><b>Resetting from a raw pointer</b></p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;A&gt;</a> <a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr</a>;</div>
<div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr</a> = <a class="code hl_function" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> C());</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Resetting to null</b></p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;A&gt;</a> <a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr</a> = <a class="code hl_function" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> C());</div>
<div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr</a> = null; <span class="comment">// The C object will be deleted here</span></div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Assigning from a <code>RCP&lt;&gt;</code> object</b></p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;A&gt;</a> <a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr1</a>;</div>
<div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;A&gt;</a> <a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr2</a> = <a class="code hl_function" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> C());</div>
<div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr1</a> = <a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr2</a>; <span class="comment">// Now a_ptr1 and a_ptr2 point to same C object</span></div>
</div><!-- fragment --><p class="endli"></p>
</li>
</ol>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Accessing the reference-counted object</b></p>
<ol>
<li>
<p class="startli"><b>Access to object reference (debug runtime checked)</b> : <code><a class="el" href="classTeuchos_1_1RCP.html#affa5e904799194e9365f78ba8c365551" title="Dereference the underlying object.">Teuchos::RCP::operator*()</a></code></p>
<div class="fragment"><div class="line">C &amp;<a class="code hl_class" href="classTeuchos_1_1RCP.html">c_ref</a> = *<a class="code hl_class" href="classTeuchos_1_1RCP.html">c_ptr</a>;</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Access to object pointer (unchecked, may return <code>NULL</code>)</b> : <code><a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">Teuchos::RCP::get()</a></code></p>
<div class="fragment"><div class="line">C *<a class="code hl_class" href="classTeuchos_1_1RCP.html">c_rptr</a> = <a class="code hl_class" href="classTeuchos_1_1RCP.html">c_ptr</a>.<a class="code hl_function" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4">get</a>();</div>
<div class="ttc" id="aclassTeuchos_1_1RCP_html_adc36a705efd91e655fef2521641c26b4"><div class="ttname"><a href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4">Teuchos::RCP::get</a></div><div class="ttdeci">T * get() const</div><div class="ttdoc">Get the raw C++ pointer to the underlying object.</div><div class="ttdef"><b>Definition</b> <a href="Teuchos__RCP_8hpp_source.html#l00365">Teuchos_RCP.hpp:365</a></div></div>
</div><!-- fragment --><p class="interli">or</p>
<div class="fragment"><div class="line">C *<a class="code hl_class" href="classTeuchos_1_1RCP.html">c_rptr</a> = <a class="code hl_class" href="classTeuchos_1_1RCP.html">c_ptr</a>.<a class="code hl_function" href="classTeuchos_1_1RCP.html#a847d59cfc4f76d8f9428ceafb8e71f45">getRawPtr</a>();</div>
<div class="ttc" id="aclassTeuchos_1_1RCP_html_a847d59cfc4f76d8f9428ceafb8e71f45"><div class="ttname"><a href="classTeuchos_1_1RCP.html#a847d59cfc4f76d8f9428ceafb8e71f45">Teuchos::RCP::getRawPtr</a></div><div class="ttdeci">T * getRawPtr() const</div><div class="ttdoc">Get the raw C++ pointer to the underlying object.</div><div class="ttdef"><b>Definition</b> <a href="Teuchos__RCP_8hpp_source.html#l00374">Teuchos_RCP.hpp:374</a></div></div>
</div><!-- fragment --><p class="interli"><b>WARNING:</b>: Avoid exposing raw C++ pointers!</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Access to object pointer (debug runtime checked, will not return <code>NULL</code>)</b> : <code><a class="el" href="classTeuchos_1_1RCP.html#affa5e904799194e9365f78ba8c365551" title="Dereference the underlying object.">Teuchos::RCP::operator*()</a></code></p>
<div class="fragment"><div class="line">C *<a class="code hl_class" href="classTeuchos_1_1RCP.html">c_rptr</a> = &amp;*<a class="code hl_class" href="classTeuchos_1_1RCP.html">c_ptr</a>;</div>
</div><!-- fragment --><p class="interli"><b>WARNING:</b>: Avoid exposing raw C++ pointers!</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Access of object's member (debug runtime checked)</b> : <code><a class="el" href="classTeuchos_1_1RCP.html#aad40c7bb5f3d9b81a479559569e58152" title="Pointer (-&gt;) access to members of underlying object.">Teuchos::RCP::operator-&gt;()</a></code></p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">c_ptr</a>-&gt;f();</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Testing for non-null</b> : <code><a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">Teuchos::RCP::get()</a></code>, <code>Teuchos::operator==()</code>, <code>Teuchos::operator!=()</code></p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr</a>.<a class="code hl_function" href="classTeuchos_1_1RCP.html#a8033d79aee37a9378d73f70eb025b05d">is_null</a>) std::cout &lt;&lt; <span class="stringliteral">&quot;a_ptr is not null!\n&quot;</span>;</div>
<div class="ttc" id="aclassTeuchos_1_1RCP_html_a8033d79aee37a9378d73f70eb025b05d"><div class="ttname"><a href="classTeuchos_1_1RCP.html#a8033d79aee37a9378d73f70eb025b05d">Teuchos::RCP::is_null</a></div><div class="ttdeci">bool is_null() const</div><div class="ttdoc">Returns true if the underlying pointer is null.</div><div class="ttdef"><b>Definition</b> <a href="Teuchos__RCP_8hpp_source.html#l00338">Teuchos_RCP.hpp:338</a></div></div>
</div><!-- fragment --><p class="interli">or</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr</a> != null) std::cout &lt;&lt; <span class="stringliteral">&quot;a_ptr is not null!\n&quot;</span>;</div>
</div><!-- fragment --><p class="interli">or</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Testing for null</b></p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!<a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr</a>.<a class="code hl_function" href="classTeuchos_1_1RCP.html#a8033d79aee37a9378d73f70eb025b05d">is_null</a>()) std::cout &lt;&lt; <span class="stringliteral">&quot;a_ptr is null!\n&quot;</span>;</div>
</div><!-- fragment --><p class="interli">or</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr</a> == null) std::cout &lt;&lt; <span class="stringliteral">&quot;a_ptr is null!\n&quot;</span>;</div>
</div><!-- fragment --><p class="interli">or</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="classTeuchos_1_1RCP.html#a8033d79aee37a9378d73f70eb025b05d">is_null</a>(<a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr</a>)) std::cout &lt;&lt; <span class="stringliteral">&quot;a_ptr is null!\n&quot;</span>;</div>
</div><!-- fragment --><p class="endli"></p>
</li>
</ol>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Casting</b></p>
<ol>
<li>
<p class="startli"><b>Implicit casting (see copy constructor above)</b></p>
<ol>
<li>
<p class="startli"><b>Using copy constructor (see above)</b></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Using conversion function</b></p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;C&gt;</a>       <a class="code hl_class" href="classTeuchos_1_1RCP.html">c_ptr</a>  = <a class="code hl_function" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> C);                       <span class="comment">// No cast</span></div>
<div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;A&gt;</a>       <a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr</a>  = <a class="code hl_class" href="classTeuchos_1_1RCP.html">rcp_implicit_cast&lt;A&gt;</a>(<a class="code hl_class" href="classTeuchos_1_1RCP.html">c_ptr</a>);      <span class="comment">// To base</span></div>
<div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;const A&gt;</a> <a class="code hl_class" href="classTeuchos_1_1RCP.html">ca_ptr</a> = <a class="code hl_class" href="classTeuchos_1_1RCP.html">rcp_implicit_cast&lt;const A&gt;</a>(<a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr</a>);<span class="comment">// To const</span></div>
</div><!-- fragment --><p class="endli"></p>
</li>
</ol>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Casting away <code>const</code></b> : <code><a class="el" href="classTeuchos_1_1RCP.html#a6931e6c2f74c9fa9467e5dc91c6cd983" title="Constant cast of underlying RCP type from T1* to T2*.">rcp_const_cast()</a></code></p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;const A&gt;</a>  <a class="code hl_class" href="classTeuchos_1_1RCP.html">ca_ptr</a> = <a class="code hl_function" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> C);</div>
<div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;A&gt;</a>        <a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr</a>  = <a class="code hl_class" href="classTeuchos_1_1RCP.html">rcp_const_cast&lt;A&gt;</a>(<a class="code hl_class" href="classTeuchos_1_1RCP.html">ca_ptr</a>); <span class="comment">// cast away const!</span></div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Static cast (no runtime check)</b> : <code><a class="el" href="classTeuchos_1_1RCP.html#a1c369381869737e67be8cab843b18076" title="Static cast of underlying RCP type from T1* to T2*.">rcp_static_cast()</a></code></p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;D&gt;</a>     <a class="code hl_class" href="classTeuchos_1_1RCP.html">d_ptr</a> = <a class="code hl_function" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> <a class="code hl_class" href="classTeuchos_1_1RCP.html">E</a>);</div>
<div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;E&gt;</a>     <a class="code hl_class" href="classTeuchos_1_1RCP.html">e_ptr</a> = <a class="code hl_class" href="classTeuchos_1_1RCP.html">rcp_static_cast&lt;E&gt;</a>(<a class="code hl_class" href="classTeuchos_1_1RCP.html">d_ptr</a>); <span class="comment">// Unchecked, unsafe?</span></div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Dynamic cast (runtime checked, failed cast allowed)</b> : <code><a class="el" href="classTeuchos_1_1RCP.html#a1580c807c6df3fdbcb953687b4ff60c7" title="Dynamic cast of underlying RCP type from T1* to T2*.">rcp_dynamic_cast()</a></code></p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;A&gt;</a>     <a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr</a>  = <a class="code hl_function" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> C);</div>
<div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;B1&gt;</a>    <a class="code hl_class" href="classTeuchos_1_1RCP.html">b1_ptr</a> = <a class="code hl_class" href="classTeuchos_1_1RCP.html">rcp_dynamic_cast&lt;B1&gt;</a>(<a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr</a>);  <span class="comment">// Checked, safe!</span></div>
<div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;B2&gt;</a>    <a class="code hl_class" href="classTeuchos_1_1RCP.html">b2_ptr</a> = <a class="code hl_class" href="classTeuchos_1_1RCP.html">rcp_dynamic_cast&lt;B2&gt;</a>(<a class="code hl_class" href="classTeuchos_1_1RCP.html">b1_ptr</a>); <span class="comment">// Checked, safe!</span></div>
<div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;C&gt;</a>     <a class="code hl_class" href="classTeuchos_1_1RCP.html">c_ptr</a>  = <a class="code hl_class" href="classTeuchos_1_1RCP.html">rcp_dynamic_cast&lt;C&gt;</a>(<a class="code hl_class" href="classTeuchos_1_1RCP.html">b2_ptr</a>);  <span class="comment">// Checked, safe!</span></div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Dynamic cast (runtime checked, failed cast not allowed)</b> : <code><a class="el" href="classTeuchos_1_1RCP.html#a1580c807c6df3fdbcb953687b4ff60c7" title="Dynamic cast of underlying RCP type from T1* to T2*.">rcp_dynamic_cast()</a></code></p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;A&gt;</a>     <a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr1</a>  = <a class="code hl_function" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> C);</div>
<div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;A&gt;</a>     <a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr2</a>  = <a class="code hl_function" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> <a class="code hl_class" href="classTeuchos_1_1RCP.html">A</a>);</div>
<div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;B1&gt;</a>    <a class="code hl_class" href="classTeuchos_1_1RCP.html">b1_ptr1</a> = <a class="code hl_class" href="classTeuchos_1_1RCP.html">rcp_dynamic_cast&lt;B1&gt;</a>(<a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr1</a>, <span class="keyword">true</span>);  <span class="comment">// Success!</span></div>
<div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;B1&gt;</a>    <a class="code hl_class" href="classTeuchos_1_1RCP.html">b1_ptr2</a> = <a class="code hl_class" href="classTeuchos_1_1RCP.html">rcp_dynamic_cast&lt;B1&gt;</a>(<a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr2</a>, <span class="keyword">true</span>);  <span class="comment">// Throw std::bad_cast!</span></div>
</div><!-- fragment --><p class="endli"></p>
</li>
</ol>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Customized deallocators</b></p>
<ol>
<li>
<p class="startli"><b>Creating a <code>RCP&lt;&gt;</code> object with a custom deallocator</b> : <code><a class="el" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4" title="Conversion function that takes in a boost::shared_ptr object and spits out a Teuchos::RCP object.">rcp()</a></code></p>
<p class="interli">TODO: Update this example!</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Access customized deallocator (runtime checked, throws on failure)</b> : <code>Teuchos::get_dealloc()</code></p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classTeuchos_1_1RCP.html">MyCustomDealloc&lt;C&gt;</a></div>
<div class="line">  &amp;<a class="code hl_class" href="classTeuchos_1_1RCP.html">dealloc</a> = <a class="code hl_class" href="classTeuchos_1_1RCP.html">get_dealloc&lt;MyCustomDealloc&lt;C&gt;</a> &gt;(<a class="code hl_class" href="classTeuchos_1_1RCP.html">c_ptr</a>);</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Access optional customized deallocator</b> : <code>Teuchos::get_optional_dealloc()</code></p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classTeuchos_1_1RCP.html">Ptr&lt;const MyCustomDealloc&lt;C&gt;</a> &gt; <a class="code hl_class" href="classTeuchos_1_1RCP.html">dealloc</a> =</div>
<div class="line">  <a class="code hl_class" href="classTeuchos_1_1RCP.html">get_optional_dealloc&lt;MyCustomDealloc&lt;C&gt;</a> &gt;(<a class="code hl_class" href="classTeuchos_1_1RCP.html">c_ptr</a>);</div>
<div class="line"><span class="keywordflow">if</span> (!<a class="code hl_function" href="classTeuchos_1_1RCP.html#a8033d79aee37a9378d73f70eb025b05d">is_null</a>(<a class="code hl_class" href="classTeuchos_1_1RCP.html">dealloc</a>))</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;This deallocator exits!\n&quot;</span>;</div>
</div><!-- fragment --><p class="endli"></p>
</li>
</ol>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Managing extra data</b></p>
<ol>
<li>
<p class="startli"><b>Adding extra data (post destruction of extra data)</b> : <code>Teuchos::set_extra_data()</code></p>
<div class="fragment"><div class="line"><a class="code hl_function" href="classTeuchos_1_1RCP.html#addd19618c28d1cbc6959f346cee07a7f">set_extra_data</a>(<a class="code hl_function" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> <a class="code hl_class" href="classTeuchos_1_1RCP.html">B1</a>), <span class="stringliteral">&quot;A:B1&quot;</span>, inOutArg(<a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr</a>));</div>
<div class="ttc" id="aclassTeuchos_1_1RCP_html_addd19618c28d1cbc6959f346cee07a7f"><div class="ttname"><a href="classTeuchos_1_1RCP.html#addd19618c28d1cbc6959f346cee07a7f">Teuchos::RCP::set_extra_data</a></div><div class="ttdeci">void set_extra_data(const T1 &amp;extra_data, const std::string &amp;name, const Ptr&lt; RCP&lt; T2 &gt; &gt; &amp;p, EPrePostDestruction destroy_when=POST_DESTROY, bool force_unique=true)</div><div class="ttdoc">Set extra data associated with a RCP object.</div></div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Adding extra data (pre destruction of extra data)</b> : <code>Teuchos::get_extra_data()</code></p>
<div class="fragment"><div class="line"><a class="code hl_function" href="classTeuchos_1_1RCP.html#addd19618c28d1cbc6959f346cee07a7f">set_extra_data</a>(<a class="code hl_function" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> <a class="code hl_class" href="classTeuchos_1_1RCP.html">B1</a>),<span class="stringliteral">&quot;A:B1&quot;</span>, inOutArg(<a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr</a>), <a class="code hl_class" href="classTeuchos_1_1RCP.html">PRE_DESTORY</a>);</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Retrieving extra data</b> : <code>Teuchos::get_extra_data()</code></p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">get_extra_data&lt;RCP&lt;B1&gt;</a> &gt;(<a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr</a>, <span class="stringliteral">&quot;A:B1&quot;</span>)-&gt;<a class="code hl_class" href="classTeuchos_1_1RCP.html">f</a>();</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Resetting extra data</b> : <code>Teuchos::get_extra_data()</code></p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">get_extra_data&lt;RCP&lt;B1&gt;</a> &gt;(<a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr</a>, <span class="stringliteral">&quot;A:B1&quot;</span>) = <a class="code hl_function" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> C);</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Retrieving optional extra data</b> : <code>Teuchos::get_optional_extra_data()</code></p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classTeuchos_1_1RCP.html">Ptr&lt;const RCP&lt;B1&gt;</a> &gt; <a class="code hl_class" href="classTeuchos_1_1RCP.html">b1</a> =</div>
<div class="line">  <a class="code hl_class" href="classTeuchos_1_1RCP.html">get_optional_extra_data&lt;RCP&lt;B1&gt;</a> &gt;(<a class="code hl_class" href="classTeuchos_1_1RCP.html">a_ptr</a>, <span class="stringliteral">&quot;A:B1&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (!<a class="code hl_function" href="classTeuchos_1_1RCP.html#a8033d79aee37a9378d73f70eb025b05d">is_null</a>(<a class="code hl_class" href="classTeuchos_1_1RCP.html">b1</a>))</div>
<div class="line">  (*b1)-&gt;f();</div>
</div><!-- fragment --><p class="endli"></p>
</li>
</ol>
<p class="endli"></p>
</li>
</ol>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ArrayRCP_test_8cpp-example.html#_a0">ArrayRCP_test.cpp</a>, <a class="el" href="BLAS_2cxx_main_8cpp-example.html#_a0">BLAS/cxx_main.cpp</a>, <a class="el" href="CommandLineProcessor_2cxx_main_8cpp-example.html#_a2">CommandLineProcessor/cxx_main.cpp</a>, <a class="el" href="DenseMatrix_2cxx_main_8cpp-example.html#_a0">DenseMatrix/cxx_main.cpp</a>, <a class="el" href="DenseMatrix_2cxx_main_sym_8cpp-example.html#_a0">DenseMatrix/cxx_main_sym.cpp</a>, <a class="el" href="FancyOutputting_test_8cpp-example.html#_a7">FancyOutputting_test.cpp</a>, <a class="el" href="LAPACK_2cxx_main_8cpp-example.html#_a0">LAPACK/cxx_main.cpp</a>, <a class="el" href="ParameterList_2cxx_main_8cpp-example.html#_a1">ParameterList/cxx_main.cpp</a>, <a class="el" href="TimeMonitor_2cxx_main_8cpp-example.html#_a0">TimeMonitor/cxx_main.cpp</a>, <a class="el" href="example_2RefCountPtr_2cxx_main_8cpp-example.html#_a0">example/RefCountPtr/cxx_main.cpp</a>, and <a class="el" href="test_2MemoryManagement_2RCP_test_8cpp-example.html#_a0">test/MemoryManagement/RCP_test.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCPDecl_8hpp_source.html#l00397">397</a> of file <a class="el" href="Teuchos__RCPDecl_8hpp_source.html">Teuchos_RCPDecl.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5718fa8c455b445078632723c8666480" name="a5718fa8c455b445078632723c8666480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5718fa8c455b445078632723c8666480">&#9670;&#160;</a></span>element_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">typedef</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::element_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCPDecl_8hpp_source.html#l00401">401</a> of file <a class="el" href="Teuchos__RCPDecl_8hpp_source.html">Teuchos_RCPDecl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6df5f0ec485e775f8d35bfdd2dbb0eac" name="a6df5f0ec485e775f8d35bfdd2dbb0eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df5f0ec485e775f8d35bfdd2dbb0eac">&#9670;&#160;</a></span>RCP() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::RCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html#ae62facd370a837a6e56086869977621b">ENull</a>&#160;</td>
          <td class="paramname"><em>null_arg</em> = <code>null</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize <code>RCP&lt;T&gt;</code> to NULL. </p>
<p><b>Postconditons:</b> </p><ul>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a> == 0</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#add364fcaa0bf4e35168eabb9d29acf28" title="Strength of the pointer.">strength()</a> == RCP_STRONG</code> </li>
<li>
<code>this-&gt;is_vali_ptr() == true</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#afc10ad498cf3fa84050e7488dc0e9db5" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> == 0</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#ae499752fc726cd6fc49ca9e8b11e2702" title="Return the number of active RCP&lt;&gt; objects that have a &quot;weak&quot; reference to the underlying reference-co...">weak_count()</a> == 0</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#ac9058e219d0e5dbda24924f62c3cccc2" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it.">has_ownership()</a> == false</code> </li>
</ul>
<p>This allows clients to write code like: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;int&gt;</a> <a class="code hl_class" href="classTeuchos_1_1RCP.html">p</a> = null;</div>
</div><!-- fragment --><p> or </p><div class="fragment"><div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">RCP&lt;int&gt;</a> <a class="code hl_class" href="classTeuchos_1_1RCP.html">p</a>;</div>
</div><!-- fragment --><p> and construct to <code>NULL</code> </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00117">117</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="aca5aaa0a0ee98f43a178e28ca5ade6b1" name="aca5aaa0a0ee98f43a178e28ca5ade6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5aaa0a0ee98f43a178e28ca5ade6b1">&#9670;&#160;</a></span>RCP() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::RCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">T</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">bool</a>&#160;</td>
          <td class="paramname"><em>has_ownership</em> = <code><a class="el" href="classTeuchos_1_1RCP.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a raw pointer. </p>
<p>Note that this constructor is declared explicit so there is no implicit conversion from a raw pointer to an <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> allowed. If <code>has_ownership==false</code>, then no attempt to delete the object will occur.</p>
<p><b>Postconditons:</b></p><ul>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a> == p</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#add364fcaa0bf4e35168eabb9d29acf28" title="Strength of the pointer.">strength()</a> == RCP_STRONG</code> </li>
<li>
<code>this-&gt;is_vali_ptr() == true</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#afc10ad498cf3fa84050e7488dc0e9db5" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> == 1</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#ae499752fc726cd6fc49ca9e8b11e2702" title="Return the number of active RCP&lt;&gt; objects that have a &quot;weak&quot; reference to the underlying reference-co...">weak_count()</a> == 0</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#ac9058e219d0e5dbda24924f62c3cccc2" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it.">has_ownership()</a> == has_ownership</code> </li>
</ul>
<p>NOTE: It is recommended that this constructor never be called directly but only through a type-specific non-member constructor function or at least through the general non-member <code><a class="el" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4" title="Conversion function that takes in a boost::shared_ptr object and spits out a Teuchos::RCP object.">rcp()</a></code> function. </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00160">160</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="ab7153f6d53b495afd4c1a4a45d9710d4" name="ab7153f6d53b495afd4c1a4a45d9710d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7153f6d53b495afd4c1a4a45d9710d4">&#9670;&#160;</a></span>RCP() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::RCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">T</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a>&#160;</td>
          <td class="paramname"><em>dealloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">bool</a>&#160;</td>
          <td class="paramname"><em>has_ownership</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a raw pointer and a custom deallocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>[in] Pointer to the reference-counted object to be wrapped</td></tr>
    <tr><td class="paramname">dealloc</td><td>[in] Deallocator policy object that will be copied by value and will perform the custom deallocation of the object pointed to by <code>p</code> when the last <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> object goes away. See the class <code><a class="el" href="classTeuchos_1_1DeallocDelete.html" title="Policy class for deallocator that uses delete to delete a pointer which is used by RCP.">DeallocDelete</a></code> for the specfication and behavior of this policy interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a> == p</code> </dd>
<dd>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#add364fcaa0bf4e35168eabb9d29acf28" title="Strength of the pointer.">strength()</a> == RCP_STRONG</code> </dd>
<dd>
<code>this-&gt;is_vali_ptr() == true</code> </dd>
<dd>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#afc10ad498cf3fa84050e7488dc0e9db5" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> == 1</code> </dd>
<dd>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#ae499752fc726cd6fc49ca9e8b11e2702" title="Return the number of active RCP&lt;&gt; objects that have a &quot;weak&quot; reference to the underlying reference-co...">weak_count()</a> == 0</code> </dd>
<dd>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#ac9058e219d0e5dbda24924f62c3cccc2" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it.">has_ownership()</a> == has_ownership</code> </dd>
<dd>
<code> get_dealloc&lt;Delalloc_T&gt;(*this) </code> returns a copy of the custom deallocator object <code>dealloc&gt;/tt&gt;. </code></dd></dl>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00194">194</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="a8711f68aa09dcaf4756aa19949d2d44a" name="a8711f68aa09dcaf4756aa19949d2d44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8711f68aa09dcaf4756aa19949d2d44a">&#9670;&#160;</a></span>RCP() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::RCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>r_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize from another <code>RCP&lt;T&gt;</code> object. </p>
<p>After construction, <code>this</code> and <code>r_ptr</code> will reference the same object.</p>
<p>This form of the copy constructor is required even though the below more general templated version is sufficient since some compilers will generate this function automatically which will give an incorrect implementation.</p>
<p><b>Postconditons:</b></p><ul>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a> == r_ptr.get()</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#afc10ad498cf3fa84050e7488dc0e9db5" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> == r_ptr.strong_count()</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#ac9058e219d0e5dbda24924f62c3cccc2" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it.">has_ownership()</a> == r_ptr.has_ownership()</code> </li>
<li>
If <code>r_ptr.get() != NULL</code> then <code>r_ptr.strong_count()</code> is incremented by 1 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00247">247</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="a89325891e0fa583a128c578f8955d279" name="a89325891e0fa583a128c578f8955d279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89325891e0fa583a128c578f8955d279">&#9670;&#160;</a></span>RCP() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::RCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>r_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p><b>Postconditons:</b></p><ul>
<li>
<code>*this</code> is an exact copy of <code>r_ptr</code> before the call. </li>
<li>
<code>r_ptr</code> is uninitialized </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00254">254</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="ab1c3e448a0ec56fe6176508c43e51c66" name="ab1c3e448a0ec56fe6176508c43e51c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c3e448a0ec56fe6176508c43e51c66">&#9670;&#160;</a></span>RCP() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::RCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>r_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize from another <code>RCP&lt;T2&gt;</code> object (implicit conversion only). </p>
<p>This function allows the implicit conversion of smart pointer objects just like with raw C++ pointers. Note that this function will only compile if the statement <code>T1 *ptr = r_ptr.get()</code> will compile.</p>
<p><b>Postconditons:</b> </p><ul>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a> == r_ptr.get()</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#afc10ad498cf3fa84050e7488dc0e9db5" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> == r_ptr.strong_count()</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#ac9058e219d0e5dbda24924f62c3cccc2" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it.">has_ownership()</a> == r_ptr.has_ownership()</code> </li>
<li>
If <code>r_ptr.get() != NULL</code> then <code>r_ptr.strong_count()</code> is incremented by 1 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00264">264</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="a5a159e4ea1dc469b000652089b2b0f27" name="a5a159e4ea1dc469b000652089b2b0f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a159e4ea1dc469b000652089b2b0f27">&#9670;&#160;</a></span>RCP() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::RCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>r_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">T</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aliasing constructor: Construct using the ownership of a <code>RCP&lt;T2&gt;</code> and from a raw pointer. </p>
<p>Constructs a <code>RCP&lt;T&gt;</code> which shares ownership information with the initial value of r_ptr, but holds an unrelated and unmanaged pointer ptr.</p>
<p>This constructor corresponds to the constructor template&lt; class Y &gt; shared_ptr( const shared_ptr&lt;Y&gt;&amp; r, element_type* ptr ) noexcept; of the std::shared_ptr. </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00273">273</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="a32c1a9a58e67a6d0a3fbdbb86bf8701b" name="a32c1a9a58e67a6d0a3fbdbb86bf8701b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c1a9a58e67a6d0a3fbdbb86bf8701b">&#9670;&#160;</a></span>~RCP()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::~<a class="el" href="classTeuchos_1_1RCP.html">RCP</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a reference to a dynamically allocated object and possibly deletes the object if owned. </p>
<p>Deletes the object if <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#ac9058e219d0e5dbda24924f62c3cccc2" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it.">has_ownership()</a> == true</code> and <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#afc10ad498cf3fa84050e7488dc0e9db5" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> == 1</code>. If <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#afc10ad498cf3fa84050e7488dc0e9db5" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> == 1</code> but <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#ac9058e219d0e5dbda24924f62c3cccc2" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it.">has_ownership()</a> == false</code> then the object is not deleted. If <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#afc10ad498cf3fa84050e7488dc0e9db5" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> &gt; 1</code> then the internal reference count shared by all the other related <code>RCP&lt;...&gt;</code> objects for this shared object is deincremented by one. If <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a> == NULL</code> then nothing happens. </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00281">281</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="aa3e9fabd5a8558882ea4a14dde9f82df" name="aa3e9fabd5a8558882ea4a14dde9f82df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e9fabd5a8558882ea4a14dde9f82df">&#9670;&#160;</a></span>RCP() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::RCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">T</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ERCPWeakNoDealloc&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a non-owning <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> from a raw pointer to a type that <em>is</em> defined. </p>
<p>This version avoids adding a deallocator but still requires the type to be defined since it looks up the base object's address when doing <a class="el" href="classTeuchos_1_1RCPNode.html" title="Node class to keep track of address and the reference count for a reference-counted utility class and...">RCPNode</a> tracing.</p>
<p>NOTE: It is recommended that this constructor never be called directly but only through a type-specific non-member constructor function or at least through the general non-member <code><a class="el" href="classTeuchos_1_1RCP.html#a6c754d72d6d232c97e38bc359ab6ef82" title="Return a non-owning weak RCP object from a raw object reference for a defined type.">rcpFromRef()</a></code> function. </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00124">124</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="a16286f0170a5ae6c7c2327ab12c681cc" name="a16286f0170a5ae6c7c2327ab12c681cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16286f0170a5ae6c7c2327ab12c681cc">&#9670;&#160;</a></span>RCP() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::RCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">T</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ERCPUndefinedWeakNoDealloc&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a non-owning <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> from a raw pointer to a type that is <em>not</em> defined. </p>
<p>This version avoids any type of compile-time queries of the type that would fail due to the type being undefined.</p>
<p>NOTE: It is recommended that this constructor never be called directly but only through a type-specific non-member constructor function or at least through the general non-member <code><a class="el" href="classTeuchos_1_1RCP.html#a823eee3138de3b23dab97b3f37e197f3" title="Return a non-owning weak RCP object from a raw object reference for an undefined type.">rcpFromUndefRef()</a></code> function. </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00152">152</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="ae9388b91f32514229024f6a108d64529" name="ae9388b91f32514229024f6a108d64529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9388b91f32514229024f6a108d64529">&#9670;&#160;</a></span>RCP() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::RCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">T</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a>&#160;</td>
          <td class="paramname"><em>dealloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ERCPUndefinedWithDealloc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">bool</a>&#160;</td>
          <td class="paramname"><em>has_ownership</em> = <code><a class="el" href="classTeuchos_1_1RCP.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a raw pointer and a custom deallocator for an undefined type. </p>
<p>This version avoids any type of compile-time queries of the type that would fail due to the type being undefined. </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00220">220</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aed3bf10956b92aeebe3bf42a37d7d05f" name="aed3bf10956b92aeebe3bf42a37d7d05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3bf10956b92aeebe3bf42a37d7d05f">&#9670;&#160;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;<a class="el" href="classTeuchos_1_1RCP.html#a6df5f0ec485e775f8d35bfdd2dbb0eac">::operator</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>r_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the pointer to the referenced object and increment the reference count. </p>
<p>If <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#ac9058e219d0e5dbda24924f62c3cccc2" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it.">has_ownership()</a> == true</code> and <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#afc10ad498cf3fa84050e7488dc0e9db5" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> == 1</code> before this operation is called, then the object pointed to by <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a></code> will be deleted (usually using <code>delete</code>) prior to binding to the pointer (possibly <code>NULL</code>) pointed to in <code>r_ptr</code>. Assignment to self (i.e. <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a> == r_ptr.get()</code>) is harmless and this function does nothing.</p>
<p><b>Postconditons:</b></p><ul>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a> == r_ptr.get()</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#afc10ad498cf3fa84050e7488dc0e9db5" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> == r_ptr.strong_count()</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#ac9058e219d0e5dbda24924f62c3cccc2" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it.">has_ownership()</a> == r_ptr.has_ownership()</code> </li>
<li>
If <code>r_ptr.get() != NULL</code> then <code>r_ptr.strong_count()</code> is incremented by 1 </li>
</ul>
<p>Provides the "strong guarantee" in a debug build! </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00287">287</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="a6a0a16203a2ec8933311964767f852bd" name="a6a0a16203a2ec8933311964767f852bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0a16203a2ec8933311964767f852bd">&#9670;&#160;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;<a class="el" href="classTeuchos_1_1RCP.html#a6df5f0ec485e775f8d35bfdd2dbb0eac">::operator</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>r_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assign. </p>
<p><b>Postconditons:</b></p><ul>
<li>
<code>*this</code> is an exact copy of <code>r_ptr</code> before the call. </li>
<li>
<code>r_ptr</code> is uninitialized </li>
</ul>
<p>Provides the "strong guarantee" in a debug build! </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00301">301</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="a9f6fd39aa3520c4b4c7a1ca733ff07f9" name="a9f6fd39aa3520c4b4c7a1ca733ff07f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6fd39aa3520c4b4c7a1ca733ff07f9">&#9670;&#160;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;<a class="el" href="classTeuchos_1_1RCP.html#a6df5f0ec485e775f8d35bfdd2dbb0eac">::operator</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html#ae62facd370a837a6e56086869977621b">ENull</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign to null. </p>
<p>If <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#ac9058e219d0e5dbda24924f62c3cccc2" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it.">has_ownership()</a> == true</code> and <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#afc10ad498cf3fa84050e7488dc0e9db5" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> == 1</code> before this operation is called, then the object pointed to by <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a></code> will be deleted (usually using <code>delete</code>) prior to binding to the pointer (possibly <code>NULL</code>) pointed to in <code>r_ptr</code>.</p>
<p><b>Postconditons:</b></p><ul>
<li>
See <code><a class="el" href="classTeuchos_1_1RCP.html#a6df5f0ec485e775f8d35bfdd2dbb0eac" title="Initialize RCP&lt;T&gt; to NULL.">RCP(ENull)</a></code> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00317">317</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="a680e6550b670c49798365a8db5f9b468" name="a680e6550b670c49798365a8db5f9b468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680e6550b670c49798365a8db5f9b468">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">void</a> <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>r_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the contents with some other <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> object. </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00326">326</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="a8033d79aee37a9378d73f70eb025b05d" name="a8033d79aee37a9378d73f70eb025b05d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8033d79aee37a9378d73f70eb025b05d">&#9670;&#160;</a></span>is_null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">bool</a> <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::is_null </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the underlying pointer is null. </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00338">338</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="aad40c7bb5f3d9b81a479559569e58152" name="aad40c7bb5f3d9b81a479559569e58152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad40c7bb5f3d9b81a479559569e58152">&#9670;&#160;</a></span>operator-&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">T</a> * <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;<a class="el" href="classTeuchos_1_1RCP.html#a6df5f0ec485e775f8d35bfdd2dbb0eac">::operator</a>-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer (<code>-&gt;</code>) access to members of underlying object. </p>
<p><b>Preconditions:</b></p><ul>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a> != NULL</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class.">NullReferenceError</a></code>) </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00346">346</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="affa5e904799194e9365f78ba8c365551" name="affa5e904799194e9365f78ba8c365551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa5e904799194e9365f78ba8c365551">&#9670;&#160;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">T</a> &amp; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;<a class="el" href="classTeuchos_1_1RCP.html#a6df5f0ec485e775f8d35bfdd2dbb0eac">::operator</a>* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereference the underlying object. </p>
<p><b>Preconditions:</b></p><ul>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a> != NULL</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class.">NullReferenceError</a></code>) </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00356">356</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="adc36a705efd91e655fef2521641c26b4" name="adc36a705efd91e655fef2521641c26b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc36a705efd91e655fef2521641c26b4">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">T</a> * <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the raw C++ pointer to the underlying object. </p>
<p>NOTE: Prefer to get the safer Ptr&lt;T&gt; object from <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a84fb567279e17b54997201f24191c583" title="Get a safer wrapper raw C++ pointer to the underlying object.">ptr()</a></code>! </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ArrayRCP_test_8cpp-example.html#a8">ArrayRCP_test.cpp</a>, and <a class="el" href="example_2RefCountPtr_2cxx_main_8cpp-example.html#a1">example/RefCountPtr/cxx_main.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00365">365</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="a847d59cfc4f76d8f9428ceafb8e71f45" name="a847d59cfc4f76d8f9428ceafb8e71f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a847d59cfc4f76d8f9428ceafb8e71f45">&#9670;&#160;</a></span>getRawPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">T</a> * <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::getRawPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the raw C++ pointer to the underlying object. </p>
<p>NOTE: Prefer to get the safer Ptr&lt;T&gt; object from <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a84fb567279e17b54997201f24191c583" title="Get a safer wrapper raw C++ pointer to the underlying object.">ptr()</a></code>! </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ArrayRCP_test_8cpp-example.html#a9">ArrayRCP_test.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00374">374</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="a84fb567279e17b54997201f24191c583" name="a84fb567279e17b54997201f24191c583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84fb567279e17b54997201f24191c583">&#9670;&#160;</a></span>ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a safer wrapper raw C++ pointer to the underlying object. </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00382">382</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="afe791e2c2a4d2ab610ed77f7804e1bb8" name="afe791e2c2a4d2ab610ed77f7804e1bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe791e2c2a4d2ab610ed77f7804e1bb8">&#9670;&#160;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;<a class="el" href="classTeuchos_1_1RCP.html#a6df5f0ec485e775f8d35bfdd2dbb0eac">::operator</a>() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shorthand for <a class="el" href="classTeuchos_1_1RCP.html#a84fb567279e17b54997201f24191c583" title="Get a safer wrapper raw C++ pointer to the underlying object.">ptr()</a>. </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00394">394</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="a964f14cf8c5542f5511862de1fd01213" name="a964f14cf8c5542f5511862de1fd01213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964f14cf8c5542f5511862de1fd01213">&#9670;&#160;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;<a class="el" href="classTeuchos_1_1RCP.html#a6df5f0ec485e775f8d35bfdd2dbb0eac">::operator</a> <a class="el" href="classTeuchos_1_1RCP.html">bool</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> stores a non-null pointer. </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00410">410</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="a00a2165565e37dc1d2c602ad2a4f49ef" name="a00a2165565e37dc1d2c602ad2a4f49ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a2165565e37dc1d2c602ad2a4f49ef">&#9670;&#160;</a></span>getConst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::getConst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an RCP&lt;const T&gt; version of *this. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ArrayRCP_test_8cpp-example.html#a11">ArrayRCP_test.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00402">402</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="add364fcaa0bf4e35168eabb9d29acf28" name="add364fcaa0bf4e35168eabb9d29acf28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add364fcaa0bf4e35168eabb9d29acf28">&#9670;&#160;</a></span>strength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__teuchos__mem__mng__grp.html#ga24eff8f12d227acf5e40935b75541c49">ERCPStrength</a> <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::strength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Strength of the pointer. </p>
<p>Return values:</p><ul>
<li>
<code>RCP_STRONG</code>: Underlying reference-counted object will be deleted when <code>*this</code> is destroyed if <code><a class="el" href="classTeuchos_1_1RCP.html#afc10ad498cf3fa84050e7488dc0e9db5" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a>==1</code>. </li>
<li>
<code>RCP_WEAK</code>: Underlying reference-counted object will not be deleted when <code>*this</code> is destroyed if <code><a class="el" href="classTeuchos_1_1RCP.html#afc10ad498cf3fa84050e7488dc0e9db5" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> &gt; 0</code>. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00421">421</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="ab586661a3c2f17a3feea0403d118bb85" name="ab586661a3c2f17a3feea0403d118bb85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab586661a3c2f17a3feea0403d118bb85">&#9670;&#160;</a></span>is_valid_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">bool</a> <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::is_valid_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return if the underlying object pointer is still valid or not. </p>
<p>The underlying object will not be valid if the strong count has gone to zero but the weak count thas not.</p>
<p>NOTE: Null is a valid object pointer. If you want to know if there is a non-null object and it is valid then <code>!is_null() &amp;&amp; <a class="el" href="classTeuchos_1_1RCP.html#ab586661a3c2f17a3feea0403d118bb85" title="Return if the underlying object pointer is still valid or not.">is_valid_ptr()</a></code> will be <code>true</code>. </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00429">429</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="afc10ad498cf3fa84050e7488dc0e9db5" name="afc10ad498cf3fa84050e7488dc0e9db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc10ad498cf3fa84050e7488dc0e9db5">&#9670;&#160;</a></span>strong_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">int</a> <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::strong_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of active <code>RCP&lt;&gt;</code> objects that have a "strong" reference to the underlying reference-counted object. </p>
<dl class="section return"><dt>Returns</dt><dd>If <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a> == NULL</code> then this function returns 0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00439">439</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="ae499752fc726cd6fc49ca9e8b11e2702" name="ae499752fc726cd6fc49ca9e8b11e2702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae499752fc726cd6fc49ca9e8b11e2702">&#9670;&#160;</a></span>weak_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">int</a> <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::weak_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of active <code>RCP&lt;&gt;</code> objects that have a "weak" reference to the underlying reference-counted object. </p>
<dl class="section return"><dt>Returns</dt><dd>If <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a> == NULL</code> then this function returns 0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00447">447</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="af3c1af341245dcc7822ff7e3d34b732e" name="af3c1af341245dcc7822ff7e3d34b732e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c1af341245dcc7822ff7e3d34b732e">&#9670;&#160;</a></span>total_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">int</a> <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::total_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total count (<a class="el" href="classTeuchos_1_1RCP.html#afc10ad498cf3fa84050e7488dc0e9db5" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> + <a class="el" href="classTeuchos_1_1RCP.html#ae499752fc726cd6fc49ca9e8b11e2702" title="Return the number of active RCP&lt;&gt; objects that have a &quot;weak&quot; reference to the underlying reference-co...">weak_count()</a>). </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00455">455</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="a2d8c9e61ac5f074a375478598f08ba05" name="a2d8c9e61ac5f074a375478598f08ba05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8c9e61ac5f074a375478598f08ba05">&#9670;&#160;</a></span>set_has_ownership()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">void</a> <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::set_has_ownership </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Give <code>this</code> and other <code>RCP&lt;&gt;</code> objects ownership of the referenced object <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a></code>. </p>
<p>See <a class="el" href="classTeuchos_1_1RCP.html#a32c1a9a58e67a6d0a3fbdbb86bf8701b" title="Removes a reference to a dynamically allocated object and possibly deletes the object if owned.">~RCP()</a> above. This function does nothing if <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a> == NULL</code>.</p>
<p><b>Postconditions:</b> </p><ul>
<li>
If <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a> == NULL</code> then <ul>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#ac9058e219d0e5dbda24924f62c3cccc2" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it.">has_ownership()</a> == false</code> (always!). </li>
</ul>
</li>
<li>
else <ul>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#ac9058e219d0e5dbda24924f62c3cccc2" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it.">has_ownership()</a> == true</code> </li>
</ul>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00463">463</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="ac9058e219d0e5dbda24924f62c3cccc2" name="ac9058e219d0e5dbda24924f62c3cccc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9058e219d0e5dbda24924f62c3cccc2">&#9670;&#160;</a></span>has_ownership()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">bool</a> <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::has_ownership </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>this</code> has ownership of object pointed to by <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a></code> in order to delete it. </p>
<p>See <a class="el" href="classTeuchos_1_1RCP.html#a32c1a9a58e67a6d0a3fbdbb86bf8701b" title="Removes a reference to a dynamically allocated object and possibly deletes the object if owned.">~RCP()</a> above.</p>
<dl class="section return"><dt>Returns</dt><dd>If this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a> <code>== NULL</code> then this function always returns <code>false</code>. Otherwise the value returned from this function depends on which function was called most recently, if any; <a class="el" href="classTeuchos_1_1RCP.html#a2d8c9e61ac5f074a375478598f08ba05" title="Give this and other RCP&lt;&gt; objects ownership of the referenced object this-&gt;get().">set_has_ownership()</a> (<code>true</code>) or <a class="el" href="classTeuchos_1_1RCP.html#a281058a75338ef844e6db99353bd6bfd" title="Release the ownership of the underlying dynamically allocated object.">release()</a> (<code>false</code>). </dd></dl>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00471">471</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="a281058a75338ef844e6db99353bd6bfd" name="a281058a75338ef844e6db99353bd6bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281058a75338ef844e6db99353bd6bfd">&#9670;&#160;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the ownership of the underlying dynamically allocated object. </p>
<p><b>WARNING!</b> Never call <code>delete rcp.release().<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a></code> as this can cause all kinds of segfaults. Instead, release your use of the shared object by simply assigning the <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> object to <code>Teuchos::null</code>.</p>
<p>This function should only be used as last result when all hell has broken loose and memory management control has broken down. This function is not to be used lightly!</p>
<p>After this function is called then the client is responsible for deallocating the shared object no matter how many <code>ref_count_prt&lt;T&gt;</code> objects have a reference to it. If <code>this-&gt;</code><a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a><code>== NULL</code>, then this call is meaningless.</p>
<p>Note that this function does not have the exact same semantics as does <code>auto_ptr&lt;T&gt;::release()</code>. In <code>auto_ptr&lt;T&gt;::release()</code>, <code>this</code> is set to <code>NULL</code> while here in RCP&lt;T&gt;:: <a class="el" href="classTeuchos_1_1RCP.html#a281058a75338ef844e6db99353bd6bfd" title="Release the ownership of the underlying dynamically allocated object.">release()</a> only an ownership flag is set and <code>*this</code> still points to the same object. It would be difficult to duplicate the behavior of <code>auto_ptr&lt;T&gt;::release()</code> for this class.</p>
<p><b>Postconditions:</b> </p><ul>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#ac9058e219d0e5dbda24924f62c3cccc2" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it.">has_ownership()</a> == false</code> </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a></code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00479">479</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="a0683495e10ff684c34ee09d89448ab24" name="a0683495e10ff684c34ee09d89448ab24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0683495e10ff684c34ee09d89448ab24">&#9670;&#160;</a></span>create_weak()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::create_weak </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new weak <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> object from another (strong) <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> object. </p>
<p>ToDo: Explain this!</p>
<p><b>Preconditons:</b> </p><ul>
<li>
<code>returnVal.is_valid_ptr()==true</code> </li>
</ul>
<p><b>Postconditons:</b> </p><ul>
<li>
<code>returnVal.get() == this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a></code> </li>
<li>
<code>returnVal.strong_count() == this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#afc10ad498cf3fa84050e7488dc0e9db5" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a></code> </li>
<li>
<code>returnVal.weak_count() == this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#ae499752fc726cd6fc49ca9e8b11e2702" title="Return the number of active RCP&lt;&gt; objects that have a &quot;weak&quot; reference to the underlying reference-co...">weak_count()</a>+1</code> </li>
<li>
<code>returnVal.strength() == RCP_WEAK</code> </li>
<li>
<code>returnVal.has_ownership() == this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#ac9058e219d0e5dbda24924f62c3cccc2" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it.">has_ownership()</a></code> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00489">489</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="ab9f68b7bcf51d6deb859b84cb1dde9c2" name="ab9f68b7bcf51d6deb859b84cb1dde9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f68b7bcf51d6deb859b84cb1dde9c2">&#9670;&#160;</a></span>create_strong()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::create_strong </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new strong <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> object from another (weak) <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> object. </p>
<p>ToDo: Explain this!</p>
<p><b>Preconditons:</b> </p><ul>
<li>
<code>returnVal.is_valid_ptr()==true</code> </li>
</ul>
<p><b>Postconditons:</b> </p><ul>
<li>
<code>returnVal.get() == this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a></code> </li>
<li>
<code>returnVal.strong_count() == this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#afc10ad498cf3fa84050e7488dc0e9db5" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> + 1</code> </li>
<li>
<code>returnVal.weak_count() == this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#ae499752fc726cd6fc49ca9e8b11e2702" title="Return the number of active RCP&lt;&gt; objects that have a &quot;weak&quot; reference to the underlying reference-co...">weak_count()</a></code> </li>
<li>
<code>returnVal.strength() == RCP_STRONG</code> </li>
<li>
<code>returnVal.has_ownership() == this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#ac9058e219d0e5dbda24924f62c3cccc2" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it.">has_ownership()</a></code> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00498">498</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="a4862af20278d5c411275847df72a3e5c" name="a4862af20278d5c411275847df72a3e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4862af20278d5c411275847df72a3e5c">&#9670;&#160;</a></span>shares_resource()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">bool</a> <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::shares_resource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>r_ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the smart pointers share the same underlying reference-counted object. </p>
<p>This method does more than just check if <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a> == r_ptr.get()</code>. It also checks to see if the underlying reference counting machinary is the same. </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00524">524</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="a97ef3d773570ad6b55c35d92ad77b8a1" name="a97ef3d773570ad6b55c35d92ad77b8a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ef3d773570ad6b55c35d92ad77b8a1">&#9670;&#160;</a></span>assert_not_null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::assert_not_null </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class.">NullReferenceError</a></code> if <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a>==NULL</code>, otherwise returns reference to <code>*this</code>. </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00538">538</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="a3db391ed541eeedfa657724aa3e06d6c" name="a3db391ed541eeedfa657724aa3e06d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db391ed541eeedfa657724aa3e06d6c">&#9670;&#160;</a></span>assert_valid_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::assert_valid_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the object pointer is non-null, assert that it is still valid. </p>
<p>If <code><a class="el" href="classTeuchos_1_1RCP.html#a8033d79aee37a9378d73f70eb025b05d" title="Returns true if the underlying pointer is null.">is_null()</a>==false &amp;&amp; <a class="el" href="classTeuchos_1_1RCP.html#afc10ad498cf3fa84050e7488dc0e9db5" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a>==0</code>, this will throw <code>DanglingReferenceErorr</code> with a great error message.</p>
<p>If <code><a class="el" href="classTeuchos_1_1RCP.html#a8033d79aee37a9378d73f70eb025b05d" title="Returns true if the underlying pointer is null.">is_null()</a>==true</code>, then this will not throw any exception.</p>
<p>In this context, null is a valid object. </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00548">548</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="aec6708feb234d34aacc5b0626827058b" name="aec6708feb234d34aacc5b0626827058b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6708feb234d34aacc5b0626827058b">&#9670;&#160;</a></span>debug_assert_not_null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::debug_assert_not_null </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls <code><a class="el" href="classTeuchos_1_1RCP.html#a97ef3d773570ad6b55c35d92ad77b8a1" title="Throws NullReferenceError if this-&gt;get()==NULL, otherwise returns reference to *this.">assert_not_null()</a></code> in a debug build. </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCPDecl_8hpp_source.html#l00821">821</a> of file <a class="el" href="Teuchos__RCPDecl_8hpp_source.html">Teuchos_RCPDecl.hpp</a>.</p>

</div>
</div>
<a id="a9fde36a6ca00b06c269827a104891caa" name="a9fde36a6ca00b06c269827a104891caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fde36a6ca00b06c269827a104891caa">&#9670;&#160;</a></span>debug_assert_valid_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::debug_assert_valid_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls <code><a class="el" href="classTeuchos_1_1RCP.html#a3db391ed541eeedfa657724aa3e06d6c" title="If the object pointer is non-null, assert that it is still valid.">assert_valid_ptr()</a></code> in a debug build. </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCPDecl_8hpp_source.html#l00830">830</a> of file <a class="el" href="Teuchos__RCPDecl_8hpp_source.html">Teuchos_RCPDecl.hpp</a>.</p>

</div>
</div>
<a id="a2cb055f53bb8d7c624cdaa771e410dc1" name="a2cb055f53bb8d7c624cdaa771e410dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb055f53bb8d7c624cdaa771e410dc1">&#9670;&#160;</a></span>reset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">void</a> <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset to null. </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00561">561</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a id="a76a4649f01205b3e7c9906ccbb87628b" name="a76a4649f01205b3e7c9906ccbb87628b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a4649f01205b3e7c9906ccbb87628b">&#9670;&#160;</a></span>reset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">void</a> <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt;::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">T2</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">bool</a>&#160;</td>
          <td class="paramname"><em>has_ownership</em> = <code><a class="el" href="classTeuchos_1_1RCP.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the raw pointer with default ownership to delete. </p>
<p>Equivalent to calling:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classTeuchos_1_1RCP.html">r_rcp</a> = <a class="code hl_function" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<a class="code hl_class" href="classTeuchos_1_1RCP.html">p</a>)</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00575">575</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="ae62facd370a837a6e56086869977621b" name="ae62facd370a837a6e56086869977621b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62facd370a837a6e56086869977621b">&#9670;&#160;</a></span>ENull</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">enum</a> <a class="el" href="classTeuchos_1_1RCP.html#ae62facd370a837a6e56086869977621b">ENull</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to initialize a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> object to NULL using an implicit conversion! </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__ENull_8hpp_source.html#l00022">22</a> of file <a class="el" href="Teuchos__ENull_8hpp_source.html">Teuchos_ENull.hpp</a>.</p>

</div>
</div>
<a id="a6b52dbfe95890c138f922a4d4e475efd" name="a6b52dbfe95890c138f922a4d4e475efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b52dbfe95890c138f922a4d4e475efd">&#9670;&#160;</a></span>rcpFromPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">typename</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; rcpFromPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an RCP&lt;T&gt; from a Ptr&lt;T&gt; object. </p>

<p class="definition">Definition at line <a class="el" href="Teuchos__PtrDecl_8hpp_source.html#l00276">276</a> of file <a class="el" href="Teuchos__PtrDecl_8hpp_source.html">Teuchos_PtrDecl.hpp</a>.</p>

</div>
</div>
<a id="a7fd9e80180eec6cf6e3038505d3dc7a4" name="a7fd9e80180eec6cf6e3038505d3dc7a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd9e80180eec6cf6e3038505d3dc7a4">&#9670;&#160;</a></span>rcp() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; rcp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> boost::shared_ptr&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion function that takes in a <code>boost::shared_ptr</code> object and spits out a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">Teuchos::RCP</a></code> object. </p>
<p>If the input <code>boost::shared_ptr</code> already wraps a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">Teuchos::RCP</a></code> object, then that <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">Teuchos::RCP</a></code> object will be copied and returned.</p>
<p>This function is not complicated, just look at its defintion below. </p>

</div>
</div>
<a id="a6e779bd6873303e722f91b21ec558b93" name="a6e779bd6873303e722f91b21ec558b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e779bd6873303e722f91b21ec558b93">&#9670;&#160;</a></span>shared_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; shared_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rcp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion function that takes in a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">Teuchos::RCP</a></code> object and spits out a <code>boost::shared_ptr</code> object. </p>
<p>If the input <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">Teuchos::RCP</a></code> already wraps a <code>boost::shared_ptr</code> object, then that <code>boost::shared_ptr</code> object will be copied and returned.</p>
<p>This function is not complicated, just look at its defintion below. </p>

</div>
</div>
<a id="a18c212dad5228ed3adb1b7b376b37edc" name="a18c212dad5228ed3adb1b7b376b37edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c212dad5228ed3adb1b7b376b37edc">&#9670;&#160;</a></span>rcp() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; rcp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">T</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">bool</a>&#160;</td>
          <td class="paramname"><em>owns_mem</em> = <code><a class="el" href="classTeuchos_1_1RCP.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> object properly typed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>[in] Pointer to an object to be reference counted.</td></tr>
    <tr><td class="paramname">owns_mem</td><td>[in] If <code>owns_mem==true</code> then <code>delete p</code> will be called when the last reference to this object is removed. If <code>owns_mem==false</code> then nothing will happen to delete the the object pointed to by <code>p</code> when the last reference is removed.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Preconditions:</b></p><ul>
<li>
If <code>owns_mem==true</code> then <code>p</code> must have been created by calling <code>new</code> to create the object since <code>delete p</code> will be called eventually. </li>
</ul>
<p>If the pointer <code>p</code> did not come from <code>new</code> then either the client should use the version of <code><a class="el" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4" title="Conversion function that takes in a boost::shared_ptr object and spits out a Teuchos::RCP object.">rcp()</a></code> that that uses a deallocator policy object or should pass in <code>owns_mem = false</code>. </p>

</div>
</div>
<a id="a0c6441ac96ec5797f7b487e4c851aebe" name="a0c6441ac96ec5797f7b487e4c851aebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c6441ac96ec5797f7b487e4c851aebe">&#9670;&#160;</a></span>rcpWithDealloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; rcpWithDealloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">T</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a>&#160;</td>
          <td class="paramname"><em>dealloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">bool</a>&#160;</td>
          <td class="paramname"><em>owns_mem</em> = <code><a class="el" href="classTeuchos_1_1RCP.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize from a raw pointer with a deallocation policy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>[in] <a class="el" href="namespaceRaw.html" title="&quot;Raw&quot; input of sparse matrices from Matrix Market files.">Raw</a> C++ pointer that <code>this</code> will represent.</td></tr>
    <tr><td class="paramname">dealloc</td><td>[in] Deallocator policy object (copied by value) that defines a function <code>void Dealloc_T::free(T* p)</code> that will free the underlying object.</td></tr>
    <tr><td class="paramname">owns_mem</td><td>[in] If true then <code>return</code> is allowed to delete the underlying pointer by calling <code>dealloc.free(p)</code>. when all references have been removed.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Preconditions:</b></p><ul>
<li>
The function <code>void Dealloc_T::free(T* p)</code> exists. </li>
</ul>
<p><b>Postconditions:</b></p><ul>
<li>
<code>return.get() == p</code> </li>
<li>
If <code>p == NULL</code> then <ul>
<li>
<code>return.count() == 0</code> </li>
<li>
<code>return.has_ownership() == false</code> </li>
</ul>
</li>
<li>
else <ul>
<li>
<code>return.count() == 1</code> </li>
<li>
<code>return.has_ownership() == owns_mem</code> </li>
</ul>
</li>
</ul>
<p>By default, <code>return</code> has ownership to delete the object pointed to by <code>p</code> when <code>return</code> is deleted (see <code><a class="el" href="classTeuchos_1_1RCP.html#a32c1a9a58e67a6d0a3fbdbb86bf8701b" title="Removes a reference to a dynamically allocated object and possibly deletes the object if owned.">~RCP()</a>)</code>. If <code>owns_mem==true</code>, it is vital that the address <code>p</code> passed in is the same address that was returned by <code>new</code>. With multiple inheritance this is not always the case. See the above discussion. This class is templated to accept a deallocator object that will free the pointer. The other functions use a default deallocator of type <code><a class="el" href="classTeuchos_1_1DeallocDelete.html" title="Policy class for deallocator that uses delete to delete a pointer which is used by RCP.">DeallocDelete</a></code> which has a method <code><a class="el" href="classTeuchos_1_1DeallocDelete.html#aa4b0787f97b55448e767d77f8f3e2b04" title="Deallocates a pointer ptr using delete ptr (required).">DeallocDelete::free()</a></code> which just calls <code>delete p</code>. </p>

</div>
</div>
<a id="a69ff146d10e16f667ef0ce4523a5eef7" name="a69ff146d10e16f667ef0ce4523a5eef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ff146d10e16f667ef0ce4523a5eef7">&#9670;&#160;</a></span>rcpWithDeallocUndef()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; rcpWithDeallocUndef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">T</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a>&#160;</td>
          <td class="paramname"><em>dealloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">bool</a>&#160;</td>
          <td class="paramname"><em>owns_mem</em> = <code><a class="el" href="classTeuchos_1_1RCP.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize from a raw pointer with a deallocation policy for an undefined type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>[in] <a class="el" href="namespaceRaw.html" title="&quot;Raw&quot; input of sparse matrices from Matrix Market files.">Raw</a> C++ pointer that <code>this</code> will represent.</td></tr>
    <tr><td class="paramname">dealloc</td><td>[in] Deallocator policy object (copied by value) that defines a function <code>void Dealloc_T::free(T* p)</code> that will free the underlying object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c754d72d6d232c97e38bc359ab6ef82" name="a6c754d72d6d232c97e38bc359ab6ef82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c754d72d6d232c97e38bc359ab6ef82">&#9670;&#160;</a></span>rcpFromRef()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; rcpFromRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">T</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a non-owning weak <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> object from a raw object reference for a defined type. </p>
<p>NOTE: When debug mode is turned on, in general, the type must be defined. If the type is undefined, then the function <code><a class="el" href="classTeuchos_1_1RCP.html#a823eee3138de3b23dab97b3f37e197f3" title="Return a non-owning weak RCP object from a raw object reference for an undefined type.">rcpFromUndefRef()</a></code> should be called instead. </p>

</div>
</div>
<a id="a823eee3138de3b23dab97b3f37e197f3" name="a823eee3138de3b23dab97b3f37e197f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823eee3138de3b23dab97b3f37e197f3">&#9670;&#160;</a></span>rcpFromUndefRef()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; rcpFromUndefRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">T</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a non-owning weak <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> object from a raw object reference for an undefined type. </p>
<p>NOTE: This version will not be able to use <a class="el" href="classTeuchos_1_1RCPNode.html" title="Node class to keep track of address and the reference count for a reference-counted utility class and...">RCPNode</a> tracing to create a weak reference to an existing <a class="el" href="classTeuchos_1_1RCPNode.html" title="Node class to keep track of address and the reference count for a reference-counted utility class and...">RCPNode</a>. Therefore, you should only use this version with an undefined type. </p>

</div>
</div>
<a id="a02148aef172f7b2c0fb2de29cb01b91a" name="a02148aef172f7b2c0fb2de29cb01b91a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02148aef172f7b2c0fb2de29cb01b91a">&#9670;&#160;</a></span>rcpWithEmbeddedObjPreDestroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; rcpWithEmbeddedObjPreDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">T</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> &amp;&#160;</td>
          <td class="paramname"><em>embedded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">bool</a>&#160;</td>
          <td class="paramname"><em>owns_mem</em> = <code><a class="el" href="classTeuchos_1_1RCP.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> with and also put in an embedded object. </p>
<p>In this case the embedded object is destroyed (by setting to Embedded()) before the object at <code>*p</code> is destroyed.</p>
<p>The embedded object can be extracted using <code><a class="el" href="classTeuchos_1_1RCP.html#afd9ce82fd86820b298f9c3847d585708" title="Get a const reference to an embedded object that was set by calling rcpWithEmbeddedObjPreDestroy(),...">getEmbeddedObj()</a></code> and <code>getNonconstEmbeddedObject()</code>. </p>

</div>
</div>
<a id="a8272eea6a27f1fce6c30fc5d568f2de7" name="a8272eea6a27f1fce6c30fc5d568f2de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8272eea6a27f1fce6c30fc5d568f2de7">&#9670;&#160;</a></span>rcpWithEmbeddedObjPostDestroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; rcpWithEmbeddedObjPostDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">T</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> &amp;&#160;</td>
          <td class="paramname"><em>embedded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">bool</a>&#160;</td>
          <td class="paramname"><em>owns_mem</em> = <code><a class="el" href="classTeuchos_1_1RCP.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> with and also put in an embedded object. </p>
<p>In this case the embedded object is destroyed (by setting to Embedded()) after the object at <code>*p</code> is destroyed.</p>
<p>The embedded object can be extracted using <code><a class="el" href="classTeuchos_1_1RCP.html#afd9ce82fd86820b298f9c3847d585708" title="Get a const reference to an embedded object that was set by calling rcpWithEmbeddedObjPreDestroy(),...">getEmbeddedObj()</a></code> and <code>getNonconstEmbeddedObject()</code>. </p>

</div>
</div>
<a id="a506210a123b6e1747d910f037065bd73" name="a506210a123b6e1747d910f037065bd73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506210a123b6e1747d910f037065bd73">&#9670;&#160;</a></span>rcpWithEmbeddedObj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; rcpWithEmbeddedObj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">T</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> &amp;&#160;</td>
          <td class="paramname"><em>embedded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">bool</a>&#160;</td>
          <td class="paramname"><em>owns_mem</em> = <code><a class="el" href="classTeuchos_1_1RCP.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> with and also put in an embedded object. </p>
<p>This function should be called when it is not important when the embedded object is destroyed (by setting to Embedded()) with respect to when <code>*p</code> is destroyed.</p>
<p>The embedded object can be extracted using <code><a class="el" href="classTeuchos_1_1RCP.html#afd9ce82fd86820b298f9c3847d585708" title="Get a const reference to an embedded object that was set by calling rcpWithEmbeddedObjPreDestroy(),...">getEmbeddedObj()</a></code> and <code>getNonconstEmbeddedObject()</code>. </p>

</div>
</div>
<a id="abaa6bdcd39bac7dd5c12c3e0f49eba25" name="abaa6bdcd39bac7dd5c12c3e0f49eba25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa6bdcd39bac7dd5c12c3e0f49eba25">&#9670;&#160;</a></span>rcpWithInvertedObjOwnership()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">ParentT</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; rcpWithInvertedObjOwnership </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">ParentT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> that inverts the ownership of parent and child. </p>
<p>This implements the "inverted object ownership" idiom.</p>
<p>NOTE: The parent can be retrieved using the function <code>getInvertedObjOwnershipParent(...)</code>. </p>

</div>
</div>
<a id="ae07a807743d25c57754a1988645ba791" name="ae07a807743d25c57754a1988645ba791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07a807743d25c57754a1988645ba791">&#9670;&#160;</a></span>rcpCloneNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; rcpCloneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> object with a new <a class="el" href="classTeuchos_1_1RCPNode.html" title="Node class to keep track of address and the reference count for a reference-counted utility class and...">RCPNode</a> with memory pointing to the initial node. </p>
<p>The purpose of this function is to create a new "handle" to the underlying memory with its own seprate reference count. The new <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> object will have a new <a class="el" href="classTeuchos_1_1RCPNodeTmpl.html" title="Templated implementation class of RCPNode that has the responsibility for deleting the reference-coun...">RCPNodeTmpl</a> object that has a copy of the input <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> object embedded in it. This maintains the correct reference counting behaviors but now gives a private count. One would want to use rcpCloneNode(...) whenever it is important to keep a private reference count which is needed for some types of use cases. </p>

</div>
</div>
<a id="a10f5c533ebfe9dcb44310780b97a349f" name="a10f5c533ebfe9dcb44310780b97a349f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f5c533ebfe9dcb44310780b97a349f">&#9670;&#160;</a></span>is_null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">bool</a> is_null </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>p.get()==NULL</code>. </p>

</div>
</div>
<a id="ad792756b35ab5a2fa8c1d1d608763aec" name="ad792756b35ab5a2fa8c1d1d608763aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad792756b35ab5a2fa8c1d1d608763aec">&#9670;&#160;</a></span>nonnull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">bool</a> nonnull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>p.get()!=NULL</code>. </p>

</div>
</div>
<a id="afab9d7e0e5480ec8b455e38de0eee49e" name="afab9d7e0e5480ec8b455e38de0eee49e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab9d7e0e5480ec8b455e38de0eee49e">&#9670;&#160;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">bool</a> <a class="el" href="classTeuchos_1_1RCP.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html#ae62facd370a837a6e56086869977621b">ENull</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>p.get()==NULL</code>. </p>

</div>
</div>
<a id="a4081b5c4ac5b9d630a695755a72771cc" name="a4081b5c4ac5b9d630a695755a72771cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4081b5c4ac5b9d630a695755a72771cc">&#9670;&#160;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">bool</a> <a class="el" href="classTeuchos_1_1RCP.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html#ae62facd370a837a6e56086869977621b">ENull</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>p.get()!=NULL</code>. </p>

</div>
</div>
<a id="a0bddcdcdc506ddab9d82990bcb48f059" name="a0bddcdcdc506ddab9d82990bcb48f059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bddcdcdc506ddab9d82990bcb48f059">&#9670;&#160;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">bool</a> <a class="el" href="classTeuchos_1_1RCP.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if two <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> objects point to the same referenced-counted object and have the same node. </p>

</div>
</div>
<a id="ad58080d40b950da5009ceb8e33ce9d1c" name="ad58080d40b950da5009ceb8e33ce9d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58080d40b950da5009ceb8e33ce9d1c">&#9670;&#160;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">bool</a> <a class="el" href="classTeuchos_1_1RCP.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if two <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> objects do not point to the same referenced-counted object and have the same node. </p>

</div>
</div>
<a id="a61fc9f719ee13e5d961dcf47053883b4" name="a61fc9f719ee13e5d961dcf47053883b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61fc9f719ee13e5d961dcf47053883b4">&#9670;&#160;</a></span>rcp_implicit_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; rcp_implicit_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implicit cast of underlying <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> type from <code>T1*</code> to <code>T2*</code>. </p>
<p>The function will compile only if (<code>T2* p2 = p1.get();</code>) compiles.</p>
<p>This is to be used for conversions up an inheritance hierarchy and from non-const to const and any other standard implicit pointer conversions allowed by C++. </p>

</div>
</div>
<a id="a1c369381869737e67be8cab843b18076" name="a1c369381869737e67be8cab843b18076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c369381869737e67be8cab843b18076">&#9670;&#160;</a></span>rcp_static_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; rcp_static_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static cast of underlying <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> type from <code>T1*</code> to <code>T2*</code>. </p>
<p>The function will compile only if (<code>static_cast&lt;T2*&gt;(p1.get());</code>) compiles.</p>
<p>This can safely be used for conversion down an inheritance hierarchy with polymorphic types only if <code>dynamic_cast&lt;T2&gt;(p1.get()) == static_cast&lt;T2&gt;(p1.get())</code>. If not then you have to use <code>rcp_dynamic_cast<code>&lt;T2&gt;(p1)</code>. </code></p>

</div>
</div>
<a id="a6931e6c2f74c9fa9467e5dc91c6cd983" name="a6931e6c2f74c9fa9467e5dc91c6cd983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6931e6c2f74c9fa9467e5dc91c6cd983">&#9670;&#160;</a></span>rcp_const_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; rcp_const_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant cast of underlying <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> type from <code>T1*</code> to <code>T2*</code>. </p>
<p>This function will compile only if (<code>const_cast&lt;T2*&gt;(p1.get());</code>) compiles. </p>

</div>
</div>
<a id="a1580c807c6df3fdbcb953687b4ff60c7" name="a1580c807c6df3fdbcb953687b4ff60c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1580c807c6df3fdbcb953687b4ff60c7">&#9670;&#160;</a></span>rcp_dynamic_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; rcp_dynamic_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">bool</a>&#160;</td>
          <td class="paramname"><em>throw_on_fail</em> = <code><a class="el" href="classTeuchos_1_1RCP.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dynamic cast of underlying <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> type from <code>T1*</code> to <code>T2*</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>[in] The smart pointer casting from</td></tr>
    <tr><td class="paramname">throw_on_fail</td><td>[in] If <code>true</code> then if the cast fails (for <code>p1.get()!=NULL) then a <code>std::bad_cast</code> std::exception is thrown with a very informative error message.</code></td></tr>
  </table>
  </dd>
</dl>
<p><b>Postconditions:</b></p><ul>
<li>
<code> If <code>( p1.get()!=NULL &amp;&amp; throw_on_fail==true &amp;&amp; dynamic_cast&lt;T2*&gt;(p1.get())==NULL ) == true</code> then an <code>std::bad_cast</code> std::exception is thrown with a very informative error message. </code></li>
<li>
<code> If <code>( p1.get()!=NULL &amp;&amp; dynamic_cast&lt;T2*&gt;(p1.get())!=NULL ) == true</code> then <code>return.get() == dynamic_cast&lt;T2*&gt;(p1.get())</code>. </code></li>
<li>
<code> If <code>( p1.get()!=NULL &amp;&amp; throw_on_fail==false &amp;&amp; dynamic_cast&lt;T2*&gt;(p1.get())==NULL ) == true</code> then <code>return.get() == NULL</code>. </code></li>
<li>
<code> If <code>( p1.get()==NULL ) == true</code> then <code>return.get() == NULL</code>. </code></li>
</ul>
<p><code>This function will compile only if (<code>dynamic_cast&lt;T2*&gt;(p1.get());</code>) compiles. </code></p>

</div>
</div>
<a id="addd19618c28d1cbc6959f346cee07a7f" name="addd19618c28d1cbc6959f346cee07a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd19618c28d1cbc6959f346cee07a7f">&#9670;&#160;</a></span>set_extra_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">void</a> set_extra_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &amp;&#160;</td>
          <td class="paramname"><em>extra_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__teuchos__mem__mng__grp.html#gacd85ba81c085fde11a3ccc0dfb6f0c5e">EPrePostDestruction</a>&#160;</td>
          <td class="paramname"><em>destroy_when</em> = <code>POST_DESTROY</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">bool</a>&#160;</td>
          <td class="paramname"><em>force_unique</em> = <code><a class="el" href="classTeuchos_1_1RCP.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set extra data associated with a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extra_data</td><td>[in] Data object that will be set (copied)</td></tr>
    <tr><td class="paramname">name</td><td>[in] The name given to the extra data. The value of <code>name</code> together with the data type <code>T1</code> of the extra data must be unique from any other such data or the other data will be overwritten.</td></tr>
    <tr><td class="paramname">p</td><td>[out] On output, will be updated with the input <code>extra_data</code></td></tr>
    <tr><td class="paramname">destroy_when</td><td>[in] Determines when <code>extra_data</code> will be destroyed in relation to the underlying reference-counted object. If <code>destroy_when==PRE_DESTROY</code> then <code>extra_data</code> will be deleted before the underlying reference-counted object. If <code>destroy_when==POST_DESTROY</code> (the default) then <code>extra_data</code> will be deleted after the underlying reference-counted object.</td></tr>
    <tr><td class="paramname">force_unique</td><td>[in] Determines if this type and name pair must be unique in which case if an object with this same type and name already exists, then an std::exception will be thrown. The default is <code>true</code> for safety.</td></tr>
  </table>
  </dd>
</dl>
<p>If there is a call to this function with the same type of extra data <code>T1</code> and same arguments <code>p</code> and <code>name</code> has already been made, then the current piece of extra data already set will be overwritten with <code>extra_data</code>. However, if the type of the extra data <code>T1</code> is different, then the extra data can be added and not overwrite existing extra data. This means that extra data is keyed on both the type and name. This helps to minimize the chance that clients will unexpectedly overwrite data by accident.</p>
<p>When the last <code>RefcountPtr</code> object is removed and the reference-count node is deleted, then objects are deleted in the following order: (1) All of the extra data that where added with <code>destroy_when==PRE_DESTROY</code> are first, (2) then the underlying reference-counted object is deleted, and (3) the rest of the extra data that was added with <code>destroy_when==PRE_DESTROY</code> is then deleted. The order in which the objects are destroyed is not guaranteed. Therefore, clients should be careful not to add extra data that has deletion dependancies (instead consider using nested <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a> objects as extra data which will guarantee the order of deletion).</p>
<p><b>Preconditions:</b></p><ul>
<li>
<code>p-&gt;<a class="el" href="classTeuchos_1_1RCP.html#adc36a705efd91e655fef2521641c26b4" title="Get the raw C++ pointer to the underlying object.">get()</a> != NULL</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class.">NullReferenceError</a></code>) </li>
<li>
If this function has already been called with the same template type <code>T1</code> for <code>extra_data</code> and the same std::string <code>name</code> and <code>force_unique==true</code>, then an <code>std::invalid_argument</code> std::exception will be thrown. </li>
</ul>
<p>Note, this function is made a non-member function to be consistent with the non-member <code><a class="el" href="classTeuchos_1_1RCP.html#ab7f7cd634c8250ff0515bd55c5f3cde6" title="Get a const reference to extra data associated with a RCP object.">get_extra_data()</a></code> functions. </p>

</div>
</div>
<a id="ab7f7cd634c8250ff0515bd55c5f3cde6" name="ab7f7cd634c8250ff0515bd55c5f3cde6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f7cd634c8250ff0515bd55c5f3cde6">&#9670;&#160;</a></span>get_extra_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &amp; get_extra_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reference to extra data associated with a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>[in] Smart pointer object that extra data is being extraced from.</td></tr>
    <tr><td class="paramname">name</td><td>[in] Name of the extra data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a const reference to the extra_data object.</dd></dl>
<p><b>Preconditions:</b></p><ul>
<li>
<code>p.get() != NULL</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class.">NullReferenceError</a></code>) </li>
<li>
<code>name</code> and <code>T1</code> must have been used in a previous call to <code><a class="el" href="classTeuchos_1_1RCP.html#addd19618c28d1cbc6959f346cee07a7f" title="Set extra data associated with a RCP object.">set_extra_data()</a></code> (throws <code>std::invalid_argument</code>). </li>
</ul>
<p>Note, this function must be a non-member function since the client must manually select the first template argument. </p>

</div>
</div>
<a id="a8978c29ca24e96cb61185507a0419dac" name="a8978c29ca24e96cb61185507a0419dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8978c29ca24e96cb61185507a0419dac">&#9670;&#160;</a></span>get_nonconst_extra_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">T1</a> &amp; get_nonconst_extra_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a non-const reference to extra data associated with a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>[in] Smart pointer object that extra data is being extraced from.</td></tr>
    <tr><td class="paramname">name</td><td>[in] Name of the extra data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a non-const reference to the extra_data object.</dd></dl>
<p><b>Preconditions:</b></p><ul>
<li>
<code>p.get() != NULL</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class.">NullReferenceError</a></code>) </li>
<li>
<code>name</code> and <code>T1</code> must have been used in a previous call to <code><a class="el" href="classTeuchos_1_1RCP.html#addd19618c28d1cbc6959f346cee07a7f" title="Set extra data associated with a RCP object.">set_extra_data()</a></code> (throws <code>std::invalid_argument</code>). </li>
</ul>
<p>Note, this function must be a non-member function since the client must manually select the first template argument. </p>

</div>
</div>
<a id="aac70269754b423e8e76d2e75b3dfbf96" name="aac70269754b423e8e76d2e75b3dfbf96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac70269754b423e8e76d2e75b3dfbf96">&#9670;&#160;</a></span>get_optional_extra_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &gt; get_optional_extra_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to const extra data (if it exists) associated with a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>[in] Smart pointer object that extra data is being extraced from.</td></tr>
    <tr><td class="paramname">name</td><td>[in] Name of the extra data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a const pointer to the extra_data object if it exists.</dd></dl>
<p><b>Preconditions:</b></p><ul>
<li>
<code>p.get() != NULL</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class.">NullReferenceError</a></code>) </li>
</ul>
<p><b>Postconditions:</b></p><ul>
<li>
If <code>name</code> and <code>T1</code> have been used in a previous call to <code><a class="el" href="classTeuchos_1_1RCP.html#addd19618c28d1cbc6959f346cee07a7f" title="Set extra data associated with a RCP object.">set_extra_data()</a></code> then <code>return !=NULL</code> and otherwise <code>return == NULL</code>. </li>
</ul>
<p>Note, this function must be a non-member function since the client must manually select the first template argument. </p>

</div>
</div>
<a id="a7b838cf99afd0bb5f2ebc94ab8d73b59" name="a7b838cf99afd0bb5f2ebc94ab8d73b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b838cf99afd0bb5f2ebc94ab8d73b59">&#9670;&#160;</a></span>get_optional_nonconst_extra_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T1</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T1</a> &gt; get_optional_nonconst_extra_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to non-const extra data (if it exists) associated with a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">RCP</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>[in] Smart pointer object that extra data is being extraced from.</td></tr>
    <tr><td class="paramname">name</td><td>[in] Name of the extra data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a non-const pointer to the extra_data object.</dd></dl>
<p><b>Preconditions:</b></p><ul>
<li>
<code>p.get() != NULL</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class.">NullReferenceError</a></code>) </li>
</ul>
<p><b>Postconditions:</b></p><ul>
<li>
If <code>name</code> and <code>T1</code> have been used in a previous call to <code><a class="el" href="classTeuchos_1_1RCP.html#addd19618c28d1cbc6959f346cee07a7f" title="Set extra data associated with a RCP object.">set_extra_data()</a></code> then <code>return !=NULL</code> and otherwise <code>return == NULL</code>. </li>
</ul>
<p>Note, this function must be a non-member function since the client must manually select the first template argument. </p>

</div>
</div>
<a id="a62a1b34d2efe42b0a0fb4e20c1089f89" name="a62a1b34d2efe42b0a0fb4e20c1089f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a1b34d2efe42b0a0fb4e20c1089f89">&#9670;&#160;</a></span>get_dealloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> &amp; get_dealloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a <code>const</code> reference to the underlying deallocator object. </p>
<p><b>Preconditions:</b></p><ul>
<li>
<code>p.get() != NULL</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class.">NullReferenceError</a></code>) </li>
<li>
The deallocator object type used to construct <code>p</code> is same as <code>Dealloc_T</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class.">NullReferenceError</a></code>) </li>
</ul>

</div>
</div>
<a id="a67483a8eaf4d6a5f234e7bd6c971b009" name="a67483a8eaf4d6a5f234e7bd6c971b009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67483a8eaf4d6a5f234e7bd6c971b009">&#9670;&#160;</a></span>get_nonconst_dealloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> &amp; get_nonconst_dealloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a non-<code>const</code> reference to the underlying deallocator object. </p>
<p><b>Preconditions:</b></p><ul>
<li>
<code>p.get() != NULL</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class.">NullReferenceError</a></code>) </li>
<li>
The deallocator object type used to construct <code>p</code> is same as <code>Dealloc_T</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class.">NullReferenceError</a></code>) </li>
</ul>

</div>
</div>
<a id="ac7868e0bffe12f3a8c82daa61cd4cefb" name="ac7868e0bffe12f3a8c82daa61cd4cefb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7868e0bffe12f3a8c82daa61cd4cefb">&#9670;&#160;</a></span>get_optional_dealloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> &gt; get_optional_dealloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the underlying <code>const</code> deallocator object if it exists. </p>
<p><b>Preconditions:</b></p><ul>
<li>
<code>p.get() != NULL</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class.">NullReferenceError</a></code>) </li>
</ul>
<p><b>Postconditions:</b></p><ul>
<li>
If the deallocator object type used to construct <code>p</code> is same as <code>Dealloc_T</code> then <code>return!=NULL</code>, otherwise <code>return==NULL</code> </li>
</ul>

</div>
</div>
<a id="a40a73590cabeeb6ac3556981e068bd5d" name="a40a73590cabeeb6ac3556981e068bd5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a73590cabeeb6ac3556981e068bd5d">&#9670;&#160;</a></span>get_optional_nonconst_dealloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">Dealloc_T</a> &gt; get_optional_nonconst_dealloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the underlying non-<code>const</code> deallocator object if it exists. </p>
<p><b>Preconditions:</b></p><ul>
<li>
<code>p.get() != NULL</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class.">NullReferenceError</a></code>) </li>
</ul>
<p><b>Postconditions:</b></p><ul>
<li>
If the deallocator object type used to construct <code>p</code> is same as <code>Dealloc_T</code> then <code>return!=NULL</code>, otherwise <code>return==NULL</code> </li>
</ul>

</div>
</div>
<a id="afd9ce82fd86820b298f9c3847d585708" name="afd9ce82fd86820b298f9c3847d585708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9ce82fd86820b298f9c3847d585708">&#9670;&#160;</a></span>getEmbeddedObj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">TOrig</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> &amp; getEmbeddedObj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reference to an embedded object that was set by calling <code><a class="el" href="classTeuchos_1_1RCP.html#a02148aef172f7b2c0fb2de29cb01b91a" title="Create an RCP with and also put in an embedded object.">rcpWithEmbeddedObjPreDestroy()</a></code>, <code>rcpWithEmbeddedObjPostDestory()</code>, or <code><a class="el" href="classTeuchos_1_1RCP.html#a506210a123b6e1747d910f037065bd73" title="Create an RCP with and also put in an embedded object.">rcpWithEmbeddedObj()</a></code>. </p>

</div>
</div>
<a id="a5dfd3a9f656d730dea2902f08a765811" name="a5dfd3a9f656d730dea2902f08a765811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dfd3a9f656d730dea2902f08a765811">&#9670;&#160;</a></span>getNonconstEmbeddedObj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">TOrig</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> &amp; getNonconstEmbeddedObj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a non-const reference to an embedded object that was set by calling <code><a class="el" href="classTeuchos_1_1RCP.html#a02148aef172f7b2c0fb2de29cb01b91a" title="Create an RCP with and also put in an embedded object.">rcpWithEmbeddedObjPreDestroy()</a></code>, <code>rcpWithEmbeddedObjPostDestory()</code>, or <code><a class="el" href="classTeuchos_1_1RCP.html#a506210a123b6e1747d910f037065bd73" title="Create an RCP with and also put in an embedded object.">rcpWithEmbeddedObj()</a></code>. </p>

</div>
</div>
<a id="ae35995646037935daf4f98375cbb7ae3" name="ae35995646037935daf4f98375cbb7ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35995646037935daf4f98375cbb7ae3">&#9670;&#160;</a></span>getOptionalEmbeddedObj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">TOrig</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> &gt; getOptionalEmbeddedObj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an optional <a class="el" href="classTeuchos_1_1Ptr.html" title="Simple wrapper class for raw pointers to single objects where no persisting relationship exists.">Ptr</a> to a const embedded object if it was set by calling <code><a class="el" href="classTeuchos_1_1RCP.html#a02148aef172f7b2c0fb2de29cb01b91a" title="Create an RCP with and also put in an embedded object.">rcpWithEmbeddedObjPreDestroy()</a></code>, <code>rcpWithEmbeddedObjPostDestory()</code>, or <code><a class="el" href="classTeuchos_1_1RCP.html#a506210a123b6e1747d910f037065bd73" title="Create an RCP with and also put in an embedded object.">rcpWithEmbeddedObj()</a></code>. </p>

</div>
</div>
<a id="a1fcb0b191b4d3f13cd7e2c139dcc4d8e" name="a1fcb0b191b4d3f13cd7e2c139dcc4d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fcb0b191b4d3f13cd7e2c139dcc4d8e">&#9670;&#160;</a></span>getOptionalNonconstEmbeddedObj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">TOrig</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> , <a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">Embedded</a> &gt; getOptionalNonconstEmbeddedObj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an optional <a class="el" href="classTeuchos_1_1Ptr.html" title="Simple wrapper class for raw pointers to single objects where no persisting relationship exists.">Ptr</a> to a non-const embedded object if it was set by calling <code><a class="el" href="classTeuchos_1_1RCP.html#a02148aef172f7b2c0fb2de29cb01b91a" title="Create an RCP with and also put in an embedded object.">rcpWithEmbeddedObjPreDestroy()</a></code>, <code>rcpWithEmbeddedObjPostDestory()</code>, or <code><a class="el" href="classTeuchos_1_1RCP.html#a506210a123b6e1747d910f037065bd73" title="Create an RCP with and also put in an embedded object.">rcpWithEmbeddedObj()</a></code>. </p>

</div>
</div>
<a id="aa92c7a8fc60f4741319ee31a12a6d75b" name="aa92c7a8fc60f4741319ee31a12a6d75b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa92c7a8fc60f4741319ee31a12a6d75b">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classTeuchos_1_1RCP.html">operator</a>&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output stream inserter. </p>
<p>The implementation of this function just print pointer addresses and therefore puts no restrictions on the data types involved. </p>

</div>
</div>
<a id="a0275ec050540d0f809454692c62aeb46" name="a0275ec050540d0f809454692c62aeb46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0275ec050540d0f809454692c62aeb46">&#9670;&#160;</a></span>rcp() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; rcp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> std::shared_ptr&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion function that takes in a <code>std::shared_ptr</code> object and spits out a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">Teuchos::RCP</a></code> object. </p>
<p>If the input <code>std::shared_ptr</code> already wraps a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">Teuchos::RCP</a></code> object, then that <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">Teuchos::RCP</a></code> object will be copied and returned.</p>
<p>This function is not complicated, just look at its defintion below. </p>

</div>
</div>
<a id="a38863b03f6f86e507045452a8186c86a" name="a38863b03f6f86e507045452a8186c86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38863b03f6f86e507045452a8186c86a">&#9670;&#160;</a></span>get_shared_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTeuchos_1_1RCP.html">class</a> <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; get_shared_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">const</a> <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rcp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion function that takes in a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">Teuchos::RCP</a></code> object and spits out a <code>std::shared_ptr</code> object. </p>
<p>If the input <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">Teuchos::RCP</a></code> already wraps a <code>std::shared_ptr</code> object, then that <code>std::shared_ptr</code> object will be copied and returned.</p>
<p>This function is not complicated, just look at its defintion below. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Teuchos__RCPDecl_8hpp_source.html">Teuchos_RCPDecl.hpp</a></li>
<li><a class="el" href="Teuchos__PtrDecl_8hpp_source.html">Teuchos_PtrDecl.hpp</a></li>
<li><a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a></li>
<li><a class="el" href="Teuchos__RCPBoostSharedPtrConversionsDecl_8hpp_source.html">Teuchos_RCPBoostSharedPtrConversionsDecl.hpp</a></li>
<li><a class="el" href="Teuchos__RCPStdSharedPtrConversionsDecl_8hpp_source.html">Teuchos_RCPStdSharedPtrConversionsDecl.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 9 2025 20:59:58 for Teuchos - Trilinos Tools Package by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
