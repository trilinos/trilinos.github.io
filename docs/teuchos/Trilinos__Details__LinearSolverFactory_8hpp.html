<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Teuchos - Trilinos Tools Package: Trilinos_Details_LinearSolverFactory.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Teuchos - Trilinos Tools Package<span id="projectnumber">&#160;Version of the Day</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_3bc14cc6e393741c22f2d8b878960a50.html">remainder</a></li><li class="navelem"><a class="el" href="dir_fac12a97a9452bf252375f7f453a03b3.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Trilinos_Details_LinearSolverFactory.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Declaration and definition of linear solver factory, and "factory of factories".  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>&quot;</code><br />
<code>#include &quot;TeuchosRemainder_config.h&quot;</code><br />
<code>#include &lt;map&gt;</code><br />
<code>#include &lt;stdexcept&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
</div>
<p><a href="Trilinos__Details__LinearSolverFactory_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinos_1_1Details_1_1LinearSolverFactory.html">Trilinos::Details::LinearSolverFactory&lt; MV, OP, NormType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for a "factory" that creates solvers.  <a href="classTrilinos_1_1Details_1_1LinearSolverFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinos_1_1Details_1_1Impl_1_1LinearSolverFactoryRepository.html">Trilinos::Details::Impl::LinearSolverFactoryRepository&lt; MV, OP, NormType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repository of solver factories.  <a href="classTrilinos_1_1Details_1_1Impl_1_1LinearSolverFactoryRepository.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceTrilinos" id="r_namespaceTrilinos"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTrilinos.html">Trilinos</a></td></tr>
<tr class="memdesc:namespaceTrilinos"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace of things generally useful to many <a class="el" href="namespaceTrilinos.html" title="Namespace of things generally useful to many Trilinos packages.">Trilinos</a> packages. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceDetails" id="r_namespaceDetails"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDetails.html">Details</a></td></tr>
<tr class="memdesc:namespaceDetails"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace of implementation details. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTrilinos_1_1Details_1_1Impl" id="r_namespaceTrilinos_1_1Details_1_1Impl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTrilinos_1_1Details_1_1Impl.html">Trilinos::Details::Impl</a></td></tr>
<tr class="memdesc:namespaceTrilinos_1_1Details_1_1Impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation details of implementation details. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2a0bb5612b70d57694084eb739b9f141" id="r_a2a0bb5612b70d57694084eb739b9f141"><td class="memTemplParams" colspan="2">template&lt;class MV , class OP , class NormType &gt; </td></tr>
<tr class="memitem:a2a0bb5612b70d57694084eb739b9f141"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html">LinearSolver</a>&lt; MV, OP, NormType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="Trilinos__Details__LinearSolverFactory_8hpp.html#a2a0bb5612b70d57694084eb739b9f141">Trilinos::Details::getLinearSolver</a> (const std::string &amp;packageName, const std::string &amp;solverName)</td></tr>
<tr class="memdesc:a2a0bb5612b70d57694084eb739b9f141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html" title="Interface for a method for solving linear system(s) AX=B.">LinearSolver</a> instance.  <br /></td></tr>
<tr class="separator:a2a0bb5612b70d57694084eb739b9f141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1753005d87a3117c49301cca7d0b276c" id="r_a1753005d87a3117c49301cca7d0b276c"><td class="memTemplParams" colspan="2">template&lt;class MV , class OP , class NormType &gt; </td></tr>
<tr class="memitem:a1753005d87a3117c49301cca7d0b276c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="Trilinos__Details__LinearSolverFactory_8hpp.html#a1753005d87a3117c49301cca7d0b276c">Trilinos::Details::registerLinearSolverFactory</a> (const std::string &amp;packageName, const <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTrilinos_1_1Details_1_1LinearSolverFactory.html">LinearSolverFactory</a>&lt; MV, OP, NormType &gt; &gt; &amp;factory)</td></tr>
<tr class="memdesc:a1753005d87a3117c49301cca7d0b276c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by a package to register its <a class="el" href="classTrilinos_1_1Details_1_1LinearSolverFactory.html" title="Interface for a &quot;factory&quot; that creates solvers.">LinearSolverFactory</a>.  <br /></td></tr>
<tr class="separator:a1753005d87a3117c49301cca7d0b276c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8ad7745636b91916c33cbee631786b" id="r_a9c8ad7745636b91916c33cbee631786b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTrilinos_1_1Details_1_1Impl.html#a9c8ad7745636b91916c33cbee631786b">Trilinos::Details::Impl::rememberRegisteredSomeLinearSolverFactory</a> (const std::string &amp;packageName)</td></tr>
<tr class="memdesc:a9c8ad7745636b91916c33cbee631786b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remember which packages registered at least one <a class="el" href="classTrilinos_1_1Details_1_1LinearSolverFactory.html" title="Interface for a &quot;factory&quot; that creates solvers.">LinearSolverFactory</a>, with any template parameters.  <br /></td></tr>
<tr class="separator:a9c8ad7745636b91916c33cbee631786b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e34bcac649f747449516c541143e313" id="r_a8e34bcac649f747449516c541143e313"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTrilinos_1_1Details_1_1Impl.html#a8e34bcac649f747449516c541143e313">Trilinos::Details::Impl::registeredSomeLinearSolverFactory</a> (const std::string &amp;packageName)</td></tr>
<tr class="memdesc:a8e34bcac649f747449516c541143e313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Did the package with the given name register at least one <a class="el" href="classTrilinos_1_1Details_1_1LinearSolverFactory.html" title="Interface for a &quot;factory&quot; that creates solvers.">LinearSolverFactory</a>, with any template parameters?  <br /></td></tr>
<tr class="separator:a8e34bcac649f747449516c541143e313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87a2c478b3b3c6596992532b2cecf48" id="r_ab87a2c478b3b3c6596992532b2cecf48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTrilinos_1_1Details_1_1Impl.html#ab87a2c478b3b3c6596992532b2cecf48">Trilinos::Details::Impl::haveLinearSolverFactoryRunTimeRegistration</a> ()</td></tr>
<tr class="memdesc:ab87a2c478b3b3c6596992532b2cecf48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the CMake run-time registration option is ON.  <br /></td></tr>
<tr class="separator:ab87a2c478b3b3c6596992532b2cecf48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Declaration and definition of linear solver factory, and "factory of factories". </p>
<dl class="section warning"><dt>Warning</dt><dd>This header file is NOT currently part of the public interface of <a class="el" href="namespaceTrilinos.html" title="Namespace of things generally useful to many Trilinos packages.">Trilinos</a>. It or its contents may change or disappear at any time.</dd></dl>
<p>Tpetra::Details::getLinearSolver, Tpetra::Details::registerLinearSolverFactory, and Tpetra::Details::LinearSolverFactory implement the Dependency Inversion and Injection (DII) pattern, as applied to "linear
solvers." A linear solver solves or helps solve linear system(s) AX=B. Examples include sparse direct solvers, iterative solvers, and preconditioners for iterative solvers.</p>
<p>DII naturally admits hierarchical run-time options, as in e.g., <a class="el" href="classTeuchos_1_1ParameterList.html" title="A list of parameters of arbitrary type.">Teuchos::ParameterList</a>. This lets solvers create inner solvers in an arbitrarily nested way, following the arbitrary nesting of the <a class="el" href="classTeuchos_1_1ParameterList.html" title="A list of parameters of arbitrary type.">Teuchos::ParameterList</a>.</p>
<p>DII works well when a ParameterList can express all the data that a solver might need. However, some solvers need or may benefit from additional data. For example, algebraic multigrid can use mesh coordinates, and a sparse factorization can use an initial permutation. Such data do not fit naturally in a <a class="el" href="classTeuchos_1_1ParameterList.html" title="A list of parameters of arbitrary type.">Teuchos::ParameterList</a>.</p>
<dl class="section note"><dt>Note</dt><dd>To developers: The LinearSolver and LinearSolverFactory interfaces, and the LinearSolverFactoryRepository interface and implementation must live in the bottom-most (most upstream) package from all solvers that depend on it. Solver defines an interface for a solver, and LinearSolverFactory defines an interface for a "factory" that knows how to create solvers. Each solver package defines its own solvers, and its own factory that knows how to create all the solvers in a given package. </dd></dl>

<p class="definition">Definition in file <a class="el" href="Trilinos__Details__LinearSolverFactory_8hpp_source.html">Trilinos_Details_LinearSolverFactory.hpp</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a2a0bb5612b70d57694084eb739b9f141" name="a2a0bb5612b70d57694084eb739b9f141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0bb5612b70d57694084eb739b9f141">&#9670;&#160;</a></span>getLinearSolver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MV , class OP , class NormType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; LinearSolver&lt; MV, OP, NormType &gt; &gt; Trilinos::Details::getLinearSolver </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>packageName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>solverName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a LinearSolver instance. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MV</td><td>Type of a (multi)vector, representing either the solution(s) X or the right-hand side(s) B of a linear system AX=B. For example, with Tpetra, use a Tpetra::MultiVector specialization. A <em>multivector</em> is a single data structure containing zero or more vectors with the same dimensions and layout.</td></tr>
    <tr><td class="paramname">OP</td><td>Type of a matrix or linear operator that this Solver understands. For example, for Tpetra, use a Tpetra::Operator specialization.</td></tr>
    <tr><td class="paramname">NormType</td><td>Type of the norm of the residual. See the documentation of LinearSolver for details.</td></tr>
  </table>
  </dd>
</dl>
<p>Call this function to create a LinearSolver instance from a particular package. LinearSolvers may create LinearSolvers. The run-time registration system (see registerLinearSolverFactory() below) breaks software dependencies between packages. Thus, Package A may create a LinearSolver from Package B, even if Package B depends on Package A.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packageName</td><td>[in] Name of the package from which to get the solver. Names are case sensitive. </td></tr>
    <tr><td class="paramname">solverName</td><td>[in] The solver's name. Names are case sensitive. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Trilinos__Details__LinearSolverFactory_8hpp_source.html#l00519">519</a> of file <a class="el" href="Trilinos__Details__LinearSolverFactory_8hpp_source.html">Trilinos_Details_LinearSolverFactory.hpp</a>.</p>

</div>
</div>
<a id="a1753005d87a3117c49301cca7d0b276c" name="a1753005d87a3117c49301cca7d0b276c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1753005d87a3117c49301cca7d0b276c">&#9670;&#160;</a></span>registerLinearSolverFactory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MV , class OP , class NormType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Trilinos::Details::registerLinearSolverFactory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>packageName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTrilinos_1_1Details_1_1LinearSolverFactory.html">LinearSolverFactory</a>&lt; MV, OP, NormType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>factory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by a package to register its LinearSolverFactory. </p>
<p>\function registerLinearSolverFactory </p>
<dl class="section note"><dt>Note</dt><dd>Most users do not need to call this function. This is mostly of interest to solver package developers. See below for details.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MV</td><td>Type of a (multi)vector, representing either the solution(s) X or the right-hand side(s) B of a linear system AX=B. For example, with Tpetra, use a Tpetra::MultiVector specialization. A <em>multivector</em> is a single data structure containing zero or more vectors with the same dimensions and layout.</td></tr>
    <tr><td class="paramname">OP</td><td>Type of a matrix or linear operator that the LinearSolver instances to create understand. For example, for Tpetra, use a Tpetra::Operator specialization.</td></tr>
    <tr><td class="paramname">NormType</td><td>Type of the norm of the residual. See the documentation of LinearSolver for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packageName</td><td>[in] Name of the package registering the factory. Package names are case sensitive. </td></tr>
    <tr><td class="paramname">factory</td><td>[in] That package's factory.</td></tr>
  </table>
  </dd>
</dl>
<p>This function lets packages register themselves, so that getLinearSolver() (see above) can create solvers from that package. A package "registers itself" by doing the following: </p><ol>
<li>
Defining a concrete LinearSolverFactory subclass, that knows how to create solvers from that package  </li>
<li>
Calling registerLinearSolverFactory() (this function) with an instance of that LinearSolverFactory subclass  </li>
</ol>
<p>Packages may call this function before main() runs. In fact, we prefer that they do so. This ensures that any package will be able to create solvers from that package, without users or other packages needing to know about that package. When people talk about "dependency injection" or "dependency inversion," this is what they mean.</p>
<p>This function is templated with the same template parameters as LinearSolverFactory. This means that it must be called for every combination of types (MV, OP) for which code will instantiate a LinearSolverFactory&lt;MV, OP, NormType&gt;. Thus, if the solver package wants to do this before main() runs, it needs a list of all type combination in advance. If using explicit template instantiation (ETI), you may plug this into the ETI system. We thus recommend that packages that use ETI register a LinearSolverFactory instance for each ETI type combination. For example, Ifpack2 should iterate over all enabled combinations of the four template parameters S, LO, GO, NT of Ifpack2::Preconditioner, creating a LinearSolverFactory&lt;MV, OP, NormType&gt; instance for each combination, with MV = Tpetra::MultiVector&lt;S, LO, GO, NT&gt; and OP = Tpetra::Operator&lt;S, LO, GO, NT&gt;. Package developers may find it useful to write a macro that does this for that package's LinearSolverFactory subclass.</p>
<p>If packages do not register a factory for certain type combinations that users need, users may in rare instances need to call this function themselves. Avoid doing this, because it defeats dependency inversion.</p>
<p>It could very well be that some packages don't implement all desired type combinations MV, OP. In that case, those packages would not register a factory for those types. Users who request solvers from those packages for forbidden type combinations would get a run-time error.</p>
<dl class="section note"><dt>Note</dt><dd>To developers: LinearSolverFactory returns LinearSolver by <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">Teuchos::RCP</a> because <a class="el" href="namespaceTrilinos.html" title="Namespace of things generally useful to many Trilinos packages.">Trilinos</a>' solvers tend to use <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">Teuchos::RCP</a>, and we don't want to break compatibility. However, if C++11 is enabled, we use std::shared_ptr to handle LinearSolverFactory instances. This is because that is an implementation detail that solvers themselves don't have to see, and because std::shared_ptr is thread safe. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Trilinos__Details__LinearSolverFactory_8hpp_source.html#l00506">506</a> of file <a class="el" href="Trilinos__Details__LinearSolverFactory_8hpp_source.html">Trilinos_Details_LinearSolverFactory.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 9 2025 20:59:56 for Teuchos - Trilinos Tools Package by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
