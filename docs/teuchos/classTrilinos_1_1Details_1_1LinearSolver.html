<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Teuchos - Trilinos Tools Package: Trilinos::Details::LinearSolver&lt; MV, OP, NormType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Teuchos - Trilinos Tools Package<span id="projectnumber">&#160;Version of the Day</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceTrilinos.html">Trilinos</a></li><li class="navelem"><b>Details</b></li><li class="navelem"><a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html">LinearSolver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classTrilinos_1_1Details_1_1LinearSolver-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Trilinos::Details::LinearSolver&lt; MV, OP, NormType &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Interface for a method for solving linear system(s) AX=B.  
 <a href="classTrilinos_1_1Details_1_1LinearSolver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Trilinos__Details__LinearSolver_8hpp_source.html">Trilinos_Details_LinearSolver.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a74520497224e79aadf3b862133c09245" id="r_a74520497224e79aadf3b862133c09245"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html#a74520497224e79aadf3b862133c09245">~LinearSolver</a> ()</td></tr>
<tr class="memdesc:a74520497224e79aadf3b862133c09245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor (virtual for memory safety of derived classes).  <br /></td></tr>
<tr class="separator:a74520497224e79aadf3b862133c09245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6106cd194bfcae897d68d7e1202c14" id="r_a2e6106cd194bfcae897d68d7e1202c14"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html#a2e6106cd194bfcae897d68d7e1202c14">setMatrix</a> (const <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; const OP &gt; &amp;A)=0</td></tr>
<tr class="memdesc:a2e6106cd194bfcae897d68d7e1202c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the solver's matrix.  <br /></td></tr>
<tr class="separator:a2e6106cd194bfcae897d68d7e1202c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a6429db764c1fa117a979705ce68af" id="r_a57a6429db764c1fa117a979705ce68af"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; const OP &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html#a57a6429db764c1fa117a979705ce68af">getMatrix</a> () const =0</td></tr>
<tr class="memdesc:a57a6429db764c1fa117a979705ce68af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to this solver's matrix.  <br /></td></tr>
<tr class="separator:a57a6429db764c1fa117a979705ce68af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b48e12b32aed7fa2fa2b7e698817510" id="r_a3b48e12b32aed7fa2fa2b7e698817510"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html#a3b48e12b32aed7fa2fa2b7e698817510">solve</a> (MV &amp;X, const MV &amp;B)=0</td></tr>
<tr class="memdesc:a3b48e12b32aed7fa2fa2b7e698817510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the linear system(s) AX=B.  <br /></td></tr>
<tr class="separator:a3b48e12b32aed7fa2fa2b7e698817510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2664382f596c5ab1124bd21f0f2d313" id="r_ac2664382f596c5ab1124bd21f0f2d313"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html#ac2664382f596c5ab1124bd21f0f2d313">setParameters</a> (const <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1ParameterList.html">Teuchos::ParameterList</a> &gt; &amp;params)=0</td></tr>
<tr class="memdesc:ac2664382f596c5ab1124bd21f0f2d313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this solver's parameters.  <br /></td></tr>
<tr class="separator:ac2664382f596c5ab1124bd21f0f2d313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273f2024686e0bf3eb74037b6586acc1" id="r_a273f2024686e0bf3eb74037b6586acc1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html#a273f2024686e0bf3eb74037b6586acc1">symbolic</a> ()=0</td></tr>
<tr class="memdesc:a273f2024686e0bf3eb74037b6586acc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up any part of the solve that depends on the structure of the input matrix, but not its numerical values.  <br /></td></tr>
<tr class="separator:a273f2024686e0bf3eb74037b6586acc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef89b7fda36355519bdd0c50c1fc3ef" id="r_a0ef89b7fda36355519bdd0c50c1fc3ef"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html#a0ef89b7fda36355519bdd0c50c1fc3ef">numeric</a> ()=0</td></tr>
<tr class="memdesc:a0ef89b7fda36355519bdd0c50c1fc3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up any part of the solve that depends on both the structure and the numerical values of the input matrix.  <br /></td></tr>
<tr class="separator:a0ef89b7fda36355519bdd0c50c1fc3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class MV, class OP, class NormType&gt;<br />
class Trilinos::Details::LinearSolver&lt; MV, OP, NormType &gt;</div><p>Interface for a method for solving linear system(s) AX=B. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MV</td><td>Type of a (multi)vector, representing either the solution(s) X or the right-hand side(s) B of a linear system AX=B. For example, with Tpetra, use a Tpetra::MultiVector specialization. A <em>multivector</em> is a single data structure containing zero or more vectors with the same dimensions and layout.</td></tr>
    <tr><td class="paramname">OP</td><td>Type of a matrix or linear operator that this <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html" title="Interface for a method for solving linear system(s) AX=B.">LinearSolver</a> understands. For example, for Tpetra, use a Tpetra::Operator specialization.</td></tr>
    <tr><td class="paramname">NormType</td><td>Type of the norm of a vector (see <code>MV</code>); in particular, the type of the norm of a <em>residual</em> <picture><source srcset="form_22_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$b - A \tilde{x}$" src="form_22.png"/></picture>, where <picture><source srcset="form_23_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\tilde{x}$" src="form_23.png"/></picture> is an approximate solution of the linear system <picture><source srcset="form_24_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$Ax = b$" src="form_24.png"/></picture>. For <code>MV = Tpetra::MultiVector</code>, use <code>NormType = MV::mag_type</code>. In general, if the entries of <code>MV</code> have type <code>double</code>, and the solver uses the Euclidean norm (i.e., the 2-norm), then <code>NormType = double</code>. If the entries of <code>MV</code> have type <code>std::complex&lt;float&gt;</code>, then <code>NormType = float</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>A <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html" title="Interface for a method for solving linear system(s) AX=B.">LinearSolver</a> knows how to solve linear systems AX=B, where A is a linear operator ("matrix") and B the right-hand side(s).</p>
<p>This interface separates "setup" from "solves." "Setup" depends only on the matrix A, while solves also depend on the right-hand side(s) B and possibly also on initial guess(es). "Setup" may be more expensive than solve, but it can be reused for different right-hand side(s) and initial guess(es). The <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html" title="Interface for a method for solving linear system(s) AX=B.">LinearSolver</a> interface further divides setup into two phases: "symbolic" and "numeric."</p>
<p>The "symbolic" phase depends only on the "structure" of the matrix, and not its values. By "structure," we mean </p><ul>
<li>
its dimensions,  </li>
<li>
its distribution over parallel processes, and most specifically,  </li>
<li>
the pattern of which entries in the matrix are nonzero. </li>
<li>
</li>
</ul>
<p>The distinction between "structure" and "values" matters most for sparse matrices. If the structure of a matrix does not change, <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html" title="Interface for a method for solving linear system(s) AX=B.">LinearSolver</a> can reuse the "symbolic" setup phase for multiple solves, even if the values in the matrix change between solves. If the structure of a matrix changes, you must ask <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html" title="Interface for a method for solving linear system(s) AX=B.">LinearSolver</a> to recompute the symbolic setup.</p>
<p>The "numeric" setup phase depends on both the matrix's structure, and the values of its entries. If the values in the matrix change, you must ask the solver to recompute the numeric setup. If only the values changed but not the matrix's structure, then you do <em>not</em> need to ask the solver to recompute the symbolic setup. The symbolic setup must be done before the numeric setup.</p>
<dl class="section note"><dt>Note</dt><dd>To implementers: For the <code>OP</code> template parameter, you should <em>consistently</em> use the most abstract base class that makes sense. For example, with Tpetra, use Tpetra::Operator, and for Epetra, use Epetra_Operator. Implementations should use dynamic_cast to get the subclass that they want, and throw an exception if the dynamic_cast fails. I emphasized "consistently," because this makes explicit template instantiation (ETI) easier, and helps keep build times and library sizes small. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Trilinos__Details__LinearSolver_8hpp_source.html#l00114">114</a> of file <a class="el" href="Trilinos__Details__LinearSolver_8hpp_source.html">Trilinos_Details_LinearSolver.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a74520497224e79aadf3b862133c09245" name="a74520497224e79aadf3b862133c09245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74520497224e79aadf3b862133c09245">&#9670;&#160;</a></span>~LinearSolver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MV , class OP , class NormType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html">Trilinos::Details::LinearSolver</a>&lt; MV, OP, NormType &gt;::~<a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html">LinearSolver</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor (virtual for memory safety of derived classes). </p>

<p class="definition">Definition at line <a class="el" href="Trilinos__Details__LinearSolver_8hpp_source.html#l00117">117</a> of file <a class="el" href="Trilinos__Details__LinearSolver_8hpp_source.html">Trilinos_Details_LinearSolver.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2e6106cd194bfcae897d68d7e1202c14" name="a2e6106cd194bfcae897d68d7e1202c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6106cd194bfcae897d68d7e1202c14">&#9670;&#160;</a></span>setMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MV , class OP , class NormType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html">Trilinos::Details::LinearSolver</a>&lt; MV, OP, NormType &gt;::setMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; const OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the solver's matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>[in] Pointer to the matrix A in the linear system(s) AX=B to solve.</td></tr>
  </table>
  </dd>
</dl>
<p>This <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html" title="Interface for a method for solving linear system(s) AX=B.">LinearSolver</a> instance keeps the matrix (by pointer) given to it by this method, and does not modify it. The solver stores any additional data needed for solves separately from the matrix.</p>
<p>Calling this method resets the solver's state. After calling this method, you must call <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html#a273f2024686e0bf3eb74037b6586acc1" title="Set up any part of the solve that depends on the structure of the input matrix, but not its numerical...">symbolic()</a> and <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html#a0ef89b7fda36355519bdd0c50c1fc3ef" title="Set up any part of the solve that depends on both the structure and the numerical values of the input...">numeric()</a> before you may call <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html#a3b48e12b32aed7fa2fa2b7e698817510" title="Solve the linear system(s) AX=B.">solve()</a>.</p>
<p>You are allowed to change the structure and/or numerical values in the matrix that this <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html" title="Interface for a method for solving linear system(s) AX=B.">LinearSolver</a> instance holds. If you do so, you do NOT need to call this method. If you change the graph structure of the matrix, you must call <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html#a273f2024686e0bf3eb74037b6586acc1" title="Set up any part of the solve that depends on the structure of the input matrix, but not its numerical...">symbolic()</a> and <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html#a0ef89b7fda36355519bdd0c50c1fc3ef" title="Set up any part of the solve that depends on both the structure and the numerical values of the input...">numeric()</a> before you may call <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html#a3b48e12b32aed7fa2fa2b7e698817510" title="Solve the linear system(s) AX=B.">solve()</a>. If you change the numerical values but not the graph structure of the matrix, you must call <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html#a0ef89b7fda36355519bdd0c50c1fc3ef" title="Set up any part of the solve that depends on both the structure and the numerical values of the input...">numeric()</a> before you may call <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html#a3b48e12b32aed7fa2fa2b7e698817510" title="Solve the linear system(s) AX=B.">solve()</a>.</p>
<p><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">Teuchos::RCP</a> is just like std::shared_ptr. It uses reference counting for automatic deallocation. Passing in a "const OP" implies that the solver may not modify A. </p>

</div>
</div>
<a id="a57a6429db764c1fa117a979705ce68af" name="a57a6429db764c1fa117a979705ce68af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a6429db764c1fa117a979705ce68af">&#9670;&#160;</a></span>getMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MV , class OP , class NormType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; const OP &gt; <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html">Trilinos::Details::LinearSolver</a>&lt; MV, OP, NormType &gt;::getMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to this solver's matrix. </p>
<p>If this <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html" title="Interface for a method for solving linear system(s) AX=B.">LinearSolver</a> instance does not (yet) have a matrix, this method will return Teuchos::null. The solver <em>must</em> have a matrix before you may call <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html#a3b48e12b32aed7fa2fa2b7e698817510" title="Solve the linear system(s) AX=B.">solve()</a>.</p>
<p><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">Teuchos::RCP</a> is just like std::shared_ptr. It uses reference counting for automatic deallocation. Returning a "const OP" implies that the caller may not modify A. </p>

</div>
</div>
<a id="a3b48e12b32aed7fa2fa2b7e698817510" name="a3b48e12b32aed7fa2fa2b7e698817510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b48e12b32aed7fa2fa2b7e698817510">&#9670;&#160;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MV , class OP , class NormType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html">Trilinos::Details::LinearSolver</a>&lt; MV, OP, NormType &gt;::solve </td>
          <td>(</td>
          <td class="paramtype">MV &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MV &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solve the linear system(s) AX=B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>[in/out] On input: (multi)vector that is allocated and ready for output. The solver may choose to read the contents as the initial guess(es). On output: the solution vector(s).</td></tr>
    <tr><td class="paramname">B</td><td>[in] Right-hand side(s) of the linear system(s).</td></tr>
  </table>
  </dd>
</dl>
<p>Solves may fail. "Failure" depends on the accuracy that the specific solver promises. The caller is responsible for determining whether the solve succeeded. This may require a dynamic cast to ask the specific kind of solver whether it succeeded, or testing some error metric (like the the residual 2-norm). </p>

</div>
</div>
<a id="ac2664382f596c5ab1124bd21f0f2d313" name="ac2664382f596c5ab1124bd21f0f2d313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2664382f596c5ab1124bd21f0f2d313">&#9670;&#160;</a></span>setParameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MV , class OP , class NormType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html">Trilinos::Details::LinearSolver</a>&lt; MV, OP, NormType &gt;::setParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; <a class="el" href="classTeuchos_1_1ParameterList.html">Teuchos::ParameterList</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this solver's parameters. </p>
<p>Depending on the solver and which parameters you set or changed, you may have to recompute the symbolic or numeric setup (by calling <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html#a273f2024686e0bf3eb74037b6586acc1" title="Set up any part of the solve that depends on the structure of the input matrix, but not its numerical...">symbolic()</a> resp. <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html#a0ef89b7fda36355519bdd0c50c1fc3ef" title="Set up any part of the solve that depends on both the structure and the numerical values of the input...">numeric()</a>) after calling <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html#ac2664382f596c5ab1124bd21f0f2d313" title="Set this solver&#39;s parameters.">setParameters()</a>, before you may call <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html#a3b48e12b32aed7fa2fa2b7e698817510" title="Solve the linear system(s) AX=B.">solve()</a> again.</p>
<p>Different solver implementations have different ideas about how to treat parameters. Some of them (like those in Ifpack2) treat the input parameter list as a complete snapshot of the desired state. Many that do this also fill the input list with unspecified parameters set to default values. Other solvers (like those in Belos) treat the input list as a "delta" &ndash; a set of changes from the current state &ndash; and thus generally do not fill in the input list.</p>
<p>This interface is compatible with either variant. The solver reserves the right to modify the input list, or to keep a pointer to the input list. Callers are responsible for copying the list if they don't want the solver to see changes, or if the <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection.">Teuchos::RCP</a> is nonowning. Users are responsible for knowing how the different solvers behave. </p>

</div>
</div>
<a id="a273f2024686e0bf3eb74037b6586acc1" name="a273f2024686e0bf3eb74037b6586acc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273f2024686e0bf3eb74037b6586acc1">&#9670;&#160;</a></span>symbolic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MV , class OP , class NormType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html">Trilinos::Details::LinearSolver</a>&lt; MV, OP, NormType &gt;::symbolic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up any part of the solve that depends on the structure of the input matrix, but not its numerical values. </p>
<p>If the structure of the matrix has changed, or if you have not yet called this method on this <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html" title="Interface for a method for solving linear system(s) AX=B.">LinearSolver</a> instance, then you must call this method before you may call <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html#a0ef89b7fda36355519bdd0c50c1fc3ef" title="Set up any part of the solve that depends on both the structure and the numerical values of the input...">numeric()</a> or <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html#a3b48e12b32aed7fa2fa2b7e698817510" title="Solve the linear system(s) AX=B.">solve()</a>.</p>
<p>There is no way that the solver can tell users whether the symbolic factorization is "done," because the solver may have no way to know whether the structure of the matrix has changed. Users are responsible for notifying the solver of structure changes, by calling <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html#a273f2024686e0bf3eb74037b6586acc1" title="Set up any part of the solve that depends on the structure of the input matrix, but not its numerical...">symbolic()</a>. (This is why there is no "symbolicDone" Boolean method.)</p>
<dl class="section note"><dt>Note</dt><dd>To developers: If you find it necessary to separate "preordering" from the symbolic factorization, you may use a mix-in for that. </dd></dl>

</div>
</div>
<a id="a0ef89b7fda36355519bdd0c50c1fc3ef" name="a0ef89b7fda36355519bdd0c50c1fc3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef89b7fda36355519bdd0c50c1fc3ef">&#9670;&#160;</a></span>numeric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MV , class OP , class NormType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html">Trilinos::Details::LinearSolver</a>&lt; MV, OP, NormType &gt;::numeric </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up any part of the solve that depends on both the structure and the numerical values of the input matrix. </p>
<p>If any values in the matrix have changed, or if you have not yet called this method on this <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html" title="Interface for a method for solving linear system(s) AX=B.">LinearSolver</a> instance, then you must call this method before you may call <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html#a3b48e12b32aed7fa2fa2b7e698817510" title="Solve the linear system(s) AX=B.">solve()</a>.</p>
<p>There is no way that the solver can tell users whether the numeric factorization is "done," because the solver may have no way to know whether the values of the matrix has changed. Users are responsible for notifying the solver of changes to values, by calling <a class="el" href="classTrilinos_1_1Details_1_1LinearSolver.html#a0ef89b7fda36355519bdd0c50c1fc3ef" title="Set up any part of the solve that depends on both the structure and the numerical values of the input...">numeric()</a>. (This is why there is no "numericDone" Boolean method.) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Trilinos__Details__LinearSolver_8hpp_source.html">Trilinos_Details_LinearSolver.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 9 2025 20:59:59 for Teuchos - Trilinos Tools Package by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
