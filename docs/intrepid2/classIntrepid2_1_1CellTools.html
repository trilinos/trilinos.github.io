<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Intrepid2: Intrepid2::CellTools&lt; DeviceType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Intrepid2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Intrepid2</b></li><li class="navelem"><a class="el" href="classIntrepid2_1_1CellTools.html">CellTools</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="classIntrepid2_1_1CellTools-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Intrepid2::CellTools&lt; DeviceType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A stateless class for operations on cell data. Provides methods for:  
 <a href="classIntrepid2_1_1CellTools.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Intrepid2__CellTools_8hpp_source.html">Intrepid2_CellTools.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaa851cbcec849f14a45eda9ebb4e13f1" id="r_aaa851cbcec849f14a45eda9ebb4e13f1"><td class="memItemLeft" align="right" valign="top"><a id="aaa851cbcec849f14a45eda9ebb4e13f1" name="aaa851cbcec849f14a45eda9ebb4e13f1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CellTools</b> ()=default</td></tr>
<tr class="memdesc:aaa851cbcec849f14a45eda9ebb4e13f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:aaa851cbcec849f14a45eda9ebb4e13f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b013b7b95ca31aeb04afef773ffb80" id="r_ab8b013b7b95ca31aeb04afef773ffb80"><td class="memItemLeft" align="right" valign="top"><a id="ab8b013b7b95ca31aeb04afef773ffb80" name="ab8b013b7b95ca31aeb04afef773ffb80"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~CellTools</b> ()=default</td></tr>
<tr class="memdesc:ab8b013b7b95ca31aeb04afef773ffb80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:ab8b013b7b95ca31aeb04afef773ffb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce0b6722af0b2447b5301333bdd4dbf" id="r_a1ce0b6722af0b2447b5301333bdd4dbf"><td class="memTemplParams" colspan="2">template&lt;typename InCellViewType , typename InputViewType &gt; </td></tr>
<tr class="memitem:a1ce0b6722af0b2447b5301333bdd4dbf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a1ce0b6722af0b2447b5301333bdd4dbf">checkPointwiseInclusion</a> (InCellViewType inCell, const InputViewType points, const shards::CellTopology cellTopo, const typename <a class="el" href="structIntrepid2_1_1ScalarTraits.html">ScalarTraits</a>&lt; typename InputViewType::value_type &gt;::scalar_type threshold)</td></tr>
<tr class="separator:a1ce0b6722af0b2447b5301333bdd4dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc80a502dc785d2d9ed40ddc979282fb" id="r_adc80a502dc785d2d9ed40ddc979282fb"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:adc80a502dc785d2d9ed40ddc979282fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#adc80a502dc785d2d9ed40ddc979282fb">setJacobianDividedByDet</a> (<a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; Scalar, DeviceType &gt; &amp;jacobianDividedByDet, const <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; Scalar, DeviceType &gt; &amp;jacobian, const <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; Scalar, DeviceType &gt; &amp;jacobianDetInv)</td></tr>
<tr class="separator:adc80a502dc785d2d9ed40ddc979282fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ca08834df5fcac6d6f3f8acb6f5b3a" id="r_a19ca08834df5fcac6d6f3f8acb6f5b3a"><td class="memTemplParams" colspan="2">template&lt;typename PhysPointViewType , typename RefPointViewType , typename WorksetType , typename HGradBasisPtrType &gt; </td></tr>
<tr class="memitem:a19ca08834df5fcac6d6f3f8acb6f5b3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a19ca08834df5fcac6d6f3f8acb6f5b3a">mapToPhysicalFrame</a> (PhysPointViewType physPoints, const RefPointViewType refPoints, const WorksetType worksetCell, const HGradBasisPtrType basis)</td></tr>
<tr class="separator:a19ca08834df5fcac6d6f3f8acb6f5b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673f99af56a3ee5f268a72e3fca2a9fa" id="r_a673f99af56a3ee5f268a72e3fca2a9fa"><td class="memTemplParams" colspan="2">template&lt;typename refSubcellViewType , typename paramViewType &gt; </td></tr>
<tr class="memitem:a673f99af56a3ee5f268a72e3fca2a9fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a673f99af56a3ee5f268a72e3fca2a9fa">mapToReferenceSubcell</a> (refSubcellViewType refSubcellPoints, const paramViewType paramPoints, const ordinal_type subcellDim, const ordinal_type subcellOrd, const shards::CellTopology parentCell)</td></tr>
<tr class="separator:a673f99af56a3ee5f268a72e3fca2a9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ce454dd565c800e75bf9e82959834d" id="r_a28ce454dd565c800e75bf9e82959834d"><td class="memTemplParams" colspan="2">template&lt;typename refSubcellViewType , typename paramViewType &gt; </td></tr>
<tr class="memitem:a28ce454dd565c800e75bf9e82959834d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a28ce454dd565c800e75bf9e82959834d">mapToReferenceSubcell</a> (refSubcellViewType refSubcellPoints, const paramViewType paramPoints, const typename <a class="el" href="classIntrepid2_1_1RefSubcellParametrization.html">RefSubcellParametrization</a>&lt; DeviceType &gt;::ConstViewType subcellParametrization, const ordinal_type subcellOrd)</td></tr>
<tr class="separator:a28ce454dd565c800e75bf9e82959834d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121ab625eb64b342af2fb6d1306df77f" id="r_a121ab625eb64b342af2fb6d1306df77f"><td class="memTemplParams" colspan="2">template&lt;typename refSubcellViewType , typename paramViewType , typename ordViewType &gt; </td></tr>
<tr class="memitem:a121ab625eb64b342af2fb6d1306df77f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a121ab625eb64b342af2fb6d1306df77f">mapToReferenceSubcell</a> (refSubcellViewType refSubcellPoints, const paramViewType paramPoints, const typename <a class="el" href="classIntrepid2_1_1RefSubcellParametrization.html">RefSubcellParametrization</a>&lt; DeviceType &gt;::ConstViewType subcellParametrization, const ordViewType subcellOrd)</td></tr>
<tr class="separator:a121ab625eb64b342af2fb6d1306df77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a78474ac2637b9b8c8b18bb5614934926" id="r_a78474ac2637b9b8c8b18bb5614934926"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a78474ac2637b9b8c8b18bb5614934926">hasReferenceCell</a> (const shards::CellTopology cellTopo)</td></tr>
<tr class="memdesc:a78474ac2637b9b8c8b18bb5614934926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a cell topology has reference cell.  <br /></td></tr>
<tr class="separator:a78474ac2637b9b8c8b18bb5614934926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4e2522850bdc5a0100dd0653154f46" id="r_a9b4e2522850bdc5a0100dd0653154f46"><td class="memTemplParams" colspan="2">template&lt;typename JacobianViewType , typename PointViewType , typename WorksetType , typename HGradBasisType &gt; </td></tr>
<tr class="memitem:a9b4e2522850bdc5a0100dd0653154f46"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a9b4e2522850bdc5a0100dd0653154f46">setJacobian</a> (JacobianViewType jacobian, const PointViewType points, const WorksetType worksetCell, const Teuchos::RCP&lt; HGradBasisType &gt; basis, const int startCell=0, const int endCell=-1)</td></tr>
<tr class="memdesc:a9b4e2522850bdc5a0100dd0653154f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian matrix <em>DF</em> of the reference-to-physical frame map <em>F</em>.  <br /></td></tr>
<tr class="separator:a9b4e2522850bdc5a0100dd0653154f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451b64ded378fc549938364860fca50c" id="r_a451b64ded378fc549938364860fca50c"><td class="memTemplParams" colspan="2">template&lt;typename JacobianViewType , typename BasisGradientsType , typename WorksetType &gt; </td></tr>
<tr class="memitem:a451b64ded378fc549938364860fca50c"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a451b64ded378fc549938364860fca50c">setJacobian</a> (JacobianViewType jacobian, const WorksetType worksetCell, const BasisGradientsType gradients, const int startCell=0, const int endCell=-1)</td></tr>
<tr class="memdesc:a451b64ded378fc549938364860fca50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian matrix <em>DF</em> of the reference-to-physical frame map <em>F</em>.  <br /></td></tr>
<tr class="separator:a451b64ded378fc549938364860fca50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2248e8b80e5009fe12aa8eeaf6eaadd6" id="r_a2248e8b80e5009fe12aa8eeaf6eaadd6"><td class="memTemplParams" colspan="2">template&lt;typename JacobianViewType , typename PointViewType , typename WorksetCellViewType &gt; </td></tr>
<tr class="memitem:a2248e8b80e5009fe12aa8eeaf6eaadd6"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a2248e8b80e5009fe12aa8eeaf6eaadd6">setJacobian</a> (JacobianViewType jacobian, const PointViewType points, const WorksetCellViewType worksetCell, const shards::CellTopology cellTopo)</td></tr>
<tr class="memdesc:a2248e8b80e5009fe12aa8eeaf6eaadd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian matrix <em>DF</em> of the reference-to-physical frame map <em>F</em>.  <br /></td></tr>
<tr class="separator:a2248e8b80e5009fe12aa8eeaf6eaadd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3f3c71168e71bf3db25e9255845126" id="r_a4b3f3c71168e71bf3db25e9255845126"><td class="memTemplParams" colspan="2">template&lt;typename JacobianInvViewType , typename JacobianViewType &gt; </td></tr>
<tr class="memitem:a4b3f3c71168e71bf3db25e9255845126"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a4b3f3c71168e71bf3db25e9255845126">setJacobianInv</a> (JacobianInvViewType jacobianInv, const JacobianViewType jacobian)</td></tr>
<tr class="memdesc:a4b3f3c71168e71bf3db25e9255845126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse of the Jacobian matrix <em>DF</em> of the reference-to-physical frame map <em>F</em>.  <br /></td></tr>
<tr class="separator:a4b3f3c71168e71bf3db25e9255845126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b9b7c93d79757812c1f00f0062bc37" id="r_a45b9b7c93d79757812c1f00f0062bc37"><td class="memTemplParams" colspan="2">template&lt;typename JacobianDetViewType , typename JacobianViewType &gt; </td></tr>
<tr class="memitem:a45b9b7c93d79757812c1f00f0062bc37"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a45b9b7c93d79757812c1f00f0062bc37">setJacobianDet</a> (JacobianDetViewType jacobianDet, const JacobianViewType jacobian)</td></tr>
<tr class="memdesc:a45b9b7c93d79757812c1f00f0062bc37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant of the Jacobian matrix <em>DF</em> of the reference-to-physical frame map <em>F</em>.  <br /></td></tr>
<tr class="separator:a45b9b7c93d79757812c1f00f0062bc37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a5b4e652b87c54c24879492957007d" id="r_a35a5b4e652b87c54c24879492957007d"><td class="memTemplParams" colspan="2">template&lt;class PointScalar &gt; </td></tr>
<tr class="memitem:a35a5b4e652b87c54c24879492957007d"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a35a5b4e652b87c54c24879492957007d">allocateJacobianDet</a> (const <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt; &amp;jacobian)</td></tr>
<tr class="memdesc:a35a5b4e652b87c54c24879492957007d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and returns a <a class="el" href="classIntrepid2_1_1Data.html" title="Wrapper around a Kokkos::View that allows data that is constant or repeating in various logical dimen...">Data</a> container suitable for storing determinants corresponding to the Jacobians in the <a class="el" href="classIntrepid2_1_1Data.html" title="Wrapper around a Kokkos::View that allows data that is constant or repeating in various logical dimen...">Data</a> container provided.  <br /></td></tr>
<tr class="separator:a35a5b4e652b87c54c24879492957007d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db99befc25604df89bb0029e5eeae09" id="r_a8db99befc25604df89bb0029e5eeae09"><td class="memTemplParams" colspan="2">template&lt;class PointScalar &gt; </td></tr>
<tr class="memitem:a8db99befc25604df89bb0029e5eeae09"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a8db99befc25604df89bb0029e5eeae09">allocateJacobianInv</a> (const <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt; &amp;jacobian)</td></tr>
<tr class="memdesc:a8db99befc25604df89bb0029e5eeae09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and returns a <a class="el" href="classIntrepid2_1_1Data.html" title="Wrapper around a Kokkos::View that allows data that is constant or repeating in various logical dimen...">Data</a> container suitable for storing inverses corresponding to the Jacobians in the <a class="el" href="classIntrepid2_1_1Data.html" title="Wrapper around a Kokkos::View that allows data that is constant or repeating in various logical dimen...">Data</a> container provided.  <br /></td></tr>
<tr class="separator:a8db99befc25604df89bb0029e5eeae09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c71ed020b59aae8688fa8b78dc1daa" id="r_a92c71ed020b59aae8688fa8b78dc1daa"><td class="memTemplParams" colspan="2">template&lt;class PointScalar &gt; </td></tr>
<tr class="memitem:a92c71ed020b59aae8688fa8b78dc1daa"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a92c71ed020b59aae8688fa8b78dc1daa">setJacobianDet</a> (<a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt; &amp;jacobianDet, const <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt; &amp;jacobian)</td></tr>
<tr class="memdesc:a92c71ed020b59aae8688fa8b78dc1daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes determinants corresponding to the Jacobians in the <a class="el" href="classIntrepid2_1_1Data.html" title="Wrapper around a Kokkos::View that allows data that is constant or repeating in various logical dimen...">Data</a> container provided.  <br /></td></tr>
<tr class="separator:a92c71ed020b59aae8688fa8b78dc1daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1d1250ba939877511af41fd37be0e8" id="r_aed1d1250ba939877511af41fd37be0e8"><td class="memTemplParams" colspan="2">template&lt;class PointScalar &gt; </td></tr>
<tr class="memitem:aed1d1250ba939877511af41fd37be0e8"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#aed1d1250ba939877511af41fd37be0e8">setJacobianDetInv</a> (<a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt; &amp;jacobianDetInv, const <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt; &amp;jacobian)</td></tr>
<tr class="memdesc:aed1d1250ba939877511af41fd37be0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes reciprocals of determinants corresponding to the Jacobians in the <a class="el" href="classIntrepid2_1_1Data.html" title="Wrapper around a Kokkos::View that allows data that is constant or repeating in various logical dimen...">Data</a> container provided.  <br /></td></tr>
<tr class="separator:aed1d1250ba939877511af41fd37be0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2e9da998624f350ed7fc860969e304" id="r_a5d2e9da998624f350ed7fc860969e304"><td class="memTemplParams" colspan="2">template&lt;class PointScalar &gt; </td></tr>
<tr class="memitem:a5d2e9da998624f350ed7fc860969e304"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a5d2e9da998624f350ed7fc860969e304">setJacobianInv</a> (<a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt; &amp;jacobianInv, const <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt; &amp;jacobian)</td></tr>
<tr class="memdesc:a5d2e9da998624f350ed7fc860969e304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes determinants corresponding to the Jacobians in the <a class="el" href="classIntrepid2_1_1Data.html" title="Wrapper around a Kokkos::View that allows data that is constant or repeating in various logical dimen...">Data</a> container provided.  <br /></td></tr>
<tr class="separator:a5d2e9da998624f350ed7fc860969e304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28740648a8b95a924afe419b1efbf016" id="r_a28740648a8b95a924afe419b1efbf016"><td class="memTemplParams" colspan="2">template&lt;class PointScalar &gt; </td></tr>
<tr class="memitem:a28740648a8b95a924afe419b1efbf016"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a28740648a8b95a924afe419b1efbf016">setJacobianDividedByDet</a> (<a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt; &amp;jacobianDividedByDet, const <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt; &amp;jacobian, const <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt; &amp;jacobianDetInv)</td></tr>
<tr class="memdesc:a28740648a8b95a924afe419b1efbf016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the Jacobian with shape (C,P,D,D) by the reciprocals of the determinants, with shape (C,P), entrywise.  <br /></td></tr>
<tr class="separator:a28740648a8b95a924afe419b1efbf016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c98d1a43783311a5a7c922faaa8d61" id="r_ac0c98d1a43783311a5a7c922faaa8d61"><td class="memTemplParams" colspan="2">template&lt;typename cellCenterValueType , class ... cellCenterProperties&gt; </td></tr>
<tr class="memitem:ac0c98d1a43783311a5a7c922faaa8d61"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#ac0c98d1a43783311a5a7c922faaa8d61">getReferenceCellCenter</a> (Kokkos::DynRankView&lt; cellCenterValueType, cellCenterProperties... &gt; cellCenter, const shards::CellTopology cell)</td></tr>
<tr class="memdesc:ac0c98d1a43783311a5a7c922faaa8d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Cartesian coordinates of reference cell barycenter.  <br /></td></tr>
<tr class="separator:ac0c98d1a43783311a5a7c922faaa8d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af869373cf2682ef97de0d4c119882724" id="r_af869373cf2682ef97de0d4c119882724"><td class="memTemplParams" colspan="2">template&lt;typename cellVertexValueType , class ... cellVertexProperties&gt; </td></tr>
<tr class="memitem:af869373cf2682ef97de0d4c119882724"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#af869373cf2682ef97de0d4c119882724">getReferenceVertex</a> (Kokkos::DynRankView&lt; cellVertexValueType, cellVertexProperties... &gt; cellVertex, const shards::CellTopology cell, const ordinal_type vertexOrd)</td></tr>
<tr class="memdesc:af869373cf2682ef97de0d4c119882724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the Cartesian coordinates of a reference cell vertex.  <br /></td></tr>
<tr class="separator:af869373cf2682ef97de0d4c119882724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30b4cc22f21428f28538307ea744c89" id="r_ad30b4cc22f21428f28538307ea744c89"><td class="memTemplParams" colspan="2">template&lt;typename subcellVertexValueType , class ... subcellVertexProperties&gt; </td></tr>
<tr class="memitem:ad30b4cc22f21428f28538307ea744c89"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#ad30b4cc22f21428f28538307ea744c89">getReferenceSubcellVertices</a> (Kokkos::DynRankView&lt; subcellVertexValueType, subcellVertexProperties... &gt; subcellVertices, const ordinal_type subcellDim, const ordinal_type subcellOrd, const shards::CellTopology parentCell)</td></tr>
<tr class="memdesc:ad30b4cc22f21428f28538307ea744c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the Cartesian coordinates of all vertices of a reference subcell.  <br /></td></tr>
<tr class="separator:ad30b4cc22f21428f28538307ea744c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227057ecee9224d7deef7d06fd816006" id="r_a227057ecee9224d7deef7d06fd816006"><td class="memTemplParams" colspan="2">template&lt;typename cellNodeValueType , class ... cellNodeProperties&gt; </td></tr>
<tr class="memitem:a227057ecee9224d7deef7d06fd816006"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a227057ecee9224d7deef7d06fd816006">getReferenceNode</a> (Kokkos::DynRankView&lt; cellNodeValueType, cellNodeProperties... &gt; cellNode, const shards::CellTopology cell, const ordinal_type nodeOrd)</td></tr>
<tr class="memdesc:a227057ecee9224d7deef7d06fd816006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the Cartesian coordinates of a reference cell node.  <br /></td></tr>
<tr class="separator:a227057ecee9224d7deef7d06fd816006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca35e9d104f2763e432fcfed87f2a23e" id="r_aca35e9d104f2763e432fcfed87f2a23e"><td class="memTemplParams" colspan="2">template&lt;typename SubcellNodeViewType &gt; </td></tr>
<tr class="memitem:aca35e9d104f2763e432fcfed87f2a23e"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#aca35e9d104f2763e432fcfed87f2a23e">getReferenceSubcellNodes</a> (SubcellNodeViewType subcellNodes, const ordinal_type subcellDim, const ordinal_type subcellOrd, const shards::CellTopology parentCell)</td></tr>
<tr class="memdesc:aca35e9d104f2763e432fcfed87f2a23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the Cartesian coordinates of all nodes of a reference subcell.  <br /></td></tr>
<tr class="separator:aca35e9d104f2763e432fcfed87f2a23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7e6b7811ff106bcdf2a3d298d6f27d" id="r_afa7e6b7811ff106bcdf2a3d298d6f27d"><td class="memTemplParams" colspan="2">template&lt;typename RefEdgeTangentViewType &gt; </td></tr>
<tr class="memitem:afa7e6b7811ff106bcdf2a3d298d6f27d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#afa7e6b7811ff106bcdf2a3d298d6f27d">getReferenceEdgeTangent</a> (RefEdgeTangentViewType refEdgeTangent, const ordinal_type edgeOrd, const shards::CellTopology parentCell)</td></tr>
<tr class="memdesc:afa7e6b7811ff106bcdf2a3d298d6f27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes constant tangent vectors to edges of 2D or 3D reference cells.  <br /></td></tr>
<tr class="separator:afa7e6b7811ff106bcdf2a3d298d6f27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0b9b40329c45b0e1ae57d2fc7e63ce" id="r_afd0b9b40329c45b0e1ae57d2fc7e63ce"><td class="memTemplParams" colspan="2">template&lt;typename RefFaceTanViewType &gt; </td></tr>
<tr class="memitem:afd0b9b40329c45b0e1ae57d2fc7e63ce"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#afd0b9b40329c45b0e1ae57d2fc7e63ce">getReferenceFaceTangents</a> (RefFaceTanViewType refFaceTanU, RefFaceTanViewType refFaceTanV, const ordinal_type faceOrd, const shards::CellTopology parentCell)</td></tr>
<tr class="memdesc:afd0b9b40329c45b0e1ae57d2fc7e63ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes pairs of constant tangent vectors to faces of a 3D reference cells.  <br /></td></tr>
<tr class="separator:afd0b9b40329c45b0e1ae57d2fc7e63ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d876366f84c9d89ec34d885b85b52c" id="r_ae6d876366f84c9d89ec34d885b85b52c"><td class="memTemplParams" colspan="2">template&lt;typename RefSideNormalViewType &gt; </td></tr>
<tr class="memitem:ae6d876366f84c9d89ec34d885b85b52c"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#ae6d876366f84c9d89ec34d885b85b52c">getReferenceSideNormal</a> (RefSideNormalViewType refSideNormal, const ordinal_type sideOrd, const shards::CellTopology parentCell)</td></tr>
<tr class="memdesc:ae6d876366f84c9d89ec34d885b85b52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes constant normal vectors to sides of 2D or 3D reference cells.  <br /></td></tr>
<tr class="separator:ae6d876366f84c9d89ec34d885b85b52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5d6883a44dc55cbcf9d8efff87f071" id="r_a7e5d6883a44dc55cbcf9d8efff87f071"><td class="memTemplParams" colspan="2">template&lt;typename RefFaceNormalViewType &gt; </td></tr>
<tr class="memitem:a7e5d6883a44dc55cbcf9d8efff87f071"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a7e5d6883a44dc55cbcf9d8efff87f071">getReferenceFaceNormal</a> (RefFaceNormalViewType refFaceNormal, const ordinal_type faceOrd, const shards::CellTopology parentCell)</td></tr>
<tr class="memdesc:a7e5d6883a44dc55cbcf9d8efff87f071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes constant normal vectors to faces of 3D reference cell.  <br /></td></tr>
<tr class="separator:a7e5d6883a44dc55cbcf9d8efff87f071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcb3e5c24c9ca6dc47c79a7b0193374" id="r_abdcb3e5c24c9ca6dc47c79a7b0193374"><td class="memTemplParams" colspan="2">template&lt;typename edgeTangentValueType , class ... edgeTangentProperties, typename worksetJacobianValueType , class ... worksetJacobianProperties&gt; </td></tr>
<tr class="memitem:abdcb3e5c24c9ca6dc47c79a7b0193374"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#abdcb3e5c24c9ca6dc47c79a7b0193374">getPhysicalEdgeTangents</a> (Kokkos::DynRankView&lt; edgeTangentValueType, edgeTangentProperties... &gt; edgeTangents, const Kokkos::DynRankView&lt; worksetJacobianValueType, worksetJacobianProperties... &gt; worksetJacobians, const ordinal_type worksetEdgeOrd, const shards::CellTopology parentCell)</td></tr>
<tr class="memdesc:abdcb3e5c24c9ca6dc47c79a7b0193374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes non-normalized tangent vectors to physical edges in an edge workset <picture><source srcset="form_32_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\mathcal{E}_{c,i}\}_{c=0}^{N}$" src="form_32.png" width="48" height="15"/></picture>; (see <a class="el" href="cell_tools_page.html#sec_cell_topology_subcell_wset">Subcell worksets</a> for definition of edge worksets).  <br /></td></tr>
<tr class="separator:abdcb3e5c24c9ca6dc47c79a7b0193374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af718bc465adbe467409a07fd67750be3" id="r_af718bc465adbe467409a07fd67750be3"><td class="memTemplParams" colspan="2">template&lt;typename edgeTangentValueType , class ... edgeTangentProperties, typename worksetJacobianValueType , class ... worksetJacobianProperties, typename edgeOrdValueType , class ... edgeOrdProperties&gt; </td></tr>
<tr class="memitem:af718bc465adbe467409a07fd67750be3"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#af718bc465adbe467409a07fd67750be3">getPhysicalEdgeTangents</a> (Kokkos::DynRankView&lt; edgeTangentValueType, edgeTangentProperties... &gt; edgeTangents, const Kokkos::DynRankView&lt; worksetJacobianValueType, worksetJacobianProperties... &gt; worksetJacobians, const Kokkos::DynRankView&lt; edgeOrdValueType, edgeOrdProperties... &gt; worksetEdgeOrds, const shards::CellTopology parentCell)</td></tr>
<tr class="memdesc:af718bc465adbe467409a07fd67750be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes non-normalized tangent vectors to physical edges in an edge workset <picture><source srcset="form_32_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\mathcal{E}_{c,i}\}_{c=0}^{N}$" src="form_32.png" width="48" height="15"/></picture>; (see <a class="el" href="cell_tools_page.html#sec_cell_topology_subcell_wset">Subcell worksets</a> for definition of edge worksets).  <br /></td></tr>
<tr class="separator:af718bc465adbe467409a07fd67750be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4522fcf52f960eb0f4eb138c8e02ae4e" id="r_a4522fcf52f960eb0f4eb138c8e02ae4e"><td class="memTemplParams" colspan="2">template&lt;typename faceTanValueType , class ... faceTanProperties, typename worksetJacobianValueType , class ... worksetJacobianProperties&gt; </td></tr>
<tr class="memitem:a4522fcf52f960eb0f4eb138c8e02ae4e"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a4522fcf52f960eb0f4eb138c8e02ae4e">getPhysicalFaceTangents</a> (Kokkos::DynRankView&lt; faceTanValueType, faceTanProperties... &gt; faceTanU, Kokkos::DynRankView&lt; faceTanValueType, faceTanProperties... &gt; faceTanV, const Kokkos::DynRankView&lt; worksetJacobianValueType, worksetJacobianProperties... &gt; worksetJacobians, const ordinal_type worksetFaceOrd, const shards::CellTopology parentCell)</td></tr>
<tr class="memdesc:a4522fcf52f960eb0f4eb138c8e02ae4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes non-normalized tangent vector pairs to physical faces in a face workset <picture><source srcset="form_43_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\mathcal{F}_{c,i}\}_{c=0}^{N}$" src="form_43.png" width="50" height="15"/></picture>; (see <a class="el" href="cell_tools_page.html#sec_cell_topology_subcell_wset">Subcell worksets</a> for definition of face worksets).  <br /></td></tr>
<tr class="separator:a4522fcf52f960eb0f4eb138c8e02ae4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7ef29b9d1bf494f668682a4f264c8a" id="r_a0f7ef29b9d1bf494f668682a4f264c8a"><td class="memTemplParams" colspan="2">template&lt;typename faceTanValueType , class ... faceTanProperties, typename worksetJacobianValueType , class ... worksetJacobianProperties, typename faceOrdValueType , class ... faceOrdProperties&gt; </td></tr>
<tr class="memitem:a0f7ef29b9d1bf494f668682a4f264c8a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a0f7ef29b9d1bf494f668682a4f264c8a">getPhysicalFaceTangents</a> (Kokkos::DynRankView&lt; faceTanValueType, faceTanProperties... &gt; faceTanU, Kokkos::DynRankView&lt; faceTanValueType, faceTanProperties... &gt; faceTanV, const Kokkos::DynRankView&lt; worksetJacobianValueType, worksetJacobianProperties... &gt; worksetJacobians, const Kokkos::DynRankView&lt; faceOrdValueType, faceOrdProperties... &gt; worksetFaceOrds, const shards::CellTopology parentCell)</td></tr>
<tr class="memdesc:a0f7ef29b9d1bf494f668682a4f264c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes non-normalized tangent vector pairs to physical faces in a face workset <picture><source srcset="form_43_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\mathcal{F}_{c,i}\}_{c=0}^{N}$" src="form_43.png" width="50" height="15"/></picture>; (see <a class="el" href="cell_tools_page.html#sec_cell_topology_subcell_wset">Subcell worksets</a> for definition of face worksets).  <br /></td></tr>
<tr class="separator:a0f7ef29b9d1bf494f668682a4f264c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff60692c07fe1a6f223273bb8ed87a9" id="r_afff60692c07fe1a6f223273bb8ed87a9"><td class="memTemplParams" colspan="2">template&lt;typename sideNormalValueType , class ... sideNormalProperties, typename worksetJacobianValueType , class ... worksetJacobianProperties&gt; </td></tr>
<tr class="memitem:afff60692c07fe1a6f223273bb8ed87a9"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#afff60692c07fe1a6f223273bb8ed87a9">getPhysicalSideNormals</a> (Kokkos::DynRankView&lt; sideNormalValueType, sideNormalProperties... &gt; sideNormals, const Kokkos::DynRankView&lt; worksetJacobianValueType, worksetJacobianProperties... &gt; worksetJacobians, const ordinal_type worksetSideOrd, const shards::CellTopology parentCell)</td></tr>
<tr class="memdesc:afff60692c07fe1a6f223273bb8ed87a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes non-normalized normal vectors to physical sides in a side workset <picture><source srcset="form_53_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\mathcal{S}_{c,i}\}_{c=0}^{N}$" src="form_53.png" width="49" height="15"/></picture>.  <br /></td></tr>
<tr class="separator:afff60692c07fe1a6f223273bb8ed87a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacef389a37fe157b206c458859fd31cd" id="r_aacef389a37fe157b206c458859fd31cd"><td class="memTemplParams" colspan="2">template&lt;typename sideNormalValueType , class ... sideNormalProperties, typename worksetJacobianValueType , class ... worksetJacobianProperties, typename edgeOrdValueType , class ... edgeOrdProperties&gt; </td></tr>
<tr class="memitem:aacef389a37fe157b206c458859fd31cd"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#aacef389a37fe157b206c458859fd31cd">getPhysicalSideNormals</a> (Kokkos::DynRankView&lt; sideNormalValueType, sideNormalProperties... &gt; sideNormals, const Kokkos::DynRankView&lt; worksetJacobianValueType, worksetJacobianProperties... &gt; worksetJacobians, const Kokkos::DynRankView&lt; edgeOrdValueType, edgeOrdProperties... &gt; worksetSideOrds, const shards::CellTopology parentCell)</td></tr>
<tr class="memdesc:aacef389a37fe157b206c458859fd31cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes non-normalized normal vectors to physical sides in a side workset <picture><source srcset="form_53_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\mathcal{S}_{c,i}\}_{c=0}^{N}$" src="form_53.png" width="49" height="15"/></picture>. It is similar to the <em><a class="el" href="classIntrepid2_1_1CellTools.html#afff60692c07fe1a6f223273bb8ed87a9" title="Computes non-normalized normal vectors to physical sides in a side workset .">CellTools::getPhysicalSideNormals</a></em> function above, with the difference that the side ordinal can change from point to point, and it is provided by the rank-2 input array <em><b>worksetSideOrds</b></em>, indexed by (C,P).  <br /></td></tr>
<tr class="separator:aacef389a37fe157b206c458859fd31cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5cb629eaa691a2cb841e04df0911e8" id="r_a6a5cb629eaa691a2cb841e04df0911e8"><td class="memTemplParams" colspan="2">template&lt;typename faceNormalValueType , class ... faceNormalProperties, typename worksetJacobianValueType , class ... worksetJacobianProperties&gt; </td></tr>
<tr class="memitem:a6a5cb629eaa691a2cb841e04df0911e8"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a6a5cb629eaa691a2cb841e04df0911e8">getPhysicalFaceNormals</a> (Kokkos::DynRankView&lt; faceNormalValueType, faceNormalProperties... &gt; faceNormals, const Kokkos::DynRankView&lt; worksetJacobianValueType, worksetJacobianProperties... &gt; worksetJacobians, const ordinal_type worksetFaceOrd, const shards::CellTopology parentCell)</td></tr>
<tr class="memdesc:a6a5cb629eaa691a2cb841e04df0911e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes non-normalized normal vectors to physical faces in a face workset <picture><source srcset="form_43_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\mathcal{F}_{c,i}\}_{c=0}^{N}$" src="form_43.png" width="50" height="15"/></picture>; (see <a class="el" href="cell_tools_page.html#sec_cell_topology_subcell_wset">Subcell worksets</a> for definition of face worksets).  <br /></td></tr>
<tr class="separator:a6a5cb629eaa691a2cb841e04df0911e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1f977298b3b7db2941f15b2c3fea0b" id="r_a6d1f977298b3b7db2941f15b2c3fea0b"><td class="memTemplParams" colspan="2">template&lt;typename faceNormalValueType , class ... faceNormalProperties, typename worksetJacobianValueType , class ... worksetJacobianProperties, typename faceOrdValueType , class ... faceOrdProperties&gt; </td></tr>
<tr class="memitem:a6d1f977298b3b7db2941f15b2c3fea0b"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a6d1f977298b3b7db2941f15b2c3fea0b">getPhysicalFaceNormals</a> (Kokkos::DynRankView&lt; faceNormalValueType, faceNormalProperties... &gt; faceNormals, const Kokkos::DynRankView&lt; worksetJacobianValueType, worksetJacobianProperties... &gt; worksetJacobians, const Kokkos::DynRankView&lt; faceOrdValueType, faceOrdProperties... &gt; worksetFaceOrds, const shards::CellTopology parentCell)</td></tr>
<tr class="memdesc:a6d1f977298b3b7db2941f15b2c3fea0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes non-normalized normal vectors to physical faces in a face workset <picture><source srcset="form_43_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\mathcal{F}_{c,i}\}_{c=0}^{N}$" src="form_43.png" width="50" height="15"/></picture>; (see <a class="el" href="cell_tools_page.html#sec_cell_topology_subcell_wset">Subcell worksets</a> for definition of face worksets). It is similar to the <em><a class="el" href="classIntrepid2_1_1CellTools.html#afff60692c07fe1a6f223273bb8ed87a9" title="Computes non-normalized normal vectors to physical sides in a side workset .">CellTools::getPhysicalSideNormals</a></em> function above, with the difference that the side ordinal can change from point to point, and it is provided by the rank-2 input array <em><b>worksetSideOrds</b></em>, indexed by (C,P).  <br /></td></tr>
<tr class="separator:a6d1f977298b3b7db2941f15b2c3fea0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4647855c7283cf8bf47c365498121314" id="r_a4647855c7283cf8bf47c365498121314"><td class="memTemplParams" colspan="2">template&lt;typename PhysPointValueType , typename RefPointValueType , typename WorksetType , typename HGradBasisPtrType &gt; </td></tr>
<tr class="memitem:a4647855c7283cf8bf47c365498121314"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a4647855c7283cf8bf47c365498121314">mapToPhysicalFrame</a> (PhysPointValueType physPoints, const RefPointValueType refPoints, const WorksetType worksetCell, const HGradBasisPtrType basis)</td></tr>
<tr class="memdesc:a4647855c7283cf8bf47c365498121314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <em>F</em>, the reference-to-physical frame map.  <br /></td></tr>
<tr class="separator:a4647855c7283cf8bf47c365498121314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a27c76bece1882e3e6d12879b5d7eb" id="r_a42a27c76bece1882e3e6d12879b5d7eb"><td class="memTemplParams" colspan="2">template&lt;typename PhysPointViewType , typename RefPointViewType , typename WorksetCellViewType &gt; </td></tr>
<tr class="memitem:a42a27c76bece1882e3e6d12879b5d7eb"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a42a27c76bece1882e3e6d12879b5d7eb">mapToPhysicalFrame</a> (PhysPointViewType physPoints, const RefPointViewType refPoints, const WorksetCellViewType worksetCell, const shards::CellTopology cellTopo)</td></tr>
<tr class="memdesc:a42a27c76bece1882e3e6d12879b5d7eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <em>F</em>, the reference-to-physical frame map.  <br /></td></tr>
<tr class="separator:a42a27c76bece1882e3e6d12879b5d7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4e906b9b8ddf007e9d1602ae211cbb" id="r_a7b4e906b9b8ddf007e9d1602ae211cbb"><td class="memTemplParams" colspan="2">template&lt;typename refSubcellViewType , typename paramPointViewType &gt; </td></tr>
<tr class="memitem:a7b4e906b9b8ddf007e9d1602ae211cbb"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a7b4e906b9b8ddf007e9d1602ae211cbb">mapToReferenceSubcell</a> (refSubcellViewType refSubcellPoints, const paramPointViewType paramPoints, const ordinal_type subcellDim, const ordinal_type subcellOrd, const shards::CellTopology parentCell)</td></tr>
<tr class="memdesc:a7b4e906b9b8ddf007e9d1602ae211cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes parameterization maps of 1- and 2-subcells of reference cells.  <br /></td></tr>
<tr class="separator:a7b4e906b9b8ddf007e9d1602ae211cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd1d714bc14e5d95beb0c1913c7db37" id="r_a0fd1d714bc14e5d95beb0c1913c7db37"><td class="memTemplParams" colspan="2">template&lt;typename refSubcellViewType , typename paramPointViewType &gt; </td></tr>
<tr class="memitem:a0fd1d714bc14e5d95beb0c1913c7db37"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a0fd1d714bc14e5d95beb0c1913c7db37">mapToReferenceSubcell</a> (refSubcellViewType refSubcellPoints, const paramPointViewType paramPoints, const typename <a class="el" href="classIntrepid2_1_1RefSubcellParametrization.html">RefSubcellParametrization</a>&lt; DeviceType &gt;::ConstViewType subcellParametrization, const ordinal_type subcellOrd)</td></tr>
<tr class="memdesc:a0fd1d714bc14e5d95beb0c1913c7db37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes parameterization maps of 1- and 2-subcells of reference cells.  <br /></td></tr>
<tr class="separator:a0fd1d714bc14e5d95beb0c1913c7db37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc73d03e80a21b3aa2f3f5c22e404c3" id="r_abfc73d03e80a21b3aa2f3f5c22e404c3"><td class="memTemplParams" colspan="2">template&lt;typename refSubcellViewType , typename paramPointViewType , typename ordViewType &gt; </td></tr>
<tr class="memitem:abfc73d03e80a21b3aa2f3f5c22e404c3"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#abfc73d03e80a21b3aa2f3f5c22e404c3">mapToReferenceSubcell</a> (refSubcellViewType refSubcellPoints, const paramPointViewType paramPoints, const typename <a class="el" href="classIntrepid2_1_1RefSubcellParametrization.html">RefSubcellParametrization</a>&lt; DeviceType &gt;::ConstViewType subcellParametrization, const ordViewType subcellOrd)</td></tr>
<tr class="memdesc:abfc73d03e80a21b3aa2f3f5c22e404c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes parameterization maps of 1- and 2-subcells of reference cells.  <br /></td></tr>
<tr class="separator:abfc73d03e80a21b3aa2f3f5c22e404c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006dc4e9c5f5ac25be8b513b8f63ca04" id="r_a006dc4e9c5f5ac25be8b513b8f63ca04"><td class="memTemplParams" colspan="2">template&lt;typename refPointValueType , class ... refPointProperties, typename physPointValueType , class ... physPointProperties, typename worksetCellValueType , class ... worksetCellProperties&gt; </td></tr>
<tr class="memitem:a006dc4e9c5f5ac25be8b513b8f63ca04"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a006dc4e9c5f5ac25be8b513b8f63ca04">mapToReferenceFrame</a> (Kokkos::DynRankView&lt; refPointValueType, refPointProperties... &gt; refPoints, const Kokkos::DynRankView&lt; physPointValueType, physPointProperties... &gt; physPoints, const Kokkos::DynRankView&lt; worksetCellValueType, worksetCellProperties... &gt; worksetCell, const shards::CellTopology cellTopo)</td></tr>
<tr class="memdesc:a006dc4e9c5f5ac25be8b513b8f63ca04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <picture><source srcset="form_76_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F^{-1}_{c} $" src="form_76.png" width="23" height="15"/></picture>, the inverse of the reference-to-physical frame map using a default initial guess.  <br /></td></tr>
<tr class="separator:a006dc4e9c5f5ac25be8b513b8f63ca04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b08ff3ec8d107e2ee85036f4f6e2025" id="r_a6b08ff3ec8d107e2ee85036f4f6e2025"><td class="memTemplParams" colspan="2">template&lt;typename refPointValueType , class ... refPointProperties, typename initGuessValueType , class ... initGuessProperties, typename physPointValueType , class ... physPointProperties, typename worksetCellValueType , class ... worksetCellProperties, typename HGradBasisPtrType &gt; </td></tr>
<tr class="memitem:a6b08ff3ec8d107e2ee85036f4f6e2025"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a6b08ff3ec8d107e2ee85036f4f6e2025">mapToReferenceFrameInitGuess</a> (Kokkos::DynRankView&lt; refPointValueType, refPointProperties... &gt; refPoints, const Kokkos::DynRankView&lt; initGuessValueType, initGuessProperties... &gt; initGuess, const Kokkos::DynRankView&lt; physPointValueType, physPointProperties... &gt; physPoints, const Kokkos::DynRankView&lt; worksetCellValueType, worksetCellProperties... &gt; worksetCell, const HGradBasisPtrType basis)</td></tr>
<tr class="memdesc:a6b08ff3ec8d107e2ee85036f4f6e2025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computation of <picture><source srcset="form_76_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F^{-1}_{c} $" src="form_76.png" width="23" height="15"/></picture>, the inverse of the reference-to-physical frame map using user-supplied initial guess.  <br /></td></tr>
<tr class="separator:a6b08ff3ec8d107e2ee85036f4f6e2025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069100237b73970c9e72252d95dc2289" id="r_a069100237b73970c9e72252d95dc2289"><td class="memTemplParams" colspan="2">template&lt;typename refPointValueType , class ... refPointProperties, typename initGuessValueType , class ... initGuessProperties, typename physPointValueType , class ... physPointProperties, typename worksetCellValueType , class ... worksetCellProperties&gt; </td></tr>
<tr class="memitem:a069100237b73970c9e72252d95dc2289"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a069100237b73970c9e72252d95dc2289">mapToReferenceFrameInitGuess</a> (Kokkos::DynRankView&lt; refPointValueType, refPointProperties... &gt; refPoints, const Kokkos::DynRankView&lt; initGuessValueType, initGuessProperties... &gt; initGuess, const Kokkos::DynRankView&lt; physPointValueType, physPointProperties... &gt; physPoints, const Kokkos::DynRankView&lt; worksetCellValueType, worksetCellProperties... &gt; worksetCell, const shards::CellTopology cellTopo)</td></tr>
<tr class="memdesc:a069100237b73970c9e72252d95dc2289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computation of <picture><source srcset="form_76_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F^{-1}_{c} $" src="form_76.png" width="23" height="15"/></picture>, the inverse of the reference-to-physical frame map using user-supplied initial guess.  <br /></td></tr>
<tr class="separator:a069100237b73970c9e72252d95dc2289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2dc9c2a5aff2b205be105a1536e1e8" id="r_a4c2dc9c2a5aff2b205be105a1536e1e8"><td class="memTemplParams" colspan="2">template&lt;typename subcvCoordValueType , class ... subcvCoordProperties, typename cellCoordValueType , class ... cellCoordProperties&gt; </td></tr>
<tr class="memitem:a4c2dc9c2a5aff2b205be105a1536e1e8"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a4c2dc9c2a5aff2b205be105a1536e1e8">getSubcvCoords</a> (Kokkos::DynRankView&lt; subcvCoordValueType, subcvCoordProperties... &gt; subcvCoords, const Kokkos::DynRankView&lt; cellCoordValueType, cellCoordProperties... &gt; cellCoords, const shards::CellTopology primaryCell)</td></tr>
<tr class="memdesc:a4c2dc9c2a5aff2b205be105a1536e1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes coordinates of sub-control volumes in each primary cell.  <br /></td></tr>
<tr class="separator:a4c2dc9c2a5aff2b205be105a1536e1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0831be92f02c6e6b51bd2a7cf877519d" id="r_a0831be92f02c6e6b51bd2a7cf877519d"><td class="memTemplParams" colspan="2">template&lt;typename PointViewType &gt; </td></tr>
<tr class="memitem:a0831be92f02c6e6b51bd2a7cf877519d"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a0831be92f02c6e6b51bd2a7cf877519d">checkPointInclusion</a> (const PointViewType point, const shards::CellTopology cellTopo, const typename <a class="el" href="structIntrepid2_1_1ScalarTraits.html">ScalarTraits</a>&lt; typename PointViewType::value_type &gt;::scalar_type thres=threshold&lt; typename <a class="el" href="structIntrepid2_1_1ScalarTraits.html">ScalarTraits</a>&lt; typename PointViewType::value_type &gt;::scalar_type &gt;())</td></tr>
<tr class="memdesc:a0831be92f02c6e6b51bd2a7cf877519d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a point belongs to a reference cell.  <br /></td></tr>
<tr class="separator:a0831be92f02c6e6b51bd2a7cf877519d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d5a76a0e56dc3ad21cd698c8ba92ef" id="r_ae5d5a76a0e56dc3ad21cd698c8ba92ef"><td class="memTemplParams" colspan="2">template&lt;unsigned cellTopologyKey, typename OutputViewType , typename InputViewType &gt; </td></tr>
<tr class="memitem:ae5d5a76a0e56dc3ad21cd698c8ba92ef"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#ae5d5a76a0e56dc3ad21cd698c8ba92ef">checkPointwiseInclusion</a> (OutputViewType inCell, const InputViewType points, const typename <a class="el" href="structIntrepid2_1_1ScalarTraits.html">ScalarTraits</a>&lt; typename InputViewType::value_type &gt;::scalar_type thresh=threshold&lt; typename <a class="el" href="structIntrepid2_1_1ScalarTraits.html">ScalarTraits</a>&lt; typename InputViewType::value_type &gt;::scalar_type &gt;())</td></tr>
<tr class="memdesc:ae5d5a76a0e56dc3ad21cd698c8ba92ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks every point for inclusion in the reference cell of a given topology. The points can belong to a global set and stored in a rank-2 view (P,D) , or to multiple sets indexed by a cell ordinal and stored in a rank-3 view (C,P,D). The cell topology key is a template argument. Requires cell topology with a reference cell.  <br /></td></tr>
<tr class="separator:ae5d5a76a0e56dc3ad21cd698c8ba92ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f843f79de3e7a1b342f1ff7c16983d" id="r_ab6f843f79de3e7a1b342f1ff7c16983d"><td class="memTemplParams" colspan="2">template&lt;typename InCellViewType , typename PointViewType &gt; </td></tr>
<tr class="memitem:ab6f843f79de3e7a1b342f1ff7c16983d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#ab6f843f79de3e7a1b342f1ff7c16983d">checkPointwiseInclusion</a> (InCellViewType inCell, const PointViewType points, const shards::CellTopology cellTopo, const typename <a class="el" href="structIntrepid2_1_1ScalarTraits.html">ScalarTraits</a>&lt; typename PointViewType::value_type &gt;::scalar_type thres=threshold&lt; typename <a class="el" href="structIntrepid2_1_1ScalarTraits.html">ScalarTraits</a>&lt; typename PointViewType::value_type &gt;::scalar_type &gt;())</td></tr>
<tr class="memdesc:ab6f843f79de3e7a1b342f1ff7c16983d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks every point in multiple sets indexed by a cell ordinal for inclusion in the reference cell of a given topology. Requires cell topology with a reference cell.  <br /></td></tr>
<tr class="separator:ab6f843f79de3e7a1b342f1ff7c16983d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e163b90214964f7d79a30f4c51ea82" id="r_a53e163b90214964f7d79a30f4c51ea82"><td class="memTemplParams" colspan="2">template&lt;typename inCellValueType , class ... inCellProperties, typename pointValueType , class ... pointProperties, typename cellWorksetValueType , class ... cellWorksetProperties&gt; </td></tr>
<tr class="memitem:a53e163b90214964f7d79a30f4c51ea82"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a53e163b90214964f7d79a30f4c51ea82">checkPointwiseInclusion</a> (Kokkos::DynRankView&lt; inCellValueType, inCellProperties... &gt; inCell, const Kokkos::DynRankView&lt; pointValueType, pointProperties... &gt; points, const Kokkos::DynRankView&lt; cellWorksetValueType, cellWorksetProperties... &gt; cellWorkset, const shards::CellTopology cellTopo, const typename <a class="el" href="structIntrepid2_1_1ScalarTraits.html">ScalarTraits</a>&lt; pointValueType &gt;::scalar_type thres=threshold&lt; typename <a class="el" href="structIntrepid2_1_1ScalarTraits.html">ScalarTraits</a>&lt; pointValueType &gt;::scalar_type &gt;())</td></tr>
<tr class="memdesc:a53e163b90214964f7d79a30f4c51ea82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks every points for inclusion in physical cells from a cell workset. The points can belong to a global set and stored in a rank-2 (P,D) view, or to multiple sets indexed by a cell ordinal and stored in a rank-3 (C,P,D) view cells in a cell workset.  <br /></td></tr>
<tr class="separator:a53e163b90214964f7d79a30f4c51ea82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a1708f89f20a2b99bdd02cdef9e07e1f2" id="r_a1708f89f20a2b99bdd02cdef9e07e1f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a1708f89f20a2b99bdd02cdef9e07e1f2">ExecSpaceType</a> = typename DeviceType::execution_space</td></tr>
<tr class="separator:a1708f89f20a2b99bdd02cdef9e07e1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d1a19112a7ef620be067c43119c4c3" id="r_a09d1a19112a7ef620be067c43119c4c3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a09d1a19112a7ef620be067c43119c4c3">MemSpaceType</a> = typename DeviceType::memory_space</td></tr>
<tr class="separator:a09d1a19112a7ef620be067c43119c4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a046c51a9ac2de45222ad3c592f1d95cc" id="r_a046c51a9ac2de45222ad3c592f1d95cc"><td class="memTemplParams" colspan="2">template&lt;typename outputValueType , typename pointValueType &gt; </td></tr>
<tr class="memitem:a046c51a9ac2de45222ad3c592f1d95cc"><td class="memTemplItemLeft" align="right" valign="top">static Teuchos::RCP&lt; <a class="el" href="classIntrepid2_1_1Basis.html">Basis</a>&lt; DeviceType, outputValueType, pointValueType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1CellTools.html#a046c51a9ac2de45222ad3c592f1d95cc">createHGradBasis</a> (const shards::CellTopology cellTopo)</td></tr>
<tr class="memdesc:a046c51a9ac2de45222ad3c592f1d95cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates default HGrad basis based on cell topology.  <br /></td></tr>
<tr class="separator:a046c51a9ac2de45222ad3c592f1d95cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename DeviceType&gt;<br />
class Intrepid2::CellTools&lt; DeviceType &gt;</div><p>A stateless class for operations on cell data. Provides methods for: </p>
<ul>
<li>computing Jacobians of reference-to-physical frame mappings, their inverses and determinants </li>
<li>application of the reference-to-physical frame mapping and its inverse </li>
<li>parametrizations of edges and faces of reference cells needed for edge and face integrals, </li>
<li>computation of edge and face tangents and face normals on both reference and physical frames </li>
<li>inclusion tests for point sets in reference and physical cells. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellTools_8hpp_source.html#l00077">77</a> of file <a class="el" href="Intrepid2__CellTools_8hpp_source.html">Intrepid2_CellTools.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1708f89f20a2b99bdd02cdef9e07e1f2" name="a1708f89f20a2b99bdd02cdef9e07e1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1708f89f20a2b99bdd02cdef9e07e1f2">&#9670;&#160;</a></span>ExecSpaceType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::ExecSpaceType =  typename DeviceType::execution_space</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellTools_8hpp_source.html#l00078">78</a> of file <a class="el" href="Intrepid2__CellTools_8hpp_source.html">Intrepid2_CellTools.hpp</a>.</p>

</div>
</div>
<a id="a09d1a19112a7ef620be067c43119c4c3" name="a09d1a19112a7ef620be067c43119c4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d1a19112a7ef620be067c43119c4c3">&#9670;&#160;</a></span>MemSpaceType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::MemSpaceType =  typename DeviceType::memory_space</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellTools_8hpp_source.html#l00079">79</a> of file <a class="el" href="Intrepid2__CellTools_8hpp_source.html">Intrepid2_CellTools.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a35a5b4e652b87c54c24879492957007d" name="a35a5b4e652b87c54c24879492957007d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a5b4e652b87c54c24879492957007d">&#9670;&#160;</a></span>allocateJacobianDet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;class PointScalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt; <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::allocateJacobianDet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>jacobian</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates and returns a <a class="el" href="classIntrepid2_1_1Data.html" title="Wrapper around a Kokkos::View that allows data that is constant or repeating in various logical dimen...">Data</a> container suitable for storing determinants corresponding to the Jacobians in the <a class="el" href="classIntrepid2_1_1Data.html" title="Wrapper around a Kokkos::View that allows data that is constant or repeating in various logical dimen...">Data</a> container provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jacobian</td><td>[in] - data with shape (C,P,D,D), as returned by <a class="el" href="classIntrepid2_1_1CellGeometry.html#aa13bcb4a1ab79a83b5a4c5a27724c903" title="Allocate a container into which Jacobians of the reference-to-physical mapping can be placed.">CellGeometry::allocateJacobianData()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classIntrepid2_1_1Data.html" title="Wrapper around a Kokkos::View that allows data that is constant or repeating in various logical dimen...">Data</a> container with shape (C,P) </dd></dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefJacobian_8hpp_source.html#l00092">92</a> of file <a class="el" href="Intrepid2__CellToolsDefJacobian_8hpp_source.html">Intrepid2_CellToolsDefJacobian.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__DataVariationType_8hpp_source.html#l00040">Intrepid2::CONSTANT</a>, <a class="el" href="Intrepid2__Data_8hpp_source.html#l00865">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::getExtents()</a>, <a class="el" href="Intrepid2__Utils_8hpp_source.html#l00336">Intrepid2::getMatchingViewWithLabel()</a>, <a class="el" href="Intrepid2__Data_8hpp_source.html#l00984">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::getUnderlyingView1()</a>, <a class="el" href="Intrepid2__Data_8hpp_source.html#l00998">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::getUnderlyingView3()</a>, <a class="el" href="Intrepid2__Data_8hpp_source.html#l01005">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::getUnderlyingView4()</a>, and <a class="el" href="Intrepid2__Data_8hpp_source.html#l01168">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::getVariationTypes()</a>.</p>

</div>
</div>
<a id="a8db99befc25604df89bb0029e5eeae09" name="a8db99befc25604df89bb0029e5eeae09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db99befc25604df89bb0029e5eeae09">&#9670;&#160;</a></span>allocateJacobianInv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;class PointScalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt; <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::allocateJacobianInv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>jacobian</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates and returns a <a class="el" href="classIntrepid2_1_1Data.html" title="Wrapper around a Kokkos::View that allows data that is constant or repeating in various logical dimen...">Data</a> container suitable for storing inverses corresponding to the Jacobians in the <a class="el" href="classIntrepid2_1_1Data.html" title="Wrapper around a Kokkos::View that allows data that is constant or repeating in various logical dimen...">Data</a> container provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jacobian</td><td>[in] - data with shape (C,P,D,D), as returned by <a class="el" href="classIntrepid2_1_1CellGeometry.html#aa13bcb4a1ab79a83b5a4c5a27724c903" title="Allocate a container into which Jacobians of the reference-to-physical mapping can be placed.">CellGeometry::allocateJacobianData()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classIntrepid2_1_1Data.html" title="Wrapper around a Kokkos::View that allows data that is constant or repeating in various logical dimen...">Data</a> container with shape (C,P,D,D) </dd></dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefJacobian_8hpp_source.html#l00126">126</a> of file <a class="el" href="Intrepid2__CellToolsDefJacobian_8hpp_source.html">Intrepid2_CellToolsDefJacobian.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__Data_8hpp_source.html#l00865">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::getExtents()</a>, <a class="el" href="Intrepid2__Utils_8hpp_source.html#l00336">Intrepid2::getMatchingViewWithLabel()</a>, <a class="el" href="Intrepid2__Data_8hpp_source.html#l00984">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::getUnderlyingView1()</a>, <a class="el" href="Intrepid2__Data_8hpp_source.html#l00991">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::getUnderlyingView2()</a>, <a class="el" href="Intrepid2__Data_8hpp_source.html#l00998">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::getUnderlyingView3()</a>, <a class="el" href="Intrepid2__Data_8hpp_source.html#l01005">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::getUnderlyingView4()</a>, <a class="el" href="Intrepid2__Data_8hpp_source.html#l01049">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::getUnderlyingViewRank()</a>, <a class="el" href="Intrepid2__Data_8hpp_source.html#l01168">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::getVariationTypes()</a>, and <a class="el" href="Intrepid2__Utils_8hpp_source.html#l00070">INTREPID2_TEST_FOR_EXCEPTION_DEVICE_SAFE</a>.</p>

</div>
</div>
<a id="a0831be92f02c6e6b51bd2a7cf877519d" name="a0831be92f02c6e6b51bd2a7cf877519d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0831be92f02c6e6b51bd2a7cf877519d">&#9670;&#160;</a></span>checkPointInclusion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename PointViewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::checkPointInclusion </td>
          <td>(</td>
          <td class="paramtype">const PointViewType&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>cellTopo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structIntrepid2_1_1ScalarTraits.html">ScalarTraits</a>&lt; typename PointViewType::value_type &gt;::scalar_type&#160;</td>
          <td class="paramname"><em>thres</em> = <code>threshold&lt;typename&#160;<a class="el" href="structIntrepid2_1_1ScalarTraits.html">ScalarTraits</a>&lt;typename&#160;PointViewType::value_type&gt;::scalar_type&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a point belongs to a reference cell. </p>
<p>Requires cell topology with a reference cell.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>[in] - rank-1 view (D) of the point tested for inclusion </td></tr>
    <tr><td class="paramname">cellTopo</td><td>[in] - cell topology </td></tr>
    <tr><td class="paramname">threshold</td><td>[in] - "tightness" of the inclusion test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the point is in the closure of the specified reference cell and false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefInclusion_8hpp_source.html#l00036">36</a> of file <a class="el" href="Intrepid2__CellToolsDefInclusion_8hpp_source.html">Intrepid2_CellToolsDefInclusion.hpp</a>.</p>

</div>
</div>
<a id="a1ce0b6722af0b2447b5301333bdd4dbf" name="a1ce0b6722af0b2447b5301333bdd4dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce0b6722af0b2447b5301333bdd4dbf">&#9670;&#160;</a></span>checkPointwiseInclusion() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename InCellViewType , typename InputViewType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::checkPointwiseInclusion </td>
          <td>(</td>
          <td class="paramtype">InCellViewType&#160;</td>
          <td class="paramname"><em>inCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputViewType&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>cellTopo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structIntrepid2_1_1ScalarTraits.html">ScalarTraits</a>&lt; typename InputViewType::value_type &gt;::scalar_type&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefInclusion_8hpp_source.html#l00150">150</a> of file <a class="el" href="Intrepid2__CellToolsDefInclusion_8hpp_source.html">Intrepid2_CellToolsDefInclusion.hpp</a>.</p>

</div>
</div>
<a id="ab6f843f79de3e7a1b342f1ff7c16983d" name="ab6f843f79de3e7a1b342f1ff7c16983d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f843f79de3e7a1b342f1ff7c16983d">&#9670;&#160;</a></span>checkPointwiseInclusion() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename InCellViewType , typename PointViewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::checkPointwiseInclusion </td>
          <td>(</td>
          <td class="paramtype">InCellViewType&#160;</td>
          <td class="paramname"><em>inCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointViewType&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>cellTopo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structIntrepid2_1_1ScalarTraits.html">ScalarTraits</a>&lt; typename PointViewType::value_type &gt;::scalar_type&#160;</td>
          <td class="paramname"><em>thres</em> = <code>threshold&lt;&#160;typename&#160;<a class="el" href="structIntrepid2_1_1ScalarTraits.html">ScalarTraits</a>&lt;&#160;typename&#160;PointViewType::value_type&#160;&gt;::scalar_type&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks every point in multiple sets indexed by a cell ordinal for inclusion in the reference cell of a given topology. Requires cell topology with a reference cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inRefCell</td><td>[out] - rank-2 view (C,P) with results from the pointwise inclusion test </td></tr>
    <tr><td class="paramname">refPoints</td><td>[in] - rank-3 view (C,P,D) </td></tr>
    <tr><td class="paramname">cellTopo</td><td>[in] - cell topology </td></tr>
    <tr><td class="paramname">threshold</td><td>[in] - "tightness" of the inclusion test </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53e163b90214964f7d79a30f4c51ea82" name="a53e163b90214964f7d79a30f4c51ea82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e163b90214964f7d79a30f4c51ea82">&#9670;&#160;</a></span>checkPointwiseInclusion() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename inCellValueType , class ... inCellProperties, typename pointValueType , class ... pointProperties, typename cellWorksetValueType , class ... cellWorksetProperties&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::checkPointwiseInclusion </td>
          <td>(</td>
          <td class="paramtype">Kokkos::DynRankView&lt; inCellValueType, inCellProperties... &gt;&#160;</td>
          <td class="paramname"><em>inCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::DynRankView&lt; pointValueType, pointProperties... &gt;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::DynRankView&lt; cellWorksetValueType, cellWorksetProperties... &gt;&#160;</td>
          <td class="paramname"><em>cellWorkset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>cellTopo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structIntrepid2_1_1ScalarTraits.html">ScalarTraits</a>&lt; pointValueType &gt;::scalar_type&#160;</td>
          <td class="paramname"><em>thres</em> = <code>threshold&lt;typename&#160;<a class="el" href="structIntrepid2_1_1ScalarTraits.html">ScalarTraits</a>&lt;pointValueType&gt;::scalar_type&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks every points for inclusion in physical cells from a cell workset. The points can belong to a global set and stored in a rank-2 (P,D) view, or to multiple sets indexed by a cell ordinal and stored in a rank-3 (C,P,D) view cells in a cell workset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inCell</td><td>[out] - rank-2 view (P,D) with results from the pointwise inclusion test </td></tr>
    <tr><td class="paramname">points</td><td>[in] - rank-2 view (P,D) or rank-3 view (C,P,D) with the physical points </td></tr>
    <tr><td class="paramname">cellWorkset</td><td>[in] - rank-3 view with dimensions (C,N,D) with the nodes of the cell workset </td></tr>
    <tr><td class="paramname">cellTopo</td><td>[in] - cell topology </td></tr>
    <tr><td class="paramname">threshold</td><td>[in] - tolerance for inclusion tests on the input points </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefInclusion_8hpp_source.html#l00215">215</a> of file <a class="el" href="Intrepid2__CellToolsDefInclusion_8hpp_source.html">Intrepid2_CellToolsDefInclusion.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__RealSpaceToolsDef_8hpp_source.html#l00301">Intrepid2::RealSpaceTools&lt; DeviceType &gt;::clone()</a>.</p>

</div>
</div>
<a id="ae5d5a76a0e56dc3ad21cd698c8ba92ef" name="ae5d5a76a0e56dc3ad21cd698c8ba92ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d5a76a0e56dc3ad21cd698c8ba92ef">&#9670;&#160;</a></span>checkPointwiseInclusion() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;unsigned cellTopologyKey, typename OutputViewType , typename InputViewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::checkPointwiseInclusion </td>
          <td>(</td>
          <td class="paramtype">OutputViewType&#160;</td>
          <td class="paramname"><em>inCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputViewType&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structIntrepid2_1_1ScalarTraits.html">ScalarTraits</a>&lt; typename InputViewType::value_type &gt;::scalar_type&#160;</td>
          <td class="paramname"><em>thresh</em> = <code>threshold&lt;typename&#160;<a class="el" href="structIntrepid2_1_1ScalarTraits.html">ScalarTraits</a>&lt;typename&#160;InputViewType::value_type&gt;::scalar_type&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks every point for inclusion in the reference cell of a given topology. The points can belong to a global set and stored in a rank-2 view (P,D) , or to multiple sets indexed by a cell ordinal and stored in a rank-3 view (C,P,D). The cell topology key is a template argument. Requires cell topology with a reference cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inCell</td><td>[out] - rank-1 view (P) or rank-2 view (C,P). On return, its entries will be set to 1 or 0 depending on whether points are included in cells </td></tr>
    <tr><td class="paramname">point</td><td>[in] - rank-2 view (P,D) or rank-3 view (C,P,D) with reference coordinates of the points tested for inclusion </td></tr>
    <tr><td class="paramname">threshold</td><td>[in] - "tightness" of the inclusion test </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefInclusion_8hpp_source.html#l00130">130</a> of file <a class="el" href="Intrepid2__CellToolsDefInclusion_8hpp_source.html">Intrepid2_CellToolsDefInclusion.hpp</a>.</p>

</div>
</div>
<a id="a046c51a9ac2de45222ad3c592f1d95cc" name="a046c51a9ac2de45222ad3c592f1d95cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a046c51a9ac2de45222ad3c592f1d95cc">&#9670;&#160;</a></span>createHGradBasis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename outputValueType , typename pointValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Teuchos::RCP&lt; <a class="el" href="classIntrepid2_1_1Basis.html">Basis</a>&lt; DeviceType, outputValueType, pointValueType &gt; &gt; <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::createHGradBasis </td>
          <td>(</td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>cellTopo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates default HGrad basis based on cell topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cellTopo</td><td>[in] - cell topology </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellTools_8hpp_source.html#l00100">100</a> of file <a class="el" href="Intrepid2__CellTools_8hpp_source.html">Intrepid2_CellTools.hpp</a>.</p>

</div>
</div>
<a id="af718bc465adbe467409a07fd67750be3" name="af718bc465adbe467409a07fd67750be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af718bc465adbe467409a07fd67750be3">&#9670;&#160;</a></span>getPhysicalEdgeTangents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename edgeTangentValueType , class ... edgeTangentProperties, typename worksetJacobianValueType , class ... worksetJacobianProperties, typename edgeOrdValueType , class ... edgeOrdProperties&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::getPhysicalEdgeTangents </td>
          <td>(</td>
          <td class="paramtype">Kokkos::DynRankView&lt; edgeTangentValueType, edgeTangentProperties... &gt;&#160;</td>
          <td class="paramname"><em>edgeTangents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::DynRankView&lt; worksetJacobianValueType, worksetJacobianProperties... &gt;&#160;</td>
          <td class="paramname"><em>worksetJacobians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::DynRankView&lt; edgeOrdValueType, edgeOrdProperties... &gt;&#160;</td>
          <td class="paramname"><em>worksetEdgeOrds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>parentCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes non-normalized tangent vectors to physical edges in an edge workset <picture><source srcset="form_32_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\mathcal{E}_{c,i}\}_{c=0}^{N}$" src="form_32.png" width="48" height="15"/></picture>; (see <a class="el" href="cell_tools_page.html#sec_cell_topology_subcell_wset">Subcell worksets</a> for definition of edge worksets). </p>
<p>It is similar to the <em><a class="el" href="classIntrepid2_1_1CellTools.html#abdcb3e5c24c9ca6dc47c79a7b0193374" title="Computes non-normalized tangent vectors to physical edges in an edge workset ; (see Subcell worksets ...">CellTools::getPhysicalEdgeTangents</a></em> function above, with the difference that the edge ordinal can change from point to point, and it is provided by the rank-2 input array <em><b>worksetEdgeOrds</b></em>, indexed by (C,P).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeTangents</td><td>[out] - rank-3 array (C,P,D1) with tangents on workset edges </td></tr>
    <tr><td class="paramname">worksetJacobians</td><td>[in] - rank-4 array (C,P,D1,D1) with Jacobians evaluated at ref. edge points </td></tr>
    <tr><td class="paramname">worksetEdgeOrds</td><td>[in] - rank-2 array (C,P) with edge ordinals, relative to ref. cell, of the edge workset </td></tr>
    <tr><td class="paramname">parentCell</td><td>[in] - cell topology of the parent reference cell </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html#l00453">453</a> of file <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html">Intrepid2_CellToolsDefNodeInfo.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__CellDataDef_8hpp_source.html#l00069">Intrepid2::RefSubcellParametrization&lt; DeviceType &gt;::get()</a>, and <a class="el" href="Intrepid2__RealSpaceToolsDef_8hpp_source.html#l01356">Intrepid2::RealSpaceTools&lt; DeviceType &gt;::matvec()</a>.</p>

</div>
</div>
<a id="abdcb3e5c24c9ca6dc47c79a7b0193374" name="abdcb3e5c24c9ca6dc47c79a7b0193374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcb3e5c24c9ca6dc47c79a7b0193374">&#9670;&#160;</a></span>getPhysicalEdgeTangents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename edgeTangentValueType , class ... edgeTangentProperties, typename worksetJacobianValueType , class ... worksetJacobianProperties&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::getPhysicalEdgeTangents </td>
          <td>(</td>
          <td class="paramtype">Kokkos::DynRankView&lt; edgeTangentValueType, edgeTangentProperties... &gt;&#160;</td>
          <td class="paramname"><em>edgeTangents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::DynRankView&lt; worksetJacobianValueType, worksetJacobianProperties... &gt;&#160;</td>
          <td class="paramname"><em>worksetJacobians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ordinal_type&#160;</td>
          <td class="paramname"><em>worksetEdgeOrd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>parentCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes non-normalized tangent vectors to physical edges in an edge workset <picture><source srcset="form_32_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\mathcal{E}_{c,i}\}_{c=0}^{N}$" src="form_32.png" width="48" height="15"/></picture>; (see <a class="el" href="cell_tools_page.html#sec_cell_topology_subcell_wset">Subcell worksets</a> for definition of edge worksets). </p>
<p>For every edge in the workset the tangents are computed at the points <picture><source srcset="form_33_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="${\bf x}_p = F_c(\hat{\Phi}_i(t_p))\in\mathcal{E}_{c,i}$" src="form_33.png" width="120" height="16"/></picture> that are images of points from <em>R=[-1,1]</em> on edge <picture><source srcset="form_34_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\mathcal{E}_{c,i}$" src="form_34.png" width="19" height="14"/></picture>. Returns rank-3 array with dimensions (C,P,D1), D1=2 or D1=3 such that  </p><p class="formulaDsp">
<picture><source srcset="form_35_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
{edgeTangents}(c,p,d) =
DF_c(\hat{\Phi}_i(t_p))\cdot {\partial{\hat{\Phi}}_{i}(t_p)\over\partial t}\,; \qquad t_p \in R
\]" src="form_35.png" width="320" height="30"/></picture>
</p>
<p> In this formula: </p><ul>
<li><picture><source srcset="form_36_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ DF_c $" src="form_36.png" width="24" height="13"/></picture> is Jacobian of parent cell <picture><source srcset="form_37_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="${\mathcal C}$" src="form_37.png" width="9" height="11"/></picture> that owns physical edge <picture><source srcset="form_38_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="${\mathcal E}_{c,i}$" src="form_38.png" width="19" height="14"/></picture>; </li>
<li><picture><source srcset="form_39_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ {\partial{\hat{\Phi}}_{i}/\partial t}$" src="form_39.png" width="39" height="16"/></picture> is the (constant) tangent to reference edge <picture><source srcset="form_7_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\mathcal E}_i$" src="form_7.png" width="11" height="15"/></picture>; see <a class="el" href="classIntrepid2_1_1CellTools.html#afa7e6b7811ff106bcdf2a3d298d6f27d" title="Computes constant tangent vectors to edges of 2D or 3D reference cells.">Intrepid2::CellTools::getReferenceEdgeTangent</a> that has the same local ordinal as the edges in the workset; </li>
<li><picture><source srcset="form_40_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \hat{\Phi}_i R\mapsto\hat{\mathcal E}_i $" src="form_40.png" width="53" height="15"/></picture> is parametrization of reference edge <picture><source srcset="form_7_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\mathcal E}_i$" src="form_7.png" width="11" height="15"/></picture>;</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd><code>worksetJacobians</code> must contain the values of <picture><source srcset="form_41_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$DF_c(\hat{\Phi}_i(t_p))$" src="form_41.png" width="65" height="16"/></picture>, where <picture><source srcset="form_42_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ t_p \in R=[-1,1] $" src="form_42.png" width="86" height="14"/></picture>, i.e., Jacobians of the parent cells evaluated at points that are located on reference edge <picture><source srcset="form_7_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\mathcal E}_i$" src="form_7.png" width="11" height="15"/></picture> having the same local ordinal as the edges in the workset.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeTangents</td><td>[out] - rank-3 array (C,P,D1) with tangents on workset edges </td></tr>
    <tr><td class="paramname">worksetJacobians</td><td>[in] - rank-4 array (C,P,D1,D1) with Jacobians evaluated at ref. edge points </td></tr>
    <tr><td class="paramname">worksetEdgeOrd</td><td>[in] - edge ordinal, relative to ref. cell, of the edge workset </td></tr>
    <tr><td class="paramname">parentCell</td><td>[in] - cell topology of the parent reference cell </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html#l00371">371</a> of file <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html">Intrepid2_CellToolsDefNodeInfo.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__RealSpaceToolsDef_8hpp_source.html#l01356">Intrepid2::RealSpaceTools&lt; DeviceType &gt;::matvec()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Intrepid2__FunctionSpaceToolsDef_8hpp_source.html#l00630">Intrepid2::FunctionSpaceTools&lt; DeviceType &gt;::computeEdgeMeasure()</a>.</p>

</div>
</div>
<a id="a6d1f977298b3b7db2941f15b2c3fea0b" name="a6d1f977298b3b7db2941f15b2c3fea0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1f977298b3b7db2941f15b2c3fea0b">&#9670;&#160;</a></span>getPhysicalFaceNormals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename faceNormalValueType , class ... faceNormalProperties, typename worksetJacobianValueType , class ... worksetJacobianProperties, typename faceOrdValueType , class ... faceOrdProperties&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::getPhysicalFaceNormals </td>
          <td>(</td>
          <td class="paramtype">Kokkos::DynRankView&lt; faceNormalValueType, faceNormalProperties... &gt;&#160;</td>
          <td class="paramname"><em>faceNormals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::DynRankView&lt; worksetJacobianValueType, worksetJacobianProperties... &gt;&#160;</td>
          <td class="paramname"><em>worksetJacobians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::DynRankView&lt; faceOrdValueType, faceOrdProperties... &gt;&#160;</td>
          <td class="paramname"><em>worksetFaceOrds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>parentCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes non-normalized normal vectors to physical faces in a face workset <picture><source srcset="form_43_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\mathcal{F}_{c,i}\}_{c=0}^{N}$" src="form_43.png" width="50" height="15"/></picture>; (see <a class="el" href="cell_tools_page.html#sec_cell_topology_subcell_wset">Subcell worksets</a> for definition of face worksets). It is similar to the <em><a class="el" href="classIntrepid2_1_1CellTools.html#afff60692c07fe1a6f223273bb8ed87a9" title="Computes non-normalized normal vectors to physical sides in a side workset .">CellTools::getPhysicalSideNormals</a></em> function above, with the difference that the side ordinal can change from point to point, and it is provided by the rank-2 input array <em><b>worksetSideOrds</b></em>, indexed by (C,P). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">faceNormals</td><td>[out] - rank-3 array (C,P,D), normals at workset faces </td></tr>
    <tr><td class="paramname">worksetJacobians</td><td>[in] - rank-4 array (C,P,D,D) with Jacobians at ref. face points </td></tr>
    <tr><td class="paramname">worksetFaceOrds</td><td>[in] - rank-2 array (C,P) with face ordinals, relative to ref. cell, of the face workset </td></tr>
    <tr><td class="paramname">parentCell</td><td>[in] - cell topology of the parent reference cell </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html#l00874">874</a> of file <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html">Intrepid2_CellToolsDefNodeInfo.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__RealSpaceToolsDef_8hpp_source.html#l01546">Intrepid2::RealSpaceTools&lt; DeviceType &gt;::vecprod()</a>.</p>

</div>
</div>
<a id="a6a5cb629eaa691a2cb841e04df0911e8" name="a6a5cb629eaa691a2cb841e04df0911e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5cb629eaa691a2cb841e04df0911e8">&#9670;&#160;</a></span>getPhysicalFaceNormals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename faceNormalValueType , class ... faceNormalProperties, typename worksetJacobianValueType , class ... worksetJacobianProperties&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::getPhysicalFaceNormals </td>
          <td>(</td>
          <td class="paramtype">Kokkos::DynRankView&lt; faceNormalValueType, faceNormalProperties... &gt;&#160;</td>
          <td class="paramname"><em>faceNormals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::DynRankView&lt; worksetJacobianValueType, worksetJacobianProperties... &gt;&#160;</td>
          <td class="paramname"><em>worksetJacobians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ordinal_type&#160;</td>
          <td class="paramname"><em>worksetFaceOrd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>parentCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes non-normalized normal vectors to physical faces in a face workset <picture><source srcset="form_43_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\mathcal{F}_{c,i}\}_{c=0}^{N}$" src="form_43.png" width="50" height="15"/></picture>; (see <a class="el" href="cell_tools_page.html#sec_cell_topology_subcell_wset">Subcell worksets</a> for definition of face worksets). </p>
<p>For every face in the workset the normals are computed at the points <picture><source srcset="form_44_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="${\bf x}_p = F_c(\hat{\Phi}_i(u_p,v_p))\in\mathcal{F}_{c,i}$" src="form_44.png" width="143" height="16"/></picture> that are images of points from the parametrization domain <em>R</em> on face <picture><source srcset="form_45_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\mathcal{F}_{c,i}$" src="form_45.png" width="21" height="14"/></picture>. Returns rank-3 array with dimensions (C,P,D), D=3, such that  </p><p class="formulaDsp">
<picture><source srcset="form_65_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
{faceNormals}(c,p,d) =
\left( DF_c(\hat{\Phi}_i(u_p, v_p))\cdot {\partial\hat{\Phi}_i\over\partial u}\right) \times
\left( DF_c(\hat{\Phi}_i(u_p, v_p))\cdot {\partial\hat{\Phi}_i\over\partial v}\right) \,;
\qquad (u_p, v_p) \in R \,.
\]" src="form_65.png" width="523" height="39"/></picture>
</p>
<p> In this formula: </p><ul>
<li><picture><source srcset="form_36_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ DF_c $" src="form_36.png" width="24" height="13"/></picture> is Jacobian of parent cell <picture><source srcset="form_37_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="${\mathcal C}$" src="form_37.png" width="9" height="11"/></picture> that owns physical face <picture><source srcset="form_47_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="${\mathcal F}_{c,i}$" src="form_47.png" width="21" height="14"/></picture>; </li>
<li><picture><source srcset="form_48_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ {\partial\hat{\Phi}_i/\partial u}, {\partial\hat{\Phi}_i/\partial v}$" src="form_48.png" width="86" height="16"/></picture> are the (constant) tangents on reference face <picture><source srcset="form_13_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\mathcal F}_i$" src="form_13.png" width="14" height="15"/></picture>; see <a class="el" href="classIntrepid2_1_1CellTools.html#afd0b9b40329c45b0e1ae57d2fc7e63ce" title="Computes pairs of constant tangent vectors to faces of a 3D reference cells.">Intrepid2::CellTools::getReferenceFaceTangents</a>; that has the same local ordinal as the faces in the workset; </li>
<li><picture><source srcset="form_49_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \hat{\Phi}_i : R\mapsto \hat{\mathcal F}_i$" src="form_49.png" width="65" height="15"/></picture> is parametrization of reference face <picture><source srcset="form_13_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\mathcal F}_i$" src="form_13.png" width="14" height="15"/></picture>; </li>
<li><em>R</em> is the parametrization domain for reference face <picture><source srcset="form_13_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\mathcal F}_i$" src="form_13.png" width="14" height="15"/></picture>:  <p class="formulaDsp">
<picture><source srcset="form_66_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
R = \left\{\begin{array}{rl}
\{(0,0),(1,0),(0,1)\} &amp; \mbox{if $\hat{\mathcal F}_i$ is Triangle} \\[1ex]
[-1,1]\times [-1,1] &amp; \mbox{if $\hat{\mathcal F}_i$ is Quadrilateral}
\end{array}\right.
\]" src="form_66.png" width="276" height="39"/></picture>
</p>
</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd><code>worksetJacobians</code> must contain the values of <picture><source srcset="form_51_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$DF_c(\hat{\Phi}_i(u_p,v_p))$" src="form_51.png" width="85" height="16"/></picture>, where <picture><source srcset="form_52_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$(u_p,v_p)\in R$" src="form_52.png" width="65" height="14"/></picture>, i.e., Jacobians of the parent cells evaluated at points that are located on reference face <picture><source srcset="form_13_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\mathcal F}_i$" src="form_13.png" width="14" height="15"/></picture> having the same local ordinal as the faces in the workset.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">faceNormals</td><td>[out] - rank-3 array (C,P,D), normals at workset faces </td></tr>
    <tr><td class="paramname">worksetJacobians</td><td>[in] - rank-4 array (C,P,D,D) with Jacobians at ref. face points </td></tr>
    <tr><td class="paramname">worksetFaceOrd</td><td>[in] - face ordinal, relative to ref. cell, of the face workset </td></tr>
    <tr><td class="paramname">parentCell</td><td>[in] - cell topology of the parent reference cell </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html#l00812">812</a> of file <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html">Intrepid2_CellToolsDefNodeInfo.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__RealSpaceToolsDef_8hpp_source.html#l01546">Intrepid2::RealSpaceTools&lt; DeviceType &gt;::vecprod()</a>.</p>

</div>
</div>
<a id="a0f7ef29b9d1bf494f668682a4f264c8a" name="a0f7ef29b9d1bf494f668682a4f264c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7ef29b9d1bf494f668682a4f264c8a">&#9670;&#160;</a></span>getPhysicalFaceTangents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename faceTanValueType , class ... faceTanProperties, typename worksetJacobianValueType , class ... worksetJacobianProperties, typename faceOrdValueType , class ... faceOrdProperties&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::getPhysicalFaceTangents </td>
          <td>(</td>
          <td class="paramtype">Kokkos::DynRankView&lt; faceTanValueType, faceTanProperties... &gt;&#160;</td>
          <td class="paramname"><em>faceTanU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kokkos::DynRankView&lt; faceTanValueType, faceTanProperties... &gt;&#160;</td>
          <td class="paramname"><em>faceTanV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::DynRankView&lt; worksetJacobianValueType, worksetJacobianProperties... &gt;&#160;</td>
          <td class="paramname"><em>worksetJacobians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::DynRankView&lt; faceOrdValueType, faceOrdProperties... &gt;&#160;</td>
          <td class="paramname"><em>worksetFaceOrds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>parentCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes non-normalized tangent vector pairs to physical faces in a face workset <picture><source srcset="form_43_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\mathcal{F}_{c,i}\}_{c=0}^{N}$" src="form_43.png" width="50" height="15"/></picture>; (see <a class="el" href="cell_tools_page.html#sec_cell_topology_subcell_wset">Subcell worksets</a> for definition of face worksets). </p>
<p>It is similar to the <em><a class="el" href="classIntrepid2_1_1CellTools.html#a4522fcf52f960eb0f4eb138c8e02ae4e" title="Computes non-normalized tangent vector pairs to physical faces in a face workset ; (see Subcell works...">CellTools::getPhysicalFaceTangents</a></em> function above, with the difference that the face ordinal can change from point to point, and it is provided by the rank-2 input array <em><b>worksetFaceOrds</b></em>, indexed by (C,P).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">faceTanU</td><td>[out] - rank-3 array (C,P,D), image of ref. face u-tangent at workset faces </td></tr>
    <tr><td class="paramname">faceTanV</td><td>[out] - rank-3 array (C,P,D), image of ref. face u-tangent at workset faces </td></tr>
    <tr><td class="paramname">worksetJacobians</td><td>[in] - rank-4 array (C,P,D,D) with Jacobians at ref. face points </td></tr>
    <tr><td class="paramname">worksetFaceOrds</td><td>[in] - rank-2 array (C,P) with face ordinals, relative to ref. cell, of the face workset </td></tr>
    <tr><td class="paramname">parentCell</td><td>[in] - cell topology of the parent reference cell </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html#l00613">613</a> of file <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html">Intrepid2_CellToolsDefNodeInfo.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__CellDataDef_8hpp_source.html#l00069">Intrepid2::RefSubcellParametrization&lt; DeviceType &gt;::get()</a>, and <a class="el" href="Intrepid2__RealSpaceToolsDef_8hpp_source.html#l01356">Intrepid2::RealSpaceTools&lt; DeviceType &gt;::matvec()</a>.</p>

</div>
</div>
<a id="a4522fcf52f960eb0f4eb138c8e02ae4e" name="a4522fcf52f960eb0f4eb138c8e02ae4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4522fcf52f960eb0f4eb138c8e02ae4e">&#9670;&#160;</a></span>getPhysicalFaceTangents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename faceTanValueType , class ... faceTanProperties, typename worksetJacobianValueType , class ... worksetJacobianProperties&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::getPhysicalFaceTangents </td>
          <td>(</td>
          <td class="paramtype">Kokkos::DynRankView&lt; faceTanValueType, faceTanProperties... &gt;&#160;</td>
          <td class="paramname"><em>faceTanU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kokkos::DynRankView&lt; faceTanValueType, faceTanProperties... &gt;&#160;</td>
          <td class="paramname"><em>faceTanV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::DynRankView&lt; worksetJacobianValueType, worksetJacobianProperties... &gt;&#160;</td>
          <td class="paramname"><em>worksetJacobians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ordinal_type&#160;</td>
          <td class="paramname"><em>worksetFaceOrd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>parentCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes non-normalized tangent vector pairs to physical faces in a face workset <picture><source srcset="form_43_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\mathcal{F}_{c,i}\}_{c=0}^{N}$" src="form_43.png" width="50" height="15"/></picture>; (see <a class="el" href="cell_tools_page.html#sec_cell_topology_subcell_wset">Subcell worksets</a> for definition of face worksets). </p>
<p>For every face in the workset the tangents are computed at the points <picture><source srcset="form_44_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="${\bf x}_p = F_c(\hat{\Phi}_i(u_p,v_p))\in\mathcal{F}_{c,i}$" src="form_44.png" width="143" height="16"/></picture> that are images of points from the parametrization domain <em>R</em> on face <picture><source srcset="form_45_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\mathcal{F}_{c,i}$" src="form_45.png" width="21" height="14"/></picture>. Returns 2 rank-3 arrays with dimensions (C,P,D), D=3 such that  </p><p class="formulaDsp">
<picture><source srcset="form_46_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
{faceTanU}(c,p,d) = DF_c(\hat{\Phi}_i(u_p, v_p))\cdot {\partial\hat{\Phi}_i\over\partial u};\qquad
{faceTanV}(c,p,d) = DF_c(\hat{\Phi}_i(u_p, v_p))\cdot {\partial\hat{\Phi}_{i}\over\partial v}\,;
\qquad (u_p, v_p) \in R \,.
\]" src="form_46.png" width="586" height="30"/></picture>
</p>
<p> In this formula: </p><ul>
<li><picture><source srcset="form_36_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ DF_c $" src="form_36.png" width="24" height="13"/></picture> is Jacobian of parent cell <picture><source srcset="form_37_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="${\mathcal C}$" src="form_37.png" width="9" height="11"/></picture> that owns physical face <picture><source srcset="form_47_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="${\mathcal F}_{c,i}$" src="form_47.png" width="21" height="14"/></picture>; </li>
<li><picture><source srcset="form_48_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ {\partial\hat{\Phi}_i/\partial u}, {\partial\hat{\Phi}_i/\partial v}$" src="form_48.png" width="86" height="16"/></picture> are the (constant) tangents on reference face <picture><source srcset="form_13_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\mathcal F}_i$" src="form_13.png" width="14" height="15"/></picture>; see <a class="el" href="classIntrepid2_1_1CellTools.html#afd0b9b40329c45b0e1ae57d2fc7e63ce" title="Computes pairs of constant tangent vectors to faces of a 3D reference cells.">Intrepid2::CellTools::getReferenceFaceTangents</a>; that has the same local ordinal as the faces in the workset; </li>
<li><picture><source srcset="form_49_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \hat{\Phi}_i : R\mapsto \hat{\mathcal F}_i$" src="form_49.png" width="65" height="15"/></picture> is parametrization of reference face <picture><source srcset="form_13_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\mathcal F}_i$" src="form_13.png" width="14" height="15"/></picture>; </li>
<li><em>R</em> is the parametrization domain for reference face <picture><source srcset="form_13_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\mathcal F}_i$" src="form_13.png" width="14" height="15"/></picture>:  <p class="formulaDsp">
<picture><source srcset="form_50_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
R =
\left\{\begin{array}{rl}
\{(0,0),(1,0),(0,1)\} &amp; \mbox{if $\hat{\mathcal F}_i$ is Triangle} \\[1ex]
[-1,1]\times [-1,1] &amp; \mbox{if $\hat{\mathcal F}_i$ is Quadrilateral}
\end{array}\right.
\]" src="form_50.png" width="276" height="39"/></picture>
</p>
</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd><code>worksetJacobians</code> must contain the values of <picture><source srcset="form_51_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$DF_c(\hat{\Phi}_i(u_p,v_p))$" src="form_51.png" width="85" height="16"/></picture>, where <picture><source srcset="form_52_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$(u_p,v_p)\in R$" src="form_52.png" width="65" height="14"/></picture>, i.e., Jacobians of the parent cells evaluated at points that are located on reference face <picture><source srcset="form_13_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\mathcal F}_i$" src="form_13.png" width="14" height="15"/></picture> having the same local ordinal as the faces in the workset.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">faceTanU</td><td>[out] - rank-3 array (C,P,D), image of ref. face u-tangent at workset faces </td></tr>
    <tr><td class="paramname">faceTanV</td><td>[out] - rank-3 array (C,P,D), image of ref. face u-tangent at workset faces </td></tr>
    <tr><td class="paramname">worksetJacobians</td><td>[in] - rank-4 array (C,P,D,D) with Jacobians at ref. face points </td></tr>
    <tr><td class="paramname">worksetFaceOrd</td><td>[in] - face ordinal, relative to ref. cell, of the face workset </td></tr>
    <tr><td class="paramname">parentCell</td><td>[in] - cell topology of the parent reference cell </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html#l00517">517</a> of file <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html">Intrepid2_CellToolsDefNodeInfo.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__RealSpaceToolsDef_8hpp_source.html#l01356">Intrepid2::RealSpaceTools&lt; DeviceType &gt;::matvec()</a>.</p>

</div>
</div>
<a id="aacef389a37fe157b206c458859fd31cd" name="aacef389a37fe157b206c458859fd31cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacef389a37fe157b206c458859fd31cd">&#9670;&#160;</a></span>getPhysicalSideNormals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename sideNormalValueType , class ... sideNormalProperties, typename worksetJacobianValueType , class ... worksetJacobianProperties, typename edgeOrdValueType , class ... edgeOrdProperties&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::getPhysicalSideNormals </td>
          <td>(</td>
          <td class="paramtype">Kokkos::DynRankView&lt; sideNormalValueType, sideNormalProperties... &gt;&#160;</td>
          <td class="paramname"><em>sideNormals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::DynRankView&lt; worksetJacobianValueType, worksetJacobianProperties... &gt;&#160;</td>
          <td class="paramname"><em>worksetJacobians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::DynRankView&lt; edgeOrdValueType, edgeOrdProperties... &gt;&#160;</td>
          <td class="paramname"><em>worksetSideOrds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>parentCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes non-normalized normal vectors to physical sides in a side workset <picture><source srcset="form_53_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\mathcal{S}_{c,i}\}_{c=0}^{N}$" src="form_53.png" width="49" height="15"/></picture>. It is similar to the <em><a class="el" href="classIntrepid2_1_1CellTools.html#afff60692c07fe1a6f223273bb8ed87a9" title="Computes non-normalized normal vectors to physical sides in a side workset .">CellTools::getPhysicalSideNormals</a></em> function above, with the difference that the side ordinal can change from point to point, and it is provided by the rank-2 input array <em><b>worksetSideOrds</b></em>, indexed by (C,P). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sideNormals</td><td>[out] - rank-3 array (C,P,D), normals at workset sides </td></tr>
    <tr><td class="paramname">worksetJacobians</td><td>[in] - rank-4 array (C,P,D,D) with Jacobians at ref. side points </td></tr>
    <tr><td class="paramname">worksetSideOrds</td><td>[in] - rank-2 array (C,P) with side ordinals, relative to ref. cell, of the side workset </td></tr>
    <tr><td class="paramname">parentCell</td><td>[in] - cell topology of the parent reference cell </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html#l00765">765</a> of file <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html">Intrepid2_CellToolsDefNodeInfo.hpp</a>.</p>

</div>
</div>
<a id="afff60692c07fe1a6f223273bb8ed87a9" name="afff60692c07fe1a6f223273bb8ed87a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff60692c07fe1a6f223273bb8ed87a9">&#9670;&#160;</a></span>getPhysicalSideNormals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename sideNormalValueType , class ... sideNormalProperties, typename worksetJacobianValueType , class ... worksetJacobianProperties&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::getPhysicalSideNormals </td>
          <td>(</td>
          <td class="paramtype">Kokkos::DynRankView&lt; sideNormalValueType, sideNormalProperties... &gt;&#160;</td>
          <td class="paramname"><em>sideNormals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::DynRankView&lt; worksetJacobianValueType, worksetJacobianProperties... &gt;&#160;</td>
          <td class="paramname"><em>worksetJacobians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ordinal_type&#160;</td>
          <td class="paramname"><em>worksetSideOrd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>parentCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes non-normalized normal vectors to physical sides in a side workset <picture><source srcset="form_53_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\{\mathcal{S}_{c,i}\}_{c=0}^{N}$" src="form_53.png" width="49" height="15"/></picture>. </p>
<p>For every side in the workset the normals are computed at the points <picture><source srcset="form_54_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="${\bf x}_p = F_c(\hat{\Phi}_i(P_p))\in\mathcal{S}_{c,i}$" src="form_54.png" width="124" height="16"/></picture> that are images of points from the parametrization domain <em>R</em> on side <picture><source srcset="form_55_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\mathcal{S}_{c,i}$" src="form_55.png" width="20" height="14"/></picture>. A side is defined as a subcell of dimension one less than that of its parent cell. Therefore, sides of 2D cells are 1-subcells (edges) and sides of 3D cells are 2-subcells (faces).</p>
<p>Returns rank-3 array with dimensions (C,P,D), D = 2 or 3, such that  </p><p class="formulaDsp">
<picture><source srcset="form_56_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
{sideNormals}(c,p,d) =
\left\{\begin{array}{crl}
\displaystyle
\left(DF_c(\hat{\Phi}_i(t_p))\cdot
{\partial{\hat{\Phi}}_{i}(t_p)\over\partial t}\right)^{\perp} &amp;  t_p\in R
&amp; \mbox{for 2D parent cells} \\[2ex]
\displaystyle
\left( DF_c(\hat{\Phi}_i(u_p, v_p))\cdot {\partial\hat{\Phi}_i\over\partial u}\right) \times
\left( DF_c(\hat{\Phi}_i(u_p, v_p))\cdot {\partial\hat{\Phi}_i\over\partial v}\right) \,;
&amp; (u_p, v_p) \in R                          &amp; \mbox{for 3D parent cells}
\end{array}\right.
\]" src="form_56.png" width="598" height="79"/></picture>
</p>
<p> In this formula: </p><ul>
<li><picture><source srcset="form_36_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ DF_c $" src="form_36.png" width="24" height="13"/></picture> is Jacobian of parent cell <picture><source srcset="form_37_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="${\mathcal C}$" src="form_37.png" width="9" height="11"/></picture> that owns physical side <picture><source srcset="form_57_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="${\mathcal S}_{c,i}$" src="form_57.png" width="20" height="14"/></picture>; </li>
<li>For 2D cells: <picture><source srcset="form_39_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ {\partial{\hat{\Phi}}_{i}/\partial t}$" src="form_39.png" width="39" height="16"/></picture> is the (constant) tangent to reference side (edge) <picture><source srcset="form_20_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\mathcal S}_i$" src="form_20.png" width="13" height="15"/></picture>; see <a class="el" href="classIntrepid2_1_1CellTools.html#afa7e6b7811ff106bcdf2a3d298d6f27d" title="Computes constant tangent vectors to edges of 2D or 3D reference cells.">Intrepid2::CellTools::getReferenceEdgeTangent</a>, that has the same local ordinal as the sides in the workset; </li>
<li>For 3D cells: <picture><source srcset="form_48_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ {\partial\hat{\Phi}_i/\partial u}, {\partial\hat{\Phi}_i/\partial v}$" src="form_48.png" width="86" height="16"/></picture> are the (constant) tangents on reference side (face) <picture><source srcset="form_20_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\mathcal S}_i$" src="form_20.png" width="13" height="15"/></picture>; see <a class="el" href="classIntrepid2_1_1CellTools.html#afd0b9b40329c45b0e1ae57d2fc7e63ce" title="Computes pairs of constant tangent vectors to faces of a 3D reference cells.">Intrepid2::CellTools::getReferenceFaceTangents</a>, that has the same local ordinal as the sides in the workset; </li>
<li><picture><source srcset="form_58_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \hat{\Phi}_i : R\mapsto \hat{\mathcal S}_i$" src="form_58.png" width="64" height="15"/></picture> is parametrization of reference side <picture><source srcset="form_20_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\mathcal S}_i$" src="form_20.png" width="13" height="15"/></picture>; </li>
<li><em>R</em> is the parametrization domain for reference side <picture><source srcset="form_20_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\mathcal S}_i$" src="form_20.png" width="13" height="15"/></picture>. For 2D parent cells <em>R=</em>[-1,1] and for 3D parent cells  <p class="formulaDsp">
<picture><source srcset="form_59_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
R = \left\{\begin{array}{rl}
\{(0,0),(1,0),(0,1)\} &amp; \mbox{if $\hat{\mathcal S}_i$ is Triangle} \\[1ex]
[-1,1]\times [-1,1] &amp; \mbox{if $\hat{\mathcal S}_i$ is Quadrilateral}
\end{array}\right.
\]" src="form_59.png" width="275" height="39"/></picture>
</p>
</li>
</ul>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>For 3D cells the physical side normals coincides with the face normals computed by <a class="el" href="classIntrepid2_1_1CellTools.html#a6a5cb629eaa691a2cb841e04df0911e8" title="Computes non-normalized normal vectors to physical faces in a face workset ; (see Subcell worksets fo...">Intrepid2::CellTools::getPhysicalFaceNormals</a> and these two methods are completely equivalent.</li>
<li>For 2D cells the physical side normals are defined by <picture><source srcset="form_60_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="${\bf n}=(t_2,-t_1)$" src="form_60.png" width="69" height="14"/></picture> where <picture><source srcset="form_61_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="${\bf t}=(t_1,t_2)$" src="form_61.png" width="58" height="14"/></picture> are the physical edge tangents computed by <a class="el" href="classIntrepid2_1_1CellTools.html#abdcb3e5c24c9ca6dc47c79a7b0193374" title="Computes non-normalized tangent vectors to physical edges in an edge workset ; (see Subcell worksets ...">Intrepid2::CellTools::getPhysicalEdgeTangents</a>. Therefore, the pairs <picture><source srcset="form_62_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$({\bf n},{\bf t})$" src="form_62.png" width="28" height="14"/></picture> are positively oriented.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><code>worksetJacobians</code> must contain the values of <picture><source srcset="form_63_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$DF_c(\hat{\Phi}_i(P_p))$" src="form_63.png" width="69" height="16"/></picture>, where <picture><source srcset="form_64_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$P_p\in R$" src="form_64.png" width="39" height="14"/></picture>, i.e., Jacobians of the parent cells evaluated at points that are located on reference side <picture><source srcset="form_20_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\mathcal S}_i$" src="form_20.png" width="13" height="15"/></picture> having the same local ordinal as the sides in the workset.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sideNormals</td><td>[out] - rank-3 array (C,P,D), normals at workset sides </td></tr>
    <tr><td class="paramname">worksetJacobians</td><td>[in] - rank-4 array (C,P,D,D) with Jacobians at ref. side points </td></tr>
    <tr><td class="paramname">worksetSideOrd</td><td>[in] - side ordinal, relative to ref. cell, of the side workset </td></tr>
    <tr><td class="paramname">parentCell</td><td>[in] - cell topology of the parent reference cell </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html#l00714">714</a> of file <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html">Intrepid2_CellToolsDefNodeInfo.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Intrepid2__CubatureControlVolumeSideDef_8hpp_source.html#l00079">Intrepid2::CubatureControlVolumeSide&lt; DeviceType, pointValueType, weightValueType &gt;::getCubature()</a>.</p>

</div>
</div>
<a id="ac0c98d1a43783311a5a7c922faaa8d61" name="ac0c98d1a43783311a5a7c922faaa8d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c98d1a43783311a5a7c922faaa8d61">&#9670;&#160;</a></span>getReferenceCellCenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename cellCenterValueType , class ... cellCenterProperties&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::getReferenceCellCenter </td>
          <td>(</td>
          <td class="paramtype">Kokkos::DynRankView&lt; cellCenterValueType, cellCenterProperties... &gt;&#160;</td>
          <td class="paramname"><em>cellCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the Cartesian coordinates of reference cell barycenter. </p>
<p>Requires cell topology with a reference cell.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cellCenter</td><td>[out] - coordinates of the specified reference cell center </td></tr>
    <tr><td class="paramname">cell</td><td>[in] - cell topology </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html#l00035">35</a> of file <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html">Intrepid2_CellToolsDefNodeInfo.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__CellDataDef_8hpp_source.html#l00734">Intrepid2::RefCellCenter&lt; DeviceType &gt;::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Intrepid2__HVOL__C0__FEMDef_8hpp_source.html#l00101">Intrepid2::Basis_HVOL_C0_FEM&lt; DeviceType, outputValueType, pointValueType &gt;::Basis_HVOL_C0_FEM()</a>.</p>

</div>
</div>
<a id="afa7e6b7811ff106bcdf2a3d298d6f27d" name="afa7e6b7811ff106bcdf2a3d298d6f27d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7e6b7811ff106bcdf2a3d298d6f27d">&#9670;&#160;</a></span>getReferenceEdgeTangent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename RefEdgeTangentViewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::getReferenceEdgeTangent </td>
          <td>(</td>
          <td class="paramtype">RefEdgeTangentViewType&#160;</td>
          <td class="paramname"><em>refEdgeTangent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ordinal_type&#160;</td>
          <td class="paramname"><em>edgeOrd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>parentCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes constant tangent vectors to edges of 2D or 3D reference cells. </p>
<p>Returns rank-1 array with dimension (D), D=2 or D=3; such that  </p><p class="formulaDsp">
<picture><source srcset="form_5_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
{refEdgeTangent}(*) = \hat{\bf t}_i = {\partial\hat{\Phi}_i(t)\over\partial t}\,,
\]" src="form_5.png" width="196" height="30"/></picture>
</p>
<p> where <picture><source srcset="form_6_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\Phi}_i : R =[-1,1]\mapsto \hat{\mathcal E}_i$" src="form_6.png" width="114" height="16"/></picture> is the parametrization map of the specified reference edge <picture><source srcset="form_7_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\mathcal E}_i$" src="form_7.png" width="11" height="15"/></picture>, given by  </p><p class="formulaDsp">
<picture><source srcset="form_8_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\hat{\Phi}_i(t) = \left\{\begin{array}{ll}
(\hat{x}(t),\hat{y}(t),\hat{z}(t)) &amp; \mbox{for 3D parent cells} \\[1ex]
(\hat{x}(t),\hat{y}(t))            &amp; \mbox{for 2D parent cells} \\[1ex]
\end{array}\right.
\]" src="form_8.png" width="256" height="39"/></picture>
</p>
<p> The length of computed edge tangents is one-half the length of their associated edges:  </p><p class="formulaDsp">
<picture><source srcset="form_9_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
|\hat{\bf t}_i | = {1\over 2} |\hat{\mathcal E}_i |\,.
\]" src="form_9.png" width="65" height="26"/></picture>
</p>
<p> Because the edges of all reference cells are always affine images of [-1,1], the edge tangent is constant vector field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refEdgeTangent</td><td>[out] - rank-1 array (D) with the edge tangent; D = cell dimension </td></tr>
    <tr><td class="paramname">edgeOrd</td><td>[in] - ordinal of the edge whose tangent is computed </td></tr>
    <tr><td class="paramname">parentCell</td><td>[in] - cell topology of the parent reference cell </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html#l00210">210</a> of file <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html">Intrepid2_CellToolsDefNodeInfo.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__CellDataDef_8hpp_source.html#l00069">Intrepid2::RefSubcellParametrization&lt; DeviceType &gt;::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Intrepid2__HCURL__TET__In__FEMDef_8hpp_source.html#l00163">Intrepid2::Basis_HCURL_TET_In_FEM&lt; DeviceType, outputValueType, pointValueType &gt;::Basis_HCURL_TET_In_FEM()</a>, <a class="el" href="Intrepid2__HCURL__TRI__In__FEMDef_8hpp_source.html#l00156">Intrepid2::Basis_HCURL_TRI_In_FEM&lt; DeviceType, outputValueType, pointValueType &gt;::Basis_HCURL_TRI_In_FEM()</a>, <a class="el" href="Intrepid2__ProjectionToolsDefHCURL_8hpp_source.html#l00400">Intrepid2::ProjectionTools&lt; DeviceType &gt;::getHCurlBasisCoeffs()</a>, <a class="el" href="Intrepid2__ProjectionToolsDefHGRAD_8hpp_source.html#l00288">Intrepid2::ProjectionTools&lt; DeviceType &gt;::getHGradBasisCoeffs()</a>, and <a class="el" href="Intrepid2__ProjectionToolsDefL2_8hpp_source.html#l00358">Intrepid2::ProjectionTools&lt; DeviceType &gt;::getL2BasisCoeffs()</a>.</p>

</div>
</div>
<a id="a7e5d6883a44dc55cbcf9d8efff87f071" name="a7e5d6883a44dc55cbcf9d8efff87f071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e5d6883a44dc55cbcf9d8efff87f071">&#9670;&#160;</a></span>getReferenceFaceNormal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename RefFaceNormalViewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::getReferenceFaceNormal </td>
          <td>(</td>
          <td class="paramtype">RefFaceNormalViewType&#160;</td>
          <td class="paramname"><em>refFaceNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ordinal_type&#160;</td>
          <td class="paramname"><em>faceOrd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>parentCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes constant normal vectors to faces of 3D reference cell. </p>
<p>Returns rank-1 array with dimension (D), D=3 such that  </p><p class="formulaDsp">
<picture><source srcset="form_28_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
{refFaceNormal}(*) = \hat{\bf n}_i = {\partial\hat{\Phi}_{i}\over\partial u} \times
{\partial\hat{\Phi}_{i}\over\partial v}
\]" src="form_28.png" width="215" height="30"/></picture>
</p>
<p> where <picture><source srcset="form_12_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\Phi}_i: R \mapsto \hat{\mathcal F}_i$" src="form_12.png" width="65" height="15"/></picture> is the parametrization map of the specified reference face <picture><source srcset="form_13_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\mathcal F}_i$" src="form_13.png" width="14" height="15"/></picture> given by  </p><p class="formulaDsp">
<picture><source srcset="form_14_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\hat{\Phi}_i(u,v) =(\hat{x}(u,v),\hat{y}(u,v),\hat{z}(u,v))
\]" src="form_14.png" width="185" height="16"/></picture>
</p>
<p> and  </p><p class="formulaDsp">
<picture><source srcset="form_29_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
R = \left\{\begin{array}{rl}
\{(0,0),(1,0),(0,1)\} &amp; \mbox{if ${\mathcal F}$  is Triangle} \\[1ex]
[-1,1]\times [-1,1] &amp; \mbox{if ${\mathcal F}$ is Quadrilateral} \,.
\end{array}\right.
\]" src="form_29.png" width="278" height="39"/></picture>
</p>
<p> The length of computed face normals is proportional to face area:  </p><p class="formulaDsp">
<picture><source srcset="form_23_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
|\hat{\bf n}_i | = \left\{\begin{array}{rl}
2 \mbox{Area}(\hat{\mathcal F}_i) &amp; \mbox{if $\hat{\mathcal F}_i$  is Triangle} \\[1ex]
\mbox{Area}(\hat{\mathcal F}_i) &amp; \mbox{if $\hat{\mathcal F}_i$ is Quadrilateral} \,.
\end{array}\right.
\]" src="form_23.png" width="238" height="39"/></picture>
</p>
<p> Because the faces of all reference cells are always affine images of <em>R</em> , the coordinate functions <picture><source srcset="form_16_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{x},\hat{y},\hat{z}$" src="form_16.png" width="33" height="13"/></picture> of the parametrization map are linear and the face normal is a constant vector.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The method <a class="el" href="classIntrepid2_1_1CellTools.html#afd0b9b40329c45b0e1ae57d2fc7e63ce" title="Computes pairs of constant tangent vectors to faces of a 3D reference cells.">Intrepid2::CellTools::getReferenceFaceTangents</a> computes the reference face tangents <picture><source srcset="form_30_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="${\partial\hat{\Phi}_{i}/\partial u}$" src="form_30.png" width="41" height="16"/></picture> and <picture><source srcset="form_31_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="${\partial\hat{\Phi}_{i}/\partial v}$" src="form_31.png" width="40" height="16"/></picture>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refFaceNormal</td><td>[out] - rank-1 array (D) with (constant) face normal </td></tr>
    <tr><td class="paramname">faceOrd</td><td>[in] - ordinal of the face whose normal is computed </td></tr>
    <tr><td class="paramname">parentCell</td><td>[in] - cell topology of the parent reference cell </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html#l00334">334</a> of file <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html">Intrepid2_CellToolsDefNodeInfo.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__RealSpaceToolsDef_8hpp_source.html#l01546">Intrepid2::RealSpaceTools&lt; DeviceType &gt;::vecprod()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Intrepid2__ProjectionToolsDefHCURL_8hpp_source.html#l00400">Intrepid2::ProjectionTools&lt; DeviceType &gt;::getHCurlBasisCoeffs()</a>, and <a class="el" href="Intrepid2__ProjectionToolsDefHGRAD_8hpp_source.html#l00288">Intrepid2::ProjectionTools&lt; DeviceType &gt;::getHGradBasisCoeffs()</a>.</p>

</div>
</div>
<a id="afd0b9b40329c45b0e1ae57d2fc7e63ce" name="afd0b9b40329c45b0e1ae57d2fc7e63ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0b9b40329c45b0e1ae57d2fc7e63ce">&#9670;&#160;</a></span>getReferenceFaceTangents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename RefFaceTanViewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::getReferenceFaceTangents </td>
          <td>(</td>
          <td class="paramtype">RefFaceTanViewType&#160;</td>
          <td class="paramname"><em>refFaceTanU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RefFaceTanViewType&#160;</td>
          <td class="paramname"><em>refFaceTanV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ordinal_type&#160;</td>
          <td class="paramname"><em>faceOrd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>parentCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes pairs of constant tangent vectors to faces of a 3D reference cells. </p>
<p>Returns 2 rank-1 arrays with dimension (D), D=3, such that  </p><p class="formulaDsp">
<picture><source srcset="form_10_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
{refFaceTanU}(*) = \hat{\bf t}_{i,u} = {\partial\hat{\Phi}_i(u,v)\over\partial u} =
\left({\partial\hat{x}(u,v)\over\partial u},
{\partial\hat{y}(u,v)\over\partial u},
{\partial\hat{z}(u,v)\over\partial u} \right) ;
\]" src="form_10.png" width="389" height="34"/></picture>
</p>
  <p class="formulaDsp">
<picture><source srcset="form_11_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
{refFaceTanV}(*) = \hat{\bf t}_{i,v} = {\partial\hat{\Phi}_i(u,v)\over \partial v} =
\left({\partial\hat{x}(u,v)\over\partial v},
{\partial\hat{y}(u,v)\over\partial v},
{\partial\hat{z}(u,v)\over\partial v} \right)\,;
\]" src="form_11.png" width="390" height="34"/></picture>
</p>
<p> where <picture><source srcset="form_12_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\Phi}_i: R \mapsto \hat{\mathcal F}_i$" src="form_12.png" width="65" height="15"/></picture> is the parametrization map of the specified reference face <picture><source srcset="form_13_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\mathcal F}_i$" src="form_13.png" width="14" height="15"/></picture> given by  </p><p class="formulaDsp">
<picture><source srcset="form_14_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\hat{\Phi}_i(u,v) =(\hat{x}(u,v),\hat{y}(u,v),\hat{z}(u,v))
\]" src="form_14.png" width="185" height="16"/></picture>
</p>
<p> and  </p><p class="formulaDsp">
<picture><source srcset="form_15_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
R = \left\{\begin{array}{rl}
\{(0,0),(1,0),(0,1)\} &amp; \mbox{if $\hat{\mathcal F}_i$  is Triangle} \\[1ex]
[-1,1]\times [-1,1] &amp; \mbox{if $\hat{\mathcal F}_i$ is Quadrilateral} \,.
\end{array}\right.
\]" src="form_15.png" width="280" height="39"/></picture>
</p>
<p> Because the faces of all reference cells are always affine images of <em>R</em> , the coordinate functions <picture><source srcset="form_16_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{x},\hat{y},\hat{z}$" src="form_16.png" width="33" height="13"/></picture> of the parametrization map are linear and the face tangents are constant vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refFaceTanU</td><td>[out] - rank-1 array (D) with (constant) tangent in u-direction </td></tr>
    <tr><td class="paramname">refFaceTanV</td><td>[out] - rank-1 array (D) with (constant) tangent in v-direction </td></tr>
    <tr><td class="paramname">faceOrd</td><td>[in] - ordinal of the face whose tangents are computed </td></tr>
    <tr><td class="paramname">parentCell</td><td>[in] - cell topology of the parent 3D reference cell </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html#l00248">248</a> of file <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html">Intrepid2_CellToolsDefNodeInfo.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__CellDataDef_8hpp_source.html#l00069">Intrepid2::RefSubcellParametrization&lt; DeviceType &gt;::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Intrepid2__HCURL__TET__In__FEMDef_8hpp_source.html#l00163">Intrepid2::Basis_HCURL_TET_In_FEM&lt; DeviceType, outputValueType, pointValueType &gt;::Basis_HCURL_TET_In_FEM()</a>.</p>

</div>
</div>
<a id="a227057ecee9224d7deef7d06fd816006" name="a227057ecee9224d7deef7d06fd816006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227057ecee9224d7deef7d06fd816006">&#9670;&#160;</a></span>getReferenceNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename cellNodeValueType , class ... cellNodeProperties&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::getReferenceNode </td>
          <td>(</td>
          <td class="paramtype">Kokkos::DynRankView&lt; cellNodeValueType, cellNodeProperties... &gt;&#160;</td>
          <td class="paramname"><em>cellNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ordinal_type&#160;</td>
          <td class="paramname"><em>nodeOrd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the Cartesian coordinates of a reference cell node. </p>
<p>Returns Cartesian coordinates of a reference cell node. Requires cell topology with a reference cell. Node coordinates are always returned as an (x,y,z)-triple regardlesss of the actual topological cell dimension. The unused coordinates are set to zero, e.g., node 0 of Line&lt;2&gt; is returned as {-1,0,0}.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Because the nodes of a cell with a base topology coincide with its vertices, for cells with base topology this method is equivalent to <a class="el" href="classIntrepid2_1_1CellTools.html#af869373cf2682ef97de0d4c119882724" title="Retrieves the Cartesian coordinates of a reference cell vertex.">Intrepid2::CellTools::getReferenceVertex</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cellNode</td><td>[out] - coordinates of the specified reference vertex </td></tr>
    <tr><td class="paramname">cell</td><td>[in] - cell topology of the cell </td></tr>
    <tr><td class="paramname">vertexOrd</td><td>[in] - node ordinal </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html#l00138">138</a> of file <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html">Intrepid2_CellToolsDefNodeInfo.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__CellDataDef_8hpp_source.html#l00486">Intrepid2::RefCellNodes&lt; DeviceType &gt;::get()</a>.</p>

</div>
</div>
<a id="ae6d876366f84c9d89ec34d885b85b52c" name="ae6d876366f84c9d89ec34d885b85b52c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d876366f84c9d89ec34d885b85b52c">&#9670;&#160;</a></span>getReferenceSideNormal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename RefSideNormalViewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::getReferenceSideNormal </td>
          <td>(</td>
          <td class="paramtype">RefSideNormalViewType&#160;</td>
          <td class="paramname"><em>refSideNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ordinal_type&#160;</td>
          <td class="paramname"><em>sideOrd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>parentCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes constant normal vectors to sides of 2D or 3D reference cells. </p>
<p>A side is defined as a subcell of dimension one less than that of its parent cell. Therefore, sides of 2D cells are 1-subcells (edges) and sides of 3D cells are 2-subcells (faces).</p>
<p>Returns rank-1 array with dimension (D), D = 2 or 3 such that  </p><p class="formulaDsp">
<picture><source srcset="form_17_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
{refSideNormal}(*) = \hat{\bf n}_i =
\left\{\begin{array}{rl}
\displaystyle
\left({\partial\hat{\Phi}_i(t)\over\partial t}\right)^{\perp}
&amp; \mbox{for 2D parent cells} \\[2ex]
\displaystyle
{\partial\hat{\Phi}_{i}\over\partial u} \times
{\partial\hat{\Phi}_{i}\over\partial v}   &amp; \mbox{for 3D parent cells}
\end{array}\right.
\]" src="form_17.png" width="346" height="71"/></picture>
</p>
<p> where <picture><source srcset="form_18_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ (u_1,u_2)^\perp = (u_2, -u_1)$" src="form_18.png" width="115" height="15"/></picture>, and <picture><source srcset="form_19_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\Phi}_i: R \mapsto \hat{\mathcal S}_i$" src="form_19.png" width="64" height="15"/></picture> is the parametrization map of the specified reference side <picture><source srcset="form_20_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\mathcal S}_i$" src="form_20.png" width="13" height="15"/></picture> given by  </p><p class="formulaDsp">
<picture><source srcset="form_21_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\hat{\Phi}_i(u,v) =
\left\{\begin{array}{rl}
(\hat{x}(t),\hat{y}(t))                   &amp; \mbox{for 2D parent cells} \\[1ex]
(\hat{x}(u,v),\hat{y}(u,v),\hat{z}(u,v))  &amp; \mbox{for 3D parent cells}
\end{array}\right.
\]" src="form_21.png" width="316" height="39"/></picture>
</p>
<p> For sides of 2D cells <em>R=</em>[-1,1] and for sides of 3D cells  </p><p class="formulaDsp">
<picture><source srcset="form_22_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
R = \left\{\begin{array}{rl}
\{(0,0),(1,0),(0,1)\}   &amp; \mbox{if $\hat{\mathcal S}_i$ is Triangle} \\[1ex]
[-1,1]\times [-1,1] &amp; \mbox{if $\hat{\mathcal S}_i$ is Quadrilateral} \,.
\end{array}\right.
\]" src="form_22.png" width="279" height="39"/></picture>
</p>
<p> For 3D cells the length of computed side normals is proportional to side area:  </p><p class="formulaDsp">
<picture><source srcset="form_23_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
|\hat{\bf n}_i | = \left\{\begin{array}{rl}
2 \mbox{Area}(\hat{\mathcal F}_i) &amp; \mbox{if $\hat{\mathcal F}_i$  is Triangle} \\[1ex]
\mbox{Area}(\hat{\mathcal F}_i) &amp; \mbox{if $\hat{\mathcal F}_i$ is Quadrilateral} \,.
\end{array}\right.
\]" src="form_23.png" width="238" height="39"/></picture>
</p>
<p> For 2D cells the length of computed side normals is proportional to side length:  </p><p class="formulaDsp">
<picture><source srcset="form_24_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
|\hat{\bf n}_i | = {1\over 2} |\hat{\mathcal F}_i |\,.
\]" src="form_24.png" width="69" height="26"/></picture>
</p>
<p> Because the sides of all reference cells are always affine images of <em>R</em> , the coordinate functions <picture><source srcset="form_16_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{x},\hat{y},\hat{z}$" src="form_16.png" width="33" height="13"/></picture> of the parametrization maps are linear and the side normal is a constant vector.</p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>For 3D cells the reference side normal coincides with the face normal computed by <a class="el" href="classIntrepid2_1_1CellTools.html#a7e5d6883a44dc55cbcf9d8efff87f071" title="Computes constant normal vectors to faces of 3D reference cell.">Intrepid2::CellTools::getReferenceFaceNormal</a> and these two methods are completely equivalent.</li>
<li>For 2D cells the reference side normal is defined by <picture><source srcset="form_25_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{{\bf n}}= \hat{\bf t}^\perp = (t_2,-t_1)$" src="form_25.png" width="99" height="16"/></picture> where <picture><source srcset="form_26_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{{\bf t}}=(t_1,t_2)$" src="form_26.png" width="58" height="16"/></picture> is the tangent vector computed by <a class="el" href="classIntrepid2_1_1CellTools.html#afa7e6b7811ff106bcdf2a3d298d6f27d" title="Computes constant tangent vectors to edges of 2D or 3D reference cells.">Intrepid2::CellTools::getReferenceEdgeTangent</a>. Therefore, the pair <picture><source srcset="form_27_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$(\hat{{\bf n}},\hat{{\bf t}})$" src="form_27.png" width="28" height="16"/></picture> is positively oriented.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refSideNormal</td><td>[out] - rank-1 array (D) with (constant) side normal </td></tr>
    <tr><td class="paramname">sideOrd</td><td>[in] - ordinal of the side whose normal is computed </td></tr>
    <tr><td class="paramname">parentCell</td><td>[in] - cell topology of the parent reference cell </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html#l00293">293</a> of file <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html">Intrepid2_CellToolsDefNodeInfo.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Intrepid2__HDIV__TET__In__FEMDef_8hpp_source.html#l00156">Intrepid2::Basis_HDIV_TET_In_FEM&lt; DeviceType, outputValueType, pointValueType &gt;::Basis_HDIV_TET_In_FEM()</a>, <a class="el" href="Intrepid2__HDIV__TRI__In__FEMDef_8hpp_source.html#l00155">Intrepid2::Basis_HDIV_TRI_In_FEM&lt; DeviceType, outputValueType, pointValueType &gt;::Basis_HDIV_TRI_In_FEM()</a>, <a class="el" href="Intrepid2__ProjectionToolsDefHDIV_8hpp_source.html#l00235">Intrepid2::ProjectionTools&lt; DeviceType &gt;::getHDivBasisCoeffs()</a>, and <a class="el" href="Intrepid2__ProjectionToolsDefL2_8hpp_source.html#l00358">Intrepid2::ProjectionTools&lt; DeviceType &gt;::getL2BasisCoeffs()</a>.</p>

</div>
</div>
<a id="aca35e9d104f2763e432fcfed87f2a23e" name="aca35e9d104f2763e432fcfed87f2a23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca35e9d104f2763e432fcfed87f2a23e">&#9670;&#160;</a></span>getReferenceSubcellNodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename SubcellNodeViewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::getReferenceSubcellNodes </td>
          <td>(</td>
          <td class="paramtype">SubcellNodeViewType&#160;</td>
          <td class="paramname"><em>subcellNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ordinal_type&#160;</td>
          <td class="paramname"><em>subcellDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ordinal_type&#160;</td>
          <td class="paramname"><em>subcellOrd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>parentCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the Cartesian coordinates of all nodes of a reference subcell. </p>
<p>Returns rank-2 array with the Cartesian coordinates of the nodes of the specified reference cell subcell. Requires cell topology with a reference cell.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subcellNodes</td><td>[out] - rank-2 (N,D) array with the Cartesian coordinates of the reference subcell nodes </td></tr>
    <tr><td class="paramname">subcellDim</td><td>[in] - dimension of the subcell; 0 &lt;= subcellDim &lt;= parentCell dimension </td></tr>
    <tr><td class="paramname">subcellOrd</td><td>[in] - ordinal of the subcell </td></tr>
    <tr><td class="paramname">parentCell</td><td>[in] - topology of the cell that owns the subcell</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>When <code>subcellDim</code> = dimension of the <code>parentCell</code> this method returns the Cartesian coordinates of the nodes of the reference cell itself. Note that this requires <code>subcellOrd=0</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html#l00168">168</a> of file <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html">Intrepid2_CellToolsDefNodeInfo.hpp</a>.</p>

</div>
</div>
<a id="ad30b4cc22f21428f28538307ea744c89" name="ad30b4cc22f21428f28538307ea744c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30b4cc22f21428f28538307ea744c89">&#9670;&#160;</a></span>getReferenceSubcellVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename subcellVertexValueType , class ... subcellVertexProperties&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::getReferenceSubcellVertices </td>
          <td>(</td>
          <td class="paramtype">Kokkos::DynRankView&lt; subcellVertexValueType, subcellVertexProperties... &gt;&#160;</td>
          <td class="paramname"><em>subcellVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ordinal_type&#160;</td>
          <td class="paramname"><em>subcellDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ordinal_type&#160;</td>
          <td class="paramname"><em>subcellOrd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>parentCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the Cartesian coordinates of all vertices of a reference subcell. </p>
<p>Returns rank-2 array with the Cartesian coordinates of the vertices of the specified reference cell subcell. Requires cell topology with a reference cell.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subcellVertices</td><td>[out] - rank-2 (V,D) array with the Cartesian coordinates of the reference subcell vertices </td></tr>
    <tr><td class="paramname">subcellDim</td><td>[in] - dimension of the subcell; 0 &lt;= subcellDim &lt;= parentCell dimension </td></tr>
    <tr><td class="paramname">subcellOrd</td><td>[in] - ordinal of the subcell </td></tr>
    <tr><td class="paramname">parentCell</td><td>[in] - topology of the cell that owns the subcell</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>When <code>subcellDim</code> = dimension of the <code>parentCell</code> this method returns the Cartesian coordinates of the vertices of the reference cell itself. Note that this requires <em>subcellOrd=0</em>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html#l00102">102</a> of file <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html">Intrepid2_CellToolsDefNodeInfo.hpp</a>.</p>

</div>
</div>
<a id="af869373cf2682ef97de0d4c119882724" name="af869373cf2682ef97de0d4c119882724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af869373cf2682ef97de0d4c119882724">&#9670;&#160;</a></span>getReferenceVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename cellVertexValueType , class ... cellVertexProperties&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::getReferenceVertex </td>
          <td>(</td>
          <td class="paramtype">Kokkos::DynRankView&lt; cellVertexValueType, cellVertexProperties... &gt;&#160;</td>
          <td class="paramname"><em>cellVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ordinal_type&#160;</td>
          <td class="paramname"><em>vertexOrd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the Cartesian coordinates of a reference cell vertex. </p>
<p>Requires cell topology with a reference cell.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cellVertex</td><td>[out] - coordinates of the specified reference cell vertex </td></tr>
    <tr><td class="paramname">cell</td><td>[in] - cell topology of the cell </td></tr>
    <tr><td class="paramname">vertexOrd</td><td>[in] - vertex ordinal </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html#l00067">67</a> of file <a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html">Intrepid2_CellToolsDefNodeInfo.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__CellDataDef_8hpp_source.html#l00486">Intrepid2::RefCellNodes&lt; DeviceType &gt;::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Intrepid2__ProjectionStructDef_8hpp_source.html#l00201">Intrepid2::ProjectionStruct&lt; DeviceType, ValueType &gt;::createHGradProjectionStruct()</a>, and <a class="el" href="Intrepid2__ProjectionStructDef_8hpp_source.html#l00033">Intrepid2::ProjectionStruct&lt; DeviceType, ValueType &gt;::createL2ProjectionStruct()</a>.</p>

</div>
</div>
<a id="a4c2dc9c2a5aff2b205be105a1536e1e8" name="a4c2dc9c2a5aff2b205be105a1536e1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2dc9c2a5aff2b205be105a1536e1e8">&#9670;&#160;</a></span>getSubcvCoords()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename subcvCoordValueType , class ... subcvCoordProperties, typename cellCoordValueType , class ... cellCoordProperties&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::getSubcvCoords </td>
          <td>(</td>
          <td class="paramtype">Kokkos::DynRankView&lt; subcvCoordValueType, subcvCoordProperties... &gt;&#160;</td>
          <td class="paramname"><em>subcvCoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::DynRankView&lt; cellCoordValueType, cellCoordProperties... &gt;&#160;</td>
          <td class="paramname"><em>cellCoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>primaryCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes coordinates of sub-control volumes in each primary cell. </p>
<p>To build the system of equations for the control volume finite element method we need to compute geometric data for integration over control volumes. A control volume is polygon or polyhedron that surrounds a primary cell node and has vertices that include the surrounding primary cells' barycenter, edge midpoints, and face midpoints if in 3-d.</p>
<p>When using element-based assembly of the discrete equations over the primary mesh, a single element will contain a piece of each control volume surrounding each of the primary cell nodes. This piece of control volume (sub-control volume) is always a quadrilateral in 2-d and a hexahedron in 3-d.</p>
<p>In 2-d the sub-control volumes are defined in the following way:</p>
<pre class="fragment">   Quadrilateral primary element:

       O________M________O
       |        |        |
       |   3    |   2    |     B = cell barycenter
       |        |        |     O = primary cell nodes
       M________B________M     M = cell edge midpoints
       |        |        |
       |   0    |   1    |     sub-control volumes 0, 1, 2, 3
       |        |        |
       O________M________O


   Triangle primary element:

                O
               / \
              /   \             B = cell barycenter
             /     \            O = primary cell nodes
            M   2   M           M = cell edge midpoints
           / \     / \
          /   \ B /   \         sub-control volumes 0, 1, 2
         /      |      \
        /   0   |   1   \
       O________M________O</pre><p>In 3-d the sub-control volumes are defined by the primary cell face centers and edge midpoints. The eight sub-control volumes for a hexahedron are shown below:</p>
<pre class="fragment">         O__________E__________O
        /|         /|         /|
       E_|________F_|________E |
      /| |       /| |       /| |
     O_|_|______E_|_|______O | |      O = primary cell nodes
     | | E------|-|-F------|-|-E      B = cell barycenter
     | |/|      | |/|      | |/|      F = cell face centers
     | F-|------|-B-|------|-F |      E = cell edge midpoints
     |/| |      |/| |      |/| |
     E_|_|______F_|_|______E | |
     | | O------|-|-E------|-|-O
     | |/       | |/       | |/
     | E--------|-F--------|-E
     |/         |/         |/
     O__________E__________O</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subCVCoords</td><td>[out] - array containing sub-control volume coordinates </td></tr>
    <tr><td class="paramname">cellCoords</td><td>[in] - array containing coordinates of primary cells </td></tr>
    <tr><td class="paramname">primaryCell</td><td>[in] - primary cell topology </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefControlVolume_8hpp_source.html#l00339">339</a> of file <a class="el" href="Intrepid2__CellToolsDefControlVolume_8hpp_source.html">Intrepid2_CellToolsDefControlVolume.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Intrepid2__CubatureControlVolumeDef_8hpp_source.html#l00060">Intrepid2::CubatureControlVolume&lt; DeviceType, pointValueType, weightValueType &gt;::getCubature()</a>, <a class="el" href="Intrepid2__CubatureControlVolumeBoundaryDef_8hpp_source.html#l00146">Intrepid2::CubatureControlVolumeBoundary&lt; DeviceType, pointValueType, weightValueType &gt;::getCubature()</a>, and <a class="el" href="Intrepid2__CubatureControlVolumeSideDef_8hpp_source.html#l00079">Intrepid2::CubatureControlVolumeSide&lt; DeviceType, pointValueType, weightValueType &gt;::getCubature()</a>.</p>

</div>
</div>
<a id="a78474ac2637b9b8c8b18bb5614934926" name="a78474ac2637b9b8c8b18bb5614934926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78474ac2637b9b8c8b18bb5614934926">&#9670;&#160;</a></span>hasReferenceCell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::hasReferenceCell </td>
          <td>(</td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>cellTopo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a cell topology has reference cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>[in] - cell topology </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the cell topology has reference cell, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellTools_8hpp_source.html#l00088">88</a> of file <a class="el" href="Intrepid2__CellTools_8hpp_source.html">Intrepid2_CellTools.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__CellDataDef_8hpp_source.html#l00027">Intrepid2::RefSubcellParametrization&lt; DeviceType &gt;::isSupported()</a>.</p>

</div>
</div>
<a id="a4647855c7283cf8bf47c365498121314" name="a4647855c7283cf8bf47c365498121314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4647855c7283cf8bf47c365498121314">&#9670;&#160;</a></span>mapToPhysicalFrame() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename PhysPointValueType , typename RefPointValueType , typename WorksetType , typename HGradBasisPtrType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::mapToPhysicalFrame </td>
          <td>(</td>
          <td class="paramtype">PhysPointValueType&#160;</td>
          <td class="paramname"><em>physPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RefPointValueType&#160;</td>
          <td class="paramname"><em>refPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WorksetType&#160;</td>
          <td class="paramname"><em>worksetCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HGradBasisPtrType&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <em>F</em>, the reference-to-physical frame map. </p>
<p>There are 2 use cases: </p><ul>
<li>Applies <picture><source srcset="form_67_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F_{c} $" src="form_67.png" width="13" height="13"/></picture> for <b>all</b> cells in a cell workset to a <b>single</b> point set stored in a rank-2 (P,D) array; </li>
<li>Applies <picture><source srcset="form_67_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F_{c} $" src="form_67.png" width="13" height="13"/></picture> for <b>all</b> cells in a cell workset to <b>multiple</b> point sets having the same number of points, indexed by cell ordinal, and stored in a rank-3 (C,P,D) array;</li>
</ul>
<p>For a single point set in a rank-2 array (P,D) returns a rank-3 (C,P,D) array such that  </p><p class="formulaDsp">
<picture><source srcset="form_68_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\mbox{physPoints}(c,p,d) = \Big(F_c(\mbox{refPoint}(p,*)) \Big)_d \quad c=0,\ldots, C
\]" src="form_68.png" width="309" height="24"/></picture>
</p>
<p> For multiple point sets in a rank-3 (C,P,D) array returns a rank-3 (C,P,D) array such that  </p><p class="formulaDsp">
<picture><source srcset="form_69_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\mbox{physPoints}(c,p,d) = \Big(F_c(\mbox{refPoint}(c,p,*)) \Big)_d \quad c=0,\ldots, C
\]" src="form_69.png" width="319" height="24"/></picture>
</p>
<p> This corresponds to mapping multiple sets of reference points to a matching number of physical cells.</p>
<p>Requires pointer to HGrad basis that defines reference to physical cell mapping. See Section <a class="el" href="cell_tools_page.html#sec_cell_topology_ref_map">Reference-to-physical cell mapping</a> for definition of the mapping function.</p>
<dl class="section warning"><dt>Warning</dt><dd>The array <code>refPoints</code> represents an arbitrary set of points in the reference frame that are not required to be in the reference cell corresponding to the specified cell topology. As a result, the images of these points under a given reference-to-physical map are not necessarily contained in the physical cell that is the image of the reference cell under that map. <a class="el" href="classIntrepid2_1_1CellTools.html" title="A stateless class for operations on cell data. Provides methods for:">CellTools</a> provides several inclusion tests methods to check whether or not the points are inside a reference cell.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">physPoints</td><td>[out] - rank-3 array with dimensions (C,P,D) with the images of the ref. points </td></tr>
    <tr><td class="paramname">refPoints</td><td>[in] - rank-3/2 array with dimensions (C,P,D)/(P,D) with points in reference frame </td></tr>
    <tr><td class="paramname">cellWorkset</td><td>[in] - rank-3 container with logical dimensions (C,N,D) with the nodes of the cell workset </td></tr>
    <tr><td class="paramname">basis</td><td>[in] - pointer to HGrad basis used in reference-to-physical cell mapping </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="Intrepid2__CellTools_8hpp_source.html#l01051">Intrepid2::CellTools&lt; DeviceType &gt;::mapToPhysicalFrame()</a>, and <a class="el" href="Intrepid2__ProjectedGeometry_8hpp_source.html#l00050">Intrepid2::ProjectedGeometry&lt; spaceDim, PointScalar, DeviceType &gt;::projectOntoHGRADBasis()</a>.</p>

</div>
</div>
<a id="a42a27c76bece1882e3e6d12879b5d7eb" name="a42a27c76bece1882e3e6d12879b5d7eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a27c76bece1882e3e6d12879b5d7eb">&#9670;&#160;</a></span>mapToPhysicalFrame() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename PhysPointViewType , typename RefPointViewType , typename WorksetCellViewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::mapToPhysicalFrame </td>
          <td>(</td>
          <td class="paramtype">PhysPointViewType&#160;</td>
          <td class="paramname"><em>physPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RefPointViewType&#160;</td>
          <td class="paramname"><em>refPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WorksetCellViewType&#160;</td>
          <td class="paramname"><em>worksetCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>cellTopo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <em>F</em>, the reference-to-physical frame map. </p>
<p>There are 2 use cases: </p><ul>
<li>Applies <picture><source srcset="form_67_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F_{c} $" src="form_67.png" width="13" height="13"/></picture> for <b>all</b> cells in a cell workset to a <b>single</b> point set stored in a rank-2 (P,D) array; </li>
<li>Applies <picture><source srcset="form_67_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F_{c} $" src="form_67.png" width="13" height="13"/></picture> for <b>all</b> cells in a cell workset to <b>multiple</b> point sets having the same number of points, indexed by cell ordinal, and stored in a rank-3 (C,P,D) array;</li>
</ul>
<p>For a single point set in a rank-2 array (P,D) returns a rank-3 (C,P,D) array such that  </p><p class="formulaDsp">
<picture><source srcset="form_68_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\mbox{physPoints}(c,p,d) = \Big(F_c(\mbox{refPoint}(p,*)) \Big)_d \quad c=0,\ldots, C
\]" src="form_68.png" width="309" height="24"/></picture>
</p>
<p> For multiple point sets in a rank-3 (C,P,D) array returns a rank-3 (C,P,D) array such that  </p><p class="formulaDsp">
<picture><source srcset="form_69_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\mbox{physPoints}(c,p,d) = \Big(F_c(\mbox{refPoint}(c,p,*)) \Big)_d \quad c=0,\ldots, C
\]" src="form_69.png" width="319" height="24"/></picture>
</p>
<p> This corresponds to mapping multiple sets of reference points to a matching number of physical cells.</p>
<p>Requires cell topology with a reference cell. See Section <a class="el" href="cell_tools_page.html#sec_cell_topology_ref_map">Reference-to-physical cell mapping</a> for definition of the mapping function. Presently supported cell topologies are</p>
<ul>
<li>1D: <code>Line&lt;2&gt;</code> </li>
<li>2D: <code>Triangle&lt;3&gt;</code>, <code>Triangle&lt;6&gt;</code>, <code>Quadrilateral&lt;4&gt;</code>, <code>Quadrilateral&lt;9&gt;</code> </li>
<li>3D: <code>Tetrahedron&lt;4&gt;</code>, <code>Tetrahedron&lt;10&gt;</code>, <code>Hexahedron&lt;8&gt;</code>, <code>Hexahedron&lt;27&gt;</code> </li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>The array <code>refPoints</code> represents an arbitrary set of points in the reference frame that are not required to be in the reference cell corresponding to the specified cell topology. As a result, the images of these points under a given reference-to-physical map are not necessarily contained in the physical cell that is the image of the reference cell under that map. <a class="el" href="classIntrepid2_1_1CellTools.html" title="A stateless class for operations on cell data. Provides methods for:">CellTools</a> provides several inclusion tests methods to check whether or not the points are inside a reference cell.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">physPoints</td><td>[out] - rank-3 array with dimensions (C,P,D) with the images of the ref. points </td></tr>
    <tr><td class="paramname">refPoints</td><td>[in] - rank-3/2 array with dimensions (C,P,D)/(P,D) with points in reference frame </td></tr>
    <tr><td class="paramname">cellWorkset</td><td>[in] - rank-3 array with dimensions (C,N,D) with the nodes of the cell workset </td></tr>
    <tr><td class="paramname">cellTopo</td><td>[in] - cell topology of the cells stored in <code>cellWorkset</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellTools_8hpp_source.html#l01051">1051</a> of file <a class="el" href="Intrepid2__CellTools_8hpp_source.html">Intrepid2_CellTools.hpp</a>.</p>

<p class="reference">References <a class="el" href="classIntrepid2_1_1CellTools.html#a4647855c7283cf8bf47c365498121314">Intrepid2::CellTools&lt; DeviceType &gt;::mapToPhysicalFrame()</a>.</p>

</div>
</div>
<a id="a19ca08834df5fcac6d6f3f8acb6f5b3a" name="a19ca08834df5fcac6d6f3f8acb6f5b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ca08834df5fcac6d6f3f8acb6f5b3a">&#9670;&#160;</a></span>mapToPhysicalFrame() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename PhysPointViewType , typename RefPointViewType , typename WorksetType , typename HGradBasisPtrType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::mapToPhysicalFrame </td>
          <td>(</td>
          <td class="paramtype">PhysPointViewType&#160;</td>
          <td class="paramname"><em>physPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RefPointViewType&#160;</td>
          <td class="paramname"><em>refPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WorksetType&#160;</td>
          <td class="paramname"><em>worksetCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HGradBasisPtrType&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefRefToPhys_8hpp_source.html#l00137">137</a> of file <a class="el" href="Intrepid2__CellToolsDefRefToPhys_8hpp_source.html">Intrepid2_CellToolsDefRefToPhys.hpp</a>.</p>

</div>
</div>
<a id="a006dc4e9c5f5ac25be8b513b8f63ca04" name="a006dc4e9c5f5ac25be8b513b8f63ca04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a006dc4e9c5f5ac25be8b513b8f63ca04">&#9670;&#160;</a></span>mapToReferenceFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename refPointValueType , class ... refPointProperties, typename physPointValueType , class ... physPointProperties, typename worksetCellValueType , class ... worksetCellProperties&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::mapToReferenceFrame </td>
          <td>(</td>
          <td class="paramtype">Kokkos::DynRankView&lt; refPointValueType, refPointProperties... &gt;&#160;</td>
          <td class="paramname"><em>refPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::DynRankView&lt; physPointValueType, physPointProperties... &gt;&#160;</td>
          <td class="paramname"><em>physPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::DynRankView&lt; worksetCellValueType, worksetCellProperties... &gt;&#160;</td>
          <td class="paramname"><em>worksetCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>cellTopo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <picture><source srcset="form_76_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F^{-1}_{c} $" src="form_76.png" width="23" height="15"/></picture>, the inverse of the reference-to-physical frame map using a default initial guess. </p>
<p>Applies <picture><source srcset="form_76_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F^{-1}_{c} $" src="form_76.png" width="23" height="15"/></picture> for <b>all</b> cells in a cell workset to <b>multiple</b> point sets having the same number of points, indexed by cell ordinal, and stored in a rank-3 (C,P,D) array. Returns a rank-3 (C,P,D) array such that  </p><p class="formulaDsp">
<picture><source srcset="form_77_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\mbox{refPoints}(c,p,d) = \Big(F^{-1}_c(physPoint(c,p,*)) \Big)_d
\]" src="form_77.png" width="254" height="24"/></picture>
</p>
<p>Requires cell topology with a reference cell. See Section <a class="el" href="cell_tools_page.html#sec_cell_topology_ref_map">Reference-to-physical cell mapping</a> for definition of the mapping function. Presently supported cell topologies are</p>
<ul>
<li>1D: <code>Line&lt;2&gt;</code> </li>
<li>2D: <code>Triangle&lt;3&gt;</code>, <code>Triangle&lt;6&gt;</code>, <code>Quadrilateral&lt;4&gt;</code>, <code>Quadrilateral&lt;9&gt;</code> </li>
<li>3D: <code>Tetrahedron&lt;4&gt;</code>, <code>Tetrahedron&lt;10&gt;</code>, <code>Hexahedron&lt;8&gt;</code>, <code>Hexahedron&lt;27&gt;</code> </li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Computation of the inverse map in this method uses default selection of the initial guess based on cell topology: <ul>
<li><code>Line</code> topologies: line center (0) </li>
<li><code>Triangle</code> topologies: the point (1/3, 1/3) </li>
<li><code>Quadrilateral</code> topologies: the point (0, 0) </li>
<li><code>Tetrahedron</code> topologies: the point (1/6, 1/6, 1/6) </li>
<li><code>Hexahedron</code> topologies: the point (0, 0, 0) </li>
<li><code>Wedge</code> topologies: the point (1/2, 1/2, 0) For some cells with extended topologies, these initial guesses may not be good enough for Newton's method to converge in the allotted number of iterations. A version of this method with user-supplied initial guesses is also available.</li>
</ul>
</dd>
<dd>
The array <code>physPoints</code> represents an arbitrary set (or sets) of points in the physical frame that are not required to belong in the physical cell (cells) that define(s) the reference to physical mapping. As a result, the images of these points in the reference frame are not necessarily contained in the reference cell corresponding to the specified cell topology.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refPoints</td><td>[out] - rank-3 array with dimensions (C,P,D) with the images of the physical points </td></tr>
    <tr><td class="paramname">physPoints</td><td>[in] - rank-3 array with dimensions (C,P,D) with points in physical frame </td></tr>
    <tr><td class="paramname">worksetCell</td><td>[in] - rank-3 array with dimensions (C,N,D) with the nodes of the cell workset </td></tr>
    <tr><td class="paramname">cellTopo</td><td>[in] - cell topology of the cells stored in <code>cellWorkset</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefPhysToRef_8hpp_source.html#l00038">38</a> of file <a class="el" href="Intrepid2__CellToolsDefPhysToRef_8hpp_source.html">Intrepid2_CellToolsDefPhysToRef.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__CellToolsDefValidateArguments_8hpp_source.html#l00262">Intrepid2::CellTools_mapToReferenceFrameArgs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Intrepid2__PointToolsDef_8hpp_source.html#l00754">Intrepid2::PointTools::getWarpBlendLatticeTetrahedron()</a>, and <a class="el" href="Intrepid2__PointToolsDef_8hpp_source.html#l00465">Intrepid2::PointTools::getWarpBlendLatticeTriangle()</a>.</p>

</div>
</div>
<a id="a6b08ff3ec8d107e2ee85036f4f6e2025" name="a6b08ff3ec8d107e2ee85036f4f6e2025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b08ff3ec8d107e2ee85036f4f6e2025">&#9670;&#160;</a></span>mapToReferenceFrameInitGuess() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename refPointValueType , class ... refPointProperties, typename initGuessValueType , class ... initGuessProperties, typename physPointValueType , class ... physPointProperties, typename worksetCellValueType , class ... worksetCellProperties, typename HGradBasisPtrType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::mapToReferenceFrameInitGuess </td>
          <td>(</td>
          <td class="paramtype">Kokkos::DynRankView&lt; refPointValueType, refPointProperties... &gt;&#160;</td>
          <td class="paramname"><em>refPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::DynRankView&lt; initGuessValueType, initGuessProperties... &gt;&#160;</td>
          <td class="paramname"><em>initGuess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::DynRankView&lt; physPointValueType, physPointProperties... &gt;&#160;</td>
          <td class="paramname"><em>physPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::DynRankView&lt; worksetCellValueType, worksetCellProperties... &gt;&#160;</td>
          <td class="paramname"><em>worksetCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HGradBasisPtrType&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computation of <picture><source srcset="form_76_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F^{-1}_{c} $" src="form_76.png" width="23" height="15"/></picture>, the inverse of the reference-to-physical frame map using user-supplied initial guess. </p>
<p>Applies <picture><source srcset="form_76_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F^{-1}_{c} $" src="form_76.png" width="23" height="15"/></picture> for <b>all</b> cells in a cell workset to <b>multiple</b> point sets having the same number of points, indexed by cell ordinal, and stored in a rank-3 (C,P,D) array. Returns a rank-3 (C,P,D) array such that  </p><p class="formulaDsp">
<picture><source srcset="form_77_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\mbox{refPoints}(c,p,d) = \Big(F^{-1}_c(physPoint(c,p,*)) \Big)_d
\]" src="form_77.png" width="254" height="24"/></picture>
</p>
<p>Requires pointer to HGrad basis that defines reference to physical cell mapping. See Section <a class="el" href="cell_tools_page.html#sec_cell_topology_ref_map">Reference-to-physical cell mapping</a> for definition of the mapping function.</p>
<dl class="section warning"><dt>Warning</dt><dd>The array <code>physPoints</code> represents an arbitrary set (or sets) of points in the physical frame that are not required to belong in the physical cell (cells) that define(s) the reference to physical mapping. As a result, the images of these points in the reference frame are not necessarily contained in the reference cell corresponding to the specified cell topology.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refPoints</td><td>[out] - rank-3/2 array with dimensions (C,P,D)/(P,D) with the images of the physical points </td></tr>
    <tr><td class="paramname">initGuess</td><td>[in] - rank-3/2 array with dimensions (C,P,D)/(P,D) with the initial guesses for each point </td></tr>
    <tr><td class="paramname">physPoints</td><td>[in] - rank-3/2 array with dimensions (C,P,D)/(P,D) with points in physical frame </td></tr>
    <tr><td class="paramname">worksetCell</td><td>[in] - rank-3 array with dimensions (C,N,D) with the nodes of the cell workset </td></tr>
    <tr><td class="paramname">basis</td><td>[in] - pointer to HGrad basis used for reference to physical cell mapping </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefPhysToRef_8hpp_source.html#l00089">89</a> of file <a class="el" href="Intrepid2__CellToolsDefPhysToRef_8hpp_source.html">Intrepid2_CellToolsDefPhysToRef.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__Types_8hpp_source.html#l00116">Intrepid2::Parameters::MaxNewton</a>.</p>

<p class="reference">Referenced by <a class="el" href="Intrepid2__CellTools_8hpp_source.html#l01283">Intrepid2::CellTools&lt; DeviceType &gt;::mapToReferenceFrameInitGuess()</a>.</p>

</div>
</div>
<a id="a069100237b73970c9e72252d95dc2289" name="a069100237b73970c9e72252d95dc2289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069100237b73970c9e72252d95dc2289">&#9670;&#160;</a></span>mapToReferenceFrameInitGuess() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename refPointValueType , class ... refPointProperties, typename initGuessValueType , class ... initGuessProperties, typename physPointValueType , class ... physPointProperties, typename worksetCellValueType , class ... worksetCellProperties&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::mapToReferenceFrameInitGuess </td>
          <td>(</td>
          <td class="paramtype">Kokkos::DynRankView&lt; refPointValueType, refPointProperties... &gt;&#160;</td>
          <td class="paramname"><em>refPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::DynRankView&lt; initGuessValueType, initGuessProperties... &gt;&#160;</td>
          <td class="paramname"><em>initGuess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::DynRankView&lt; physPointValueType, physPointProperties... &gt;&#160;</td>
          <td class="paramname"><em>physPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::DynRankView&lt; worksetCellValueType, worksetCellProperties... &gt;&#160;</td>
          <td class="paramname"><em>worksetCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>cellTopo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computation of <picture><source srcset="form_76_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F^{-1}_{c} $" src="form_76.png" width="23" height="15"/></picture>, the inverse of the reference-to-physical frame map using user-supplied initial guess. </p>
<p>Applies <picture><source srcset="form_76_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F^{-1}_{c} $" src="form_76.png" width="23" height="15"/></picture> for <b>all</b> cells in a cell workset to <b>multiple</b> point sets having the same number of points, indexed by cell ordinal, and stored in a rank-3 (C,P,D) array. Returns a rank-3 (C,P,D) array such that  </p><p class="formulaDsp">
<picture><source srcset="form_77_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\mbox{refPoints}(c,p,d) = \Big(F^{-1}_c(physPoint(c,p,*)) \Big)_d
\]" src="form_77.png" width="254" height="24"/></picture>
</p>
<p>Requires cell topology with a reference cell. See Section <a class="el" href="cell_tools_page.html#sec_cell_topology_ref_map">Reference-to-physical cell mapping</a> for definition of the mapping function. Presently supported cell topologies are</p>
<ul>
<li>1D: <code>Line&lt;2&gt;</code> </li>
<li>2D: <code>Triangle&lt;3&gt;</code>, <code>Triangle&lt;6&gt;</code>, <code>Quadrilateral&lt;4&gt;</code>, <code>Quadrilateral&lt;9&gt;</code> </li>
<li>3D: <code>Tetrahedron&lt;4&gt;</code>, <code>Tetrahedron&lt;10&gt;</code>, <code>Hexahedron&lt;8&gt;</code>, <code>Hexahedron&lt;27&gt;</code> </li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>The array <code>physPoints</code> represents an arbitrary set (or sets) of points in the physical frame that are not required to belong in the physical cell (cells) that define(s) the reference to physical mapping. As a result, the images of these points in the reference frame are not necessarily contained in the reference cell corresponding to the specified cell topology.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refPoints</td><td>[out] - rank-3/2 array with dimensions (C,P,D)/(P,D) with the images of the physical points </td></tr>
    <tr><td class="paramname">initGuess</td><td>[in] - rank-3/2 array with dimensions (C,P,D)/(P,D) with the initial guesses for each point </td></tr>
    <tr><td class="paramname">physPoints</td><td>[in] - rank-3/2 array with dimensions (C,P,D)/(P,D) with points in physical frame </td></tr>
    <tr><td class="paramname">worksetCell</td><td>[in] - rank-3 array with dimensions (C,N,D) with the nodes of the cell workset </td></tr>
    <tr><td class="paramname">cellTopo</td><td>[in] - cell topology of the cells stored in <code>cellWorkset</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellTools_8hpp_source.html#l01283">1283</a> of file <a class="el" href="Intrepid2__CellTools_8hpp_source.html">Intrepid2_CellTools.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__CellToolsDefPhysToRef_8hpp_source.html#l00090">Intrepid2::CellTools&lt; DeviceType &gt;::mapToReferenceFrameInitGuess()</a>.</p>

</div>
</div>
<a id="a7b4e906b9b8ddf007e9d1602ae211cbb" name="a7b4e906b9b8ddf007e9d1602ae211cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4e906b9b8ddf007e9d1602ae211cbb">&#9670;&#160;</a></span>mapToReferenceSubcell() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename refSubcellViewType , typename paramPointViewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::mapToReferenceSubcell </td>
          <td>(</td>
          <td class="paramtype">refSubcellViewType&#160;</td>
          <td class="paramname"><em>refSubcellPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const paramPointViewType&#160;</td>
          <td class="paramname"><em>paramPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ordinal_type&#160;</td>
          <td class="paramname"><em>subcellDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ordinal_type&#160;</td>
          <td class="paramname"><em>subcellOrd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>parentCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes parameterization maps of 1- and 2-subcells of reference cells. </p>
<p>Applies <picture><source srcset="form_70_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\Phi}_i$" src="form_70.png" width="13" height="15"/></picture>, the parametrization map of a subcell <picture><source srcset="form_71_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\mathcal{S}}_i$" src="form_71.png" width="13" height="15"/></picture> from a given reference cell, to a set of points in the parametrization domain <em>R</em> of <picture><source srcset="form_71_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat{\mathcal{S}}_i$" src="form_71.png" width="13" height="15"/></picture>. Returns a rank-2 array with dimensions (P,D) where for 1-subcells:  </p><p class="formulaDsp">
<picture><source srcset="form_72_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
{subcellPoints}(p,*) = \hat{\Phi}_i(t_p) \quad\mbox{and}\quad
\hat{\Phi}_i(t_p) = \left\{
\begin{array}{ll}
(\hat{x}(t_p),\hat{y}(t_p),\hat{z}(t_p)) &amp; \mbox{for 3D parent cells}\\[1.5ex]
(\hat{x}(t_p),\hat{y}(t_p))              &amp; \mbox{for 2D parent cells}
\end{array} \right.
\quad t_p \in R = [-1,1] \,;
\]" src="form_72.png" width="591" height="39"/></picture>
</p>
<p> for 2-subcells:  </p><p class="formulaDsp">
<picture><source srcset="form_73_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
{subcellPoints}(p,*) = \hat{\Phi}_i(u_p,v_p)\quad\mbox{and}\quad
\hat{\Phi}_i(u_p,v_p) = (\hat{x}(u_p,v_p), \hat{y}(u_p,v_p), \hat{z}(u_p, v_p))
\quad (u_p,v_p)\in R
\]" src="form_73.png" width="525" height="16"/></picture>
</p>
<p> and  </p><p class="formulaDsp">
<picture><source srcset="form_74_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
R = \left\{\begin{array}{rl}
\{(0,0),(1,0),(0,1)\} &amp; \mbox{if face is Triangle} \\[1ex]
[-1,1]\times [-1,1] &amp; \mbox{if face is Quadrilateral}
\end{array}\right.
\]" src="form_74.png" width="284" height="39"/></picture>
</p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>Parametrization of 1-subcells is defined for all 2D and 3D cell topologies with reference cells, including special 2D and 3D topologies such as shell and beams. </li>
<li>Parametrization of 2-subcells is defined for all 3D cell topologies with reference cells, including special 3D topologies such as shells.</li>
</ul>
To map a set of points from a parametrization domain to a physical subcell workset, apply <a class="el" href="classIntrepid2_1_1CellTools.html#a4647855c7283cf8bf47c365498121314" title="Computes F, the reference-to-physical frame map.">Intrepid2::CellTools::mapToPhysicalFrame</a> to the output of this method. This will effectively apply the parametrization map <picture><source srcset="form_75_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \Phi_{c,i} =  F_{c}\circ\hat{\Phi}_i $" src="form_75.png" width="75" height="16"/></picture> of each subcell in the workset to <code>paramPoints</code>. Here <em>c</em> is ordinal of a parent cell, relative to subcell workset, and <em>i</em> is subcell ordinal, relative to a reference cell, of the subcell workset. See Section <a class="el" href="cell_tools_page.html#sec_cell_topology_subcell_wset">Subcell worksets</a> for definition of subcell workset and Section <a class="el" href="cell_tools_page.html#sec_cell_topology_subcell_map">Parametrization of physical 1- and 2-subcells</a> for definition of parametrization maps.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refSubcellPoints</td><td>[out] - rank-2 (P,D1) array with images of parameter space points </td></tr>
    <tr><td class="paramname">paramPoints</td><td>[in] - rank-2 (P,D2) array with points in 1D or 2D parameter domain </td></tr>
    <tr><td class="paramname">subcellDim</td><td>[in] - dimension of the subcell where points are mapped to </td></tr>
    <tr><td class="paramname">subcellOrd</td><td>[in] - subcell ordinal </td></tr>
    <tr><td class="paramname">parentCell</td><td>[in] - cell topology of the parent cell. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="Intrepid2__HCURL__TET__In__FEMDef_8hpp_source.html#l00163">Intrepid2::Basis_HCURL_TET_In_FEM&lt; DeviceType, outputValueType, pointValueType &gt;::Basis_HCURL_TET_In_FEM()</a>, <a class="el" href="Intrepid2__HCURL__TRI__In__FEMDef_8hpp_source.html#l00156">Intrepid2::Basis_HCURL_TRI_In_FEM&lt; DeviceType, outputValueType, pointValueType &gt;::Basis_HCURL_TRI_In_FEM()</a>, <a class="el" href="Intrepid2__HDIV__TET__In__FEMDef_8hpp_source.html#l00156">Intrepid2::Basis_HDIV_TET_In_FEM&lt; DeviceType, outputValueType, pointValueType &gt;::Basis_HDIV_TET_In_FEM()</a>, <a class="el" href="Intrepid2__HDIV__TRI__In__FEMDef_8hpp_source.html#l00155">Intrepid2::Basis_HDIV_TRI_In_FEM&lt; DeviceType, outputValueType, pointValueType &gt;::Basis_HDIV_TRI_In_FEM()</a>, <a class="el" href="Intrepid2__HGRAD__TET__Cn__FEMDef_8hpp_source.html#l00184">Intrepid2::Basis_HGRAD_TET_Cn_FEM&lt; DeviceType, outputValueType, pointValueType &gt;::Basis_HGRAD_TET_Cn_FEM()</a>, <a class="el" href="Intrepid2__ProjectionStructDef_8hpp_source.html#l00357">Intrepid2::ProjectionStruct&lt; DeviceType, ValueType &gt;::createHCurlProjectionStruct()</a>, <a class="el" href="Intrepid2__ProjectionStructDef_8hpp_source.html#l00531">Intrepid2::ProjectionStruct&lt; DeviceType, ValueType &gt;::createHDivProjectionStruct()</a>, <a class="el" href="Intrepid2__ProjectionStructDef_8hpp_source.html#l00201">Intrepid2::ProjectionStruct&lt; DeviceType, ValueType &gt;::createHGradProjectionStruct()</a>, <a class="el" href="Intrepid2__ProjectionStructDef_8hpp_source.html#l00033">Intrepid2::ProjectionStruct&lt; DeviceType, ValueType &gt;::createL2ProjectionStruct()</a>, <a class="el" href="Intrepid2__CubatureControlVolumeBoundaryDef_8hpp_source.html#l00024">Intrepid2::CubatureControlVolumeBoundary&lt; DeviceType, pointValueType, weightValueType &gt;::CubatureControlVolumeBoundary()</a>, and <a class="el" href="Intrepid2__CubatureControlVolumeSideDef_8hpp_source.html#l00023">Intrepid2::CubatureControlVolumeSide&lt; DeviceType, pointValueType, weightValueType &gt;::CubatureControlVolumeSide()</a>.</p>

</div>
</div>
<a id="a0fd1d714bc14e5d95beb0c1913c7db37" name="a0fd1d714bc14e5d95beb0c1913c7db37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd1d714bc14e5d95beb0c1913c7db37">&#9670;&#160;</a></span>mapToReferenceSubcell() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename refSubcellViewType , typename paramPointViewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::mapToReferenceSubcell </td>
          <td>(</td>
          <td class="paramtype">refSubcellViewType&#160;</td>
          <td class="paramname"><em>refSubcellPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const paramPointViewType&#160;</td>
          <td class="paramname"><em>paramPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classIntrepid2_1_1RefSubcellParametrization.html">RefSubcellParametrization</a>&lt; DeviceType &gt;::ConstViewType&#160;</td>
          <td class="paramname"><em>subcellParametrization</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ordinal_type&#160;</td>
          <td class="paramname"><em>subcellOrd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes parameterization maps of 1- and 2-subcells of reference cells. </p>
<p>Overload of the previous function (see explanation above) where the subcell parametrization is used instead of passing the parent cell topology. </p>

</div>
</div>
<a id="abfc73d03e80a21b3aa2f3f5c22e404c3" name="abfc73d03e80a21b3aa2f3f5c22e404c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc73d03e80a21b3aa2f3f5c22e404c3">&#9670;&#160;</a></span>mapToReferenceSubcell() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename refSubcellViewType , typename paramPointViewType , typename ordViewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::mapToReferenceSubcell </td>
          <td>(</td>
          <td class="paramtype">refSubcellViewType&#160;</td>
          <td class="paramname"><em>refSubcellPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const paramPointViewType&#160;</td>
          <td class="paramname"><em>paramPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classIntrepid2_1_1RefSubcellParametrization.html">RefSubcellParametrization</a>&lt; DeviceType &gt;::ConstViewType&#160;</td>
          <td class="paramname"><em>subcellParametrization</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ordViewType&#160;</td>
          <td class="paramname"><em>subcellOrd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes parameterization maps of 1- and 2-subcells of reference cells. </p>
<p>Overload of the previous function (see explanation above) where the subcellOrd is a rank-1 array (P). </p>

</div>
</div>
<a id="a673f99af56a3ee5f268a72e3fca2a9fa" name="a673f99af56a3ee5f268a72e3fca2a9fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673f99af56a3ee5f268a72e3fca2a9fa">&#9670;&#160;</a></span>mapToReferenceSubcell() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename refSubcellViewType , typename paramViewType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::mapToReferenceSubcell </td>
          <td>(</td>
          <td class="paramtype">refSubcellViewType&#160;</td>
          <td class="paramname"><em>refSubcellPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const paramViewType&#160;</td>
          <td class="paramname"><em>paramPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ordinal_type&#160;</td>
          <td class="paramname"><em>subcellDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ordinal_type&#160;</td>
          <td class="paramname"><em>subcellOrd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>parentCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefRefToPhys_8hpp_source.html#l00197">197</a> of file <a class="el" href="Intrepid2__CellToolsDefRefToPhys_8hpp_source.html">Intrepid2_CellToolsDefRefToPhys.hpp</a>.</p>

</div>
</div>
<a id="a28ce454dd565c800e75bf9e82959834d" name="a28ce454dd565c800e75bf9e82959834d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ce454dd565c800e75bf9e82959834d">&#9670;&#160;</a></span>mapToReferenceSubcell() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename refSubcellViewType , typename paramViewType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::mapToReferenceSubcell </td>
          <td>(</td>
          <td class="paramtype">refSubcellViewType&#160;</td>
          <td class="paramname"><em>refSubcellPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const paramViewType&#160;</td>
          <td class="paramname"><em>paramPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classIntrepid2_1_1RefSubcellParametrization.html">RefSubcellParametrization</a>&lt; DeviceType &gt;::ConstViewType&#160;</td>
          <td class="paramname"><em>subcellParametrization</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ordinal_type&#160;</td>
          <td class="paramname"><em>subcellOrd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefRefToPhys_8hpp_source.html#l00242">242</a> of file <a class="el" href="Intrepid2__CellToolsDefRefToPhys_8hpp_source.html">Intrepid2_CellToolsDefRefToPhys.hpp</a>.</p>

</div>
</div>
<a id="a121ab625eb64b342af2fb6d1306df77f" name="a121ab625eb64b342af2fb6d1306df77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121ab625eb64b342af2fb6d1306df77f">&#9670;&#160;</a></span>mapToReferenceSubcell() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename refSubcellViewType , typename paramViewType , typename ordViewType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::mapToReferenceSubcell </td>
          <td>(</td>
          <td class="paramtype">refSubcellViewType&#160;</td>
          <td class="paramname"><em>refSubcellPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const paramViewType&#160;</td>
          <td class="paramname"><em>paramPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classIntrepid2_1_1RefSubcellParametrization.html">RefSubcellParametrization</a>&lt; DeviceType &gt;::ConstViewType&#160;</td>
          <td class="paramname"><em>subcellParametrization</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ordViewType&#160;</td>
          <td class="paramname"><em>subcellOrd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefRefToPhys_8hpp_source.html#l00280">280</a> of file <a class="el" href="Intrepid2__CellToolsDefRefToPhys_8hpp_source.html">Intrepid2_CellToolsDefRefToPhys.hpp</a>.</p>

</div>
</div>
<a id="a2248e8b80e5009fe12aa8eeaf6eaadd6" name="a2248e8b80e5009fe12aa8eeaf6eaadd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2248e8b80e5009fe12aa8eeaf6eaadd6">&#9670;&#160;</a></span>setJacobian() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename JacobianViewType , typename PointViewType , typename WorksetCellViewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::setJacobian </td>
          <td>(</td>
          <td class="paramtype">JacobianViewType&#160;</td>
          <td class="paramname"><em>jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointViewType&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WorksetCellViewType&#160;</td>
          <td class="paramname"><em>worksetCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shards::CellTopology&#160;</td>
          <td class="paramname"><em>cellTopo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the Jacobian matrix <em>DF</em> of the reference-to-physical frame map <em>F</em>. </p>
<pre class="fragment">    There are two use cases:
</pre> <ul>
<li>Computes Jacobians <picture><source srcset="form_0_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$DF_{c}$" src="form_0.png" width="24" height="13"/></picture> of the reference-to-physical map for <b>all</b> physical cells in a cell workset on a <b>single</b> set of reference points stored in a rank-2 (P,D) array; </li>
<li>Computes Jacobians <picture><source srcset="form_0_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$DF_{c}$" src="form_0.png" width="24" height="13"/></picture> of the reference-to-physical map for <b>all</b> physical cells in a cell workset on <b>multiple</b> reference point sets having the same number of points, indexed by cell ordinal, and stored in a rank-3 (C,P,D) array;</li>
</ul>
<p>For a single point set in a rank-2 array (P,D) returns a rank-4 (C,P,D,D) array such that  </p><p class="formulaDsp">
<picture><source srcset="form_1_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
        \mbox{jacobian}(c,p,i,j) = [DF_{c}(\mbox{points}(p))]_{ij} \quad c=0,\ldots, C
\]" src="form_1.png" width="289" height="14"/></picture>
</p>
<p> For multiple sets of reference points in a rank-3 (C,P,D) array returns rank-4 (C,P,D,D) array such that  </p><p class="formulaDsp">
<picture><source srcset="form_2_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
        \mbox{jacobian}(c,p,i,j) = [DF_{c}(\mbox{points}(c,p))]_{ij} \quad c=0,\ldots, C
\]" src="form_2.png" width="299" height="14"/></picture>
</p>
 <pre class="fragment">    Requires cell topology with a reference cell. See Section \ref sec_cell_topology_ref_map_DF
    for definition of the Jacobian.

    \warning
    The points are not required to be in the reference cell associated with the specified
    cell topology. CellTools provides several inclusion tests methods to check whether
    or not the points are inside a reference cell.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jacobian</td><td>[out] - rank-4 array with dimensions (C,P,D,D) with the Jacobians </td></tr>
    <tr><td class="paramname">points</td><td>[in] - rank-2/3 array with dimensions (P,D)/(C,P,D) with the evaluation points </td></tr>
    <tr><td class="paramname">cellWorkset</td><td>[in] - rank-3 array with dimensions (C,N,D) with the nodes of the cell workset </td></tr>
    <tr><td class="paramname">cellTopo</td><td>[in] - cell topology of the cells stored in <code>cellWorkset</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellTools_8hpp_source.html#l00284">284</a> of file <a class="el" href="Intrepid2__CellTools_8hpp_source.html">Intrepid2_CellTools.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__CellToolsDefJacobian_8hpp_source.html#l00799">Intrepid2::CellTools&lt; DeviceType &gt;::setJacobian()</a>.</p>

</div>
</div>
<a id="a9b4e2522850bdc5a0100dd0653154f46" name="a9b4e2522850bdc5a0100dd0653154f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4e2522850bdc5a0100dd0653154f46">&#9670;&#160;</a></span>setJacobian() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename JacobianViewType , typename PointViewType , typename WorksetType , typename HGradBasisType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::setJacobian </td>
          <td>(</td>
          <td class="paramtype">JacobianViewType&#160;</td>
          <td class="paramname"><em>jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointViewType&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WorksetType&#160;</td>
          <td class="paramname"><em>worksetCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::RCP&lt; HGradBasisType &gt;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>startCell</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>endCell</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the Jacobian matrix <em>DF</em> of the reference-to-physical frame map <em>F</em>. </p>
<pre class="fragment">    There are two use cases:
</pre> <ul>
<li>Computes Jacobians <picture><source srcset="form_0_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$DF_{c}$" src="form_0.png" width="24" height="13"/></picture> of the reference-to-physical map for <b>all</b> physical cells in a cell workset on a <b>single</b> set of reference points stored in a rank-2 (P,D) array; </li>
<li>Computes Jacobians <picture><source srcset="form_0_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$DF_{c}$" src="form_0.png" width="24" height="13"/></picture> of the reference-to-physical map for <b>all</b> physical cells in a cell workset on <b>multiple</b> reference point sets having the same number of points, indexed by cell ordinal, and stored in a rank-3 (C,P,D) array;</li>
</ul>
<p>For a single point set in a rank-2 array (P,D) returns a rank-4 (C,P,D,D) array such that  </p><p class="formulaDsp">
<picture><source srcset="form_1_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
        \mbox{jacobian}(c,p,i,j) = [DF_{c}(\mbox{points}(p))]_{ij} \quad c=0,\ldots, C
\]" src="form_1.png" width="289" height="14"/></picture>
</p>
<p> For multiple sets of reference points in a rank-3 (C,P,D) array returns rank-4 (C,P,D,D) array such that  </p><p class="formulaDsp">
<picture><source srcset="form_2_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
        \mbox{jacobian}(c,p,i,j) = [DF_{c}(\mbox{points}(c,p))]_{ij} \quad c=0,\ldots, C
\]" src="form_2.png" width="299" height="14"/></picture>
</p>
 <pre class="fragment">    Requires pointer to HGrad basis that defines reference to physical cell mapping.
    See Section \ref sec_cell_topology_ref_map_DF for definition of the Jacobian.

    \warning
    The points are not required to be in the reference cell associated with the specified
    cell topology. CellTools provides several inclusion tests methods to check whether
    or not the points are inside a reference cell.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jacobian</td><td>[out] - rank-4 array with dimensions (C,P,D,D) with the Jacobians </td></tr>
    <tr><td class="paramname">points</td><td>[in] - rank-2/3 array with dimensions (P,D)/(C,P,D) with the evaluation points </td></tr>
    <tr><td class="paramname">cellWorkset</td><td>[in] - rank-3 container with logical dimensions (C,N,D) with the nodes of the cell workset </td></tr>
    <tr><td class="paramname">basis</td><td>[in] - HGrad basis for reference to physical cell mapping </td></tr>
    <tr><td class="paramname">startCell</td><td>[in] - first cell index in cellWorkset for which we should compute the Jacobian; corresponds to the 0 index in Jacobian and/or points container. Default: 0. </td></tr>
    <tr><td class="paramname">endCell</td><td>[in] - first cell index in cellWorkset that we do not process; endCell - startCell must equal the extent of the Jacobian container in dimension 0. Default: -1, a special value that indicates the extent of the cellWorkset should be used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefJacobian_8hpp_source.html#l00798">798</a> of file <a class="el" href="Intrepid2__CellToolsDefJacobian_8hpp_source.html">Intrepid2_CellToolsDefJacobian.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Intrepid2__CubatureControlVolumeDef_8hpp_source.html#l00060">Intrepid2::CubatureControlVolume&lt; DeviceType, pointValueType, weightValueType &gt;::getCubature()</a>, <a class="el" href="Intrepid2__CubatureControlVolumeBoundaryDef_8hpp_source.html#l00146">Intrepid2::CubatureControlVolumeBoundary&lt; DeviceType, pointValueType, weightValueType &gt;::getCubature()</a>, <a class="el" href="Intrepid2__CubatureControlVolumeSideDef_8hpp_source.html#l00079">Intrepid2::CubatureControlVolumeSide&lt; DeviceType, pointValueType, weightValueType &gt;::getCubature()</a>, <a class="el" href="Intrepid2__CellTools_8hpp_source.html#l00284">Intrepid2::CellTools&lt; DeviceType &gt;::setJacobian()</a>, and <a class="el" href="Intrepid2__CellGeometryDef_8hpp_source.html#l00243">Intrepid2::CellGeometry&lt; PointScalar, spaceDim, DeviceType &gt;::setJacobianDataPrivate()</a>.</p>

</div>
</div>
<a id="a451b64ded378fc549938364860fca50c" name="a451b64ded378fc549938364860fca50c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451b64ded378fc549938364860fca50c">&#9670;&#160;</a></span>setJacobian() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename JacobianViewType , typename BasisGradientsType , typename WorksetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::setJacobian </td>
          <td>(</td>
          <td class="paramtype">JacobianViewType&#160;</td>
          <td class="paramname"><em>jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WorksetType&#160;</td>
          <td class="paramname"><em>worksetCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisGradientsType&#160;</td>
          <td class="paramname"><em>gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>startCell</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>endCell</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the Jacobian matrix <em>DF</em> of the reference-to-physical frame map <em>F</em>. </p>
<pre class="fragment">    There are two use cases:
</pre> <ul>
<li>Computes Jacobians <picture><source srcset="form_0_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$DF_{c}$" src="form_0.png" width="24" height="13"/></picture> of the reference-to-physical map for <b>all</b> physical cells in a cell workset on a <b>single</b> set of reference points stored in a rank-2 (P,D) array; </li>
<li>Computes Jacobians <picture><source srcset="form_0_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$DF_{c}$" src="form_0.png" width="24" height="13"/></picture> of the reference-to-physical map for <b>all</b> physical cells in a cell workset on <b>multiple</b> reference point sets having the same number of points, indexed by cell ordinal, and stored in a rank-3 (C,P,D) array;</li>
</ul>
<p>For a single point set in a rank-2 array (P,D) returns a rank-4 (C,P,D,D) array such that  </p><p class="formulaDsp">
<picture><source srcset="form_1_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
        \mbox{jacobian}(c,p,i,j) = [DF_{c}(\mbox{points}(p))]_{ij} \quad c=0,\ldots, C
\]" src="form_1.png" width="289" height="14"/></picture>
</p>
<p> For multiple sets of reference points in a rank-3 (C,P,D) array returns rank-4 (C,P,D,D) array such that  </p><p class="formulaDsp">
<picture><source srcset="form_2_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
        \mbox{jacobian}(c,p,i,j) = [DF_{c}(\mbox{points}(c,p))]_{ij} \quad c=0,\ldots, C
\]" src="form_2.png" width="299" height="14"/></picture>
</p>
 <pre class="fragment">    Requires pointer to HGrad basis that defines reference to physical cell mapping.
    See Section \ref sec_cell_topology_ref_map_DF for definition of the Jacobian.

    \warning
    The points are not required to be in the reference cell associated with the specified
    cell topology. CellTools provides several inclusion tests methods to check whether
    or not the points are inside a reference cell.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jacobian</td><td>[out] - rank-4 array with dimensions (C,P,D,D) with the Jacobians </td></tr>
    <tr><td class="paramname">cellWorkset</td><td>[in] - rank-3 container with logical dimensions (C,N,D) with the nodes of the cell workset </td></tr>
    <tr><td class="paramname">gradients</td><td>[in] - rank-3/4 array with dimensions (N,P,D)/(C,N,P,D) with the gradients of the physical-to-cell mapping </td></tr>
    <tr><td class="paramname">startCell</td><td>[in] - first cell index in cellWorkset for which we should compute the Jacobian; corresponds to the 0 index in Jacobian and/or points container. Default: 0. </td></tr>
    <tr><td class="paramname">endCell</td><td>[in] - first cell index in cellWorkset that we do not process; endCell - startCell must equal the extent of the Jacobian container in dimension 0. Default: -1, a special value that indicates the extent of the cellWorkset should be used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefJacobian_8hpp_source.html#l00770">770</a> of file <a class="el" href="Intrepid2__CellToolsDefJacobian_8hpp_source.html">Intrepid2_CellToolsDefJacobian.hpp</a>.</p>

</div>
</div>
<a id="a92c71ed020b59aae8688fa8b78dc1daa" name="a92c71ed020b59aae8688fa8b78dc1daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c71ed020b59aae8688fa8b78dc1daa">&#9670;&#160;</a></span>setJacobianDet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;class PointScalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::setJacobianDet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>jacobianDet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes determinants corresponding to the Jacobians in the <a class="el" href="classIntrepid2_1_1Data.html" title="Wrapper around a Kokkos::View that allows data that is constant or repeating in various logical dimen...">Data</a> container provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jacobianDet</td><td>[out] - data with shape (C,P), as returned by <a class="el" href="classIntrepid2_1_1CellTools.html#a35a5b4e652b87c54c24879492957007d" title="Allocates and returns a Data container suitable for storing determinants corresponding to the Jacobia...">CellTools::allocateJacobianDet()</a> </td></tr>
    <tr><td class="paramname">jacobian</td><td>[in] - data with shape (C,P,D,D), as returned by <a class="el" href="classIntrepid2_1_1CellGeometry.html#aa13bcb4a1ab79a83b5a4c5a27724c903" title="Allocate a container into which Jacobians of the reference-to-physical mapping can be placed.">CellGeometry::allocateJacobianData()</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefJacobian_8hpp_source.html#l00165">165</a> of file <a class="el" href="Intrepid2__CellToolsDefJacobian_8hpp_source.html">Intrepid2_CellToolsDefJacobian.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__DataVariationType_8hpp_source.html#l00042">Intrepid2::BLOCK_PLUS_DIAGONAL</a>, <a class="el" href="Intrepid2__Data_8hpp_source.html#l00858">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::blockPlusDiagonalLastNonDiagonal()</a>, <a class="el" href="Intrepid2__DataVariationType_8hpp_source.html#l00040">Intrepid2::CONSTANT</a>, <a class="el" href="Intrepid2__RealSpaceToolsDef_8hpp_source.html#l00823">Intrepid2::RealSpaceTools&lt; DeviceType &gt;::det()</a>, <a class="el" href="Intrepid2__Data_8hpp_source.html#l01216">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::extent_int()</a>, <a class="el" href="Intrepid2__Data_8hpp_source.html#l00984">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::getUnderlyingView1()</a>, <a class="el" href="Intrepid2__Data_8hpp_source.html#l00991">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::getUnderlyingView2()</a>, <a class="el" href="Intrepid2__Data_8hpp_source.html#l00998">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::getUnderlyingView3()</a>, <a class="el" href="Intrepid2__Data_8hpp_source.html#l01005">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::getUnderlyingView4()</a>, <a class="el" href="Intrepid2__Data_8hpp_source.html#l01049">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::getUnderlyingViewRank()</a>, <a class="el" href="Intrepid2__Data_8hpp_source.html#l01168">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::getVariationTypes()</a>, and <a class="el" href="Intrepid2__Utils_8hpp_source.html#l00070">INTREPID2_TEST_FOR_EXCEPTION_DEVICE_SAFE</a>.</p>

</div>
</div>
<a id="a45b9b7c93d79757812c1f00f0062bc37" name="a45b9b7c93d79757812c1f00f0062bc37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b9b7c93d79757812c1f00f0062bc37">&#9670;&#160;</a></span>setJacobianDet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename JacobianDetViewType , typename JacobianViewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::setJacobianDet </td>
          <td>(</td>
          <td class="paramtype">JacobianDetViewType&#160;</td>
          <td class="paramname"><em>jacobianDet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const JacobianViewType&#160;</td>
          <td class="paramname"><em>jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the determinant of the Jacobian matrix <em>DF</em> of the reference-to-physical frame map <em>F</em>. </p>
<p>Returns rank-2 array with dimensions (C,P) such that  </p><p class="formulaDsp">
<picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\mbox{jacobianDet}(c,p) = \mbox{det}(\mbox{jacobian}(c,p,*,*)) \quad c=0,\ldots, C
\]" src="form_4.png" width="311" height="14"/></picture>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jacobianDet</td><td>[out] - rank-2 array with dimensions (C,P) with Jacobian determinants </td></tr>
    <tr><td class="paramname">jacobian</td><td>[in] - rank-4 array with dimensions (C,P,D,D) with the Jacobians </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefJacobian_8hpp_source.html#l00873">873</a> of file <a class="el" href="Intrepid2__CellToolsDefJacobian_8hpp_source.html">Intrepid2_CellToolsDefJacobian.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__CellToolsDefValidateArguments_8hpp_source.html#l00154">Intrepid2::CellTools_setJacobianDetArgs()</a>, and <a class="el" href="Intrepid2__RealSpaceToolsDef_8hpp_source.html#l00823">Intrepid2::RealSpaceTools&lt; DeviceType &gt;::det()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Intrepid2__CubatureControlVolumeDef_8hpp_source.html#l00060">Intrepid2::CubatureControlVolume&lt; DeviceType, pointValueType, weightValueType &gt;::getCubature()</a>, and <a class="el" href="Intrepid2__CubatureControlVolumeBoundaryDef_8hpp_source.html#l00146">Intrepid2::CubatureControlVolumeBoundary&lt; DeviceType, pointValueType, weightValueType &gt;::getCubature()</a>.</p>

</div>
</div>
<a id="aed1d1250ba939877511af41fd37be0e8" name="aed1d1250ba939877511af41fd37be0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1d1250ba939877511af41fd37be0e8">&#9670;&#160;</a></span>setJacobianDetInv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;class PointScalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::setJacobianDetInv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>jacobianDetInv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes reciprocals of determinants corresponding to the Jacobians in the <a class="el" href="classIntrepid2_1_1Data.html" title="Wrapper around a Kokkos::View that allows data that is constant or repeating in various logical dimen...">Data</a> container provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jacobianDetInv</td><td>[out] - data with shape (C,P), as returned by <a class="el" href="classIntrepid2_1_1CellTools.html#a35a5b4e652b87c54c24879492957007d" title="Allocates and returns a Data container suitable for storing determinants corresponding to the Jacobia...">CellTools::allocateJacobianDet()</a> </td></tr>
    <tr><td class="paramname">jacobian</td><td>[in] - data with shape (C,P,D,D), as returned by <a class="el" href="classIntrepid2_1_1CellGeometry.html#aa13bcb4a1ab79a83b5a4c5a27724c903" title="Allocate a container into which Jacobians of the reference-to-physical mapping can be placed.">CellGeometry::allocateJacobianData()</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefJacobian_8hpp_source.html#l00432">432</a> of file <a class="el" href="Intrepid2__CellToolsDefJacobian_8hpp_source.html">Intrepid2_CellToolsDefJacobian.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__Data_8hpp_source.html#l01248">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::allocateConstantData()</a>, and <a class="el" href="Intrepid2__Data_8hpp_source.html#l01763">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::storeInPlaceQuotient()</a>.</p>

</div>
</div>
<a id="a28740648a8b95a924afe419b1efbf016" name="a28740648a8b95a924afe419b1efbf016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28740648a8b95a924afe419b1efbf016">&#9670;&#160;</a></span>setJacobianDividedByDet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;class PointScalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::setJacobianDividedByDet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>jacobianDividedByDet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>jacobianDetInv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the Jacobian with shape (C,P,D,D) by the reciprocals of the determinants, with shape (C,P), entrywise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jacobianDividedByDet</td><td>[out] - data container with shape (C,P,D,D), as returned by <a class="el" href="classIntrepid2_1_1CellTools.html#a8db99befc25604df89bb0029e5eeae09" title="Allocates and returns a Data container suitable for storing inverses corresponding to the Jacobians i...">CellTools::allocateJacobianInv()</a> </td></tr>
    <tr><td class="paramname">jacobian</td><td>[in] - data container with shape (C,P,D,D), as returned by <a class="el" href="classIntrepid2_1_1CellTools.html#a8db99befc25604df89bb0029e5eeae09" title="Allocates and returns a Data container suitable for storing inverses corresponding to the Jacobians i...">CellTools::allocateJacobianInv()</a> </td></tr>
    <tr><td class="paramname">jacobianDetInv</td><td>[in] - data with shape (C,P,D,D), as returned by <a class="el" href="classIntrepid2_1_1CellGeometry.html#aa13bcb4a1ab79a83b5a4c5a27724c903" title="Allocate a container into which Jacobians of the reference-to-physical mapping can be placed.">CellGeometry::allocateJacobianData()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc80a502dc785d2d9ed40ddc979282fb" name="adc80a502dc785d2d9ed40ddc979282fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc80a502dc785d2d9ed40ddc979282fb">&#9670;&#160;</a></span>setJacobianDividedByDet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::setJacobianDividedByDet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; Scalar, DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>jacobianDividedByDet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; Scalar, DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; Scalar, DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>jacobianDetInv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefJacobian_8hpp_source.html#l00885">885</a> of file <a class="el" href="Intrepid2__CellToolsDefJacobian_8hpp_source.html">Intrepid2_CellToolsDefJacobian.hpp</a>.</p>

</div>
</div>
<a id="a5d2e9da998624f350ed7fc860969e304" name="a5d2e9da998624f350ed7fc860969e304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2e9da998624f350ed7fc860969e304">&#9670;&#160;</a></span>setJacobianInv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;class PointScalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::setJacobianInv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>jacobianInv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; PointScalar, DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes determinants corresponding to the Jacobians in the <a class="el" href="classIntrepid2_1_1Data.html" title="Wrapper around a Kokkos::View that allows data that is constant or repeating in various logical dimen...">Data</a> container provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jacobianInv</td><td>[out] - data container with shape (C,P,D,D), as returned by <a class="el" href="classIntrepid2_1_1CellTools.html#a8db99befc25604df89bb0029e5eeae09" title="Allocates and returns a Data container suitable for storing inverses corresponding to the Jacobians i...">CellTools::allocateJacobianInv()</a> </td></tr>
    <tr><td class="paramname">jacobian</td><td>[in] - data with shape (C,P,D,D), as returned by <a class="el" href="classIntrepid2_1_1CellGeometry.html#aa13bcb4a1ab79a83b5a4c5a27724c903" title="Allocate a container into which Jacobians of the reference-to-physical mapping can be placed.">CellGeometry::allocateJacobianData()</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefJacobian_8hpp_source.html#l00442">442</a> of file <a class="el" href="Intrepid2__CellToolsDefJacobian_8hpp_source.html">Intrepid2_CellToolsDefJacobian.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__DataVariationType_8hpp_source.html#l00042">Intrepid2::BLOCK_PLUS_DIAGONAL</a>, <a class="el" href="Intrepid2__Data_8hpp_source.html#l00858">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::blockPlusDiagonalLastNonDiagonal()</a>, <a class="el" href="Intrepid2__DataVariationType_8hpp_source.html#l00040">Intrepid2::CONSTANT</a>, <a class="el" href="Intrepid2__Data_8hpp_source.html#l00984">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::getUnderlyingView1()</a>, <a class="el" href="Intrepid2__Data_8hpp_source.html#l00991">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::getUnderlyingView2()</a>, <a class="el" href="Intrepid2__Data_8hpp_source.html#l00998">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::getUnderlyingView3()</a>, <a class="el" href="Intrepid2__Data_8hpp_source.html#l01005">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::getUnderlyingView4()</a>, <a class="el" href="Intrepid2__Data_8hpp_source.html#l01049">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::getUnderlyingViewRank()</a>, <a class="el" href="Intrepid2__Data_8hpp_source.html#l01168">Intrepid2::Data&lt; DataScalar, DeviceType &gt;::getVariationTypes()</a>, <a class="el" href="Intrepid2__Utils_8hpp_source.html#l00070">INTREPID2_TEST_FOR_EXCEPTION_DEVICE_SAFE</a>, and <a class="el" href="Intrepid2__RealSpaceToolsDef_8hpp_source.html#l00717">Intrepid2::RealSpaceTools&lt; DeviceType &gt;::inverse()</a>.</p>

</div>
</div>
<a id="a4b3f3c71168e71bf3db25e9255845126" name="a4b3f3c71168e71bf3db25e9255845126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b3f3c71168e71bf3db25e9255845126">&#9670;&#160;</a></span>setJacobianInv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename JacobianInvViewType , typename JacobianViewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1CellTools.html">Intrepid2::CellTools</a>&lt; DeviceType &gt;::setJacobianInv </td>
          <td>(</td>
          <td class="paramtype">JacobianInvViewType&#160;</td>
          <td class="paramname"><em>jacobianInv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const JacobianViewType&#160;</td>
          <td class="paramname"><em>jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse of the Jacobian matrix <em>DF</em> of the reference-to-physical frame map <em>F</em>. </p>
<p>Returns rank-4 array with dimensions (C,P,D,D) such that  </p><p class="formulaDsp">
<picture><source srcset="form_3_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\mbox{jacobianInv}(c,p,*,*) = \mbox{jacobian}^{-1}(c,p,*,*) \quad c = 0,\ldots, C
\]" src="form_3.png" width="319" height="16"/></picture>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jacobianInv</td><td>[out] - rank-4 array with dimensions (C,P,D,D) with the inverse Jacobians </td></tr>
    <tr><td class="paramname">jacobian</td><td>[in] - rank-4 array with dimensions (C,P,D,D) with the Jacobians </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__CellToolsDefJacobian_8hpp_source.html#l00860">860</a> of file <a class="el" href="Intrepid2__CellToolsDefJacobian_8hpp_source.html">Intrepid2_CellToolsDefJacobian.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__CellToolsDefValidateArguments_8hpp_source.html#l00122">Intrepid2::CellTools_setJacobianInvArgs()</a>, and <a class="el" href="Intrepid2__RealSpaceToolsDef_8hpp_source.html#l00717">Intrepid2::RealSpaceTools&lt; DeviceType &gt;::inverse()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/trilinos.github.io/trilinos.github.io/Trilinos/packages/intrepid2/src/Cell/<a class="el" href="Intrepid2__CellTools_8hpp_source.html">Intrepid2_CellTools.hpp</a></li>
<li>/home/runner/work/trilinos.github.io/trilinos.github.io/Trilinos/packages/intrepid2/src/Cell/<a class="el" href="Intrepid2__CellToolsDefControlVolume_8hpp_source.html">Intrepid2_CellToolsDefControlVolume.hpp</a></li>
<li>/home/runner/work/trilinos.github.io/trilinos.github.io/Trilinos/packages/intrepid2/src/Cell/<a class="el" href="Intrepid2__CellToolsDefInclusion_8hpp_source.html">Intrepid2_CellToolsDefInclusion.hpp</a></li>
<li>/home/runner/work/trilinos.github.io/trilinos.github.io/Trilinos/packages/intrepid2/src/Cell/<a class="el" href="Intrepid2__CellToolsDefJacobian_8hpp_source.html">Intrepid2_CellToolsDefJacobian.hpp</a></li>
<li>/home/runner/work/trilinos.github.io/trilinos.github.io/Trilinos/packages/intrepid2/src/Cell/<a class="el" href="Intrepid2__CellToolsDefNodeInfo_8hpp_source.html">Intrepid2_CellToolsDefNodeInfo.hpp</a></li>
<li>/home/runner/work/trilinos.github.io/trilinos.github.io/Trilinos/packages/intrepid2/src/Cell/<a class="el" href="Intrepid2__CellToolsDefPhysToRef_8hpp_source.html">Intrepid2_CellToolsDefPhysToRef.hpp</a></li>
<li>/home/runner/work/trilinos.github.io/trilinos.github.io/Trilinos/packages/intrepid2/src/Cell/<a class="el" href="Intrepid2__CellToolsDefRefToPhys_8hpp_source.html">Intrepid2_CellToolsDefRefToPhys.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
