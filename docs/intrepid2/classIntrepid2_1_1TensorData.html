<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Intrepid2: Intrepid2::TensorData&lt; Scalar, DeviceType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Intrepid2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Intrepid2</b></li><li class="navelem"><a class="el" href="classIntrepid2_1_1TensorData.html">TensorData</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classIntrepid2_1_1TensorData-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Intrepid2::TensorData&lt; Scalar, DeviceType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>View-like interface to tensor data; tensor components are stored separately and multiplied together at access time.  
 <a href="classIntrepid2_1_1TensorData.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a418232de9b4c299f345aaa28c09969d2" id="r_a418232de9b4c299f345aaa28c09969d2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#a418232de9b4c299f345aaa28c09969d2">value_type</a> = Scalar</td></tr>
<tr class="separator:a418232de9b4c299f345aaa28c09969d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aec2b3f9bc2e209793a78433972be59" id="r_a6aec2b3f9bc2e209793a78433972be59"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#a6aec2b3f9bc2e209793a78433972be59">execution_space</a> = typename DeviceType::execution_space</td></tr>
<tr class="separator:a6aec2b3f9bc2e209793a78433972be59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7f3def36eee19699ed8e578e1431bb22" id="r_a7f3def36eee19699ed8e578e1431bb22"><td class="memTemplParams" colspan="2">template&lt;size_t numTensorComponents&gt; </td></tr>
<tr class="memitem:a7f3def36eee19699ed8e578e1431bb22"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#a7f3def36eee19699ed8e578e1431bb22">TensorData</a> (Kokkos::Array&lt; <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; Scalar, DeviceType &gt;, <a class="el" href="classIntrepid2_1_1TensorData.html#ad10acc292773eac532a538316c61b15e">numTensorComponents</a> &gt; tensorComponents, bool <a class="el" href="classIntrepid2_1_1TensorData.html#a13172559ad75ec2b572d4b6e9554c98a">separateFirstComponent</a>=false)</td></tr>
<tr class="memdesc:a7f3def36eee19699ed8e578e1431bb22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with fixed-length Kokkos::Array argument.  <br /></td></tr>
<tr class="separator:a7f3def36eee19699ed8e578e1431bb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90aae26ea47256bfa972a0982c9bc2d" id="r_ab90aae26ea47256bfa972a0982c9bc2d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#ab90aae26ea47256bfa972a0982c9bc2d">TensorData</a> (std::vector&lt; <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; Scalar, DeviceType &gt; &gt; tensorComponents, bool <a class="el" href="classIntrepid2_1_1TensorData.html#a13172559ad75ec2b572d4b6e9554c98a">separateFirstComponent</a>=false)</td></tr>
<tr class="memdesc:ab90aae26ea47256bfa972a0982c9bc2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with variable-length std::vector containing the components.  <br /></td></tr>
<tr class="separator:ab90aae26ea47256bfa972a0982c9bc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c35dce81744d03d585a23654f1e9e9" id="r_af5c35dce81744d03d585a23654f1e9e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#af5c35dce81744d03d585a23654f1e9e9">TensorData</a> (const <a class="el" href="classIntrepid2_1_1TensorData.html">TensorData</a> &amp;first, const <a class="el" href="classIntrepid2_1_1TensorData.html">TensorData</a> &amp;second, bool <a class="el" href="classIntrepid2_1_1TensorData.html#a13172559ad75ec2b572d4b6e9554c98a">separateFirstComponent</a>=false)</td></tr>
<tr class="memdesc:af5c35dce81744d03d585a23654f1e9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to combine two other <a class="el" href="classIntrepid2_1_1TensorData.html" title="View-like interface to tensor data; tensor components are stored separately and multiplied together a...">TensorData</a> objects.  <br /></td></tr>
<tr class="separator:af5c35dce81744d03d585a23654f1e9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab873fd0e217d788b3c2e9493b2bcc040" id="r_ab873fd0e217d788b3c2e9493b2bcc040"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#ab873fd0e217d788b3c2e9493b2bcc040">TensorData</a> (<a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; Scalar, DeviceType &gt; tensorComponent)</td></tr>
<tr class="memdesc:ab873fd0e217d788b3c2e9493b2bcc040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple constructor for the case of trivial tensor-product structure (single component)  <br /></td></tr>
<tr class="separator:ab873fd0e217d788b3c2e9493b2bcc040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f9969571a4a26266b57c0b77294574" id="r_a08f9969571a4a26266b57c0b77294574"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#a08f9969571a4a26266b57c0b77294574">TensorData</a> ()</td></tr>
<tr class="memdesc:a08f9969571a4a26266b57c0b77294574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a08f9969571a4a26266b57c0b77294574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86aed0fda7c223a8fca41518b87e051" id="r_ad86aed0fda7c223a8fca41518b87e051"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#ad86aed0fda7c223a8fca41518b87e051">TensorData</a> (<a class="el" href="classIntrepid2_1_1TensorData.html">TensorData</a> otherTensorData, std::vector&lt; int &gt; whichComps)</td></tr>
<tr class="memdesc:ad86aed0fda7c223a8fca41518b87e051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that takes a subset of the tensorial components of another <a class="el" href="classIntrepid2_1_1TensorData.html" title="View-like interface to tensor data; tensor components are stored separately and multiplied together a...">TensorData</a> container.  <br /></td></tr>
<tr class="separator:ad86aed0fda7c223a8fca41518b87e051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a5892ffce547d4c569d091a343018c" id="r_af0a5892ffce547d4c569d091a343018c"><td class="memTemplParams" colspan="2">template&lt;typename OtherDeviceType , class  = typename std::enable_if&lt; std::is_same&lt;typename DeviceType::memory_space, typename OtherDeviceType::memory_space&gt;::value&gt;::type, class  = typename std::enable_if&lt;!std::is_same&lt;DeviceType,OtherDeviceType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:af0a5892ffce547d4c569d091a343018c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#af0a5892ffce547d4c569d091a343018c">TensorData</a> (const <a class="el" href="classIntrepid2_1_1TensorData.html">TensorData</a>&lt; Scalar, OtherDeviceType &gt; &amp;tensorData)</td></tr>
<tr class="memdesc:af0a5892ffce547d4c569d091a343018c"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy-like constructor for differing device type, but same memory space. This does a shallow copy of the underlying view.  <br /></td></tr>
<tr class="separator:af0a5892ffce547d4c569d091a343018c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8c6d440d13b04cb6c5b5f471519e92" id="r_a4e8c6d440d13b04cb6c5b5f471519e92"><td class="memTemplParams" colspan="2">template&lt;typename OtherDeviceType , class  = typename std::enable_if&lt;!std::is_same&lt;typename DeviceType::memory_space, typename OtherDeviceType::memory_space&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a4e8c6d440d13b04cb6c5b5f471519e92"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#a4e8c6d440d13b04cb6c5b5f471519e92">TensorData</a> (const <a class="el" href="classIntrepid2_1_1TensorData.html">TensorData</a>&lt; Scalar, OtherDeviceType &gt; &amp;tensorData)</td></tr>
<tr class="memdesc:a4e8c6d440d13b04cb6c5b5f471519e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-like constructor for differing execution spaces. This performs a deep copy of the underlying data.  <br /></td></tr>
<tr class="separator:a4e8c6d440d13b04cb6c5b5f471519e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30aba35ff78bf4091cdd7e7f3404d285" id="r_a30aba35ff78bf4091cdd7e7f3404d285"><td class="memItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION const <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; Scalar, DeviceType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#a30aba35ff78bf4091cdd7e7f3404d285">getTensorComponent</a> (const ordinal_type &amp;r) const</td></tr>
<tr class="memdesc:a30aba35ff78bf4091cdd7e7f3404d285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested tensor component.  <br /></td></tr>
<tr class="separator:a30aba35ff78bf4091cdd7e7f3404d285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739a813618a633a521245bd78b0445b8" id="r_a739a813618a633a521245bd78b0445b8"><td class="memTemplParams" colspan="2">template&lt;typename iType0 &gt; </td></tr>
<tr class="memitem:a739a813618a633a521245bd78b0445b8"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if&lt; std::is_integral&lt; iType0 &gt;::value, Scalar &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#a739a813618a633a521245bd78b0445b8">operator()</a> (const iType0 &amp;tensorEntryIndex) const</td></tr>
<tr class="memdesc:a739a813618a633a521245bd78b0445b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for rank-1 objects.  <br /></td></tr>
<tr class="separator:a739a813618a633a521245bd78b0445b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7a4e282222fa41858c6bf0ce3c4bfe" id="r_a3a7a4e282222fa41858c6bf0ce3c4bfe"><td class="memTemplParams" colspan="2">template&lt;typename iType0 , ordinal_type numTensorComponents&gt; </td></tr>
<tr class="memitem:a3a7a4e282222fa41858c6bf0ce3c4bfe"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if&lt; std::is_integral&lt; iType0 &gt;::value, Scalar &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#a3a7a4e282222fa41858c6bf0ce3c4bfe">operator()</a> (const Kokkos::Array&lt; iType0, <a class="el" href="classIntrepid2_1_1TensorData.html#ad10acc292773eac532a538316c61b15e">numTensorComponents</a> &gt; &amp;entryComponents) const</td></tr>
<tr class="memdesc:a3a7a4e282222fa41858c6bf0ce3c4bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor that accepts a fixed-length array with entries corresponding to component indices.  <br /></td></tr>
<tr class="separator:a3a7a4e282222fa41858c6bf0ce3c4bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26da2402b2ec13d6f7244b6d859646e7" id="r_a26da2402b2ec13d6f7244b6d859646e7"><td class="memTemplParams" colspan="2">template&lt;typename iType0 , typename iType1 &gt; </td></tr>
<tr class="memitem:a26da2402b2ec13d6f7244b6d859646e7"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if&lt;(std::is_integral&lt; iType0 &gt;::value &amp;&amp;std::is_integral&lt; iType1 &gt;::value), Scalar &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#a26da2402b2ec13d6f7244b6d859646e7">operator()</a> (const iType0 &amp;tensorEntryIndex0, const iType1 &amp;tensorEntryIndex1) const</td></tr>
<tr class="memdesc:a26da2402b2ec13d6f7244b6d859646e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for rank-2 objects.  <br /></td></tr>
<tr class="separator:a26da2402b2ec13d6f7244b6d859646e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5524cc707a3105095c0601af32a33e" id="r_a2a5524cc707a3105095c0601af32a33e"><td class="memItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION ordinal_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#a2a5524cc707a3105095c0601af32a33e">getTensorComponentIndex</a> (const ordinal_type &amp;tensorComponent, const ordinal_type &amp;dim, const ordinal_type &amp;enumerationIndex) const</td></tr>
<tr class="memdesc:a2a5524cc707a3105095c0601af32a33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the index into the specified tensorial component in the dimension specified corresponding to the enumerationIndex given for that dimension.  <br /></td></tr>
<tr class="separator:a2a5524cc707a3105095c0601af32a33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace792d2d0e3406de8ad45859465ccb84" id="r_ace792d2d0e3406de8ad45859465ccb84"><td class="memTemplParams" colspan="2">template&lt;typename iType0 , typename iType1 , typename iType2 &gt; </td></tr>
<tr class="memitem:ace792d2d0e3406de8ad45859465ccb84"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if&lt;(std::is_integral&lt; iType0 &gt;::value &amp;&amp;std::is_integral&lt; iType1 &gt;::value &amp;&amp;std::is_integral&lt; iType2 &gt;::value), Scalar &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#ace792d2d0e3406de8ad45859465ccb84">operator()</a> (const iType0 &amp;tensorEntryIndex0, const iType1 &amp;tensorEntryIndex1, const iType2 &amp;tensorEntryIndex2) const</td></tr>
<tr class="memdesc:ace792d2d0e3406de8ad45859465ccb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for rank-3 objects.  <br /></td></tr>
<tr class="separator:ace792d2d0e3406de8ad45859465ccb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d906ee6d6d51b3c678a5a6cde9702e" id="r_a63d906ee6d6d51b3c678a5a6cde9702e"><td class="memTemplParams" colspan="2">template&lt;typename iType0 , typename iType1 , ordinal_type numTensorComponents&gt; </td></tr>
<tr class="memitem:a63d906ee6d6d51b3c678a5a6cde9702e"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if&lt;(std::is_integral&lt; iType0 &gt;::value &amp;&amp;std::is_integral&lt; iType1 &gt;::value), Scalar &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#a63d906ee6d6d51b3c678a5a6cde9702e">operator()</a> (const Kokkos::Array&lt; iType0, <a class="el" href="classIntrepid2_1_1TensorData.html#ad10acc292773eac532a538316c61b15e">numTensorComponents</a> &gt; &amp;entryComponents0, const Kokkos::Array&lt; iType1, <a class="el" href="classIntrepid2_1_1TensorData.html#ad10acc292773eac532a538316c61b15e">numTensorComponents</a> &gt; &amp;entryComponents1) const</td></tr>
<tr class="memdesc:a63d906ee6d6d51b3c678a5a6cde9702e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for rank-2 objects that accepts fixed-length arrays with entries corresponding to component indices.  <br /></td></tr>
<tr class="separator:a63d906ee6d6d51b3c678a5a6cde9702e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe3dd39eace9a9a5467611c705813ec" id="r_a9fe3dd39eace9a9a5467611c705813ec"><td class="memTemplParams" colspan="2">template&lt;typename iType &gt; </td></tr>
<tr class="memitem:a9fe3dd39eace9a9a5467611c705813ec"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if&lt; std::is_integral&lt; iType &gt;::value, ordinal_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#a9fe3dd39eace9a9a5467611c705813ec">extent_int</a> (const iType &amp;d) const</td></tr>
<tr class="memdesc:a9fe3dd39eace9a9a5467611c705813ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logical extent in the requested dimension.  <br /></td></tr>
<tr class="separator:a9fe3dd39eace9a9a5467611c705813ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3a7139140dd9207c850d22c6111d73" id="r_a8c3a7139140dd9207c850d22c6111d73"><td class="memTemplParams" colspan="2">template&lt;typename iType &gt; </td></tr>
<tr class="memitem:a8c3a7139140dd9207c850d22c6111d73"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION constexpr std::enable_if&lt; std::is_integral&lt; iType &gt;::value, size_t &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#a8c3a7139140dd9207c850d22c6111d73">extent</a> (const iType &amp;d) const</td></tr>
<tr class="memdesc:a8c3a7139140dd9207c850d22c6111d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logical extent in the requested dimension.  <br /></td></tr>
<tr class="separator:a8c3a7139140dd9207c850d22c6111d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e44854bb0869fe9d8b6d950d77bff9" id="r_a81e44854bb0869fe9d8b6d950d77bff9"><td class="memItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#a81e44854bb0869fe9d8b6d950d77bff9">isValid</a> () const</td></tr>
<tr class="memdesc:a81e44854bb0869fe9d8b6d950d77bff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true for containers that have data; false for those that don't (e.g., those that have been constructed by the default constructor).  <br /></td></tr>
<tr class="separator:a81e44854bb0869fe9d8b6d950d77bff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a14a04e323ff274eb9e5829c9b1d85" id="r_a93a14a04e323ff274eb9e5829c9b1d85"><td class="memItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION ordinal_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#a93a14a04e323ff274eb9e5829c9b1d85">rank</a> () const</td></tr>
<tr class="memdesc:a93a14a04e323ff274eb9e5829c9b1d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank of the container.  <br /></td></tr>
<tr class="separator:a93a14a04e323ff274eb9e5829c9b1d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10acc292773eac532a538316c61b15e" id="r_ad10acc292773eac532a538316c61b15e"><td class="memItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION ordinal_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#ad10acc292773eac532a538316c61b15e">numTensorComponents</a> () const</td></tr>
<tr class="memdesc:ad10acc292773eac532a538316c61b15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of tensorial components.  <br /></td></tr>
<tr class="separator:ad10acc292773eac532a538316c61b15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13172559ad75ec2b572d4b6e9554c98a" id="r_a13172559ad75ec2b572d4b6e9554c98a"><td class="memItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#a13172559ad75ec2b572d4b6e9554c98a">separateFirstComponent</a> () const</td></tr>
<tr class="memdesc:a13172559ad75ec2b572d4b6e9554c98a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the first component is indexed separately; false if not.  <br /></td></tr>
<tr class="separator:a13172559ad75ec2b572d4b6e9554c98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada1c2b80ac42a5ce68a494847c716cf" id="r_aada1c2b80ac42a5ce68a494847c716cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#aada1c2b80ac42a5ce68a494847c716cf">setFirstComponentExtentInDimension0</a> (const ordinal_type &amp;newExtent)</td></tr>
<tr class="memdesc:aada1c2b80ac42a5ce68a494847c716cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the extent of the first component. Only valid when either there is only one component, or when <a class="el" href="classIntrepid2_1_1TensorData.html#a13172559ad75ec2b572d4b6e9554c98a" title="Returns true if the first component is indexed separately; false if not.">separateFirstComponent()</a> returns true. The intended use case is when the 0 dimension in first component represents a cell index, and the container is resized to match a workset size that does not evenly divide the number of cells.  <br /></td></tr>
<tr class="separator:aada1c2b80ac42a5ce68a494847c716cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0652578db7b9f848b224431e8e09ef28" id="r_a0652578db7b9f848b224431e8e09ef28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#a0652578db7b9f848b224431e8e09ef28">initialize</a> ()</td></tr>
<tr class="memdesc:a0652578db7b9f848b224431e8e09ef28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize members based on constructor parameters.  <br /></td></tr>
<tr class="separator:a0652578db7b9f848b224431e8e09ef28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a66d109eb38ead9f0a497caa82b8a150a" id="r_a66d109eb38ead9f0a497caa82b8a150a"><td class="memItemLeft" align="right" valign="top">Kokkos::Array&lt; <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; Scalar, DeviceType &gt;, <a class="el" href="classIntrepid2_1_1Parameters.html#aa88f67cf02b1f9dfa82120e52984e345">Parameters::MaxTensorComponents</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#a66d109eb38ead9f0a497caa82b8a150a">tensorComponents_</a></td></tr>
<tr class="separator:a66d109eb38ead9f0a497caa82b8a150a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5a4cd8a005d8dd54a7fd4450a4c3a1" id="r_a0c5a4cd8a005d8dd54a7fd4450a4c3a1"><td class="memItemLeft" align="right" valign="top">Kokkos::Array&lt; ordinal_type, 7 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#a0c5a4cd8a005d8dd54a7fd4450a4c3a1">extents_</a></td></tr>
<tr class="separator:a0c5a4cd8a005d8dd54a7fd4450a4c3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13887c7ae6d5de5ddfca28dc979f3def" id="r_a13887c7ae6d5de5ddfca28dc979f3def"><td class="memItemLeft" align="right" valign="top">Kokkos::Array&lt; Kokkos::Array&lt; ordinal_type, <a class="el" href="classIntrepid2_1_1Parameters.html#aa88f67cf02b1f9dfa82120e52984e345">Parameters::MaxTensorComponents</a> &gt;, 7 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#a13887c7ae6d5de5ddfca28dc979f3def">entryModulus_</a></td></tr>
<tr class="separator:a13887c7ae6d5de5ddfca28dc979f3def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae843c58aadab8094077930546464fba5" id="r_ae843c58aadab8094077930546464fba5"><td class="memItemLeft" align="right" valign="top">ordinal_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#ae843c58aadab8094077930546464fba5">rank_</a></td></tr>
<tr class="separator:ae843c58aadab8094077930546464fba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe1c400a4c11eeee3e99eec20cfdda7" id="r_a3fe1c400a4c11eeee3e99eec20cfdda7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#a3fe1c400a4c11eeee3e99eec20cfdda7">separateFirstComponent_</a> = false</td></tr>
<tr class="separator:a3fe1c400a4c11eeee3e99eec20cfdda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e06bcf6462a073cc7e77f977319fc4" id="r_a48e06bcf6462a073cc7e77f977319fc4"><td class="memItemLeft" align="right" valign="top">ordinal_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrepid2_1_1TensorData.html#a48e06bcf6462a073cc7e77f977319fc4">numTensorComponents_</a> = 0</td></tr>
<tr class="separator:a48e06bcf6462a073cc7e77f977319fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Scalar, typename DeviceType&gt;<br />
class Intrepid2::TensorData&lt; Scalar, DeviceType &gt;</div><p>View-like interface to tensor data; tensor components are stored separately and multiplied together at access time. </p>

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00030">30</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a6aec2b3f9bc2e209793a78433972be59" name="a6aec2b3f9bc2e209793a78433972be59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aec2b3f9bc2e209793a78433972be59">&#9670;&#160;</a></span>execution_space</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::execution_space =  typename DeviceType::execution_space</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00033">33</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

</div>
</div>
<a id="a418232de9b4c299f345aaa28c09969d2" name="a418232de9b4c299f345aaa28c09969d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418232de9b4c299f345aaa28c09969d2">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::value_type =  Scalar</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00032">32</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7f3def36eee19699ed8e578e1431bb22" name="a7f3def36eee19699ed8e578e1431bb22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3def36eee19699ed8e578e1431bb22">&#9670;&#160;</a></span>TensorData() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;size_t numTensorComponents&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::TensorData </td>
          <td>(</td>
          <td class="paramtype">Kokkos::Array&lt; <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; Scalar, DeviceType &gt;, <a class="el" href="classIntrepid2_1_1TensorData.html#ad10acc292773eac532a538316c61b15e">numTensorComponents</a> &gt;&#160;</td>
          <td class="paramname"><em>tensorComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>separateFirstComponent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with fixed-length Kokkos::Array argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tensorComponents</td><td>- the data components that will be multiplied together. May not have more than <a class="el" href="classIntrepid2_1_1Parameters.html#aa88f67cf02b1f9dfa82120e52984e345" title="Maximum number of tensor/Cartesian products that can be taken: this allows hypercube basis in 7D to b...">Parameters::MaxTensorComponents</a> entries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separateFirstComponent</td><td>- if true, indicates that the first component will be indexed separately (this is used when the first index corresponds to a cell ordinal)</td></tr>
  </table>
  </dd>
</dl>
<p>When <em>separateFirstComponent</em> is false, <a class="el" href="classIntrepid2_1_1TensorData.html" title="View-like interface to tensor data; tensor components are stored separately and multiplied together a...">TensorData</a> has rank equal to the maximum rank of the components in <em>tensorComponents</em>, and the logical index in rank <em>r</em> is a function of the indices in rank <em>r</em> of its components, where the function is such that the fastest-moving component index is the one for the final component. Components that have rank less than <em>r</em> are understood to have index 0 in that dimension.</p>
<p>When <em>separateFirstComponent</em> is true, all components are required to have rank 1, and <a class="el" href="classIntrepid2_1_1TensorData.html" title="View-like interface to tensor data; tensor components are stored separately and multiplied together a...">TensorData</a> has rank 2, with the first argument reserved for the first component. The second argument is indexed precisely as described above, omitting the first component. </p>

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00094">94</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00045">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::initialize()</a>, and <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00518">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::numTensorComponents()</a>.</p>

</div>
</div>
<a id="ab90aae26ea47256bfa972a0982c9bc2d" name="ab90aae26ea47256bfa972a0982c9bc2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90aae26ea47256bfa972a0982c9bc2d">&#9670;&#160;</a></span>TensorData() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::TensorData </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; Scalar, DeviceType &gt; &gt;&#160;</td>
          <td class="paramname"><em>tensorComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>separateFirstComponent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with variable-length std::vector containing the components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tensorComponents</td><td>- the data components that will be multiplied together. May not have more than <a class="el" href="classIntrepid2_1_1Parameters.html#aa88f67cf02b1f9dfa82120e52984e345" title="Maximum number of tensor/Cartesian products that can be taken: this allows hypercube basis in 7D to b...">Parameters::MaxTensorComponents</a> entries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separateFirstComponent</td><td>- if true, indicates that the first component will be indexed separately (this is used when the first index corresponds to a cell ordinal)</td></tr>
  </table>
  </dd>
</dl>
<p>When <em>separateFirstComponent</em> is false, <a class="el" href="classIntrepid2_1_1TensorData.html" title="View-like interface to tensor data; tensor components are stored separately and multiplied together a...">TensorData</a> has rank equal to the maximum rank of the components in <em>tensorComponents</em>, and the logical index in rank <em>r</em> is a function of the indices in rank <em>r</em> of its components, where the function is such that the fastest-moving component index is the one for the final component. Components that have rank less than <em>r</em> are understood to have index 0 in that dimension.</p>
<p>When <em>separateFirstComponent</em> is true, all components are required to have rank 1, and <a class="el" href="classIntrepid2_1_1TensorData.html" title="View-like interface to tensor data; tensor components are stored separately and multiplied together a...">TensorData</a> has rank 2, with the first argument reserved for the first component. The second argument is indexed precisely as described above, omitting the first component. </p>

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00116">116</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00045">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::initialize()</a>.</p>

</div>
</div>
<a id="af5c35dce81744d03d585a23654f1e9e9" name="af5c35dce81744d03d585a23654f1e9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c35dce81744d03d585a23654f1e9e9">&#9670;&#160;</a></span>TensorData() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::TensorData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntrepid2_1_1TensorData.html">TensorData</a>&lt; Scalar, DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIntrepid2_1_1TensorData.html">TensorData</a>&lt; Scalar, DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>separateFirstComponent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor to combine two other <a class="el" href="classIntrepid2_1_1TensorData.html" title="View-like interface to tensor data; tensor components are stored separately and multiplied together a...">TensorData</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>- <a class="el" href="classIntrepid2_1_1TensorData.html" title="View-like interface to tensor data; tensor components are stored separately and multiplied together a...">TensorData</a> object with the components for the first dimension(s) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second</td><td>- <a class="el" href="classIntrepid2_1_1TensorData.html" title="View-like interface to tensor data; tensor components are stored separately and multiplied together a...">TensorData</a> object with the components for the remaining dimension(s). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separateFirstComponent</td><td>- if true, indicates that the first component (from the first <a class="el" href="classIntrepid2_1_1TensorData.html" title="View-like interface to tensor data; tensor components are stored separately and multiplied together a...">TensorData</a> object) will be indexed separately (this is used when the first index corresponds to a cell ordinal)</td></tr>
  </table>
  </dd>
</dl>
<p>When <em>separateFirstComponent</em> is true, all components are required to have rank 1, and <a class="el" href="classIntrepid2_1_1TensorData.html" title="View-like interface to tensor data; tensor components are stored separately and multiplied together a...">TensorData</a> has rank 2, with the first argument reserved for the first component. The second argument is indexed precisely as described above, omitting the first component. </p>

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00137">137</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00248">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::getTensorComponent()</a>, <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00045">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::initialize()</a>, and <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00518">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::numTensorComponents()</a>.</p>

</div>
</div>
<a id="ab873fd0e217d788b3c2e9493b2bcc040" name="ab873fd0e217d788b3c2e9493b2bcc040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab873fd0e217d788b3c2e9493b2bcc040">&#9670;&#160;</a></span>TensorData() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::TensorData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; Scalar, DeviceType &gt;&#160;</td>
          <td class="paramname"><em>tensorComponent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple constructor for the case of trivial tensor-product structure (single component) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tensorComponent</td><td>- the data component.</td></tr>
  </table>
  </dd>
</dl>
<p>Simple constructor for trivial tensor-product structure. The <a class="el" href="classIntrepid2_1_1TensorData.html" title="View-like interface to tensor data; tensor components are stored separately and multiplied together a...">TensorData</a> object will have precisely the same logical data layout as the provided <em>tensorComponent</em>. </p>

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00161">161</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

</div>
</div>
<a id="a08f9969571a4a26266b57c0b77294574" name="a08f9969571a4a26266b57c0b77294574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f9969571a4a26266b57c0b77294574">&#9670;&#160;</a></span>TensorData() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::TensorData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Default constructor provided to allow an indication of empty/zero data. <a class="el" href="classIntrepid2_1_1TensorData.html#a81e44854bb0869fe9d8b6d950d77bff9" title="Returns true for containers that have data; false for those that don&#39;t (e.g., those that have been co...">TensorData::isValid()</a> will return false. </p>

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00171">171</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

</div>
</div>
<a id="ad86aed0fda7c223a8fca41518b87e051" name="ad86aed0fda7c223a8fca41518b87e051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86aed0fda7c223a8fca41518b87e051">&#9670;&#160;</a></span>TensorData() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::TensorData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntrepid2_1_1TensorData.html">TensorData</a>&lt; Scalar, DeviceType &gt;&#160;</td>
          <td class="paramname"><em>otherTensorData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>whichComps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that takes a subset of the tensorial components of another <a class="el" href="classIntrepid2_1_1TensorData.html" title="View-like interface to tensor data; tensor components are stored separately and multiplied together a...">TensorData</a> container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherTensorData</td><td>- the original <a class="el" href="classIntrepid2_1_1TensorData.html" title="View-like interface to tensor data; tensor components are stored separately and multiplied together a...">TensorData</a> container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">whichComps</td><td>- the tensorial component indices to take from the other container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this does not copy the data. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00184">184</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00248">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::getTensorComponent()</a>, and <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00045">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::initialize()</a>.</p>

</div>
</div>
<a id="af0a5892ffce547d4c569d091a343018c" name="af0a5892ffce547d4c569d091a343018c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a5892ffce547d4c569d091a343018c">&#9670;&#160;</a></span>TensorData() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDeviceType , class  = typename std::enable_if&lt; std::is_same&lt;typename DeviceType::memory_space, typename OtherDeviceType::memory_space&gt;::value&gt;::type, class  = typename std::enable_if&lt;!std::is_same&lt;DeviceType,OtherDeviceType&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::TensorData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntrepid2_1_1TensorData.html">TensorData</a>&lt; Scalar, OtherDeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensorData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy-like constructor for differing device type, but same memory space. This does a shallow copy of the underlying view. </p>

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00200">200</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00518">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::numTensorComponents()</a>.</p>

</div>
</div>
<a id="a4e8c6d440d13b04cb6c5b5f471519e92" name="a4e8c6d440d13b04cb6c5b5f471519e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8c6d440d13b04cb6c5b5f471519e92">&#9670;&#160;</a></span>TensorData() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDeviceType , class  = typename std::enable_if&lt;!std::is_same&lt;typename DeviceType::memory_space, typename OtherDeviceType::memory_space&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::TensorData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIntrepid2_1_1TensorData.html">TensorData</a>&lt; Scalar, OtherDeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensorData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-like constructor for differing execution spaces. This performs a deep copy of the underlying data. </p>

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00223">223</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00248">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::getTensorComponent()</a>, <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00045">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::initialize()</a>, <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00504">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::isValid()</a>, and <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00518">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::numTensorComponents()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8c3a7139140dd9207c850d22c6111d73" name="a8c3a7139140dd9207c850d22c6111d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3a7139140dd9207c850d22c6111d73">&#9670;&#160;</a></span>extent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename iType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION constexpr std::enable_if&lt; std::is_integral&lt; iType &gt;::value, size_t &gt;::type <a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::extent </td>
          <td>(</td>
          <td class="paramtype">const iType &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the logical extent in the requested dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>- the dimension</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the logical extent in the requested dimension. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00499">499</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

</div>
</div>
<a id="a9fe3dd39eace9a9a5467611c705813ec" name="a9fe3dd39eace9a9a5467611c705813ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe3dd39eace9a9a5467611c705813ec">&#9670;&#160;</a></span>extent_int()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename iType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION std::enable_if&lt; std::is_integral&lt; iType &gt;::value, ordinal_type &gt;::type <a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::extent_int </td>
          <td>(</td>
          <td class="paramtype">const iType &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the logical extent in the requested dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>- the dimension</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>logical extent as an integer </dd></dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00487">487</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Intrepid2__CellGeometryDef_8hpp_source.html#l00569">Intrepid2::CellGeometry&lt; PointScalar, spaceDim, DeviceType &gt;::allocateCellMeasure()</a>, <a class="el" href="Intrepid2__IntegrationToolsDef_8hpp_source.html#l00871">Intrepid2::Impl::F_Integrate&lt; Scalar, DeviceType, integralViewRank &gt;::approximateFlopCountPerCell()</a>, <a class="el" href="Intrepid2__CellGeometryDef_8hpp_source.html#l00628">Intrepid2::CellGeometry&lt; PointScalar, spaceDim, DeviceType &gt;::computeCellMeasure()</a>, and <a class="el" href="Intrepid2__IntegrationToolsDef_8hpp_source.html#l01924">Intrepid2::IntegrationTools&lt; DeviceType &gt;::integrate()</a>.</p>

</div>
</div>
<a id="a30aba35ff78bf4091cdd7e7f3404d285" name="a30aba35ff78bf4091cdd7e7f3404d285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30aba35ff78bf4091cdd7e7f3404d285">&#9670;&#160;</a></span>getTensorComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION const <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt; Scalar, DeviceType &gt; &amp; <a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::getTensorComponent </td>
          <td>(</td>
          <td class="paramtype">const ordinal_type &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the requested tensor component. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>- the tensor ordinal of the component </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested tensor component. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00248">248</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Intrepid2__CellGeometryDef_8hpp_source.html#l00569">Intrepid2::CellGeometry&lt; PointScalar, spaceDim, DeviceType &gt;::allocateCellMeasure()</a>, <a class="el" href="Intrepid2__IntegrationToolsDef_8hpp_source.html#l01866">Intrepid2::IntegrationTools&lt; DeviceType &gt;::allocateIntegralData()</a>, <a class="el" href="Intrepid2__IntegrationToolsDef_8hpp_source.html#l00871">Intrepid2::Impl::F_Integrate&lt; Scalar, DeviceType, integralViewRank &gt;::approximateFlopCountPerCell()</a>, <a class="el" href="Intrepid2__CellGeometryDef_8hpp_source.html#l00628">Intrepid2::CellGeometry&lt; PointScalar, spaceDim, DeviceType &gt;::computeCellMeasure()</a>, <a class="el" href="Intrepid2__Cubature_8hpp_source.html#l00166">Intrepid2::Cubature&lt; DeviceType, pointValueType, weightValueType &gt;::getCubature()</a>, <a class="el" href="Intrepid2__TensorBasis_8hpp_source.html#l01437">Intrepid2::Basis_TensorBasis&lt; BasisBaseClass &gt;::getValues()</a>, <a class="el" href="Intrepid2__Basis_8hpp_source.html#l00426">Intrepid2::HierarchicalBasis_HCURL_TRI&lt; DeviceType, double, double, true &gt;::getValues()</a>, <a class="el" href="Intrepid2__IntegrationToolsDef_8hpp_source.html#l01924">Intrepid2::IntegrationTools&lt; DeviceType &gt;::integrate()</a>, <a class="el" href="Intrepid2__IntegrationToolsDef_8hpp_source.html#l00266">Intrepid2::Impl::F_Integrate&lt; Scalar, DeviceType, integralViewRank &gt;::runSpecialized3()</a>, <a class="el" href="Intrepid2__IntegrationToolsDef_8hpp_source.html#l01179">Intrepid2::Impl::F_IntegratePointValueCache&lt; Scalar, DeviceType, integralViewRank &gt;::runSpecialized3()</a>, <a class="el" href="Intrepid2__TensorArgumentIterator_8hpp_source.html#l00049">Intrepid2::TensorArgumentIterator::TensorArgumentIterator()</a>, <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00137">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::TensorData()</a>, <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00223">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::TensorData()</a>, and <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00184">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::TensorData()</a>.</p>

</div>
</div>
<a id="a2a5524cc707a3105095c0601af32a33e" name="a2a5524cc707a3105095c0601af32a33e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5524cc707a3105095c0601af32a33e">&#9670;&#160;</a></span>getTensorComponentIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION ordinal_type <a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::getTensorComponentIndex </td>
          <td>(</td>
          <td class="paramtype">const ordinal_type &amp;&#160;</td>
          <td class="paramname"><em>tensorComponent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ordinal_type &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ordinal_type &amp;&#160;</td>
          <td class="paramname"><em>enumerationIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the index into the specified tensorial component in the dimension specified corresponding to the enumerationIndex given for that dimension. </p>

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00373">373</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

</div>
</div>
<a id="a0652578db7b9f848b224431e8e09ef28" name="a0652578db7b9f848b224431e8e09ef28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0652578db7b9f848b224431e8e09ef28">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize members based on constructor parameters. </p>

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00045">45</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__Utils_8hpp_source.html#l00070">INTREPID2_TEST_FOR_EXCEPTION_DEVICE_SAFE</a>.</p>

<p class="reference">Referenced by <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00137">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::TensorData()</a>, <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00223">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::TensorData()</a>, <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00094">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::TensorData()</a>, <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00116">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::TensorData()</a>, and <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00184">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::TensorData()</a>.</p>

</div>
</div>
<a id="a81e44854bb0869fe9d8b6d950d77bff9" name="a81e44854bb0869fe9d8b6d950d77bff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e44854bb0869fe9d8b6d950d77bff9">&#9670;&#160;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION constexpr bool <a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true for containers that have data; false for those that don't (e.g., those that have been constructed by the default constructor). </p>

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00504">504</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Intrepid2__IntegrationToolsDef_8hpp_source.html#l01924">Intrepid2::IntegrationTools&lt; DeviceType &gt;::integrate()</a>, and <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00223">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::TensorData()</a>.</p>

</div>
</div>
<a id="ad10acc292773eac532a538316c61b15e" name="ad10acc292773eac532a538316c61b15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10acc292773eac532a538316c61b15e">&#9670;&#160;</a></span>numTensorComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION ordinal_type <a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::numTensorComponents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of tensorial components. </p>

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00518">518</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Intrepid2__CellGeometryDef_8hpp_source.html#l00569">Intrepid2::CellGeometry&lt; PointScalar, spaceDim, DeviceType &gt;::allocateCellMeasure()</a>, <a class="el" href="Intrepid2__IntegrationToolsDef_8hpp_source.html#l00871">Intrepid2::Impl::F_Integrate&lt; Scalar, DeviceType, integralViewRank &gt;::approximateFlopCountPerCell()</a>, <a class="el" href="Intrepid2__IntegrationToolsDef_8hpp_source.html#l01618">Intrepid2::Impl::F_IntegratePointValueCache&lt; Scalar, DeviceType, integralViewRank &gt;::approximateFlopCountPerCell()</a>, <a class="el" href="Intrepid2__CellGeometryDef_8hpp_source.html#l00628">Intrepid2::CellGeometry&lt; PointScalar, spaceDim, DeviceType &gt;::computeCellMeasure()</a>, <a class="el" href="Intrepid2__Cubature_8hpp_source.html#l00166">Intrepid2::Cubature&lt; DeviceType, pointValueType, weightValueType &gt;::getCubature()</a>, <a class="el" href="Intrepid2__TensorBasis_8hpp_source.html#l01437">Intrepid2::Basis_TensorBasis&lt; BasisBaseClass &gt;::getValues()</a>, <a class="el" href="Intrepid2__Basis_8hpp_source.html#l00426">Intrepid2::HierarchicalBasis_HCURL_TRI&lt; DeviceType, double, double, true &gt;::getValues()</a>, <a class="el" href="Intrepid2__IntegrationToolsDef_8hpp_source.html#l01924">Intrepid2::IntegrationTools&lt; DeviceType &gt;::integrate()</a>, <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00285">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::operator()()</a>, <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00454">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::operator()()</a>, <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00137">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::TensorData()</a>, <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00200">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::TensorData()</a>, and <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00094">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::TensorData()</a>.</p>

</div>
</div>
<a id="a739a813618a633a521245bd78b0445b8" name="a739a813618a633a521245bd78b0445b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739a813618a633a521245bd78b0445b8">&#9670;&#160;</a></span>operator()() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename iType0 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION std::enable_if&lt; std::is_integral&lt; iType0 &gt;::value, Scalar &gt;::type <a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const iType0 &amp;&#160;</td>
          <td class="paramname"><em>tensorEntryIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor for rank-1 objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tensorEntryIndex</td><td>- the composite entry index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of tensorComponent values with component entry indices corresponding to <em>tensorEntryIndex</em>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00260">260</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__Utils_8hpp_source.html#l00070">INTREPID2_TEST_FOR_EXCEPTION_DEVICE_SAFE</a>.</p>

</div>
</div>
<a id="a26da2402b2ec13d6f7244b6d859646e7" name="a26da2402b2ec13d6f7244b6d859646e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26da2402b2ec13d6f7244b6d859646e7">&#9670;&#160;</a></span>operator()() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename iType0 , typename iType1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION std::enable_if&lt;(std::is_integral&lt; iType0 &gt;::value &amp;&amp;std::is_integral&lt; iType1 &gt;::value), Scalar &gt;::type <a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const iType0 &amp;&#160;</td>
          <td class="paramname"><em>tensorEntryIndex0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iType1 &amp;&#160;</td>
          <td class="paramname"><em>tensorEntryIndex1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor for rank-2 objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tensorEntryIndex0</td><td>- the composite tensor index in the first dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensorEntryIndex1</td><td>- the composite tensor index in the second dimension If constructed with separateFirstComponent = true, <em>tensorEntryIndex0</em> corresponds to the index to be used for the first component. Otherwise, it corresponds to an enumeration of all valid combinations of first arguments to the tensorial components.</td></tr>
  </table>
  </dd>
</dl>
<p>If constructed with separateFirstComponent = true, <em>tensorEntryIndex1</em> corresponds to an enumeration of all valid combinations of second arguments to components after the first. Otherwise, it corresponds to an enumeration of all valid combinations of second arguments to all the tensorial components.</p>
<dl class="section return"><dt>Returns</dt><dd>The product of tensor component values with the specified component entry indices. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00312">312</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__Utils_8hpp_source.html#l00070">INTREPID2_TEST_FOR_EXCEPTION_DEVICE_SAFE</a>.</p>

</div>
</div>
<a id="ace792d2d0e3406de8ad45859465ccb84" name="ace792d2d0e3406de8ad45859465ccb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace792d2d0e3406de8ad45859465ccb84">&#9670;&#160;</a></span>operator()() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename iType0 , typename iType1 , typename iType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION std::enable_if&lt;(std::is_integral&lt; iType0 &gt;::value &amp;&amp;std::is_integral&lt; iType1 &gt;::value &amp;&amp;std::is_integral&lt; iType2 &gt;::value), Scalar &gt;::type <a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const iType0 &amp;&#160;</td>
          <td class="paramname"><em>tensorEntryIndex0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iType1 &amp;&#160;</td>
          <td class="paramname"><em>tensorEntryIndex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iType2 &amp;&#160;</td>
          <td class="paramname"><em>tensorEntryIndex2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor for rank-3 objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tensorEntryIndex0</td><td>- the composite tensor index in the first dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensorEntryIndex1</td><td>- the composite tensor index in the second dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensorEntryIndex2</td><td>- the composite tensor index in the third dimension <em>tensorEntryIndex0</em> corresponds to an enumeration of all valid combinations of first arguments to the tensorial components. Similarly, <em>tensorEntryIndex1</em> and <em>tensorEntryIndex2</em> correspond to an enumeration of all valid second and third arguments to the tensorial components.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of tensor component values with the specified component entry indices. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00399">399</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__Utils_8hpp_source.html#l00070">INTREPID2_TEST_FOR_EXCEPTION_DEVICE_SAFE</a>.</p>

</div>
</div>
<a id="a3a7a4e282222fa41858c6bf0ce3c4bfe" name="a3a7a4e282222fa41858c6bf0ce3c4bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7a4e282222fa41858c6bf0ce3c4bfe">&#9670;&#160;</a></span>operator()() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename iType0 , ordinal_type numTensorComponents&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION std::enable_if&lt; std::is_integral&lt; iType0 &gt;::value, Scalar &gt;::type <a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::Array&lt; iType0, <a class="el" href="classIntrepid2_1_1TensorData.html#ad10acc292773eac532a538316c61b15e">numTensorComponents</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>entryComponents</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor that accepts a fixed-length array with entries corresponding to component indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entryComponents</td><td>- an array with one entry per tensorial component, each entry indicating the requested index into that component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of tensor component values with the specified component entry indices. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00285">285</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__Utils_8hpp_source.html#l00070">INTREPID2_TEST_FOR_EXCEPTION_DEVICE_SAFE</a>, and <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00518">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::numTensorComponents()</a>.</p>

</div>
</div>
<a id="a63d906ee6d6d51b3c678a5a6cde9702e" name="a63d906ee6d6d51b3c678a5a6cde9702e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d906ee6d6d51b3c678a5a6cde9702e">&#9670;&#160;</a></span>operator()() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<div class="memtemplate">
template&lt;typename iType0 , typename iType1 , ordinal_type numTensorComponents&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION std::enable_if&lt;(std::is_integral&lt; iType0 &gt;::value &amp;&amp;std::is_integral&lt; iType1 &gt;::value), Scalar &gt;::type <a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::Array&lt; iType0, <a class="el" href="classIntrepid2_1_1TensorData.html#ad10acc292773eac532a538316c61b15e">numTensorComponents</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>entryComponents0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::Array&lt; iType1, <a class="el" href="classIntrepid2_1_1TensorData.html#ad10acc292773eac532a538316c61b15e">numTensorComponents</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>entryComponents1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor for rank-2 objects that accepts fixed-length arrays with entries corresponding to component indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entryComponents0</td><td>- an array with one entry per tensorial component, each entry indicating the requested index into that component's first dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entryComponents1</td><td>- an array with one entry per tensorial component, each entry indicating the requested index into that component's second dimension</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of tensor component values with the specified component entry indices. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00454">454</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

<p class="reference">References <a class="el" href="Intrepid2__Utils_8hpp_source.html#l00070">INTREPID2_TEST_FOR_EXCEPTION_DEVICE_SAFE</a>, and <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00518">Intrepid2::TensorData&lt; Scalar, DeviceType &gt;::numTensorComponents()</a>.</p>

</div>
</div>
<a id="a93a14a04e323ff274eb9e5829c9b1d85" name="a93a14a04e323ff274eb9e5829c9b1d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a14a04e323ff274eb9e5829c9b1d85">&#9670;&#160;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION ordinal_type <a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rank of the container. </p>

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00511">511</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Intrepid2__CellGeometryDef_8hpp_source.html#l00569">Intrepid2::CellGeometry&lt; PointScalar, spaceDim, DeviceType &gt;::allocateCellMeasure()</a>, and <a class="el" href="Intrepid2__CellGeometryDef_8hpp_source.html#l00628">Intrepid2::CellGeometry&lt; PointScalar, spaceDim, DeviceType &gt;::computeCellMeasure()</a>.</p>

</div>
</div>
<a id="a13172559ad75ec2b572d4b6e9554c98a" name="a13172559ad75ec2b572d4b6e9554c98a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13172559ad75ec2b572d4b6e9554c98a">&#9670;&#160;</a></span>separateFirstComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION bool <a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::separateFirstComponent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the first component is indexed separately; false if not. </p>

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00525">525</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

</div>
</div>
<a id="aada1c2b80ac42a5ce68a494847c716cf" name="aada1c2b80ac42a5ce68a494847c716cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada1c2b80ac42a5ce68a494847c716cf">&#9670;&#160;</a></span>setFirstComponentExtentInDimension0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::setFirstComponentExtentInDimension0 </td>
          <td>(</td>
          <td class="paramtype">const ordinal_type &amp;&#160;</td>
          <td class="paramname"><em>newExtent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the extent of the first component. Only valid when either there is only one component, or when <a class="el" href="classIntrepid2_1_1TensorData.html#a13172559ad75ec2b572d4b6e9554c98a" title="Returns true if the first component is indexed separately; false if not.">separateFirstComponent()</a> returns true. The intended use case is when the 0 dimension in first component represents a cell index, and the container is resized to match a workset size that does not evenly divide the number of cells. </p>

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00531">531</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a13887c7ae6d5de5ddfca28dc979f3def" name="a13887c7ae6d5de5ddfca28dc979f3def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13887c7ae6d5de5ddfca28dc979f3def">&#9670;&#160;</a></span>entryModulus_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::Array&lt;Kokkos::Array&lt;ordinal_type, <a class="el" href="classIntrepid2_1_1Parameters.html#aa88f67cf02b1f9dfa82120e52984e345">Parameters::MaxTensorComponents</a>&gt;, 7&gt; <a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::entryModulus_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00037">37</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

</div>
</div>
<a id="a0c5a4cd8a005d8dd54a7fd4450a4c3a1" name="a0c5a4cd8a005d8dd54a7fd4450a4c3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5a4cd8a005d8dd54a7fd4450a4c3a1">&#9670;&#160;</a></span>extents_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::Array&lt;ordinal_type, 7&gt; <a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::extents_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00036">36</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

</div>
</div>
<a id="a48e06bcf6462a073cc7e77f977319fc4" name="a48e06bcf6462a073cc7e77f977319fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e06bcf6462a073cc7e77f977319fc4">&#9670;&#160;</a></span>numTensorComponents_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ordinal_type <a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::numTensorComponents_ = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00040">40</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

</div>
</div>
<a id="ae843c58aadab8094077930546464fba5" name="ae843c58aadab8094077930546464fba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae843c58aadab8094077930546464fba5">&#9670;&#160;</a></span>rank_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ordinal_type <a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::rank_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00038">38</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

</div>
</div>
<a id="a3fe1c400a4c11eeee3e99eec20cfdda7" name="a3fe1c400a4c11eeee3e99eec20cfdda7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe1c400a4c11eeee3e99eec20cfdda7">&#9670;&#160;</a></span>separateFirstComponent_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::separateFirstComponent_ = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00039">39</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

</div>
</div>
<a id="a66d109eb38ead9f0a497caa82b8a150a" name="a66d109eb38ead9f0a497caa82b8a150a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d109eb38ead9f0a497caa82b8a150a">&#9670;&#160;</a></span>tensorComponents_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::Array&lt; <a class="el" href="classIntrepid2_1_1Data.html">Data</a>&lt;Scalar,DeviceType&gt;, <a class="el" href="classIntrepid2_1_1Parameters.html#aa88f67cf02b1f9dfa82120e52984e345">Parameters::MaxTensorComponents</a>&gt; <a class="el" href="classIntrepid2_1_1TensorData.html">Intrepid2::TensorData</a>&lt; Scalar, DeviceType &gt;::tensorComponents_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Intrepid2__TensorData_8hpp_source.html#l00035">35</a> of file <a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/trilinos.github.io/trilinos.github.io/Trilinos/packages/intrepid2/src/Shared/<a class="el" href="Intrepid2__TensorData_8hpp_source.html">Intrepid2_TensorData.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
