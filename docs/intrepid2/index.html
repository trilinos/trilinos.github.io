<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Intrepid2: INTREPID2 Documentation (Development Version)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Intrepid2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">INTREPID2 Documentation (Development Version) </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro_sec"></a>
Introduction</h1>
<p>Intrepid2 is an extension of <a href="https://trilinos.org/packages/intrepid/">Intrepid</a>, a library of interoperable tools for compatible discretizations of Partial Differential Equations (PDEs). Intrepid2 utilizes <a href="https://github.com/kokkos/">Kokkos</a> dynamic rank views as the default multidimensional array type, which enables the use of Intrepid2 on heterogeneous architectures.</p>
<h1><a class="anchor" id="overview_sec"></a>
Overview</h1>
<p>Current release of Intrepid2 includes the following features: </p><ul>
<li>Default finite element basis functions for <em>H(grad)</em>, <em>H(curl)</em>, <em>H(div)</em> and <em>H(vol)</em> spaces of orders up to 2 on standard cell topologies in 1D, 2D and 3D </li>
<li>High-order (up to 10) basis functions for <em>H(grad)</em>, <em>H(curl)</em>, <em>H(div)</em> and <em>H(vol)</em> spaces on select cell topologies </li>
<li>Pullbacks (transformations) from reference coordinate frame of <em>H(grad)</em>, <em>H(curl)</em>, <em>H(div)</em> and <em>H(vol)</em> fields </li>
<li>Pullbacks of gradient, curl and divergence of <em>H(grad)</em>, <em>H(curl)</em>, <em>H(div)</em> fields </li>
<li>Cubature rules of orders up to 20 on most standard 1D, 2D and 3D cell topologies</li>
</ul>
<h1><a class="anchor" id="quickstart_sec"></a>
Quick Start</h1>
<p>Familiarity with with the following concepts, objects, and tools is required: </p><ul>
<li><a href="https://trilinos.org/packages/shards/">Shards</a> cell topologies, </li>
<li>numerical integration / <a class="el" href="classIntrepid2_1_1Cubature.html" title="Defines the base class for cubature (integration) rules in Intrepid.">Intrepid2::Cubature</a>, </li>
<li>discrete (e.g. finite element) bases / <a class="el" href="classIntrepid2_1_1Basis.html" title="An abstract base class that defines interface for concrete basis implementations for Finite Element (...">Intrepid2::Basis</a> / <a class="el" href="basis_page.html">Intrepid2 basis class</a>, </li>
<li>cell mappings and transformations / <a class="el" href="classIntrepid2_1_1CellTools.html" title="A stateless class for operations on cell data. Provides methods for:">Intrepid2::CellTools</a> / <a class="el" href="cell_tools_page.html">Cell tools</a>, and </li>
<li>function mappings (pullbacks) / <a class="el" href="classIntrepid2_1_1FunctionSpaceTools.html" title="Defines expert-level interfaces for the evaluation of functions and operators in physical space (supp...">Intrepid2::FunctionSpaceTools</a> / <a class="el" href="function_space_tools_page.html">Function space tools</a>.</li>
</ul>
<p>The following example demonstrates, in 7 steps, the computation of finite element stiffness matrices on a set of tetrahedral cells using a piecewise linear basis and an appropriate integration rule.</p>
<h2><a class="anchor" id="topo_qs_sec"></a>
Step 1: Select a cell topology</h2>
<div class="fragment"><div class="line">shards::CellTopology cellType = shards::getCellTopologyData&lt; shards::Tetrahedron&lt;&gt; &gt;(); <span class="comment">// cell type: tetrahedron</span></div>
<div class="line">ordinal_type spaceDim = cellType-&gt;getDimension();                                       <span class="comment">// retrieve spatial dimension</span></div>
<div class="line">ordinal_type numNodes = cellType-&gt;getNodeCount();                                       <span class="comment">// retrieve number of 0-cells (nodes)</span></div>
</div><!-- fragment --><p>We additionally set the number of computational cells <code>numCells</code>.</p>
<h2><a class="anchor" id="integration_qs_sec"></a>
Step 2: Select integration (cubature) rule</h2>
<div class="fragment"><div class="line">DefaultCubatureFactory&lt;double&gt; cubFactory;                                              <span class="comment">// create cubature factory</span></div>
<div class="line">ordinal_type cubDegree = 2;                                                             <span class="comment">// set cubature degree, e.g. 2</span></div>
<div class="line">Teuchos::RCP&lt;Cubature&lt;double&gt; &gt; myCub = cubFactory.create(cellType, cubDegree);         <span class="comment">// create default cubature</span></div>
<div class="line">ordinal_type numCubPoints = myCub-&gt;getNumPoints();                                      <span class="comment">// retrieve number of cubature points</span></div>
</div><!-- fragment --><h2><a class="anchor" id="bases_qs_sec"></a>
Step 3: Select discrete basis</h2>
<div class="fragment"><div class="line">Basis_HGRAD_TET_C1_FEM&lt;double, DynRankView&lt;double&gt; &gt; tetBasis;                          <span class="comment">// create tet basis</span></div>
<div class="line">ordinal_type numFields = tetBasis.getCardinality();                                     <span class="comment">// get basis cardinality</span></div>
</div><!-- fragment --><h2><a class="anchor" id="mdarray_qs_sec"></a>
Step 4: Format multi-dimensional arrays</h2>
<div class="fragment"><div class="line">DynRankView&lt;double&gt; cub_points(numCubPoints, spaceDim);</div>
<div class="line">DynRankView&lt;double&gt; cub_weights(numCubPoints);</div>
<div class="line"> </div>
<div class="line">DynRankView&lt;double&gt; cell_nodes(numCells, numNodes, spaceDim);</div>
<div class="line"> </div>
<div class="line">DynRankView&lt;double&gt; jacobian(numCells, numCubPoints, spaceDim, spaceDim);</div>
<div class="line">DynRankView&lt;double&gt; jacobian_inv(numCells, numCubPoints, spaceDim, spaceDim);</div>
<div class="line">DynRankView&lt;double&gt; jacobian_det(numCells, numCubPoints);</div>
<div class="line">DynRankView&lt;double&gt; weighted_measure(numCells, numCubPoints);</div>
<div class="line"> </div>
<div class="line">DynRankView&lt;double&gt; grad_at_cub_points(numFields, numCubPoints, spaceDim);</div>
<div class="line">DynRankView&lt;double&gt; transformed_grad_at_cub_points(numCells, numFields, numCubPoints, spaceDim);</div>
<div class="line">DynRankView&lt;double&gt; weighted_transformed_grad_at_cub_points(numCells, numFields, numCubPoints, spaceDim);</div>
<div class="line">DynRankView&lt;double&gt; stiffness_matrices(numCells, numFields, numFields);</div>
</div><!-- fragment --><p>We assume that the array <code>cell_nodes</code> is filled with nodes defining a set of computational (physical) cells.</p>
<h2><a class="anchor" id="tabulate_qs_sec"></a>
Step 5: Evaluate differential operator applied to basis at cubature points</h2>
<div class="fragment"><div class="line">myCub-&gt;getCubature(cub_points, cub_weights);                                          <span class="comment">// retrieve cubature points and weights</span></div>
<div class="line">tetBasis.getValues(grad_at_cub_points, cub_points, OPERATOR_GRAD);                    <span class="comment">// evaluate grad operator at cubature points</span></div>
</div><!-- fragment --><h2><a class="anchor" id="ct_qs_sec"></a>
Step 6: Apply cell tools</h2>
<div class="fragment"><div class="line">CellTools&lt;double&gt;::setJacobian(jacobian, cub_points, cell_nodes, cellType);           <span class="comment">// compute cell Jacobians</span></div>
<div class="line">CellTools&lt;double&gt;::setJacobianInv(jacobian_inv, jacobian);                            <span class="comment">// compute inverses of cell Jacobians</span></div>
<div class="line">CellTools&lt;double&gt;::setJacobianDet(jacobian_det, jacobian);                            <span class="comment">// compute determinants of cell Jacobians</span></div>
</div><!-- fragment --><h2><a class="anchor" id="fst_qs_sec"></a>
Step 7: Apply function space tools</h2>
<div class="fragment"><div class="line">FunctionSpaceTools::computeCellMeasure(weighted_measure,                              <span class="comment">// compute weighted cell measure</span></div>
<div class="line">                                               jacobian_det,</div>
<div class="line">                                               cub_weights);</div>
<div class="line">FunctionSpaceTools::HGRADtransformGRAD(transformed_grad_at_cub_points,                <span class="comment">// transform reference gradients into physical space</span></div>
<div class="line">                                               jacobian_inv,</div>
<div class="line">                                               grad_at_cub_points);</div>
<div class="line">FunctionSpaceTools::multiplyMeasure&lt;double&gt;(weighted_transformed_grad_at_cub_points,  <span class="comment">// multiply with weighted measure</span></div>
<div class="line">                                            weighted_measure,</div>
<div class="line">                                            transformed_grad_at_cub_points);</div>
<div class="line">FunctionSpaceTools::integrate&lt;double&gt;(stiffness_matrices,                             <span class="comment">// compute stiffness matrices</span></div>
<div class="line">                                      transformed_grad_at_cub_points,</div>
<div class="line">                                      weighted_transformed_grad_at_cub_points,</div>
<div class="line">                                      COMP_CPP);</div>
</div><!-- fragment --><p>The computed (local) stiffness matrices can now be used in the assembly of a (global) discrete differential operator, e.g. a discrete Laplacian.</p>
<h2><a class="anchor" id="doen_qs_sec"></a>
Done!</h2>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
