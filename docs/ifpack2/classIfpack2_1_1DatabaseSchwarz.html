<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ifpack2 Templated Preconditioning Package: Ifpack2::DatabaseSchwarz&lt; MatrixType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Ifpack2 Templated Preconditioning Package<span id="projectnumber">&#160;Version 1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceIfpack2.html">Ifpack2</a></li><li class="navelem"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">DatabaseSchwarz</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classIfpack2_1_1DatabaseSchwarz-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ifpack2::DatabaseSchwarz&lt; MatrixType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Overlapping Schwarz where redundant patches are not stored explicitly.  
 <a href="classIfpack2_1_1DatabaseSchwarz.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Ifpack2__DatabaseSchwarz__decl_8hpp_source.html">Ifpack2_DatabaseSchwarz_decl.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Ifpack2::DatabaseSchwarz&lt; MatrixType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classIfpack2_1_1DatabaseSchwarz__inherit__graph.png" border="0" usemap="#aIfpack2_1_1DatabaseSchwarz_3_01MatrixType_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aIfpack2_1_1DatabaseSchwarz_3_01MatrixType_01_4_inherit__map" id="aIfpack2_1_1DatabaseSchwarz_3_01MatrixType_01_4_inherit__map">
<area shape="rect" title="Overlapping Schwarz where redundant patches are not stored explicitly." alt="" coords="771,117,965,157"/>
<area shape="rect" href="classIfpack2_1_1Preconditioner.html" title=" " alt="" coords="480,37,719,121"/>
<area shape="poly" title=" " alt="" coords="733,105,777,115,775,120,731,110"/>
<area shape="rect" href="classIfpack2_1_1Preconditioner.html" title="Interface for all Ifpack2 preconditioners." alt="" coords="23,50,195,105"/>
<area shape="poly" title=" " alt="" coords="209,75,480,76,480,81,209,80"/>
<area shape="rect" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html" title=" " alt="" coords="477,145,721,244"/>
<area shape="poly" title=" " alt="" coords="734,163,773,155,774,160,735,168"/>
<area shape="rect" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html" title="Mix&#45;in interface for preconditioners that can change their matrix after construction." alt="" coords="5,176,212,216"/>
<area shape="poly" title=" " alt="" coords="226,193,477,192,477,198,226,198"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Preconditioner computation methods</div></td></tr>
<tr class="memitem:a2df407a7e84e1ddc1cf1509d151c2001" id="r_a2df407a7e84e1ddc1cf1509d151c2001"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a2df407a7e84e1ddc1cf1509d151c2001">setParameters</a> (const Teuchos::ParameterList &amp;params)</td></tr>
<tr class="memdesc:a2df407a7e84e1ddc1cf1509d151c2001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set (or reset) parameters.  <br /></td></tr>
<tr class="separator:a2df407a7e84e1ddc1cf1509d151c2001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837d0d2ed59238fd1c7333845bdfc6f4" id="r_a837d0d2ed59238fd1c7333845bdfc6f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a837d0d2ed59238fd1c7333845bdfc6f4">setZeroStartingSolution</a> (bool zeroStartingSolution)</td></tr>
<tr class="memdesc:a837d0d2ed59238fd1c7333845bdfc6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this preconditioner's parameters.  <br /></td></tr>
<tr class="separator:a837d0d2ed59238fd1c7333845bdfc6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedab37893765194cd61700f820217ed4" id="r_aedab37893765194cd61700f820217ed4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#aedab37893765194cd61700f820217ed4">initialize</a> ()</td></tr>
<tr class="memdesc:aedab37893765194cd61700f820217ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the preconditioner.  <br /></td></tr>
<tr class="separator:aedab37893765194cd61700f820217ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c68b52fac9bd97b46a25d479d54908" id="r_a37c68b52fac9bd97b46a25d479d54908"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a37c68b52fac9bd97b46a25d479d54908">isInitialized</a> () const</td></tr>
<tr class="separator:a37c68b52fac9bd97b46a25d479d54908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47c04c7490f6b37c3cc053934c49624" id="r_ac47c04c7490f6b37c3cc053934c49624"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ac47c04c7490f6b37c3cc053934c49624">compute</a> ()</td></tr>
<tr class="memdesc:ac47c04c7490f6b37c3cc053934c49624"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.  <br /></td></tr>
<tr class="separator:ac47c04c7490f6b37c3cc053934c49624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734b1d76717ba0c0f211445db978d0bf" id="r_a734b1d76717ba0c0f211445db978d0bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a734b1d76717ba0c0f211445db978d0bf">isComputed</a> () const</td></tr>
<tr class="memdesc:a734b1d76717ba0c0f211445db978d0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ac47c04c7490f6b37c3cc053934c49624" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a> has been called at least once.  <br /></td></tr>
<tr class="separator:a734b1d76717ba0c0f211445db978d0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implementation of Ifpack2::Details::CanChangeMatrix</div></td></tr>
<tr class="memitem:ab1f441d93e2f5ae7d626e964f68aeb76" id="r_ab1f441d93e2f5ae7d626e964f68aeb76"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab1f441d93e2f5ae7d626e964f68aeb76">setMatrix</a> (const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#aec9f50c1ab9373d1ad04730715defe6e">row_matrix_type</a> &gt; &amp;A)</td></tr>
<tr class="memdesc:ab1f441d93e2f5ae7d626e964f68aeb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the matrix to be preconditioned.  <br /></td></tr>
<tr class="separator:ab1f441d93e2f5ae7d626e964f68aeb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implementation of Tpetra::Operator</div></td></tr>
<tr class="memitem:a043a55a128148ebe9b08aa281ea52e80" id="r_a043a55a128148ebe9b08aa281ea52e80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a043a55a128148ebe9b08aa281ea52e80">apply</a> (const Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab382eef17ad926c7cd9d298eaf1c94c2">scalar_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a93e5bc7489f84a8d3206ff57bdbc510a">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a60fd4142215dbde1d03992d002bf7a3d">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a1e4de1efdafb07e6ff2aa13d255fb72c">node_type</a> &gt; &amp;X, Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab382eef17ad926c7cd9d298eaf1c94c2">scalar_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a93e5bc7489f84a8d3206ff57bdbc510a">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a60fd4142215dbde1d03992d002bf7a3d">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a1e4de1efdafb07e6ff2aa13d255fb72c">node_type</a> &gt; &amp;Y, Teuchos::ETransp mode=Teuchos::NO_TRANS, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab382eef17ad926c7cd9d298eaf1c94c2">scalar_type</a> alpha=Teuchos::ScalarTraits&lt; <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab382eef17ad926c7cd9d298eaf1c94c2">scalar_type</a> &gt;::one(), <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab382eef17ad926c7cd9d298eaf1c94c2">scalar_type</a> beta=Teuchos::ScalarTraits&lt; <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab382eef17ad926c7cd9d298eaf1c94c2">scalar_type</a> &gt;::zero()) const</td></tr>
<tr class="memdesc:a043a55a128148ebe9b08aa281ea52e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the preconditioner to X, returning the result in Y. Y = alpha*Op(A)*X + beta*Y.  <br /></td></tr>
<tr class="separator:a043a55a128148ebe9b08aa281ea52e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a482b15fa0786d1fb40faf71f299639" id="r_a7a482b15fa0786d1fb40faf71f299639"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a375aad4f078c8c105693d523c4363641">map_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a7a482b15fa0786d1fb40faf71f299639">getDomainMap</a> () const</td></tr>
<tr class="memdesc:a7a482b15fa0786d1fb40faf71f299639"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Tpetra::Map representing the domain of this operator.  <br /></td></tr>
<tr class="separator:a7a482b15fa0786d1fb40faf71f299639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ee1ddd3b81df0bef66637dd61ab649" id="r_ac0ee1ddd3b81df0bef66637dd61ab649"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a375aad4f078c8c105693d523c4363641">map_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ac0ee1ddd3b81df0bef66637dd61ab649">getRangeMap</a> () const</td></tr>
<tr class="memdesc:ac0ee1ddd3b81df0bef66637dd61ab649"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Tpetra::Map representing the range of this operator.  <br /></td></tr>
<tr class="separator:ac0ee1ddd3b81df0bef66637dd61ab649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3efa6b03ff8849269f5668ca89bf297e" id="r_a3efa6b03ff8849269f5668ca89bf297e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a3efa6b03ff8849269f5668ca89bf297e">hasTransposeApply</a> () const</td></tr>
<tr class="memdesc:a3efa6b03ff8849269f5668ca89bf297e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether it's possible to apply the transpose of this operator.  <br /></td></tr>
<tr class="separator:a3efa6b03ff8849269f5668ca89bf297e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f37eb0aa94a2514ddf84839d1e14c62" id="r_a4f37eb0aa94a2514ddf84839d1e14c62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a4f37eb0aa94a2514ddf84839d1e14c62">applyMat</a> (const Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab382eef17ad926c7cd9d298eaf1c94c2">scalar_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a93e5bc7489f84a8d3206ff57bdbc510a">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a60fd4142215dbde1d03992d002bf7a3d">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a1e4de1efdafb07e6ff2aa13d255fb72c">node_type</a> &gt; &amp;X, Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab382eef17ad926c7cd9d298eaf1c94c2">scalar_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a93e5bc7489f84a8d3206ff57bdbc510a">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a60fd4142215dbde1d03992d002bf7a3d">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a1e4de1efdafb07e6ff2aa13d255fb72c">node_type</a> &gt; &amp;Y, Teuchos::ETransp mode=Teuchos::NO_TRANS) const</td></tr>
<tr class="memdesc:a4f37eb0aa94a2514ddf84839d1e14c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Y = Op(A)*X, where Op(A) is either A, \(A^T\), or \(A^H\).  <br /></td></tr>
<tr class="separator:a4f37eb0aa94a2514ddf84839d1e14c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classIfpack2_1_1Preconditioner"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classIfpack2_1_1Preconditioner')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classIfpack2_1_1Preconditioner.html">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a></td></tr>
<tr class="memitem:a637973211128e0c09db53772df0f345d inherit pub_methods_classIfpack2_1_1Preconditioner" id="r_a637973211128e0c09db53772df0f345d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Preconditioner.html#a637973211128e0c09db53772df0f345d">~Preconditioner</a> ()</td></tr>
<tr class="memdesc:a637973211128e0c09db53772df0f345d inherit pub_methods_classIfpack2_1_1Preconditioner"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a637973211128e0c09db53772df0f345d inherit pub_methods_classIfpack2_1_1Preconditioner"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html">Ifpack2::Details::CanChangeMatrix&lt; Tpetra::RowMatrix&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt; &gt;</a></td></tr>
<tr class="memitem:acad726ffa06a9eef5d675364f996101a inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix" id="r_acad726ffa06a9eef5d675364f996101a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">virtual</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html#acad726ffa06a9eef5d675364f996101a">setMatrix</a> (<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> Tpetra::RowMatrix&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt; &gt; &amp;A)=0</td></tr>
<tr class="memdesc:acad726ffa06a9eef5d675364f996101a inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the new matrix.  <br /></td></tr>
<tr class="separator:acad726ffa06a9eef5d675364f996101a inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad9626e6fa50980dc192a4a63341c12 inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix" id="r_abad9626e6fa50980dc192a4a63341c12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">virtual</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html#abad9626e6fa50980dc192a4a63341c12">~CanChangeMatrix</a> ()</td></tr>
<tr class="memdesc:abad9626e6fa50980dc192a4a63341c12 inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:abad9626e6fa50980dc192a4a63341c12 inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Typedefs</h2></td></tr>
<tr class="memitem:a3f213105390ce7f9319b76abe60d8186" id="r_a3f213105390ce7f9319b76abe60d8186"><td class="memItemLeft" align="right" valign="top">typedef MatrixType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a3f213105390ce7f9319b76abe60d8186">matrix_type</a></td></tr>
<tr class="memdesc:a3f213105390ce7f9319b76abe60d8186"><td class="mdescLeft">&#160;</td><td class="mdescRight">The template parameter of this class.  <br /></td></tr>
<tr class="separator:a3f213105390ce7f9319b76abe60d8186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab382eef17ad926c7cd9d298eaf1c94c2" id="r_ab382eef17ad926c7cd9d298eaf1c94c2"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::scalar_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab382eef17ad926c7cd9d298eaf1c94c2">scalar_type</a></td></tr>
<tr class="memdesc:ab382eef17ad926c7cd9d298eaf1c94c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the entries of the input MatrixType.  <br /></td></tr>
<tr class="separator:ab382eef17ad926c7cd9d298eaf1c94c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e5bc7489f84a8d3206ff57bdbc510a" id="r_a93e5bc7489f84a8d3206ff57bdbc510a"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::local_ordinal_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a93e5bc7489f84a8d3206ff57bdbc510a">local_ordinal_type</a></td></tr>
<tr class="memdesc:a93e5bc7489f84a8d3206ff57bdbc510a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of local indices in the input MatrixType.  <br /></td></tr>
<tr class="separator:a93e5bc7489f84a8d3206ff57bdbc510a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60fd4142215dbde1d03992d002bf7a3d" id="r_a60fd4142215dbde1d03992d002bf7a3d"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::global_ordinal_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a60fd4142215dbde1d03992d002bf7a3d">global_ordinal_type</a></td></tr>
<tr class="memdesc:a60fd4142215dbde1d03992d002bf7a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of global indices in the input MatrixType.  <br /></td></tr>
<tr class="separator:a60fd4142215dbde1d03992d002bf7a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e3f6bc74f3bfe2397c0611e605b500" id="r_ab5e3f6bc74f3bfe2397c0611e605b500"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::node_type::device_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab5e3f6bc74f3bfe2397c0611e605b500">device_type</a></td></tr>
<tr class="memdesc:ab5e3f6bc74f3bfe2397c0611e605b500"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Kokkos::Device specialization used by the input MatrixType.  <br /></td></tr>
<tr class="separator:ab5e3f6bc74f3bfe2397c0611e605b500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4de1efdafb07e6ff2aa13d255fb72c" id="r_a1e4de1efdafb07e6ff2aa13d255fb72c"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a1e4de1efdafb07e6ff2aa13d255fb72c">node_type</a></td></tr>
<tr class="memdesc:a1e4de1efdafb07e6ff2aa13d255fb72c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Node type used by the input MatrixType.  <br /></td></tr>
<tr class="separator:a1e4de1efdafb07e6ff2aa13d255fb72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ccc830fe86f8d95c805eb248457b79" id="r_a57ccc830fe86f8d95c805eb248457b79"><td class="memItemLeft" align="right" valign="top">typedef Teuchos::ScalarTraits&lt; <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab382eef17ad926c7cd9d298eaf1c94c2">scalar_type</a> &gt;::magnitudeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a57ccc830fe86f8d95c805eb248457b79">magnitude_type</a></td></tr>
<tr class="memdesc:a57ccc830fe86f8d95c805eb248457b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the magnitude (absolute value) of a matrix entry.  <br /></td></tr>
<tr class="separator:a57ccc830fe86f8d95c805eb248457b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9f50c1ab9373d1ad04730715defe6e" id="r_aec9f50c1ab9373d1ad04730715defe6e"><td class="memItemLeft" align="right" valign="top">typedef Tpetra::RowMatrix&lt; <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab382eef17ad926c7cd9d298eaf1c94c2">scalar_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a93e5bc7489f84a8d3206ff57bdbc510a">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a60fd4142215dbde1d03992d002bf7a3d">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a1e4de1efdafb07e6ff2aa13d255fb72c">node_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#aec9f50c1ab9373d1ad04730715defe6e">row_matrix_type</a></td></tr>
<tr class="memdesc:aec9f50c1ab9373d1ad04730715defe6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Tpetra::RowMatrix specialization matching MatrixType.  <br /></td></tr>
<tr class="separator:aec9f50c1ab9373d1ad04730715defe6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375aad4f078c8c105693d523c4363641" id="r_a375aad4f078c8c105693d523c4363641"><td class="memItemLeft" align="right" valign="top">typedef Tpetra::Map&lt; <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a93e5bc7489f84a8d3206ff57bdbc510a">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a60fd4142215dbde1d03992d002bf7a3d">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a1e4de1efdafb07e6ff2aa13d255fb72c">node_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a375aad4f078c8c105693d523c4363641">map_type</a></td></tr>
<tr class="memdesc:a375aad4f078c8c105693d523c4363641"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Tpetra::Map specialization matching MatrixType.  <br /></td></tr>
<tr class="separator:a375aad4f078c8c105693d523c4363641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad847cdce960935e3b0f8d0f664efe267" id="r_ad847cdce960935e3b0f8d0f664efe267"><td class="memItemLeft" align="right" valign="top">typedef Tpetra::Vector&lt; <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab382eef17ad926c7cd9d298eaf1c94c2">scalar_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a93e5bc7489f84a8d3206ff57bdbc510a">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a60fd4142215dbde1d03992d002bf7a3d">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a1e4de1efdafb07e6ff2aa13d255fb72c">node_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ad847cdce960935e3b0f8d0f664efe267">vector_type</a></td></tr>
<tr class="memdesc:ad847cdce960935e3b0f8d0f664efe267"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Tpetra::Vector specialization matching MatrixType.  <br /></td></tr>
<tr class="separator:ad847cdce960935e3b0f8d0f664efe267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddec396169fdad7889e89257df4f1e5" id="r_a6ddec396169fdad7889e89257df4f1e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a6ddec396169fdad7889e89257df4f1e5">DatabaseSchwarz</a> (const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#aec9f50c1ab9373d1ad04730715defe6e">row_matrix_type</a> &gt; &amp;A)</td></tr>
<tr class="memdesc:a6ddec396169fdad7889e89257df4f1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a6ddec396169fdad7889e89257df4f1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa917b0cba9d8abd921e0b525037ae360" id="r_aa917b0cba9d8abd921e0b525037ae360"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#aa917b0cba9d8abd921e0b525037ae360">DatabaseSchwarz</a> (const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#aec9f50c1ab9373d1ad04730715defe6e">row_matrix_type</a> &gt; &amp;A, Teuchos::ParameterList &amp;params)</td></tr>
<tr class="memdesc:aa917b0cba9d8abd921e0b525037ae360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:aa917b0cba9d8abd921e0b525037ae360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afd48dc1a9a39ec9a509bf0942151b4" id="r_a7afd48dc1a9a39ec9a509bf0942151b4"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a7afd48dc1a9a39ec9a509bf0942151b4">~DatabaseSchwarz</a> ()</td></tr>
<tr class="memdesc:a7afd48dc1a9a39ec9a509bf0942151b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a7afd48dc1a9a39ec9a509bf0942151b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Implementation of Teuchos::Describable</h2></td></tr>
<tr class="memitem:aeb551c468baa681af326341cbf0ad93f" id="r_aeb551c468baa681af326341cbf0ad93f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#aeb551c468baa681af326341cbf0ad93f">description</a> () const</td></tr>
<tr class="memdesc:aeb551c468baa681af326341cbf0ad93f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple one-line description of this object.  <br /></td></tr>
<tr class="separator:aeb551c468baa681af326341cbf0ad93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a44bb8333826db6f3349cc5a06c5048" id="r_a4a44bb8333826db6f3349cc5a06c5048"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a4a44bb8333826db6f3349cc5a06c5048">describe</a> (Teuchos::FancyOStream &amp;out, const Teuchos::EVerbosityLevel verbLevel=Teuchos::Describable::verbLevel_default) const</td></tr>
<tr class="memdesc:a4a44bb8333826db6f3349cc5a06c5048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the object with some verbosity level to a Teuchos::FancyOStream.  <br /></td></tr>
<tr class="separator:a4a44bb8333826db6f3349cc5a06c5048"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Attribute accessor methods</h2></td></tr>
<tr class="memitem:ab5bbd6a70a92f58280664e80c6793985" id="r_ab5bbd6a70a92f58280664e80c6793985"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#aec9f50c1ab9373d1ad04730715defe6e">row_matrix_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab5bbd6a70a92f58280664e80c6793985">A_</a></td></tr>
<tr class="memdesc:ab5bbd6a70a92f58280664e80c6793985"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix for which this is a preconditioner.  <br /></td></tr>
<tr class="separator:ab5bbd6a70a92f58280664e80c6793985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6c744b9708e250e4ff8527d2cc747a" id="r_aca6c744b9708e250e4ff8527d2cc747a"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const Teuchos::Comm&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#aca6c744b9708e250e4ff8527d2cc747a">getComm</a> () const</td></tr>
<tr class="memdesc:aca6c744b9708e250e4ff8527d2cc747a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The communicator over which the matrix is distributed.  <br /></td></tr>
<tr class="separator:aca6c744b9708e250e4ff8527d2cc747a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba2f1fcf36b52c01121b1c25c06d0dc" id="r_afba2f1fcf36b52c01121b1c25c06d0dc"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#aec9f50c1ab9373d1ad04730715defe6e">row_matrix_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#afba2f1fcf36b52c01121b1c25c06d0dc">getMatrix</a> () const</td></tr>
<tr class="memdesc:afba2f1fcf36b52c01121b1c25c06d0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix for which this is a preconditioner.  <br /></td></tr>
<tr class="separator:afba2f1fcf36b52c01121b1c25c06d0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06668f1dc633ce88a553bf9b5362b8b5" id="r_a06668f1dc633ce88a553bf9b5362b8b5"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const Tpetra::CrsMatrix&lt; <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab382eef17ad926c7cd9d298eaf1c94c2">scalar_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a93e5bc7489f84a8d3206ff57bdbc510a">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a60fd4142215dbde1d03992d002bf7a3d">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a1e4de1efdafb07e6ff2aa13d255fb72c">node_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a06668f1dc633ce88a553bf9b5362b8b5">getCrsMatrix</a> () const</td></tr>
<tr class="memdesc:a06668f1dc633ce88a553bf9b5362b8b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to return the matrix A as a Tpetra::CrsMatrix.  <br /></td></tr>
<tr class="separator:a06668f1dc633ce88a553bf9b5362b8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4718b715c44ef45888b5e48650df15aa" id="r_a4718b715c44ef45888b5e48650df15aa"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a4718b715c44ef45888b5e48650df15aa">getComputeFlops</a> () const</td></tr>
<tr class="memdesc:a4718b715c44ef45888b5e48650df15aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of floating-point operations taken by all calls to <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ac47c04c7490f6b37c3cc053934c49624" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a>.  <br /></td></tr>
<tr class="separator:a4718b715c44ef45888b5e48650df15aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a97ee6b67ebe5257dee52abcbe4860" id="r_ae7a97ee6b67ebe5257dee52abcbe4860"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ae7a97ee6b67ebe5257dee52abcbe4860">getApplyFlops</a> () const</td></tr>
<tr class="memdesc:ae7a97ee6b67ebe5257dee52abcbe4860"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of floating-point operations taken by all calls to <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a043a55a128148ebe9b08aa281ea52e80" title="Apply the preconditioner to X, returning the result in Y. Y = alpha*Op(A)*X + beta*Y.">apply()</a>.  <br /></td></tr>
<tr class="separator:ae7a97ee6b67ebe5257dee52abcbe4860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf431c4fa8d8f3d572e176b027ce0ba" id="r_accf431c4fa8d8f3d572e176b027ce0ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#accf431c4fa8d8f3d572e176b027ce0ba">getNumInitialize</a> () const</td></tr>
<tr class="memdesc:accf431c4fa8d8f3d572e176b027ce0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of successful calls to <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#aedab37893765194cd61700f820217ed4" title="Initialize the preconditioner.">initialize()</a>.  <br /></td></tr>
<tr class="separator:accf431c4fa8d8f3d572e176b027ce0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01e4b68b3d23d88a3f4d18d89a7fd1d" id="r_aa01e4b68b3d23d88a3f4d18d89a7fd1d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#aa01e4b68b3d23d88a3f4d18d89a7fd1d">getNumCompute</a> () const</td></tr>
<tr class="memdesc:aa01e4b68b3d23d88a3f4d18d89a7fd1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of successful calls to <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ac47c04c7490f6b37c3cc053934c49624" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a>.  <br /></td></tr>
<tr class="separator:aa01e4b68b3d23d88a3f4d18d89a7fd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605a2f7d4b41a95d0a4240d2af595619" id="r_a605a2f7d4b41a95d0a4240d2af595619"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a605a2f7d4b41a95d0a4240d2af595619">getNumApply</a> () const</td></tr>
<tr class="memdesc:a605a2f7d4b41a95d0a4240d2af595619"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of successful calls to <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a043a55a128148ebe9b08aa281ea52e80" title="Apply the preconditioner to X, returning the result in Y. Y = alpha*Op(A)*X + beta*Y.">apply()</a>.  <br /></td></tr>
<tr class="separator:a605a2f7d4b41a95d0a4240d2af595619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde81b772fe3810d89dd1d905bee9162" id="r_abde81b772fe3810d89dd1d905bee9162"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#abde81b772fe3810d89dd1d905bee9162">getInitializeTime</a> () const</td></tr>
<tr class="memdesc:abde81b772fe3810d89dd1d905bee9162"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total time spent in all calls to <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#aedab37893765194cd61700f820217ed4" title="Initialize the preconditioner.">initialize()</a>.  <br /></td></tr>
<tr class="separator:abde81b772fe3810d89dd1d905bee9162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51c9964b610d8ab6f35b47a8edcd354" id="r_aa51c9964b610d8ab6f35b47a8edcd354"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#aa51c9964b610d8ab6f35b47a8edcd354">getComputeTime</a> () const</td></tr>
<tr class="memdesc:aa51c9964b610d8ab6f35b47a8edcd354"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total time spent in all calls to <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ac47c04c7490f6b37c3cc053934c49624" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a>.  <br /></td></tr>
<tr class="separator:aa51c9964b610d8ab6f35b47a8edcd354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcacc2d4e9e366d134996da74871819" id="r_aabcacc2d4e9e366d134996da74871819"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#aabcacc2d4e9e366d134996da74871819">getApplyTime</a> () const</td></tr>
<tr class="memdesc:aabcacc2d4e9e366d134996da74871819"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total time spent in all calls to <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a043a55a128148ebe9b08aa281ea52e80" title="Apply the preconditioner to X, returning the result in Y. Y = alpha*Op(A)*X + beta*Y.">apply()</a>.  <br /></td></tr>
<tr class="separator:aabcacc2d4e9e366d134996da74871819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2ed880025a259a747bc2f05e46e3f4" id="r_a5a2ed880025a259a747bc2f05e46e3f4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a5a2ed880025a259a747bc2f05e46e3f4">getNodeSmootherComplexity</a> () const</td></tr>
<tr class="memdesc:a5a2ed880025a259a747bc2f05e46e3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a rough estimate of cost per iteration.  <br /></td></tr>
<tr class="separator:a5a2ed880025a259a747bc2f05e46e3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classIfpack2_1_1Preconditioner"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classIfpack2_1_1Preconditioner')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classIfpack2_1_1Preconditioner.html">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a></td></tr>
<tr class="memitem:a222c0e260ac8dc1226573e8a0773ac63 inherit pub_types_classIfpack2_1_1Preconditioner" id="r_a222c0e260ac8dc1226573e8a0773ac63"><td class="memItemLeft" align="right" valign="top">typedef Teuchos::ScalarTraits&lt; MatrixType::scalar_type &gt;::magnitudeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Preconditioner.html#a222c0e260ac8dc1226573e8a0773ac63">magnitude_type</a></td></tr>
<tr class="memdesc:a222c0e260ac8dc1226573e8a0773ac63 inherit pub_types_classIfpack2_1_1Preconditioner"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the magnitude (absolute value) of a matrix entry.  <br /></td></tr>
<tr class="separator:a222c0e260ac8dc1226573e8a0773ac63 inherit pub_types_classIfpack2_1_1Preconditioner"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class MatrixType&gt;<br />
class Ifpack2::DatabaseSchwarz&lt; MatrixType &gt;</div><p>Overlapping Schwarz where redundant patches are not stored explicitly. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>The type of matrix to use.</td></tr>
  </table>
  </dd>
</dl>
<p>This class implements an overlapping Schwarz assuming it has already been provided overlapping data containers. Additionally, it is assumed there is at least one row with PatchSize_ nonzeros for each patch. This means that a matrix obtained from piecewise linear FEMs in 2d, for example, will not have rows with 4 nonzeros for each patch. However, piecewise quadratic FEMs in 2d will have one row with 9 nonzeros for each cell in the mesh, meaning all the patches will be detected. For a matrix corresponding to a Taylor-Hood discretization in 2d (quadratic velocities and linear pressures), the patch size would be 22.</p>
<p>The general algorithm proceeds as follows: </p><ol>
<li>
The rows of A are analyzed sequentially for any row with num_entries == PatchSize_  </li>
<li>
If the current row corresponds to a DOF that has already been "visited", it is skipped  </li>
<li>
Then, all nonzero indices belonging to the row are marked as "visited"  </li>
<li>
The local patch matrix is formed and compared to a database of previous patch matrices. If any patch matrix in the database has an l1 distance to the current patch matrix less than tol, the current patch is not matrix is not stored, but an index pointing it to a replacement is stored instead  </li>
<li>
Finally, if this patch matrix is not sufficiently close to one that has already been seen, it is added to the database  </li>
<li>
The compute phase then inverts only the patch matcies in the database, and the apply phase loops over all patches and applies the inverse of each appropriate patch matrix  </li>
</ol>
<p>In general, there is a noticeable speedup when using this method compared to a typical method. This speedup may be further improved by using more advanced linear algebra interfaces such as batched Kokkos solves instead of the current LAPACK approach. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3f213105390ce7f9319b76abe60d8186" name="a3f213105390ce7f9319b76abe60d8186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f213105390ce7f9319b76abe60d8186">&#9670;&#160;</a></span>matrix_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::matrix_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The template parameter of this class. </p>

</div>
</div>
<a id="ab382eef17ad926c7cd9d298eaf1c94c2" name="ab382eef17ad926c7cd9d298eaf1c94c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab382eef17ad926c7cd9d298eaf1c94c2">&#9670;&#160;</a></span>scalar_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::scalar_type <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::scalar_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the entries of the input MatrixType. </p>

</div>
</div>
<a id="a93e5bc7489f84a8d3206ff57bdbc510a" name="a93e5bc7489f84a8d3206ff57bdbc510a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e5bc7489f84a8d3206ff57bdbc510a">&#9670;&#160;</a></span>local_ordinal_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::local_ordinal_type <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::local_ordinal_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of local indices in the input MatrixType. </p>

</div>
</div>
<a id="a60fd4142215dbde1d03992d002bf7a3d" name="a60fd4142215dbde1d03992d002bf7a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60fd4142215dbde1d03992d002bf7a3d">&#9670;&#160;</a></span>global_ordinal_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::global_ordinal_type <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::global_ordinal_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of global indices in the input MatrixType. </p>

</div>
</div>
<a id="ab5e3f6bc74f3bfe2397c0611e605b500" name="ab5e3f6bc74f3bfe2397c0611e605b500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e3f6bc74f3bfe2397c0611e605b500">&#9670;&#160;</a></span>device_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::node_type::device_type <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::device_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Kokkos::Device specialization used by the input MatrixType. </p>

</div>
</div>
<a id="a1e4de1efdafb07e6ff2aa13d255fb72c" name="a1e4de1efdafb07e6ff2aa13d255fb72c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4de1efdafb07e6ff2aa13d255fb72c">&#9670;&#160;</a></span>node_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::node_type <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::node_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Node type used by the input MatrixType. </p>

</div>
</div>
<a id="a57ccc830fe86f8d95c805eb248457b79" name="a57ccc830fe86f8d95c805eb248457b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ccc830fe86f8d95c805eb248457b79">&#9670;&#160;</a></span>magnitude_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Teuchos::ScalarTraits&lt;<a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab382eef17ad926c7cd9d298eaf1c94c2">scalar_type</a>&gt;::magnitudeType <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::magnitude_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the magnitude (absolute value) of a matrix entry. </p>

</div>
</div>
<a id="aec9f50c1ab9373d1ad04730715defe6e" name="aec9f50c1ab9373d1ad04730715defe6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec9f50c1ab9373d1ad04730715defe6e">&#9670;&#160;</a></span>row_matrix_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Tpetra::RowMatrix&lt;<a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab382eef17ad926c7cd9d298eaf1c94c2">scalar_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a93e5bc7489f84a8d3206ff57bdbc510a">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a60fd4142215dbde1d03992d002bf7a3d">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a1e4de1efdafb07e6ff2aa13d255fb72c">node_type</a>&gt; <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::row_matrix_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Tpetra::RowMatrix specialization matching MatrixType. </p>
<p>MatrixType must be a Tpetra::RowMatrix specialization. This typedef will always be a Tpetra::RowMatrix specialization. </p>

</div>
</div>
<a id="a375aad4f078c8c105693d523c4363641" name="a375aad4f078c8c105693d523c4363641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a375aad4f078c8c105693d523c4363641">&#9670;&#160;</a></span>map_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Tpetra::Map&lt;<a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a93e5bc7489f84a8d3206ff57bdbc510a">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a60fd4142215dbde1d03992d002bf7a3d">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a1e4de1efdafb07e6ff2aa13d255fb72c">node_type</a>&gt; <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::map_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Tpetra::Map specialization matching MatrixType. </p>

</div>
</div>
<a id="ad847cdce960935e3b0f8d0f664efe267" name="ad847cdce960935e3b0f8d0f664efe267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad847cdce960935e3b0f8d0f664efe267">&#9670;&#160;</a></span>vector_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Tpetra::Vector&lt;<a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab382eef17ad926c7cd9d298eaf1c94c2">scalar_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a93e5bc7489f84a8d3206ff57bdbc510a">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a60fd4142215dbde1d03992d002bf7a3d">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a1e4de1efdafb07e6ff2aa13d255fb72c">node_type</a>&gt; <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::vector_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Tpetra::Vector specialization matching MatrixType. </p>
<p>If you wish to supply <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a2df407a7e84e1ddc1cf1509d151c2001" title="Set (or reset) parameters.">setParameters()</a> a precomputed vector of diagonal entries of the matrix, use a pointer to an object of this type. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6ddec396169fdad7889e89257df4f1e5" name="a6ddec396169fdad7889e89257df4f1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ddec396169fdad7889e89257df4f1e5">&#9670;&#160;</a></span>DatabaseSchwarz() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::DatabaseSchwarz </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#aec9f50c1ab9373d1ad04730715defe6e">row_matrix_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>The sparse matrix to which to apply <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html" title="Overlapping Schwarz where redundant patches are not stored explicitly.">DatabaseSchwarz</a> iteration. The matrix A must be square, and its domain Map and range Map must be the same. The latter means that the vectors x and y in the sparse matrix-vector product y = A*x must both have the same distribution over process(es). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa917b0cba9d8abd921e0b525037ae360" name="aa917b0cba9d8abd921e0b525037ae360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa917b0cba9d8abd921e0b525037ae360">&#9670;&#160;</a></span>DatabaseSchwarz() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::DatabaseSchwarz </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#aec9f50c1ab9373d1ad04730715defe6e">row_matrix_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>The sparse matrix to which to apply <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html" title="Overlapping Schwarz where redundant patches are not stored explicitly.">DatabaseSchwarz</a> iteration. The matrix A must be square, and its domain Map and range Map must be the same. The latter means that the vectors x and y in the sparse matrix-vector product y = A*x must both have the same distribution over process(es). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>The parameterlist containing settings for the object, such as the patch size to search for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7afd48dc1a9a39ec9a509bf0942151b4" name="a7afd48dc1a9a39ec9a509bf0942151b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7afd48dc1a9a39ec9a509bf0942151b4">&#9670;&#160;</a></span>~DatabaseSchwarz()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::~<a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">DatabaseSchwarz</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2df407a7e84e1ddc1cf1509d151c2001" name="a2df407a7e84e1ddc1cf1509d151c2001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df407a7e84e1ddc1cf1509d151c2001">&#9670;&#160;</a></span>setParameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::setParameters </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set (or reset) parameters. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a60340992fc1b9eac82ef35333bee6efd">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a837d0d2ed59238fd1c7333845bdfc6f4" name="a837d0d2ed59238fd1c7333845bdfc6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837d0d2ed59238fd1c7333845bdfc6f4">&#9670;&#160;</a></span>setZeroStartingSolution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::setZeroStartingSolution </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zeroStartingSolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this preconditioner's parameters. </p>

<p>Reimplemented from <a class="el" href="classIfpack2_1_1Preconditioner.html#a12495acd22d15212241c0d518d7f6536">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="aedab37893765194cd61700f820217ed4" name="aedab37893765194cd61700f820217ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedab37893765194cd61700f820217ed4">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the preconditioner. </p>
<p>The <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ac47c04c7490f6b37c3cc053934c49624" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a> method will call <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#aedab37893765194cd61700f820217ed4" title="Initialize the preconditioner.">initialize()</a> automatically if it has not yet been called, so you do not normally need to call this. However, it is correct to call <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#aedab37893765194cd61700f820217ed4" title="Initialize the preconditioner.">initialize()</a> yourself, and <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ac47c04c7490f6b37c3cc053934c49624" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a> will not call it again if it already has been called. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#ad3aefd6f16e8ef4cddb696cd23f160b0">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a37c68b52fac9bd97b46a25d479d54908" name="a37c68b52fac9bd97b46a25d479d54908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c68b52fac9bd97b46a25d479d54908">&#9670;&#160;</a></span>isInitialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::isInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether the preconditioner has been successfully initialized (by calling <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#aedab37893765194cd61700f820217ed4" title="Initialize the preconditioner.">initialize()</a>). </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a180c876ccf7af87f10a1c1d08ba2dc01">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="ac47c04c7490f6b37c3cc053934c49624" name="ac47c04c7490f6b37c3cc053934c49624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47c04c7490f6b37c3cc053934c49624">&#9670;&#160;</a></span>compute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::compute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a23954dd69f62b56455a9c0988bbe9e67">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a734b1d76717ba0c0f211445db978d0bf" name="a734b1d76717ba0c0f211445db978d0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734b1d76717ba0c0f211445db978d0bf">&#9670;&#160;</a></span>isComputed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::isComputed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ac47c04c7490f6b37c3cc053934c49624" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a> has been called at least once. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#abb5af77756a7488ab636dbd97483ca66">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="ab1f441d93e2f5ae7d626e964f68aeb76" name="ab1f441d93e2f5ae7d626e964f68aeb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f441d93e2f5ae7d626e964f68aeb76">&#9670;&#160;</a></span>setMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::setMatrix </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#aec9f50c1ab9373d1ad04730715defe6e">row_matrix_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the matrix to be preconditioned. </p>

</div>
</div>
<a id="a043a55a128148ebe9b08aa281ea52e80" name="a043a55a128148ebe9b08aa281ea52e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043a55a128148ebe9b08aa281ea52e80">&#9670;&#160;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab382eef17ad926c7cd9d298eaf1c94c2">scalar_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a93e5bc7489f84a8d3206ff57bdbc510a">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a60fd4142215dbde1d03992d002bf7a3d">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a1e4de1efdafb07e6ff2aa13d255fb72c">node_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab382eef17ad926c7cd9d298eaf1c94c2">scalar_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a93e5bc7489f84a8d3206ff57bdbc510a">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a60fd4142215dbde1d03992d002bf7a3d">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a1e4de1efdafb07e6ff2aa13d255fb72c">node_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::ETransp&#160;</td>
          <td class="paramname"><em>mode</em> = <code>Teuchos::NO_TRANS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab382eef17ad926c7cd9d298eaf1c94c2">scalar_type</a>&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>Teuchos::ScalarTraits&lt;<a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab382eef17ad926c7cd9d298eaf1c94c2">scalar_type</a>&gt;::one()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab382eef17ad926c7cd9d298eaf1c94c2">scalar_type</a>&#160;</td>
          <td class="paramname"><em>beta</em> = <code>Teuchos::ScalarTraits&lt;<a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab382eef17ad926c7cd9d298eaf1c94c2">scalar_type</a>&gt;::zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the preconditioner to X, returning the result in Y. Y = alpha*Op(A)*X + beta*Y. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a606c3f8155f67f2867fac3a7c44bd5df">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a7a482b15fa0786d1fb40faf71f299639" name="a7a482b15fa0786d1fb40faf71f299639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a482b15fa0786d1fb40faf71f299639">&#9670;&#160;</a></span>getDomainMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const typename <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">DatabaseSchwarz</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a375aad4f078c8c105693d523c4363641">::map_type</a> &gt; <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::getDomainMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Tpetra::Map representing the domain of this operator. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#aafeb2143ff699f2289503a85f6e3523c">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="ac0ee1ddd3b81df0bef66637dd61ab649" name="ac0ee1ddd3b81df0bef66637dd61ab649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ee1ddd3b81df0bef66637dd61ab649">&#9670;&#160;</a></span>getRangeMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const typename <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">DatabaseSchwarz</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a375aad4f078c8c105693d523c4363641">::map_type</a> &gt; <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::getRangeMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Tpetra::Map representing the range of this operator. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a75b32e1de03024035b00cd2ee95a60da">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a3efa6b03ff8849269f5668ca89bf297e" name="a3efa6b03ff8849269f5668ca89bf297e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3efa6b03ff8849269f5668ca89bf297e">&#9670;&#160;</a></span>hasTransposeApply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::hasTransposeApply </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether it's possible to apply the transpose of this operator. </p>

</div>
</div>
<a id="a4f37eb0aa94a2514ddf84839d1e14c62" name="a4f37eb0aa94a2514ddf84839d1e14c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f37eb0aa94a2514ddf84839d1e14c62">&#9670;&#160;</a></span>applyMat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::applyMat </td>
          <td>(</td>
          <td class="paramtype">const Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab382eef17ad926c7cd9d298eaf1c94c2">scalar_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a93e5bc7489f84a8d3206ff57bdbc510a">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a60fd4142215dbde1d03992d002bf7a3d">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a1e4de1efdafb07e6ff2aa13d255fb72c">node_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ab382eef17ad926c7cd9d298eaf1c94c2">scalar_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a93e5bc7489f84a8d3206ff57bdbc510a">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a60fd4142215dbde1d03992d002bf7a3d">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a1e4de1efdafb07e6ff2aa13d255fb72c">node_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::ETransp&#160;</td>
          <td class="paramname"><em>mode</em> = <code>Teuchos::NO_TRANS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Y = Op(A)*X, where Op(A) is either A, \(A^T\), or \(A^H\). </p>

</div>
</div>
<a id="aca6c744b9708e250e4ff8527d2cc747a" name="aca6c744b9708e250e4ff8527d2cc747a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6c744b9708e250e4ff8527d2cc747a">&#9670;&#160;</a></span>getComm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const Teuchos::Comm&lt; int &gt; &gt; <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::getComm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The communicator over which the matrix is distributed. </p>

</div>
</div>
<a id="afba2f1fcf36b52c01121b1c25c06d0dc" name="afba2f1fcf36b52c01121b1c25c06d0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba2f1fcf36b52c01121b1c25c06d0dc">&#9670;&#160;</a></span>getMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const typename <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">DatabaseSchwarz</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#aec9f50c1ab9373d1ad04730715defe6e">::row_matrix_type</a> &gt; <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::getMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The matrix for which this is a preconditioner. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a4258d242e7ff6003c399da8f0a11d634">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a06668f1dc633ce88a553bf9b5362b8b5" name="a06668f1dc633ce88a553bf9b5362b8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06668f1dc633ce88a553bf9b5362b8b5">&#9670;&#160;</a></span>getCrsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const Tpetra::CrsMatrix&lt; typename MatrixType::scalar_type, typename MatrixType::local_ordinal_type, typename MatrixType::global_ordinal_type, typename MatrixType::node_type &gt; &gt; <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::getCrsMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to return the matrix A as a Tpetra::CrsMatrix. </p>
<p>This class does not require that A be a Tpetra::CrsMatrix. If it is NOT, this method will return Teuchos::null. </p>

</div>
</div>
<a id="a4718b715c44ef45888b5e48650df15aa" name="a4718b715c44ef45888b5e48650df15aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4718b715c44ef45888b5e48650df15aa">&#9670;&#160;</a></span>getComputeFlops()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::getComputeFlops </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The total number of floating-point operations taken by all calls to <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ac47c04c7490f6b37c3cc053934c49624" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a>. </p>

</div>
</div>
<a id="ae7a97ee6b67ebe5257dee52abcbe4860" name="ae7a97ee6b67ebe5257dee52abcbe4860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a97ee6b67ebe5257dee52abcbe4860">&#9670;&#160;</a></span>getApplyFlops()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::getApplyFlops </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The total number of floating-point operations taken by all calls to <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a043a55a128148ebe9b08aa281ea52e80" title="Apply the preconditioner to X, returning the result in Y. Y = alpha*Op(A)*X + beta*Y.">apply()</a>. </p>

</div>
</div>
<a id="accf431c4fa8d8f3d572e176b027ce0ba" name="accf431c4fa8d8f3d572e176b027ce0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf431c4fa8d8f3d572e176b027ce0ba">&#9670;&#160;</a></span>getNumInitialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::getNumInitialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of successful calls to <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#aedab37893765194cd61700f820217ed4" title="Initialize the preconditioner.">initialize()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#afe6c77c5ab6da065f8dbade353e8535a">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="aa01e4b68b3d23d88a3f4d18d89a7fd1d" name="aa01e4b68b3d23d88a3f4d18d89a7fd1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01e4b68b3d23d88a3f4d18d89a7fd1d">&#9670;&#160;</a></span>getNumCompute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::getNumCompute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of successful calls to <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ac47c04c7490f6b37c3cc053934c49624" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a286b18ee0769ecc8bf992dffdc442791">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a605a2f7d4b41a95d0a4240d2af595619" name="a605a2f7d4b41a95d0a4240d2af595619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605a2f7d4b41a95d0a4240d2af595619">&#9670;&#160;</a></span>getNumApply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::getNumApply </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of successful calls to <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a043a55a128148ebe9b08aa281ea52e80" title="Apply the preconditioner to X, returning the result in Y. Y = alpha*Op(A)*X + beta*Y.">apply()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a565e6c00bf14873ae7b23187c9978078">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="abde81b772fe3810d89dd1d905bee9162" name="abde81b772fe3810d89dd1d905bee9162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde81b772fe3810d89dd1d905bee9162">&#9670;&#160;</a></span>getInitializeTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::getInitializeTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total time spent in all calls to <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#aedab37893765194cd61700f820217ed4" title="Initialize the preconditioner.">initialize()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#aeb91a16f5544ad4efaf756b1d2a8b39d">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="aa51c9964b610d8ab6f35b47a8edcd354" name="aa51c9964b610d8ab6f35b47a8edcd354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51c9964b610d8ab6f35b47a8edcd354">&#9670;&#160;</a></span>getComputeTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::getComputeTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total time spent in all calls to <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#ac47c04c7490f6b37c3cc053934c49624" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a111d9bd4e28c0633696f271955ddcb4c">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="aabcacc2d4e9e366d134996da74871819" name="aabcacc2d4e9e366d134996da74871819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabcacc2d4e9e366d134996da74871819">&#9670;&#160;</a></span>getApplyTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::getApplyTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total time spent in all calls to <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#a043a55a128148ebe9b08aa281ea52e80" title="Apply the preconditioner to X, returning the result in Y. Y = alpha*Op(A)*X + beta*Y.">apply()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a57c2d00799de050cd2a5a75ce80f48b9">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a5a2ed880025a259a747bc2f05e46e3f4" name="a5a2ed880025a259a747bc2f05e46e3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2ed880025a259a747bc2f05e46e3f4">&#9670;&#160;</a></span>getNodeSmootherComplexity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::getNodeSmootherComplexity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a rough estimate of cost per iteration. </p>

</div>
</div>
<a id="aeb551c468baa681af326341cbf0ad93f" name="aeb551c468baa681af326341cbf0ad93f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb551c468baa681af326341cbf0ad93f">&#9670;&#160;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple one-line description of this object. </p>

</div>
</div>
<a id="a4a44bb8333826db6f3349cc5a06c5048" name="a4a44bb8333826db6f3349cc5a06c5048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a44bb8333826db6f3349cc5a06c5048">&#9670;&#160;</a></span>describe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::describe </td>
          <td>(</td>
          <td class="paramtype">Teuchos::FancyOStream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::EVerbosityLevel&#160;</td>
          <td class="paramname"><em>verbLevel</em> = <code>Teuchos::Describable::verbLevel_default</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the object with some verbosity level to a Teuchos::FancyOStream. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab5bbd6a70a92f58280664e80c6793985" name="ab5bbd6a70a92f58280664e80c6793985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5bbd6a70a92f58280664e80c6793985">&#9670;&#160;</a></span>A_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt;const <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html#aec9f50c1ab9373d1ad04730715defe6e">row_matrix_type</a>&gt; <a class="el" href="classIfpack2_1_1DatabaseSchwarz.html">Ifpack2::DatabaseSchwarz</a>&lt; MatrixType &gt;::A_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The matrix for which this is a preconditioner. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Ifpack2__DatabaseSchwarz__decl_8hpp_source.html">Ifpack2_DatabaseSchwarz_decl.hpp</a></li>
<li><a class="el" href="Ifpack2__DatabaseSchwarz__def_8hpp_source.html">Ifpack2_DatabaseSchwarz_def.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
