<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ifpack2 Templated Preconditioning Package: Ifpack2::MDF&lt; MatrixType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Ifpack2 Templated Preconditioning Package<span id="projectnumber">&#160;Version 1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceIfpack2.html">Ifpack2</a></li><li class="navelem"><a class="el" href="classIfpack2_1_1MDF.html">MDF</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="classIfpack2_1_1MDF-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ifpack2::MDF&lt; MatrixType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classIfpack2_1_1MDF.html" title="MDF (incomplete LU factorization with minimum discarded fill reordering) of a Tpetra sparse matrix.">MDF</a> (incomplete LU factorization with minimum discarded fill reordering) of a Tpetra sparse matrix.  
 <a href="classIfpack2_1_1MDF.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Ifpack2__MDF__decl_8hpp_source.html">Ifpack2_MDF_decl.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Ifpack2::MDF&lt; MatrixType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classIfpack2_1_1MDF__inherit__graph.png" border="0" usemap="#aIfpack2_1_1MDF_3_01MatrixType_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aIfpack2_1_1MDF_3_01MatrixType_01_4_inherit__map" id="aIfpack2_1_1MDF_3_01MatrixType_01_4_inherit__map">
<area shape="rect" title="MDF (incomplete LU factorization with minimum discarded fill reordering) of a Tpetra sparse matrix." alt="" coords="771,125,981,150"/>
<area shape="rect" href="classIfpack2_1_1Preconditioner.html" title=" " alt="" coords="480,37,719,121"/>
<area shape="poly" title=" " alt="" coords="733,104,816,122,815,127,732,109"/>
<area shape="rect" href="classIfpack2_1_1Preconditioner.html" title="Interface for all Ifpack2 preconditioners." alt="" coords="23,50,195,105"/>
<area shape="poly" title=" " alt="" coords="209,75,480,76,480,81,209,80"/>
<area shape="rect" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html" title=" " alt="" coords="477,145,721,244"/>
<area shape="poly" title=" " alt="" coords="734,164,813,147,815,153,735,169"/>
<area shape="rect" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html" title="Mix&#45;in interface for preconditioners that can change their matrix after construction." alt="" coords="5,176,212,216"/>
<area shape="poly" title=" " alt="" coords="226,193,477,192,477,198,226,198"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad909535d2d95008ad5960fd1ebb26c03" id="r_ad909535d2d95008ad5960fd1ebb26c03"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::scalar_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#ad909535d2d95008ad5960fd1ebb26c03">scalar_type</a></td></tr>
<tr class="memdesc:ad909535d2d95008ad5960fd1ebb26c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the entries of the input MatrixType.  <br /></td></tr>
<tr class="separator:ad909535d2d95008ad5960fd1ebb26c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb88c2b827d16b505aae0db1d4af1b4" id="r_a4bb88c2b827d16b505aae0db1d4af1b4"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::local_ordinal_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a4bb88c2b827d16b505aae0db1d4af1b4">local_ordinal_type</a></td></tr>
<tr class="memdesc:a4bb88c2b827d16b505aae0db1d4af1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of local indices in the input MatrixType.  <br /></td></tr>
<tr class="separator:a4bb88c2b827d16b505aae0db1d4af1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf29d4a280fbf0dce1ea5dcd691bf0c5" id="r_aaf29d4a280fbf0dce1ea5dcd691bf0c5"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::global_ordinal_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#aaf29d4a280fbf0dce1ea5dcd691bf0c5">global_ordinal_type</a></td></tr>
<tr class="memdesc:aaf29d4a280fbf0dce1ea5dcd691bf0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of global indices in the input MatrixType.  <br /></td></tr>
<tr class="separator:aaf29d4a280fbf0dce1ea5dcd691bf0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4559e2048e71da85196e184842bdd1" id="r_aab4559e2048e71da85196e184842bdd1"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#aab4559e2048e71da85196e184842bdd1">node_type</a></td></tr>
<tr class="memdesc:aab4559e2048e71da85196e184842bdd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Node type used by the input MatrixType.  <br /></td></tr>
<tr class="separator:aab4559e2048e71da85196e184842bdd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125acd37687f6dd046d5e5d5f2ad9173" id="r_a125acd37687f6dd046d5e5d5f2ad9173"><td class="memItemLeft" align="right" valign="top">typedef Teuchos::ScalarTraits&lt; <a class="el" href="classIfpack2_1_1MDF.html#ad909535d2d95008ad5960fd1ebb26c03">scalar_type</a> &gt;::magnitudeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a125acd37687f6dd046d5e5d5f2ad9173">magnitude_type</a></td></tr>
<tr class="memdesc:a125acd37687f6dd046d5e5d5f2ad9173"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the magnitude (absolute value) of a matrix entry.  <br /></td></tr>
<tr class="separator:a125acd37687f6dd046d5e5d5f2ad9173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae974a0f0803a8428c4eda9558db220a9" id="r_ae974a0f0803a8428c4eda9558db220a9"><td class="memItemLeft" align="right" valign="top">typedef node_type::device_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#ae974a0f0803a8428c4eda9558db220a9">device_type</a></td></tr>
<tr class="memdesc:ae974a0f0803a8428c4eda9558db220a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Kokkos device type of the input MatrixType.  <br /></td></tr>
<tr class="separator:ae974a0f0803a8428c4eda9558db220a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0901627f8b97a1977a0585246b5c568b" id="r_a0901627f8b97a1977a0585246b5c568b"><td class="memItemLeft" align="right" valign="top">typedef node_type::execution_space&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a0901627f8b97a1977a0585246b5c568b">execution_space</a></td></tr>
<tr class="memdesc:a0901627f8b97a1977a0585246b5c568b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Kokkos execution space of the input MatrixType.  <br /></td></tr>
<tr class="separator:a0901627f8b97a1977a0585246b5c568b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71700e90faed3525ea51ece7a28b312" id="r_aa71700e90faed3525ea51ece7a28b312"><td class="memItemLeft" align="right" valign="top">typedef Tpetra::RowMatrix&lt; <a class="el" href="classIfpack2_1_1MDF.html#ad909535d2d95008ad5960fd1ebb26c03">scalar_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#a4bb88c2b827d16b505aae0db1d4af1b4">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#aaf29d4a280fbf0dce1ea5dcd691bf0c5">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#aab4559e2048e71da85196e184842bdd1">node_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#aa71700e90faed3525ea51ece7a28b312">row_matrix_type</a></td></tr>
<tr class="memdesc:aa71700e90faed3525ea51ece7a28b312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tpetra::RowMatrix specialization used by this class.  <br /></td></tr>
<tr class="separator:aa71700e90faed3525ea51ece7a28b312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968a62c443f467afbf8728a475421df9" id="r_a968a62c443f467afbf8728a475421df9"><td class="memItemLeft" align="right" valign="top">typedef Tpetra::CrsMatrix&lt; <a class="el" href="classIfpack2_1_1MDF.html#ad909535d2d95008ad5960fd1ebb26c03">scalar_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#a4bb88c2b827d16b505aae0db1d4af1b4">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#aaf29d4a280fbf0dce1ea5dcd691bf0c5">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#aab4559e2048e71da85196e184842bdd1">node_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a968a62c443f467afbf8728a475421df9">crs_matrix_type</a></td></tr>
<tr class="memdesc:a968a62c443f467afbf8728a475421df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tpetra::CrsMatrix specialization used by this class for representing L and U.  <br /></td></tr>
<tr class="separator:a968a62c443f467afbf8728a475421df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac969696d7cc34a6468802618b4db35a0" id="r_ac969696d7cc34a6468802618b4db35a0"><td class="memItemLeft" align="right" valign="top">typedef crs_matrix_type::impl_scalar_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#ac969696d7cc34a6468802618b4db35a0">impl_scalar_type</a></td></tr>
<tr class="memdesc:ac969696d7cc34a6468802618b4db35a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar type stored in Kokkos::Views (CrsMatrix and MultiVector)  <br /></td></tr>
<tr class="separator:ac969696d7cc34a6468802618b4db35a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classIfpack2_1_1Preconditioner"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classIfpack2_1_1Preconditioner')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classIfpack2_1_1Preconditioner.html">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a></td></tr>
<tr class="memitem:a222c0e260ac8dc1226573e8a0773ac63 inherit pub_types_classIfpack2_1_1Preconditioner" id="r_a222c0e260ac8dc1226573e8a0773ac63"><td class="memItemLeft" align="right" valign="top">typedef Teuchos::ScalarTraits&lt; MatrixType::scalar_type &gt;::magnitudeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Preconditioner.html#a222c0e260ac8dc1226573e8a0773ac63">magnitude_type</a></td></tr>
<tr class="memdesc:a222c0e260ac8dc1226573e8a0773ac63 inherit pub_types_classIfpack2_1_1Preconditioner"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the magnitude (absolute value) of a matrix entry.  <br /></td></tr>
<tr class="separator:a222c0e260ac8dc1226573e8a0773ac63 inherit pub_types_classIfpack2_1_1Preconditioner"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Implementation of Ifpack2::Details::CanChangeMatrix</div></td></tr>
<tr class="memitem:ae07a61e9c3ba1f966bd08753abe6cd55" id="r_ae07a61e9c3ba1f966bd08753abe6cd55"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#ae07a61e9c3ba1f966bd08753abe6cd55">setMatrix</a> (const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1MDF.html#aa71700e90faed3525ea51ece7a28b312">row_matrix_type</a> &gt; &amp;A)</td></tr>
<tr class="memdesc:ae07a61e9c3ba1f966bd08753abe6cd55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the matrix to be preconditioned.  <br /></td></tr>
<tr class="separator:ae07a61e9c3ba1f966bd08753abe6cd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implementation of Teuchos::Describable interface</div></td></tr>
<tr class="memitem:a6510e511444f8d1c72e38f992420c119" id="r_a6510e511444f8d1c72e38f992420c119"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a6510e511444f8d1c72e38f992420c119">description</a> () const</td></tr>
<tr class="memdesc:a6510e511444f8d1c72e38f992420c119"><td class="mdescLeft">&#160;</td><td class="mdescRight">A one-line description of this object.  <br /></td></tr>
<tr class="separator:a6510e511444f8d1c72e38f992420c119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classIfpack2_1_1Preconditioner"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classIfpack2_1_1Preconditioner')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classIfpack2_1_1Preconditioner.html">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a></td></tr>
<tr class="memitem:a637973211128e0c09db53772df0f345d inherit pub_methods_classIfpack2_1_1Preconditioner" id="r_a637973211128e0c09db53772df0f345d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Preconditioner.html#a637973211128e0c09db53772df0f345d">~Preconditioner</a> ()</td></tr>
<tr class="memdesc:a637973211128e0c09db53772df0f345d inherit pub_methods_classIfpack2_1_1Preconditioner"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a637973211128e0c09db53772df0f345d inherit pub_methods_classIfpack2_1_1Preconditioner"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12495acd22d15212241c0d518d7f6536 inherit pub_methods_classIfpack2_1_1Preconditioner" id="r_a12495acd22d15212241c0d518d7f6536"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Preconditioner.html#a12495acd22d15212241c0d518d7f6536">setZeroStartingSolution</a> (bool zeroStartingSolution)</td></tr>
<tr class="memdesc:a12495acd22d15212241c0d518d7f6536 inherit pub_methods_classIfpack2_1_1Preconditioner"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this preconditioner's parameters.  <br /></td></tr>
<tr class="separator:a12495acd22d15212241c0d518d7f6536 inherit pub_methods_classIfpack2_1_1Preconditioner"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html">Ifpack2::Details::CanChangeMatrix&lt; Tpetra::RowMatrix&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt; &gt;</a></td></tr>
<tr class="memitem:acad726ffa06a9eef5d675364f996101a inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix" id="r_acad726ffa06a9eef5d675364f996101a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">virtual</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html#acad726ffa06a9eef5d675364f996101a">setMatrix</a> (<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> Tpetra::RowMatrix&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt; &gt; &amp;A)=0</td></tr>
<tr class="memdesc:acad726ffa06a9eef5d675364f996101a inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the new matrix.  <br /></td></tr>
<tr class="separator:acad726ffa06a9eef5d675364f996101a inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad9626e6fa50980dc192a4a63341c12 inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix" id="r_abad9626e6fa50980dc192a4a63341c12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">virtual</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html#abad9626e6fa50980dc192a4a63341c12">~CanChangeMatrix</a> ()</td></tr>
<tr class="memdesc:abad9626e6fa50980dc192a4a63341c12 inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:abad9626e6fa50980dc192a4a63341c12 inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Implementation of Kokkos Kernels MDF.</h2></td></tr>
<tr class="memitem:a56e30e53961de869b30a1964fc47612d" id="r_a56e30e53961de869b30a1964fc47612d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a56e30e53961de869b30a1964fc47612d">MDF</a> (const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1MDF.html#aa71700e90faed3525ea51ece7a28b312">row_matrix_type</a> &gt; &amp;A_in)</td></tr>
<tr class="memdesc:a56e30e53961de869b30a1964fc47612d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that takes a Tpetra::RowMatrix.  <br /></td></tr>
<tr class="separator:a56e30e53961de869b30a1964fc47612d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b38723a529783994d21ab746648e57" id="r_a69b38723a529783994d21ab746648e57"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a69b38723a529783994d21ab746648e57">MDF</a> (const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1MDF.html#a968a62c443f467afbf8728a475421df9">crs_matrix_type</a> &gt; &amp;A_in)</td></tr>
<tr class="memdesc:a69b38723a529783994d21ab746648e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that takes a Tpetra::CrsMatrix.  <br /></td></tr>
<tr class="separator:a69b38723a529783994d21ab746648e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48ca6c8a3ffcfc99de0fa5a7ea9eded" id="r_af48ca6c8a3ffcfc99de0fa5a7ea9eded"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#af48ca6c8a3ffcfc99de0fa5a7ea9eded">~MDF</a> ()=default</td></tr>
<tr class="memdesc:af48ca6c8a3ffcfc99de0fa5a7ea9eded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor (declared virtual for memory safety).  <br /></td></tr>
<tr class="separator:af48ca6c8a3ffcfc99de0fa5a7ea9eded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0376791e5a350d3e212c0132e446268d" id="r_a0376791e5a350d3e212c0132e446268d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a0376791e5a350d3e212c0132e446268d">setParameters</a> (const Teuchos::ParameterList &amp;params)</td></tr>
<tr class="separator:a0376791e5a350d3e212c0132e446268d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae3378179276a4f4344ecd6343c29c2" id="r_a5ae3378179276a4f4344ecd6343c29c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a5ae3378179276a4f4344ecd6343c29c2">initialize</a> ()</td></tr>
<tr class="memdesc:a5ae3378179276a4f4344ecd6343c29c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize by computing the symbolic incomplete factorization.  <br /></td></tr>
<tr class="separator:a5ae3378179276a4f4344ecd6343c29c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451eeebf1de27d55d62a332f52e14067" id="r_a451eeebf1de27d55d62a332f52e14067"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a451eeebf1de27d55d62a332f52e14067">compute</a> ()</td></tr>
<tr class="memdesc:a451eeebf1de27d55d62a332f52e14067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (numeric) incomplete factorization.  <br /></td></tr>
<tr class="separator:a451eeebf1de27d55d62a332f52e14067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5147f6b0c1373bef9d70b386297e6ba8" id="r_a5147f6b0c1373bef9d70b386297e6ba8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a5147f6b0c1373bef9d70b386297e6ba8">isInitialized</a> () const</td></tr>
<tr class="memdesc:a5147f6b0c1373bef9d70b386297e6ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether <a class="el" href="classIfpack2_1_1MDF.html#a5ae3378179276a4f4344ecd6343c29c2" title="Initialize by computing the symbolic incomplete factorization.">initialize()</a> has been called on this object.  <br /></td></tr>
<tr class="separator:a5147f6b0c1373bef9d70b386297e6ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a144eb82bc463621a85b49c94f4356" id="r_a29a144eb82bc463621a85b49c94f4356"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a29a144eb82bc463621a85b49c94f4356">isComputed</a> () const</td></tr>
<tr class="memdesc:a29a144eb82bc463621a85b49c94f4356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether <a class="el" href="classIfpack2_1_1MDF.html#a451eeebf1de27d55d62a332f52e14067" title="Compute the (numeric) incomplete factorization.">compute()</a> has been called on this object.  <br /></td></tr>
<tr class="separator:a29a144eb82bc463621a85b49c94f4356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88156e9dcbd11066f5d9c24d1937bb6" id="r_ac88156e9dcbd11066f5d9c24d1937bb6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#ac88156e9dcbd11066f5d9c24d1937bb6">getNumInitialize</a> () const</td></tr>
<tr class="memdesc:ac88156e9dcbd11066f5d9c24d1937bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of successful <a class="el" href="classIfpack2_1_1MDF.html#a5ae3378179276a4f4344ecd6343c29c2" title="Initialize by computing the symbolic incomplete factorization.">initialize()</a> calls for this object.  <br /></td></tr>
<tr class="separator:ac88156e9dcbd11066f5d9c24d1937bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf0f3217affb2f6f88ca5401f2ce0a4" id="r_a5cf0f3217affb2f6f88ca5401f2ce0a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a5cf0f3217affb2f6f88ca5401f2ce0a4">getNumCompute</a> () const</td></tr>
<tr class="memdesc:a5cf0f3217affb2f6f88ca5401f2ce0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of successful <a class="el" href="classIfpack2_1_1MDF.html#a451eeebf1de27d55d62a332f52e14067" title="Compute the (numeric) incomplete factorization.">compute()</a> calls for this object.  <br /></td></tr>
<tr class="separator:a5cf0f3217affb2f6f88ca5401f2ce0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaac587ba9e68b9558ba5502e95fcdbc" id="r_afaac587ba9e68b9558ba5502e95fcdbc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#afaac587ba9e68b9558ba5502e95fcdbc">getNumApply</a> () const</td></tr>
<tr class="memdesc:afaac587ba9e68b9558ba5502e95fcdbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of successful <a class="el" href="classIfpack2_1_1MDF.html#a0c92fd89ffa094f7b7b286dc77d9cbbc" title="Apply the (inverse of the) incomplete factorization to X, resulting in Y.">apply()</a> calls for this object.  <br /></td></tr>
<tr class="separator:afaac587ba9e68b9558ba5502e95fcdbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58612e5503d19219dcb4350163ac642" id="r_ab58612e5503d19219dcb4350163ac642"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#ab58612e5503d19219dcb4350163ac642">getInitializeTime</a> () const</td></tr>
<tr class="memdesc:ab58612e5503d19219dcb4350163ac642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total time in seconds taken by all successful <a class="el" href="classIfpack2_1_1MDF.html#a5ae3378179276a4f4344ecd6343c29c2" title="Initialize by computing the symbolic incomplete factorization.">initialize()</a> calls for this object.  <br /></td></tr>
<tr class="separator:ab58612e5503d19219dcb4350163ac642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b71dfa5debc7160c1fd1c7a3420397" id="r_a79b71dfa5debc7160c1fd1c7a3420397"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a79b71dfa5debc7160c1fd1c7a3420397">getComputeTime</a> () const</td></tr>
<tr class="memdesc:a79b71dfa5debc7160c1fd1c7a3420397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total time in seconds taken by all successful <a class="el" href="classIfpack2_1_1MDF.html#a451eeebf1de27d55d62a332f52e14067" title="Compute the (numeric) incomplete factorization.">compute()</a> calls for this object.  <br /></td></tr>
<tr class="separator:a79b71dfa5debc7160c1fd1c7a3420397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cca9d562dff722b012e6a025134bdc" id="r_a05cca9d562dff722b012e6a025134bdc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a05cca9d562dff722b012e6a025134bdc">getApplyTime</a> () const</td></tr>
<tr class="memdesc:a05cca9d562dff722b012e6a025134bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total time in seconds taken by all successful <a class="el" href="classIfpack2_1_1MDF.html#a0c92fd89ffa094f7b7b286dc77d9cbbc" title="Apply the (inverse of the) incomplete factorization to X, resulting in Y.">apply()</a> calls for this object.  <br /></td></tr>
<tr class="separator:a05cca9d562dff722b012e6a025134bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd735346eb6a4d12afaf105a7fbb248" id="r_aecd735346eb6a4d12afaf105a7fbb248"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#aecd735346eb6a4d12afaf105a7fbb248">getNodeSmootherComplexity</a> () const</td></tr>
<tr class="memdesc:aecd735346eb6a4d12afaf105a7fbb248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a rough estimate of cost per iteration.  <br /></td></tr>
<tr class="separator:aecd735346eb6a4d12afaf105a7fbb248"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Implementation of Tpetra::Operator</h2></td></tr>
<tr class="memitem:af04906ebfc6273bdaf26e3c0a8f2443c" id="r_af04906ebfc6273bdaf26e3c0a8f2443c"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1MDF.html#aa71700e90faed3525ea51ece7a28b312">row_matrix_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#af04906ebfc6273bdaf26e3c0a8f2443c">A_</a></td></tr>
<tr class="memdesc:af04906ebfc6273bdaf26e3c0a8f2443c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The (original) input matrix for which to compute ILU(k).  <br /></td></tr>
<tr class="separator:af04906ebfc6273bdaf26e3c0a8f2443c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576ca69751dbc321dceb667ee4250728" id="r_a576ca69751dbc321dceb667ee4250728"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1MDF.html#aa71700e90faed3525ea51ece7a28b312">row_matrix_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a576ca69751dbc321dceb667ee4250728">A_local_</a></td></tr>
<tr class="memdesc:a576ca69751dbc321dceb667ee4250728"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix whos numbers are used to to compute ILU(k). The graph may be computed using a crs_matrix_type that <a class="el" href="classIfpack2_1_1MDF.html#a5ae3378179276a4f4344ecd6343c29c2" title="Initialize by computing the symbolic incomplete factorization.">initialize()</a> constructs temporarily.  <br /></td></tr>
<tr class="separator:a576ca69751dbc321dceb667ee4250728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4d57b36f7b357c09c8be3faf7a6966" id="r_aee4d57b36f7b357c09c8be3faf7a6966"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1MDF.html#a968a62c443f467afbf8728a475421df9">crs_matrix_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#aee4d57b36f7b357c09c8be3faf7a6966">L_</a></td></tr>
<tr class="memdesc:aee4d57b36f7b357c09c8be3faf7a6966"><td class="mdescLeft">&#160;</td><td class="mdescRight">The L (lower triangular) factor of ILU(k).  <br /></td></tr>
<tr class="separator:aee4d57b36f7b357c09c8be3faf7a6966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27740e140af39130c1f5ecbbb7d42465" id="r_a27740e140af39130c1f5ecbbb7d42465"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1LocalSparseTriangularSolver.html">LocalSparseTriangularSolver</a>&lt; <a class="el" href="classIfpack2_1_1MDF.html#aa71700e90faed3525ea51ece7a28b312">row_matrix_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a27740e140af39130c1f5ecbbb7d42465">L_solver_</a></td></tr>
<tr class="memdesc:a27740e140af39130c1f5ecbbb7d42465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse triangular solver for L.  <br /></td></tr>
<tr class="separator:a27740e140af39130c1f5ecbbb7d42465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48253c2c40ccae5187ea72ade6c0b5a9" id="r_a48253c2c40ccae5187ea72ade6c0b5a9"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1MDF.html#a968a62c443f467afbf8728a475421df9">crs_matrix_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a48253c2c40ccae5187ea72ade6c0b5a9">U_</a></td></tr>
<tr class="memdesc:a48253c2c40ccae5187ea72ade6c0b5a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The U (upper triangular) factor of ILU(k).  <br /></td></tr>
<tr class="separator:a48253c2c40ccae5187ea72ade6c0b5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bff117691b8f12a39ceb6193f8ad32" id="r_ad3bff117691b8f12a39ceb6193f8ad32"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1LocalSparseTriangularSolver.html">LocalSparseTriangularSolver</a>&lt; <a class="el" href="classIfpack2_1_1MDF.html#aa71700e90faed3525ea51ece7a28b312">row_matrix_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#ad3bff117691b8f12a39ceb6193f8ad32">U_solver_</a></td></tr>
<tr class="memdesc:ad3bff117691b8f12a39ceb6193f8ad32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse triangular solver for U.  <br /></td></tr>
<tr class="separator:ad3bff117691b8f12a39ceb6193f8ad32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab947eb93a70232cb801ce84d74860913" id="r_ab947eb93a70232cb801ce84d74860913"><td class="memItemLeft" align="right" valign="top">permutations_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#ab947eb93a70232cb801ce84d74860913">permutations_</a></td></tr>
<tr class="memdesc:ab947eb93a70232cb801ce84d74860913"><td class="mdescLeft">&#160;</td><td class="mdescRight">The computed permuations from <a class="el" href="classIfpack2_1_1MDF.html" title="MDF (incomplete LU factorization with minimum discarded fill reordering) of a Tpetra sparse matrix.">MDF</a> factorization.  <br /></td></tr>
<tr class="separator:ab947eb93a70232cb801ce84d74860913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c24cafde948768802363a049c567c3" id="r_a33c24cafde948768802363a049c567c3"><td class="memItemLeft" align="right" valign="top">permutations_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a33c24cafde948768802363a049c567c3">reversePermutations_</a></td></tr>
<tr class="memdesc:a33c24cafde948768802363a049c567c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reverse permuations from <a class="el" href="classIfpack2_1_1MDF.html" title="MDF (incomplete LU factorization with minimum discarded fill reordering) of a Tpetra sparse matrix.">MDF</a> factorization.  <br /></td></tr>
<tr class="separator:a33c24cafde948768802363a049c567c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b9bb633fa3ab07c111843d48a4cd8a" id="r_aa4b9bb633fa3ab07c111843d48a4cd8a"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const Tpetra::Map&lt; <a class="el" href="classIfpack2_1_1MDF.html#a4bb88c2b827d16b505aae0db1d4af1b4">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#aaf29d4a280fbf0dce1ea5dcd691bf0c5">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#aab4559e2048e71da85196e184842bdd1">node_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#aa4b9bb633fa3ab07c111843d48a4cd8a">getDomainMap</a> () const</td></tr>
<tr class="memdesc:aa4b9bb633fa3ab07c111843d48a4cd8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Tpetra::Map object associated with the domain of this operator.  <br /></td></tr>
<tr class="separator:aa4b9bb633fa3ab07c111843d48a4cd8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1977e2061ce468170a3e2061296c28" id="r_a7a1977e2061ce468170a3e2061296c28"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const Tpetra::Map&lt; <a class="el" href="classIfpack2_1_1MDF.html#a4bb88c2b827d16b505aae0db1d4af1b4">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#aaf29d4a280fbf0dce1ea5dcd691bf0c5">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#aab4559e2048e71da85196e184842bdd1">node_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a7a1977e2061ce468170a3e2061296c28">getRangeMap</a> () const</td></tr>
<tr class="memdesc:a7a1977e2061ce468170a3e2061296c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Tpetra::Map object associated with the range of this operator.  <br /></td></tr>
<tr class="separator:a7a1977e2061ce468170a3e2061296c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c92fd89ffa094f7b7b286dc77d9cbbc" id="r_a0c92fd89ffa094f7b7b286dc77d9cbbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a0c92fd89ffa094f7b7b286dc77d9cbbc">apply</a> (const Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1MDF.html#ad909535d2d95008ad5960fd1ebb26c03">scalar_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#a4bb88c2b827d16b505aae0db1d4af1b4">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#aaf29d4a280fbf0dce1ea5dcd691bf0c5">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#aab4559e2048e71da85196e184842bdd1">node_type</a> &gt; &amp;X, Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1MDF.html#ad909535d2d95008ad5960fd1ebb26c03">scalar_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#a4bb88c2b827d16b505aae0db1d4af1b4">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#aaf29d4a280fbf0dce1ea5dcd691bf0c5">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#aab4559e2048e71da85196e184842bdd1">node_type</a> &gt; &amp;Y, Teuchos::ETransp mode=Teuchos::NO_TRANS, <a class="el" href="classIfpack2_1_1MDF.html#ad909535d2d95008ad5960fd1ebb26c03">scalar_type</a> alpha=Teuchos::ScalarTraits&lt; <a class="el" href="classIfpack2_1_1MDF.html#ad909535d2d95008ad5960fd1ebb26c03">scalar_type</a> &gt;::one(), <a class="el" href="classIfpack2_1_1MDF.html#ad909535d2d95008ad5960fd1ebb26c03">scalar_type</a> beta=Teuchos::ScalarTraits&lt; <a class="el" href="classIfpack2_1_1MDF.html#ad909535d2d95008ad5960fd1ebb26c03">scalar_type</a> &gt;::zero()) const</td></tr>
<tr class="memdesc:a0c92fd89ffa094f7b7b286dc77d9cbbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the (inverse of the) incomplete factorization to X, resulting in Y.  <br /></td></tr>
<tr class="separator:a0c92fd89ffa094f7b7b286dc77d9cbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe7d0ce312b752dc366c2b54d991a83" id="r_adfe7d0ce312b752dc366c2b54d991a83"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1MDF.html#aa71700e90faed3525ea51ece7a28b312">row_matrix_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#adfe7d0ce312b752dc366c2b54d991a83">getMatrix</a> () const</td></tr>
<tr class="memdesc:adfe7d0ce312b752dc366c2b54d991a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the input matrix.  <br /></td></tr>
<tr class="separator:adfe7d0ce312b752dc366c2b54d991a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2164bd386b6ef1bd97d15661d9ab3fb4" id="r_a2164bd386b6ef1bd97d15661d9ab3fb4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a2164bd386b6ef1bd97d15661d9ab3fb4">getLevelOfFill</a> () const</td></tr>
<tr class="memdesc:a2164bd386b6ef1bd97d15661d9ab3fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get level of fill (the "k" in ILU(k)).  <br /></td></tr>
<tr class="separator:a2164bd386b6ef1bd97d15661d9ab3fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c1dec273f85edb85b87a82d8c4bc69" id="r_a36c1dec273f85edb85b87a82d8c4bc69"><td class="memItemLeft" align="right" valign="top">Tpetra::CombineMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a36c1dec273f85edb85b87a82d8c4bc69">getOverlapMode</a> ()</td></tr>
<tr class="memdesc:a36c1dec273f85edb85b87a82d8c4bc69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get overlap mode type.  <br /></td></tr>
<tr class="separator:a36c1dec273f85edb85b87a82d8c4bc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dbd712cc4b2b81eb387545aba5a338" id="r_a82dbd712cc4b2b81eb387545aba5a338"><td class="memItemLeft" align="right" valign="top">Tpetra::global_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a82dbd712cc4b2b81eb387545aba5a338">getGlobalNumEntries</a> () const</td></tr>
<tr class="memdesc:a82dbd712cc4b2b81eb387545aba5a338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nonzero entries in the global graph.  <br /></td></tr>
<tr class="separator:a82dbd712cc4b2b81eb387545aba5a338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cdf80b39060fa289b51680551e5764" id="r_a05cdf80b39060fa289b51680551e5764"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIfpack2_1_1MDF.html#a968a62c443f467afbf8728a475421df9">crs_matrix_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a05cdf80b39060fa289b51680551e5764">getL</a> () const</td></tr>
<tr class="memdesc:a05cdf80b39060fa289b51680551e5764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the L factor of the <a class="el" href="classIfpack2_1_1MDF.html" title="MDF (incomplete LU factorization with minimum discarded fill reordering) of a Tpetra sparse matrix.">MDF</a> factorization.  <br /></td></tr>
<tr class="separator:a05cdf80b39060fa289b51680551e5764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a602ba68978d72d798598a4e168825" id="r_a38a602ba68978d72d798598a4e168825"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIfpack2_1_1MDF.html#a968a62c443f467afbf8728a475421df9">crs_matrix_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a38a602ba68978d72d798598a4e168825">getU</a> () const</td></tr>
<tr class="memdesc:a38a602ba68978d72d798598a4e168825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the U factor of the <a class="el" href="classIfpack2_1_1MDF.html" title="MDF (incomplete LU factorization with minimum discarded fill reordering) of a Tpetra sparse matrix.">MDF</a> factorization.  <br /></td></tr>
<tr class="separator:a38a602ba68978d72d798598a4e168825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1902416d51931a389eef24a138cef42" id="r_af1902416d51931a389eef24a138cef42"><td class="memItemLeft" align="right" valign="top">permutations_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#af1902416d51931a389eef24a138cef42">getPermutations</a> () const</td></tr>
<tr class="memdesc:af1902416d51931a389eef24a138cef42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the permutations of the <a class="el" href="classIfpack2_1_1MDF.html" title="MDF (incomplete LU factorization with minimum discarded fill reordering) of a Tpetra sparse matrix.">MDF</a> factorization.  <br /></td></tr>
<tr class="separator:af1902416d51931a389eef24a138cef42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d355e59aa84a3c12a062400d53d14f2" id="r_a2d355e59aa84a3c12a062400d53d14f2"><td class="memItemLeft" align="right" valign="top">permutations_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#a2d355e59aa84a3c12a062400d53d14f2">getReversePermutations</a> () const</td></tr>
<tr class="memdesc:a2d355e59aa84a3c12a062400d53d14f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reverse permutations of the <a class="el" href="classIfpack2_1_1MDF.html" title="MDF (incomplete LU factorization with minimum discarded fill reordering) of a Tpetra sparse matrix.">MDF</a> factorization.  <br /></td></tr>
<tr class="separator:a2d355e59aa84a3c12a062400d53d14f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa03c1bbf902136097943c867bebb622" id="r_aaa03c1bbf902136097943c867bebb622"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1MDF.html#a968a62c443f467afbf8728a475421df9">crs_matrix_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1MDF.html#aaa03c1bbf902136097943c867bebb622">getCrsMatrix</a> () const</td></tr>
<tr class="memdesc:aaa03c1bbf902136097943c867bebb622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the input matrix A as a Tpetra::CrsMatrix, if possible; else throws.  <br /></td></tr>
<tr class="separator:aaa03c1bbf902136097943c867bebb622"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class MatrixType&gt;<br />
class Ifpack2::MDF&lt; MatrixType &gt;</div><p><a class="el" href="classIfpack2_1_1MDF.html" title="MDF (incomplete LU factorization with minimum discarded fill reordering) of a Tpetra sparse matrix.">MDF</a> (incomplete LU factorization with minimum discarded fill reordering) of a Tpetra sparse matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>specialization of Tpetra::RowMatrix.</td></tr>
  </table>
  </dd>
</dl>
<p>This class computes a sparse <a class="el" href="classIfpack2_1_1MDF.html" title="MDF (incomplete LU factorization with minimum discarded fill reordering) of a Tpetra sparse matrix.">MDF</a> (incomplete LU) factorization with a reordering that minimizes the discarded fill of the local part of a given sparse matrix represented as a Tpetra::RowMatrix or Tpetra::CrsMatrix. The "local part" is the square diagonal block of the matrix owned by the calling process. Thus, if the input matrix is distributed over multiple MPI processes, this preconditioner is equivalent to nonoverlapping additive Schwarz domain decomposition over the MPI processes, with <a class="el" href="classIfpack2_1_1MDF.html" title="MDF (incomplete LU factorization with minimum discarded fill reordering) of a Tpetra sparse matrix.">MDF</a> as the subdomain solver on each process.</p>
<dl class="section remark"><dt>Remarks</dt><dd>See the documentation of <a class="el" href="classIfpack2_1_1MDF.html#a0376791e5a350d3e212c0132e446268d">setParameters()</a> for a list of valid parameters. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad909535d2d95008ad5960fd1ebb26c03" name="ad909535d2d95008ad5960fd1ebb26c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad909535d2d95008ad5960fd1ebb26c03">&#9670;&#160;</a></span>scalar_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::scalar_type <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::scalar_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the entries of the input MatrixType. </p>

</div>
</div>
<a id="a4bb88c2b827d16b505aae0db1d4af1b4" name="a4bb88c2b827d16b505aae0db1d4af1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb88c2b827d16b505aae0db1d4af1b4">&#9670;&#160;</a></span>local_ordinal_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::local_ordinal_type <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::local_ordinal_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of local indices in the input MatrixType. </p>

</div>
</div>
<a id="aaf29d4a280fbf0dce1ea5dcd691bf0c5" name="aaf29d4a280fbf0dce1ea5dcd691bf0c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf29d4a280fbf0dce1ea5dcd691bf0c5">&#9670;&#160;</a></span>global_ordinal_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::global_ordinal_type <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::global_ordinal_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of global indices in the input MatrixType. </p>

</div>
</div>
<a id="aab4559e2048e71da85196e184842bdd1" name="aab4559e2048e71da85196e184842bdd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab4559e2048e71da85196e184842bdd1">&#9670;&#160;</a></span>node_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::node_type <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::node_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Node type used by the input MatrixType. </p>

</div>
</div>
<a id="a125acd37687f6dd046d5e5d5f2ad9173" name="a125acd37687f6dd046d5e5d5f2ad9173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125acd37687f6dd046d5e5d5f2ad9173">&#9670;&#160;</a></span>magnitude_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Teuchos::ScalarTraits&lt;<a class="el" href="classIfpack2_1_1MDF.html#ad909535d2d95008ad5960fd1ebb26c03">scalar_type</a>&gt;::magnitudeType <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::magnitude_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the magnitude (absolute value) of a matrix entry. </p>

</div>
</div>
<a id="ae974a0f0803a8428c4eda9558db220a9" name="ae974a0f0803a8428c4eda9558db220a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae974a0f0803a8428c4eda9558db220a9">&#9670;&#160;</a></span>device_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef node_type::device_type <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::device_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Kokkos device type of the input MatrixType. </p>

</div>
</div>
<a id="a0901627f8b97a1977a0585246b5c568b" name="a0901627f8b97a1977a0585246b5c568b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0901627f8b97a1977a0585246b5c568b">&#9670;&#160;</a></span>execution_space</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef node_type::execution_space <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::execution_space</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Kokkos execution space of the input MatrixType. </p>

</div>
</div>
<a id="aa71700e90faed3525ea51ece7a28b312" name="aa71700e90faed3525ea51ece7a28b312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71700e90faed3525ea51ece7a28b312">&#9670;&#160;</a></span>row_matrix_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Tpetra::RowMatrix&lt;<a class="el" href="classIfpack2_1_1MDF.html#ad909535d2d95008ad5960fd1ebb26c03">scalar_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#a4bb88c2b827d16b505aae0db1d4af1b4">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#aaf29d4a280fbf0dce1ea5dcd691bf0c5">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#aab4559e2048e71da85196e184842bdd1">node_type</a>&gt; <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::row_matrix_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tpetra::RowMatrix specialization used by this class. </p>

</div>
</div>
<a id="a968a62c443f467afbf8728a475421df9" name="a968a62c443f467afbf8728a475421df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a968a62c443f467afbf8728a475421df9">&#9670;&#160;</a></span>crs_matrix_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Tpetra::CrsMatrix&lt;<a class="el" href="classIfpack2_1_1MDF.html#ad909535d2d95008ad5960fd1ebb26c03">scalar_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#a4bb88c2b827d16b505aae0db1d4af1b4">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#aaf29d4a280fbf0dce1ea5dcd691bf0c5">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#aab4559e2048e71da85196e184842bdd1">node_type</a>&gt; <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::crs_matrix_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tpetra::CrsMatrix specialization used by this class for representing L and U. </p>

</div>
</div>
<a id="ac969696d7cc34a6468802618b4db35a0" name="ac969696d7cc34a6468802618b4db35a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac969696d7cc34a6468802618b4db35a0">&#9670;&#160;</a></span>impl_scalar_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef crs_matrix_type::impl_scalar_type <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::impl_scalar_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scalar type stored in Kokkos::Views (CrsMatrix and MultiVector) </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a56e30e53961de869b30a1964fc47612d" name="a56e30e53961de869b30a1964fc47612d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e30e53961de869b30a1964fc47612d">&#9670;&#160;</a></span>MDF() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::MDF </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1MDF.html#aa71700e90faed3525ea51ece7a28b312">row_matrix_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor that takes a Tpetra::RowMatrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_in</td><td>[in] The input matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69b38723a529783994d21ab746648e57" name="a69b38723a529783994d21ab746648e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b38723a529783994d21ab746648e57">&#9670;&#160;</a></span>MDF() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::MDF </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1MDF.html#a968a62c443f467afbf8728a475421df9">crs_matrix_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor that takes a Tpetra::CrsMatrix. </p>
<p>This constructor exists to avoid "ambiguous constructor" warnings. It does the same thing as the constructor that takes a Tpetra::RowMatrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_in</td><td>[in] The input matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af48ca6c8a3ffcfc99de0fa5a7ea9eded" name="af48ca6c8a3ffcfc99de0fa5a7ea9eded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af48ca6c8a3ffcfc99de0fa5a7ea9eded">&#9670;&#160;</a></span>~MDF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::~<a class="el" href="classIfpack2_1_1MDF.html">MDF</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor (declared virtual for memory safety). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0376791e5a350d3e212c0132e446268d" name="a0376791e5a350d3e212c0132e446268d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0376791e5a350d3e212c0132e446268d">&#9670;&#160;</a></span>setParameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::setParameters </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set parameters for the incomplete factorization.</p>
<p>This preconditioner supports the following parameters:</p><ul>
<li>"fact: mdf level-of-fill" (int)</li>
<li>"fact: relax value" (magnitude_type)</li>
<li>"fact: mdf overalloc" (double) </li>
</ul>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a60340992fc1b9eac82ef35333bee6efd">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a5ae3378179276a4f4344ecd6343c29c2" name="a5ae3378179276a4f4344ecd6343c29c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae3378179276a4f4344ecd6343c29c2">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize by computing the symbolic incomplete factorization. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#ad3aefd6f16e8ef4cddb696cd23f160b0">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a451eeebf1de27d55d62a332f52e14067" name="a451eeebf1de27d55d62a332f52e14067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451eeebf1de27d55d62a332f52e14067">&#9670;&#160;</a></span>compute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::compute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the (numeric) incomplete factorization. </p>
<p>This function computes the RILU(k) factors L and U using the current:</p><ul>
<li>Ifpack2_IlukGraph specifying the structure of L and U.</li>
<li>Value for the RILU(k) relaxation parameter.</li>
<li>Value for the a priori diagonal threshold values.</li>
</ul>
<p><a class="el" href="classIfpack2_1_1MDF.html#a5ae3378179276a4f4344ecd6343c29c2" title="Initialize by computing the symbolic incomplete factorization.">initialize()</a> must be called first, before this method may be called. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a23954dd69f62b56455a9c0988bbe9e67">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a5147f6b0c1373bef9d70b386297e6ba8" name="a5147f6b0c1373bef9d70b386297e6ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5147f6b0c1373bef9d70b386297e6ba8">&#9670;&#160;</a></span>isInitialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::isInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether <a class="el" href="classIfpack2_1_1MDF.html#a5ae3378179276a4f4344ecd6343c29c2" title="Initialize by computing the symbolic incomplete factorization.">initialize()</a> has been called on this object. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a180c876ccf7af87f10a1c1d08ba2dc01">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a29a144eb82bc463621a85b49c94f4356" name="a29a144eb82bc463621a85b49c94f4356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a144eb82bc463621a85b49c94f4356">&#9670;&#160;</a></span>isComputed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::isComputed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether <a class="el" href="classIfpack2_1_1MDF.html#a451eeebf1de27d55d62a332f52e14067" title="Compute the (numeric) incomplete factorization.">compute()</a> has been called on this object. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#abb5af77756a7488ab636dbd97483ca66">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="ac88156e9dcbd11066f5d9c24d1937bb6" name="ac88156e9dcbd11066f5d9c24d1937bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88156e9dcbd11066f5d9c24d1937bb6">&#9670;&#160;</a></span>getNumInitialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::getNumInitialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of successful <a class="el" href="classIfpack2_1_1MDF.html#a5ae3378179276a4f4344ecd6343c29c2" title="Initialize by computing the symbolic incomplete factorization.">initialize()</a> calls for this object. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#afe6c77c5ab6da065f8dbade353e8535a">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a5cf0f3217affb2f6f88ca5401f2ce0a4" name="a5cf0f3217affb2f6f88ca5401f2ce0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf0f3217affb2f6f88ca5401f2ce0a4">&#9670;&#160;</a></span>getNumCompute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::getNumCompute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of successful <a class="el" href="classIfpack2_1_1MDF.html#a451eeebf1de27d55d62a332f52e14067" title="Compute the (numeric) incomplete factorization.">compute()</a> calls for this object. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a286b18ee0769ecc8bf992dffdc442791">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="afaac587ba9e68b9558ba5502e95fcdbc" name="afaac587ba9e68b9558ba5502e95fcdbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaac587ba9e68b9558ba5502e95fcdbc">&#9670;&#160;</a></span>getNumApply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::getNumApply </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of successful <a class="el" href="classIfpack2_1_1MDF.html#a0c92fd89ffa094f7b7b286dc77d9cbbc" title="Apply the (inverse of the) incomplete factorization to X, resulting in Y.">apply()</a> calls for this object. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a565e6c00bf14873ae7b23187c9978078">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="ab58612e5503d19219dcb4350163ac642" name="ab58612e5503d19219dcb4350163ac642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab58612e5503d19219dcb4350163ac642">&#9670;&#160;</a></span>getInitializeTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::getInitializeTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total time in seconds taken by all successful <a class="el" href="classIfpack2_1_1MDF.html#a5ae3378179276a4f4344ecd6343c29c2" title="Initialize by computing the symbolic incomplete factorization.">initialize()</a> calls for this object. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#aeb91a16f5544ad4efaf756b1d2a8b39d">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a79b71dfa5debc7160c1fd1c7a3420397" name="a79b71dfa5debc7160c1fd1c7a3420397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b71dfa5debc7160c1fd1c7a3420397">&#9670;&#160;</a></span>getComputeTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::getComputeTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total time in seconds taken by all successful <a class="el" href="classIfpack2_1_1MDF.html#a451eeebf1de27d55d62a332f52e14067" title="Compute the (numeric) incomplete factorization.">compute()</a> calls for this object. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a111d9bd4e28c0633696f271955ddcb4c">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a05cca9d562dff722b012e6a025134bdc" name="a05cca9d562dff722b012e6a025134bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05cca9d562dff722b012e6a025134bdc">&#9670;&#160;</a></span>getApplyTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::getApplyTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total time in seconds taken by all successful <a class="el" href="classIfpack2_1_1MDF.html#a0c92fd89ffa094f7b7b286dc77d9cbbc" title="Apply the (inverse of the) incomplete factorization to X, resulting in Y.">apply()</a> calls for this object. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a57c2d00799de050cd2a5a75ce80f48b9">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="aecd735346eb6a4d12afaf105a7fbb248" name="aecd735346eb6a4d12afaf105a7fbb248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd735346eb6a4d12afaf105a7fbb248">&#9670;&#160;</a></span>getNodeSmootherComplexity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::getNodeSmootherComplexity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a rough estimate of cost per iteration. </p>

</div>
</div>
<a id="ae07a61e9c3ba1f966bd08753abe6cd55" name="ae07a61e9c3ba1f966bd08753abe6cd55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07a61e9c3ba1f966bd08753abe6cd55">&#9670;&#160;</a></span>setMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::setMatrix </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1MDF.html#aa71700e90faed3525ea51ece7a28b312">row_matrix_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the matrix to be preconditioned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>[in] The new matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>! isInitialized ()</code> </dd>
<dd>
<code>! isComputed ()</code></dd></dl>
<p>Calling this method resets the preconditioner's state. After calling this method with a nonnull input, you must first call <a class="el" href="classIfpack2_1_1MDF.html#a5ae3378179276a4f4344ecd6343c29c2" title="Initialize by computing the symbolic incomplete factorization.">initialize()</a> and <a class="el" href="classIfpack2_1_1MDF.html#a451eeebf1de27d55d62a332f52e14067" title="Compute the (numeric) incomplete factorization.">compute()</a> (in that order) before you may call <a class="el" href="classIfpack2_1_1MDF.html#a0c92fd89ffa094f7b7b286dc77d9cbbc" title="Apply the (inverse of the) incomplete factorization to X, resulting in Y.">apply()</a>.</p>
<p>You may call this method with a null input. If A is null, then you may not call <a class="el" href="classIfpack2_1_1MDF.html#a5ae3378179276a4f4344ecd6343c29c2" title="Initialize by computing the symbolic incomplete factorization.">initialize()</a> or <a class="el" href="classIfpack2_1_1MDF.html#a451eeebf1de27d55d62a332f52e14067" title="Compute the (numeric) incomplete factorization.">compute()</a> until you first call this method again with a nonnull input. This method invalidates any previous factorization whether or not A is null, so calling <a class="el" href="classIfpack2_1_1MDF.html#ae07a61e9c3ba1f966bd08753abe6cd55" title="Change the matrix to be preconditioned.">setMatrix()</a> with a null input is one way to clear the preconditioner's state (and free any memory that it may be using).</p>
<p>The new matrix A need not necessarily have the same Maps or even the same communicator as the original matrix. </p>

</div>
</div>
<a id="a6510e511444f8d1c72e38f992420c119" name="a6510e511444f8d1c72e38f992420c119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6510e511444f8d1c72e38f992420c119">&#9670;&#160;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A one-line description of this object. </p>

</div>
</div>
<a id="aa4b9bb633fa3ab07c111843d48a4cd8a" name="aa4b9bb633fa3ab07c111843d48a4cd8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b9bb633fa3ab07c111843d48a4cd8a">&#9670;&#160;</a></span>getDomainMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const Tpetra::Map&lt; typename <a class="el" href="classIfpack2_1_1MDF.html">MDF</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1MDF.html#a4bb88c2b827d16b505aae0db1d4af1b4">::local_ordinal_type</a>, typename <a class="el" href="classIfpack2_1_1MDF.html">MDF</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1MDF.html#aaf29d4a280fbf0dce1ea5dcd691bf0c5">::global_ordinal_type</a>, typename <a class="el" href="classIfpack2_1_1MDF.html">MDF</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1MDF.html#aab4559e2048e71da85196e184842bdd1">::node_type</a> &gt; &gt; <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::getDomainMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Tpetra::Map object associated with the domain of this operator. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#aafeb2143ff699f2289503a85f6e3523c">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a7a1977e2061ce468170a3e2061296c28" name="a7a1977e2061ce468170a3e2061296c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1977e2061ce468170a3e2061296c28">&#9670;&#160;</a></span>getRangeMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const Tpetra::Map&lt; typename <a class="el" href="classIfpack2_1_1MDF.html">MDF</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1MDF.html#a4bb88c2b827d16b505aae0db1d4af1b4">::local_ordinal_type</a>, typename <a class="el" href="classIfpack2_1_1MDF.html">MDF</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1MDF.html#aaf29d4a280fbf0dce1ea5dcd691bf0c5">::global_ordinal_type</a>, typename <a class="el" href="classIfpack2_1_1MDF.html">MDF</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1MDF.html#aab4559e2048e71da85196e184842bdd1">::node_type</a> &gt; &gt; <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::getRangeMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Tpetra::Map object associated with the range of this operator. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a75b32e1de03024035b00cd2ee95a60da">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a0c92fd89ffa094f7b7b286dc77d9cbbc" name="a0c92fd89ffa094f7b7b286dc77d9cbbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c92fd89ffa094f7b7b286dc77d9cbbc">&#9670;&#160;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1MDF.html#ad909535d2d95008ad5960fd1ebb26c03">scalar_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#a4bb88c2b827d16b505aae0db1d4af1b4">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#aaf29d4a280fbf0dce1ea5dcd691bf0c5">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#aab4559e2048e71da85196e184842bdd1">node_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1MDF.html#ad909535d2d95008ad5960fd1ebb26c03">scalar_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#a4bb88c2b827d16b505aae0db1d4af1b4">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#aaf29d4a280fbf0dce1ea5dcd691bf0c5">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1MDF.html#aab4559e2048e71da85196e184842bdd1">node_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::ETransp&#160;</td>
          <td class="paramname"><em>mode</em> = <code>Teuchos::NO_TRANS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIfpack2_1_1MDF.html#ad909535d2d95008ad5960fd1ebb26c03">scalar_type</a>&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>Teuchos::ScalarTraits&lt;<a class="el" href="classIfpack2_1_1MDF.html#ad909535d2d95008ad5960fd1ebb26c03">scalar_type</a>&gt;::one()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIfpack2_1_1MDF.html#ad909535d2d95008ad5960fd1ebb26c03">scalar_type</a>&#160;</td>
          <td class="paramname"><em>beta</em> = <code>Teuchos::ScalarTraits&lt;<a class="el" href="classIfpack2_1_1MDF.html#ad909535d2d95008ad5960fd1ebb26c03">scalar_type</a>&gt;::zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the (inverse of the) incomplete factorization to X, resulting in Y. </p>
<p>For an incomplete factorization \(A \approx LDU\), this method computes the following, depending on the value of <code>mode:</code> </p><ul>
<li>
If mode = Teuchos::NO_TRANS, it computes <code>Y = beta*Y + alpha*(U \ (D \ (L \ X)))</code>  </li>
<li>
If mode = Teuchos::TRANS, it computes <code>Y = beta*Y + alpha*(L^T \ (D^T \ (U^T \ X)))</code>  </li>
<li>
If mode = Teuchos::CONJ_TRANS, it computes <code>Y = beta*Y + alpha*(L^* \ (D^* \ (U^* \ X)))</code>, where the asterisk indicates the conjugate transpose.  </li>
</ul>
<p>If alpha is zero, then the result of applying the operator to a vector is ignored. This matters because zero times NaN (not a number) is NaN, not zero. Analogously, if beta is zero, then any values in Y on input are ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>[in] The input multivector.</td></tr>
    <tr><td class="paramname">Y</td><td>[in/out] The output multivector.</td></tr>
    <tr><td class="paramname">mode</td><td>[in] If Teuchos::TRANS resp. Teuchos::CONJ_TRANS, apply the transpose resp. conjugate transpose of the incomplete factorization. Otherwise, don't apply the tranpose.</td></tr>
    <tr><td class="paramname">alpha</td><td>[in] Scaling factor for the result of applying the preconditioner.</td></tr>
    <tr><td class="paramname">beta</td><td>[in] Scaling factor for the initial value of Y. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a606c3f8155f67f2867fac3a7c44bd5df">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="adfe7d0ce312b752dc366c2b54d991a83" name="adfe7d0ce312b752dc366c2b54d991a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe7d0ce312b752dc366c2b54d991a83">&#9670;&#160;</a></span>getMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const typename <a class="el" href="classIfpack2_1_1MDF.html">MDF</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1MDF.html#aa71700e90faed3525ea51ece7a28b312">::row_matrix_type</a> &gt; <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::getMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the input matrix. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a4258d242e7ff6003c399da8f0a11d634">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a2164bd386b6ef1bd97d15661d9ab3fb4" name="a2164bd386b6ef1bd97d15661d9ab3fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2164bd386b6ef1bd97d15661d9ab3fb4">&#9670;&#160;</a></span>getLevelOfFill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::getLevelOfFill </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get level of fill (the "k" in ILU(k)). </p>

</div>
</div>
<a id="a36c1dec273f85edb85b87a82d8c4bc69" name="a36c1dec273f85edb85b87a82d8c4bc69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c1dec273f85edb85b87a82d8c4bc69">&#9670;&#160;</a></span>getOverlapMode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tpetra::CombineMode <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::getOverlapMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get overlap mode type. </p>

</div>
</div>
<a id="a82dbd712cc4b2b81eb387545aba5a338" name="a82dbd712cc4b2b81eb387545aba5a338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82dbd712cc4b2b81eb387545aba5a338">&#9670;&#160;</a></span>getGlobalNumEntries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tpetra::global_size_t <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::getGlobalNumEntries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of nonzero entries in the global graph. </p>

</div>
</div>
<a id="a05cdf80b39060fa289b51680551e5764" name="a05cdf80b39060fa289b51680551e5764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05cdf80b39060fa289b51680551e5764">&#9670;&#160;</a></span>getL()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIfpack2_1_1MDF.html">MDF</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1MDF.html#a968a62c443f467afbf8728a475421df9">::crs_matrix_type</a> &amp; <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::getL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the L factor of the <a class="el" href="classIfpack2_1_1MDF.html" title="MDF (incomplete LU factorization with minimum discarded fill reordering) of a Tpetra sparse matrix.">MDF</a> factorization. </p>

</div>
</div>
<a id="a38a602ba68978d72d798598a4e168825" name="a38a602ba68978d72d798598a4e168825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a602ba68978d72d798598a4e168825">&#9670;&#160;</a></span>getU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIfpack2_1_1MDF.html">MDF</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1MDF.html#a968a62c443f467afbf8728a475421df9">::crs_matrix_type</a> &amp; <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::getU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the U factor of the <a class="el" href="classIfpack2_1_1MDF.html" title="MDF (incomplete LU factorization with minimum discarded fill reordering) of a Tpetra sparse matrix.">MDF</a> factorization. </p>

</div>
</div>
<a id="af1902416d51931a389eef24a138cef42" name="af1902416d51931a389eef24a138cef42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1902416d51931a389eef24a138cef42">&#9670;&#160;</a></span>getPermutations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1MDF.html">MDF</a>&lt; MatrixType &gt;::permutations_type &amp; <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::getPermutations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the permutations of the <a class="el" href="classIfpack2_1_1MDF.html" title="MDF (incomplete LU factorization with minimum discarded fill reordering) of a Tpetra sparse matrix.">MDF</a> factorization. </p>

</div>
</div>
<a id="a2d355e59aa84a3c12a062400d53d14f2" name="a2d355e59aa84a3c12a062400d53d14f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d355e59aa84a3c12a062400d53d14f2">&#9670;&#160;</a></span>getReversePermutations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1MDF.html">MDF</a>&lt; MatrixType &gt;::permutations_type &amp; <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::getReversePermutations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the reverse permutations of the <a class="el" href="classIfpack2_1_1MDF.html" title="MDF (incomplete LU factorization with minimum discarded fill reordering) of a Tpetra sparse matrix.">MDF</a> factorization. </p>

</div>
</div>
<a id="aaa03c1bbf902136097943c867bebb622" name="aaa03c1bbf902136097943c867bebb622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa03c1bbf902136097943c867bebb622">&#9670;&#160;</a></span>getCrsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const typename <a class="el" href="classIfpack2_1_1MDF.html">MDF</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1MDF.html#a968a62c443f467afbf8728a475421df9">::crs_matrix_type</a> &gt; <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::getCrsMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the input matrix A as a Tpetra::CrsMatrix, if possible; else throws. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af04906ebfc6273bdaf26e3c0a8f2443c" name="af04906ebfc6273bdaf26e3c0a8f2443c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04906ebfc6273bdaf26e3c0a8f2443c">&#9670;&#160;</a></span>A_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt;const <a class="el" href="classIfpack2_1_1MDF.html#aa71700e90faed3525ea51ece7a28b312">row_matrix_type</a>&gt; <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::A_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The (original) input matrix for which to compute ILU(k). </p>

</div>
</div>
<a id="a576ca69751dbc321dceb667ee4250728" name="a576ca69751dbc321dceb667ee4250728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576ca69751dbc321dceb667ee4250728">&#9670;&#160;</a></span>A_local_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt;const <a class="el" href="classIfpack2_1_1MDF.html#aa71700e90faed3525ea51ece7a28b312">row_matrix_type</a>&gt; <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::A_local_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The matrix whos numbers are used to to compute ILU(k). The graph may be computed using a crs_matrix_type that <a class="el" href="classIfpack2_1_1MDF.html#a5ae3378179276a4f4344ecd6343c29c2" title="Initialize by computing the symbolic incomplete factorization.">initialize()</a> constructs temporarily. </p>

</div>
</div>
<a id="aee4d57b36f7b357c09c8be3faf7a6966" name="aee4d57b36f7b357c09c8be3faf7a6966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4d57b36f7b357c09c8be3faf7a6966">&#9670;&#160;</a></span>L_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt;<a class="el" href="classIfpack2_1_1MDF.html#a968a62c443f467afbf8728a475421df9">crs_matrix_type</a>&gt; <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::L_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The L (lower triangular) factor of ILU(k). </p>

</div>
</div>
<a id="a27740e140af39130c1f5ecbbb7d42465" name="a27740e140af39130c1f5ecbbb7d42465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27740e140af39130c1f5ecbbb7d42465">&#9670;&#160;</a></span>L_solver_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt;<a class="el" href="classIfpack2_1_1LocalSparseTriangularSolver.html">LocalSparseTriangularSolver</a>&lt;<a class="el" href="classIfpack2_1_1MDF.html#aa71700e90faed3525ea51ece7a28b312">row_matrix_type</a>&gt; &gt; <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::L_solver_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sparse triangular solver for L. </p>

</div>
</div>
<a id="a48253c2c40ccae5187ea72ade6c0b5a9" name="a48253c2c40ccae5187ea72ade6c0b5a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48253c2c40ccae5187ea72ade6c0b5a9">&#9670;&#160;</a></span>U_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt;<a class="el" href="classIfpack2_1_1MDF.html#a968a62c443f467afbf8728a475421df9">crs_matrix_type</a>&gt; <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::U_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The U (upper triangular) factor of ILU(k). </p>

</div>
</div>
<a id="ad3bff117691b8f12a39ceb6193f8ad32" name="ad3bff117691b8f12a39ceb6193f8ad32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3bff117691b8f12a39ceb6193f8ad32">&#9670;&#160;</a></span>U_solver_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt;<a class="el" href="classIfpack2_1_1LocalSparseTriangularSolver.html">LocalSparseTriangularSolver</a>&lt;<a class="el" href="classIfpack2_1_1MDF.html#aa71700e90faed3525ea51ece7a28b312">row_matrix_type</a>&gt; &gt; <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::U_solver_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sparse triangular solver for U. </p>

</div>
</div>
<a id="ab947eb93a70232cb801ce84d74860913" name="ab947eb93a70232cb801ce84d74860913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab947eb93a70232cb801ce84d74860913">&#9670;&#160;</a></span>permutations_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">permutations_type <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::permutations_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The computed permuations from <a class="el" href="classIfpack2_1_1MDF.html" title="MDF (incomplete LU factorization with minimum discarded fill reordering) of a Tpetra sparse matrix.">MDF</a> factorization. </p>

</div>
</div>
<a id="a33c24cafde948768802363a049c567c3" name="a33c24cafde948768802363a049c567c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c24cafde948768802363a049c567c3">&#9670;&#160;</a></span>reversePermutations_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">permutations_type <a class="el" href="classIfpack2_1_1MDF.html">Ifpack2::MDF</a>&lt; MatrixType &gt;::reversePermutations_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The reverse permuations from <a class="el" href="classIfpack2_1_1MDF.html" title="MDF (incomplete LU factorization with minimum discarded fill reordering) of a Tpetra sparse matrix.">MDF</a> factorization. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Ifpack2__MDF__decl_8hpp_source.html">Ifpack2_MDF_decl.hpp</a></li>
<li><a class="el" href="Ifpack2__MDF__def_8hpp_source.html">Ifpack2_MDF_def.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
