<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ifpack2 Templated Preconditioning Package: Ifpack2::ILUT&lt; MatrixType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Ifpack2 Templated Preconditioning Package<span id="projectnumber">&#160;Version 1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceIfpack2.html">Ifpack2</a></li><li class="navelem"><a class="el" href="classIfpack2_1_1ILUT.html">ILUT</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classIfpack2_1_1ILUT-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ifpack2::ILUT&lt; MatrixType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classIfpack2_1_1ILUT.html" title="ILUT (incomplete LU factorization with threshold) of a Tpetra sparse matrix.">ILUT</a> (incomplete LU factorization with threshold) of a Tpetra sparse matrix.  
 <a href="classIfpack2_1_1ILUT.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Ifpack2__ILUT__decl_8hpp_source.html">Ifpack2_ILUT_decl.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Ifpack2::ILUT&lt; MatrixType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classIfpack2_1_1ILUT__inherit__graph.png" border="0" usemap="#aIfpack2_1_1ILUT_3_01MatrixType_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aIfpack2_1_1ILUT_3_01MatrixType_01_4_inherit__map" id="aIfpack2_1_1ILUT_3_01MatrixType_01_4_inherit__map">
<area shape="rect" title="ILUT (incomplete LU factorization with threshold) of a Tpetra sparse matrix." alt="" coords="771,125,980,150"/>
<area shape="rect" href="classIfpack2_1_1Preconditioner.html" title=" " alt="" coords="480,37,719,121"/>
<area shape="poly" title=" " alt="" coords="733,104,815,122,814,127,732,110"/>
<area shape="rect" href="classIfpack2_1_1Preconditioner.html" title="Interface for all Ifpack2 preconditioners." alt="" coords="23,50,195,105"/>
<area shape="poly" title=" " alt="" coords="209,75,480,76,480,81,209,80"/>
<area shape="rect" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html" title=" " alt="" coords="477,145,721,244"/>
<area shape="poly" title=" " alt="" coords="734,164,813,147,814,153,735,169"/>
<area shape="rect" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html" title="Mix&#45;in interface for preconditioners that can change their matrix after construction." alt="" coords="5,176,212,216"/>
<area shape="poly" title=" " alt="" coords="226,193,477,192,477,198,226,198"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Typedefs</div></td></tr>
<tr class="memitem:a75e04d08a9999eeb484d884a93f0dac7" id="r_a75e04d08a9999eeb484d884a93f0dac7"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::scalar_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a75e04d08a9999eeb484d884a93f0dac7">scalar_type</a></td></tr>
<tr class="memdesc:a75e04d08a9999eeb484d884a93f0dac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the entries of the input MatrixType.  <br /></td></tr>
<tr class="separator:a75e04d08a9999eeb484d884a93f0dac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508845095b28fb1dc8d06371260cd2ba" id="r_a508845095b28fb1dc8d06371260cd2ba"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::local_ordinal_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a508845095b28fb1dc8d06371260cd2ba">local_ordinal_type</a></td></tr>
<tr class="memdesc:a508845095b28fb1dc8d06371260cd2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of local indices in the input MatrixType.  <br /></td></tr>
<tr class="separator:a508845095b28fb1dc8d06371260cd2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85dbb1441354412c67248b1caf7bc341" id="r_a85dbb1441354412c67248b1caf7bc341"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::global_ordinal_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a85dbb1441354412c67248b1caf7bc341">global_ordinal_type</a></td></tr>
<tr class="memdesc:a85dbb1441354412c67248b1caf7bc341"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of global indices in the input MatrixType.  <br /></td></tr>
<tr class="separator:a85dbb1441354412c67248b1caf7bc341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3f6604438174239b4fed6d925e5433" id="r_a8a3f6604438174239b4fed6d925e5433"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a8a3f6604438174239b4fed6d925e5433">node_type</a></td></tr>
<tr class="memdesc:a8a3f6604438174239b4fed6d925e5433"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Node type used by the input MatrixType.  <br /></td></tr>
<tr class="separator:a8a3f6604438174239b4fed6d925e5433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15747a242b79a48129aa91cc11df8fe5" id="r_a15747a242b79a48129aa91cc11df8fe5"><td class="memItemLeft" align="right" valign="top">typedef Teuchos::ScalarTraits&lt; <a class="el" href="classIfpack2_1_1ILUT.html#a75e04d08a9999eeb484d884a93f0dac7">scalar_type</a> &gt;::magnitudeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a15747a242b79a48129aa91cc11df8fe5">magnitude_type</a></td></tr>
<tr class="memdesc:a15747a242b79a48129aa91cc11df8fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the magnitude (absolute value) of a matrix entry.  <br /></td></tr>
<tr class="separator:a15747a242b79a48129aa91cc11df8fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced9b631138a06261d685b1e50d44b9c" id="r_aced9b631138a06261d685b1e50d44b9c"><td class="memItemLeft" align="right" valign="top">typedef Tpetra::RowMatrix&lt; <a class="el" href="classIfpack2_1_1ILUT.html#a75e04d08a9999eeb484d884a93f0dac7">scalar_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a508845095b28fb1dc8d06371260cd2ba">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a85dbb1441354412c67248b1caf7bc341">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a8a3f6604438174239b4fed6d925e5433">node_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#aced9b631138a06261d685b1e50d44b9c">row_matrix_type</a></td></tr>
<tr class="memdesc:aced9b631138a06261d685b1e50d44b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the Tpetra::RowMatrix specialization that this class uses.  <br /></td></tr>
<tr class="separator:aced9b631138a06261d685b1e50d44b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa456d2ea5d87a29d0487477d8764f143" id="r_aa456d2ea5d87a29d0487477d8764f143"><td class="memItemLeft" align="right" valign="top">typedef Tpetra::CrsMatrix&lt; <a class="el" href="classIfpack2_1_1ILUT.html#a75e04d08a9999eeb484d884a93f0dac7">scalar_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a508845095b28fb1dc8d06371260cd2ba">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a85dbb1441354412c67248b1caf7bc341">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a8a3f6604438174239b4fed6d925e5433">node_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#aa456d2ea5d87a29d0487477d8764f143">crs_matrix_type</a></td></tr>
<tr class="memdesc:aa456d2ea5d87a29d0487477d8764f143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the Tpetra::CrsMatrix specialization that this class uses for the L and U factors.  <br /></td></tr>
<tr class="separator:aa456d2ea5d87a29d0487477d8764f143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">For implementation of Kokkos Kernels parallel ILUt (thresholded ILU)</div></td></tr>
<tr class="memitem:a365624414243ed090493a7d59969761b" id="r_a365624414243ed090493a7d59969761b"><td class="memItemLeft" align="right" valign="top">typedef Tpetra::Map&lt; <a class="el" href="classIfpack2_1_1ILUT.html#a508845095b28fb1dc8d06371260cd2ba">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a85dbb1441354412c67248b1caf7bc341">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a8a3f6604438174239b4fed6d925e5433">node_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a365624414243ed090493a7d59969761b">map_type</a></td></tr>
<tr class="memdesc:a365624414243ed090493a7d59969761b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the Tpetra::Map specialization that this class uses.  <br /></td></tr>
<tr class="separator:a365624414243ed090493a7d59969761b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classIfpack2_1_1Preconditioner"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classIfpack2_1_1Preconditioner')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classIfpack2_1_1Preconditioner.html">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a></td></tr>
<tr class="memitem:a222c0e260ac8dc1226573e8a0773ac63 inherit pub_types_classIfpack2_1_1Preconditioner" id="r_a222c0e260ac8dc1226573e8a0773ac63"><td class="memItemLeft" align="right" valign="top">typedef Teuchos::ScalarTraits&lt; MatrixType::scalar_type &gt;::magnitudeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Preconditioner.html#a222c0e260ac8dc1226573e8a0773ac63">magnitude_type</a></td></tr>
<tr class="memdesc:a222c0e260ac8dc1226573e8a0773ac63 inherit pub_types_classIfpack2_1_1Preconditioner"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the magnitude (absolute value) of a matrix entry.  <br /></td></tr>
<tr class="separator:a222c0e260ac8dc1226573e8a0773ac63 inherit pub_types_classIfpack2_1_1Preconditioner"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and Destructors</div></td></tr>
<tr class="memitem:a9a2de03e6f6cf1693d63d333c26118bb" id="r_a9a2de03e6f6cf1693d63d333c26118bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a9a2de03e6f6cf1693d63d333c26118bb">ILUT</a> (const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1ILUT.html#aced9b631138a06261d685b1e50d44b9c">row_matrix_type</a> &gt; &amp;A)</td></tr>
<tr class="memdesc:a9a2de03e6f6cf1693d63d333c26118bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a9a2de03e6f6cf1693d63d333c26118bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaff355371748c8bb16541c707c5d4fe" id="r_adaff355371748c8bb16541c707c5d4fe"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#adaff355371748c8bb16541c707c5d4fe">~ILUT</a> ()=default</td></tr>
<tr class="memdesc:adaff355371748c8bb16541c707c5d4fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:adaff355371748c8bb16541c707c5d4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods for setting up and computing the incomplete factorization</div></td></tr>
<tr class="memitem:aee2011b313e3070ee43b2cfc2d183634" id="r_aee2011b313e3070ee43b2cfc2d183634"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#aee2011b313e3070ee43b2cfc2d183634">setParameters</a> (const Teuchos::ParameterList &amp;params)</td></tr>
<tr class="memdesc:aee2011b313e3070ee43b2cfc2d183634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set preconditioner parameters.  <br /></td></tr>
<tr class="separator:aee2011b313e3070ee43b2cfc2d183634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1213bdd746d0570905d9fe1b0728ba7" id="r_ad1213bdd746d0570905d9fe1b0728ba7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#ad1213bdd746d0570905d9fe1b0728ba7">initialize</a> ()</td></tr>
<tr class="memdesc:ad1213bdd746d0570905d9fe1b0728ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear any previously computed factors, and potentially compute sparsity patterns of factors.  <br /></td></tr>
<tr class="separator:ad1213bdd746d0570905d9fe1b0728ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a0505c1317c69d5493fad610eaecb7" id="r_a35a0505c1317c69d5493fad610eaecb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a35a0505c1317c69d5493fad610eaecb7">isInitialized</a> () const</td></tr>
<tr class="memdesc:a35a0505c1317c69d5493fad610eaecb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the preconditioner has been successfully initialized.  <br /></td></tr>
<tr class="separator:a35a0505c1317c69d5493fad610eaecb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dcabf60eecf315f70448ebc4140a7f9" id="r_a2dcabf60eecf315f70448ebc4140a7f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a2dcabf60eecf315f70448ebc4140a7f9">compute</a> ()</td></tr>
<tr class="memdesc:a2dcabf60eecf315f70448ebc4140a7f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute factors L and U using the specified diagonal perturbation thresholds and relaxation parameters.  <br /></td></tr>
<tr class="separator:a2dcabf60eecf315f70448ebc4140a7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bacdc07510138336b50e2657bcbec7c" id="r_a6bacdc07510138336b50e2657bcbec7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a6bacdc07510138336b50e2657bcbec7c">isComputed</a> () const</td></tr>
<tr class="memdesc:a6bacdc07510138336b50e2657bcbec7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="classIfpack2_1_1ILUT.html#a2dcabf60eecf315f70448ebc4140a7f9" title="Compute factors L and U using the specified diagonal perturbation thresholds and relaxation parameter...">compute()</a> is completed, this query returns true, otherwise it returns false.  <br /></td></tr>
<tr class="separator:a6bacdc07510138336b50e2657bcbec7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implementation of Ifpack2::Details::CanChangeMatrix</div></td></tr>
<tr class="memitem:a9bc97476985a4cba606bc078d0a71986" id="r_a9bc97476985a4cba606bc078d0a71986"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a9bc97476985a4cba606bc078d0a71986">setMatrix</a> (const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1ILUT.html#aced9b631138a06261d685b1e50d44b9c">row_matrix_type</a> &gt; &amp;A)</td></tr>
<tr class="memdesc:a9bc97476985a4cba606bc078d0a71986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the matrix to be preconditioned.  <br /></td></tr>
<tr class="separator:a9bc97476985a4cba606bc078d0a71986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implementation of Tpetra::Operator</div></td></tr>
<tr class="memitem:a54af762015cf342c91927b5cdee96fd6" id="r_a54af762015cf342c91927b5cdee96fd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a54af762015cf342c91927b5cdee96fd6">apply</a> (const Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1ILUT.html#a75e04d08a9999eeb484d884a93f0dac7">scalar_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a508845095b28fb1dc8d06371260cd2ba">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a85dbb1441354412c67248b1caf7bc341">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a8a3f6604438174239b4fed6d925e5433">node_type</a> &gt; &amp;X, Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1ILUT.html#a75e04d08a9999eeb484d884a93f0dac7">scalar_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a508845095b28fb1dc8d06371260cd2ba">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a85dbb1441354412c67248b1caf7bc341">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a8a3f6604438174239b4fed6d925e5433">node_type</a> &gt; &amp;Y, Teuchos::ETransp mode=Teuchos::NO_TRANS, <a class="el" href="classIfpack2_1_1ILUT.html#a75e04d08a9999eeb484d884a93f0dac7">scalar_type</a> alpha=Teuchos::ScalarTraits&lt; <a class="el" href="classIfpack2_1_1ILUT.html#a75e04d08a9999eeb484d884a93f0dac7">scalar_type</a> &gt;::one(), <a class="el" href="classIfpack2_1_1ILUT.html#a75e04d08a9999eeb484d884a93f0dac7">scalar_type</a> beta=Teuchos::ScalarTraits&lt; <a class="el" href="classIfpack2_1_1ILUT.html#a75e04d08a9999eeb484d884a93f0dac7">scalar_type</a> &gt;::zero()) const</td></tr>
<tr class="memdesc:a54af762015cf342c91927b5cdee96fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the <a class="el" href="classIfpack2_1_1ILUT.html" title="ILUT (incomplete LU factorization with threshold) of a Tpetra sparse matrix.">ILUT</a> preconditioner to X, resulting in Y.  <br /></td></tr>
<tr class="separator:a54af762015cf342c91927b5cdee96fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53bd24bf3670a9ed56cecdfe04614428" id="r_a53bd24bf3670a9ed56cecdfe04614428"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1ILUT.html#a365624414243ed090493a7d59969761b">map_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a53bd24bf3670a9ed56cecdfe04614428">getDomainMap</a> () const</td></tr>
<tr class="memdesc:a53bd24bf3670a9ed56cecdfe04614428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tpetra::Map representing the domain of this operator.  <br /></td></tr>
<tr class="separator:a53bd24bf3670a9ed56cecdfe04614428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0d172ee1b53100a47024faac975f56" id="r_aac0d172ee1b53100a47024faac975f56"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1ILUT.html#a365624414243ed090493a7d59969761b">map_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#aac0d172ee1b53100a47024faac975f56">getRangeMap</a> () const</td></tr>
<tr class="memdesc:aac0d172ee1b53100a47024faac975f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tpetra::Map representing the range of this operator.  <br /></td></tr>
<tr class="separator:aac0d172ee1b53100a47024faac975f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e76d9b4883663ab53dc5a0243eedb04" id="r_a8e76d9b4883663ab53dc5a0243eedb04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a8e76d9b4883663ab53dc5a0243eedb04">hasTransposeApply</a> () const</td></tr>
<tr class="memdesc:a8e76d9b4883663ab53dc5a0243eedb04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this object's <a class="el" href="classIfpack2_1_1ILUT.html#a54af762015cf342c91927b5cdee96fd6" title="Apply the ILUT preconditioner to X, resulting in Y.">apply()</a> method can apply the transpose (or conjugate transpose, if applicable).  <br /></td></tr>
<tr class="separator:a8e76d9b4883663ab53dc5a0243eedb04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mathematical functions</div></td></tr>
<tr class="memitem:a185c7eeff6de3770208ec2fdbfb60b48" id="r_a185c7eeff6de3770208ec2fdbfb60b48"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const Teuchos::Comm&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a185c7eeff6de3770208ec2fdbfb60b48">getComm</a> () const</td></tr>
<tr class="memdesc:a185c7eeff6de3770208ec2fdbfb60b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input matrix's communicator.  <br /></td></tr>
<tr class="separator:a185c7eeff6de3770208ec2fdbfb60b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1b3de1c15072fc44e43c29b8740f9b" id="r_a2e1b3de1c15072fc44e43c29b8740f9b"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1ILUT.html#aced9b631138a06261d685b1e50d44b9c">row_matrix_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a2e1b3de1c15072fc44e43c29b8740f9b">getMatrix</a> () const</td></tr>
<tr class="memdesc:a2e1b3de1c15072fc44e43c29b8740f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the matrix to be preconditioned.  <br /></td></tr>
<tr class="separator:a2e1b3de1c15072fc44e43c29b8740f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d489d377676783bc48ef807abd7d83f" id="r_a8d489d377676783bc48ef807abd7d83f"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1ILUT.html#aa456d2ea5d87a29d0487477d8764f143">crs_matrix_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a8d489d377676783bc48ef807abd7d83f">getL</a> () const</td></tr>
<tr class="memdesc:a8d489d377676783bc48ef807abd7d83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the L factor.  <br /></td></tr>
<tr class="separator:a8d489d377676783bc48ef807abd7d83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f87f349351028b50a0a413d201569e" id="r_ac8f87f349351028b50a0a413d201569e"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1ILUT.html#aa456d2ea5d87a29d0487477d8764f143">crs_matrix_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#ac8f87f349351028b50a0a413d201569e">getU</a> () const</td></tr>
<tr class="memdesc:ac8f87f349351028b50a0a413d201569e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the U factor.  <br /></td></tr>
<tr class="separator:ac8f87f349351028b50a0a413d201569e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0417fd932a5f551caa0c56833c84eb" id="r_a4c0417fd932a5f551caa0c56833c84eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a4c0417fd932a5f551caa0c56833c84eb">getNumInitialize</a> () const</td></tr>
<tr class="memdesc:a4c0417fd932a5f551caa0c56833c84eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of calls to Initialize().  <br /></td></tr>
<tr class="separator:a4c0417fd932a5f551caa0c56833c84eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12b97d6fc1516cece5e50c9e9d2d326" id="r_ae12b97d6fc1516cece5e50c9e9d2d326"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#ae12b97d6fc1516cece5e50c9e9d2d326">getNumCompute</a> () const</td></tr>
<tr class="memdesc:ae12b97d6fc1516cece5e50c9e9d2d326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of calls to Compute().  <br /></td></tr>
<tr class="separator:ae12b97d6fc1516cece5e50c9e9d2d326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571919cc0308a066d544030f9fc0d57b" id="r_a571919cc0308a066d544030f9fc0d57b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a571919cc0308a066d544030f9fc0d57b">getNumApply</a> () const</td></tr>
<tr class="memdesc:a571919cc0308a066d544030f9fc0d57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of calls to <a class="el" href="classIfpack2_1_1ILUT.html#a54af762015cf342c91927b5cdee96fd6" title="Apply the ILUT preconditioner to X, resulting in Y.">apply()</a>.  <br /></td></tr>
<tr class="separator:a571919cc0308a066d544030f9fc0d57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca199ff6fee711993c3c2add98b6dde" id="r_a1ca199ff6fee711993c3c2add98b6dde"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a1ca199ff6fee711993c3c2add98b6dde">getInitializeTime</a> () const</td></tr>
<tr class="memdesc:a1ca199ff6fee711993c3c2add98b6dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time spent in Initialize().  <br /></td></tr>
<tr class="separator:a1ca199ff6fee711993c3c2add98b6dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7335dbd2122c4b7cf76e48e98ebdba" id="r_afa7335dbd2122c4b7cf76e48e98ebdba"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#afa7335dbd2122c4b7cf76e48e98ebdba">getComputeTime</a> () const</td></tr>
<tr class="memdesc:afa7335dbd2122c4b7cf76e48e98ebdba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time spent in Compute().  <br /></td></tr>
<tr class="separator:afa7335dbd2122c4b7cf76e48e98ebdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d6bf0d3c6aa72ff5f31ad44ffa2737" id="r_ae7d6bf0d3c6aa72ff5f31ad44ffa2737"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#ae7d6bf0d3c6aa72ff5f31ad44ffa2737">getApplyTime</a> () const</td></tr>
<tr class="memdesc:ae7d6bf0d3c6aa72ff5f31ad44ffa2737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time spent in <a class="el" href="classIfpack2_1_1ILUT.html#a54af762015cf342c91927b5cdee96fd6" title="Apply the ILUT preconditioner to X, resulting in Y.">apply()</a>.  <br /></td></tr>
<tr class="separator:ae7d6bf0d3c6aa72ff5f31ad44ffa2737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c45be5ae05d178e70a1fc584248768" id="r_a72c45be5ae05d178e70a1fc584248768"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a72c45be5ae05d178e70a1fc584248768">getNodeSmootherComplexity</a> () const</td></tr>
<tr class="memdesc:a72c45be5ae05d178e70a1fc584248768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a rough estimate of cost per iteration.  <br /></td></tr>
<tr class="separator:a72c45be5ae05d178e70a1fc584248768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16822ca3a5cf6917784d4a258f5bb220" id="r_a16822ca3a5cf6917784d4a258f5bb220"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a16822ca3a5cf6917784d4a258f5bb220">getLevelOfFill</a> () const</td></tr>
<tr class="memdesc:a16822ca3a5cf6917784d4a258f5bb220"><td class="mdescLeft">&#160;</td><td class="mdescRight">The level of fill.  <br /></td></tr>
<tr class="separator:a16822ca3a5cf6917784d4a258f5bb220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fab4771735d687e89e1acf73672fd6" id="r_af4fab4771735d687e89e1acf73672fd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1ILUT.html#a15747a242b79a48129aa91cc11df8fe5">magnitude_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#af4fab4771735d687e89e1acf73672fd6">getAbsoluteThreshold</a> () const</td></tr>
<tr class="memdesc:af4fab4771735d687e89e1acf73672fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get absolute threshold value.  <br /></td></tr>
<tr class="separator:af4fab4771735d687e89e1acf73672fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af226d8a8d23f77af34cd240b6f14b5cd" id="r_af226d8a8d23f77af34cd240b6f14b5cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1ILUT.html#a15747a242b79a48129aa91cc11df8fe5">magnitude_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#af226d8a8d23f77af34cd240b6f14b5cd">getRelativeThreshold</a> () const</td></tr>
<tr class="memdesc:af226d8a8d23f77af34cd240b6f14b5cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get relative threshold value.  <br /></td></tr>
<tr class="separator:af226d8a8d23f77af34cd240b6f14b5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae054799616d30e4018c15e08cba3ed47" id="r_ae054799616d30e4018c15e08cba3ed47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1ILUT.html#a15747a242b79a48129aa91cc11df8fe5">magnitude_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#ae054799616d30e4018c15e08cba3ed47">getRelaxValue</a> () const</td></tr>
<tr class="memdesc:ae054799616d30e4018c15e08cba3ed47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the relax value.  <br /></td></tr>
<tr class="separator:ae054799616d30e4018c15e08cba3ed47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f990ab5288fbb2bf11fa5969a95099f" id="r_a3f990ab5288fbb2bf11fa5969a95099f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1ILUT.html#a15747a242b79a48129aa91cc11df8fe5">magnitude_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a3f990ab5288fbb2bf11fa5969a95099f">getDropTolerance</a> () const</td></tr>
<tr class="memdesc:a3f990ab5288fbb2bf11fa5969a95099f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the dropping tolerance.  <br /></td></tr>
<tr class="separator:a3f990ab5288fbb2bf11fa5969a95099f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bafff3469d6d3c53149ef814d83240d" id="r_a4bafff3469d6d3c53149ef814d83240d"><td class="memItemLeft" align="right" valign="top">global_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a4bafff3469d6d3c53149ef814d83240d">getGlobalNumEntries</a> () const</td></tr>
<tr class="memdesc:a4bafff3469d6d3c53149ef814d83240d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nonzero entries in the global graph.  <br /></td></tr>
<tr class="separator:a4bafff3469d6d3c53149ef814d83240d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b4604231d98ef76ba94dcc23ff382c" id="r_ab5b4604231d98ef76ba94dcc23ff382c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#ab5b4604231d98ef76ba94dcc23ff382c">getLocalNumEntries</a> () const</td></tr>
<tr class="memdesc:ab5b4604231d98ef76ba94dcc23ff382c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nonzero entries in the local graph.  <br /></td></tr>
<tr class="separator:ab5b4604231d98ef76ba94dcc23ff382c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classIfpack2_1_1Preconditioner"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classIfpack2_1_1Preconditioner')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classIfpack2_1_1Preconditioner.html">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a></td></tr>
<tr class="memitem:a637973211128e0c09db53772df0f345d inherit pub_methods_classIfpack2_1_1Preconditioner" id="r_a637973211128e0c09db53772df0f345d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Preconditioner.html#a637973211128e0c09db53772df0f345d">~Preconditioner</a> ()</td></tr>
<tr class="memdesc:a637973211128e0c09db53772df0f345d inherit pub_methods_classIfpack2_1_1Preconditioner"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a637973211128e0c09db53772df0f345d inherit pub_methods_classIfpack2_1_1Preconditioner"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12495acd22d15212241c0d518d7f6536 inherit pub_methods_classIfpack2_1_1Preconditioner" id="r_a12495acd22d15212241c0d518d7f6536"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Preconditioner.html#a12495acd22d15212241c0d518d7f6536">setZeroStartingSolution</a> (bool zeroStartingSolution)</td></tr>
<tr class="memdesc:a12495acd22d15212241c0d518d7f6536 inherit pub_methods_classIfpack2_1_1Preconditioner"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this preconditioner's parameters.  <br /></td></tr>
<tr class="separator:a12495acd22d15212241c0d518d7f6536 inherit pub_methods_classIfpack2_1_1Preconditioner"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html">Ifpack2::Details::CanChangeMatrix&lt; Tpetra::RowMatrix&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt; &gt;</a></td></tr>
<tr class="memitem:acad726ffa06a9eef5d675364f996101a inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix" id="r_acad726ffa06a9eef5d675364f996101a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">virtual</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html#acad726ffa06a9eef5d675364f996101a">setMatrix</a> (<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> Tpetra::RowMatrix&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt; &gt; &amp;A)=0</td></tr>
<tr class="memdesc:acad726ffa06a9eef5d675364f996101a inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the new matrix.  <br /></td></tr>
<tr class="separator:acad726ffa06a9eef5d675364f996101a inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad9626e6fa50980dc192a4a63341c12 inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix" id="r_abad9626e6fa50980dc192a4a63341c12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">virtual</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html#abad9626e6fa50980dc192a4a63341c12">~CanChangeMatrix</a> ()</td></tr>
<tr class="memdesc:abad9626e6fa50980dc192a4a63341c12 inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:abad9626e6fa50980dc192a4a63341c12 inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Implementation of Teuchos::Describable</h2></td></tr>
<tr class="memitem:a877850b48c4fdfcb4c7c310c78e92a40" id="r_a877850b48c4fdfcb4c7c310c78e92a40"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a877850b48c4fdfcb4c7c310c78e92a40">description</a> () const</td></tr>
<tr class="memdesc:a877850b48c4fdfcb4c7c310c78e92a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a simple one-line description of this object.  <br /></td></tr>
<tr class="separator:a877850b48c4fdfcb4c7c310c78e92a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98083c9d28fe5413863ad5eb9d38994c" id="r_a98083c9d28fe5413863ad5eb9d38994c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1ILUT.html#a98083c9d28fe5413863ad5eb9d38994c">describe</a> (Teuchos::FancyOStream &amp;out, const Teuchos::EVerbosityLevel verbLevel=Teuchos::Describable::verbLevel_default) const</td></tr>
<tr class="memdesc:a98083c9d28fe5413863ad5eb9d38994c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the object with some verbosity level to an FancyOStream object.  <br /></td></tr>
<tr class="separator:a98083c9d28fe5413863ad5eb9d38994c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class MatrixType&gt;<br />
class Ifpack2::ILUT&lt; MatrixType &gt;</div><p><a class="el" href="classIfpack2_1_1ILUT.html" title="ILUT (incomplete LU factorization with threshold) of a Tpetra sparse matrix.">ILUT</a> (incomplete LU factorization with threshold) of a Tpetra sparse matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>specialization of Tpetra::RowMatrix.</td></tr>
  </table>
  </dd>
</dl>
<p>This class computes a sparse <a class="el" href="classIfpack2_1_1ILUT.html" title="ILUT (incomplete LU factorization with threshold) of a Tpetra sparse matrix.">ILUT</a> (incomplete LU) factorization with specified fill and drop tolerance, of the local part of a given sparse matrix represented as a Tpetra::RowMatrix or Tpetra::CrsMatrix. The "local part" is the square diagonal block of the matrix owned by the calling process. Thus, if the input matrix is distributed over multiple MPI processes, this preconditioner is equivalent to nonoverlapping additive Schwarz domain decomposition over the MPI processes, with <a class="el" href="classIfpack2_1_1ILUT.html" title="ILUT (incomplete LU factorization with threshold) of a Tpetra sparse matrix.">ILUT</a> as the subdomain solver on each process.</p>
<dl class="section remark"><dt>Remarks</dt><dd>See the documentation of <a class="el" href="classIfpack2_1_1ILUT.html#aee2011b313e3070ee43b2cfc2d183634" title="Set preconditioner parameters.">setParameters()</a> for a list of valid parameters.</dd>
<dd>
This version of <a class="el" href="classIfpack2_1_1ILUT.html" title="ILUT (incomplete LU factorization with threshold) of a Tpetra sparse matrix.">ILUT</a> is a translation of Aztec's <a class="el" href="classIfpack2_1_1ILUT.html" title="ILUT (incomplete LU factorization with threshold) of a Tpetra sparse matrix.">ILUT</a> implementation, which was written by Ray Tuminaro.</dd>
<dd>
There is an important difference between this implementation and the version described in Saad's paper. See <a class="el" href="classIfpack2_1_1ILUT.html#aee2011b313e3070ee43b2cfc2d183634" title="Set preconditioner parameters.">setParameters()</a> for details. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a75e04d08a9999eeb484d884a93f0dac7" name="a75e04d08a9999eeb484d884a93f0dac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e04d08a9999eeb484d884a93f0dac7">&#9670;&#160;</a></span>scalar_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::scalar_type <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::scalar_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the entries of the input MatrixType. </p>

</div>
</div>
<a id="a508845095b28fb1dc8d06371260cd2ba" name="a508845095b28fb1dc8d06371260cd2ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508845095b28fb1dc8d06371260cd2ba">&#9670;&#160;</a></span>local_ordinal_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::local_ordinal_type <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::local_ordinal_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of local indices in the input MatrixType. </p>

</div>
</div>
<a id="a85dbb1441354412c67248b1caf7bc341" name="a85dbb1441354412c67248b1caf7bc341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85dbb1441354412c67248b1caf7bc341">&#9670;&#160;</a></span>global_ordinal_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::global_ordinal_type <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::global_ordinal_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of global indices in the input MatrixType. </p>

</div>
</div>
<a id="a8a3f6604438174239b4fed6d925e5433" name="a8a3f6604438174239b4fed6d925e5433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3f6604438174239b4fed6d925e5433">&#9670;&#160;</a></span>node_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::node_type <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::node_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Node type used by the input MatrixType. </p>

</div>
</div>
<a id="a15747a242b79a48129aa91cc11df8fe5" name="a15747a242b79a48129aa91cc11df8fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15747a242b79a48129aa91cc11df8fe5">&#9670;&#160;</a></span>magnitude_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Teuchos::ScalarTraits&lt;<a class="el" href="classIfpack2_1_1ILUT.html#a75e04d08a9999eeb484d884a93f0dac7">scalar_type</a>&gt;::magnitudeType <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::magnitude_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the magnitude (absolute value) of a matrix entry. </p>

</div>
</div>
<a id="aced9b631138a06261d685b1e50d44b9c" name="aced9b631138a06261d685b1e50d44b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced9b631138a06261d685b1e50d44b9c">&#9670;&#160;</a></span>row_matrix_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Tpetra::RowMatrix&lt;<a class="el" href="classIfpack2_1_1ILUT.html#a75e04d08a9999eeb484d884a93f0dac7">scalar_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a508845095b28fb1dc8d06371260cd2ba">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a85dbb1441354412c67248b1caf7bc341">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a8a3f6604438174239b4fed6d925e5433">node_type</a>&gt; <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::row_matrix_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the Tpetra::RowMatrix specialization that this class uses. </p>

</div>
</div>
<a id="aa456d2ea5d87a29d0487477d8764f143" name="aa456d2ea5d87a29d0487477d8764f143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa456d2ea5d87a29d0487477d8764f143">&#9670;&#160;</a></span>crs_matrix_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Tpetra::CrsMatrix&lt;<a class="el" href="classIfpack2_1_1ILUT.html#a75e04d08a9999eeb484d884a93f0dac7">scalar_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a508845095b28fb1dc8d06371260cd2ba">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a85dbb1441354412c67248b1caf7bc341">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a8a3f6604438174239b4fed6d925e5433">node_type</a>&gt; <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::crs_matrix_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the Tpetra::CrsMatrix specialization that this class uses for the L and U factors. </p>

</div>
</div>
<a id="a365624414243ed090493a7d59969761b" name="a365624414243ed090493a7d59969761b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365624414243ed090493a7d59969761b">&#9670;&#160;</a></span>map_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Tpetra::Map&lt;<a class="el" href="classIfpack2_1_1ILUT.html#a508845095b28fb1dc8d06371260cd2ba">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a85dbb1441354412c67248b1caf7bc341">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a8a3f6604438174239b4fed6d925e5433">node_type</a>&gt; <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::map_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the Tpetra::Map specialization that this class uses. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9a2de03e6f6cf1693d63d333c26118bb" name="a9a2de03e6f6cf1693d63d333c26118bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2de03e6f6cf1693d63d333c26118bb">&#9670;&#160;</a></span>ILUT()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::ILUT </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1ILUT.html#aced9b631138a06261d685b1e50d44b9c">row_matrix_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>[in] The sparse matrix to factor, as a Tpetra::RowMatrix. (Tpetra::CrsMatrix inherits from this, so you may use a Tpetra::CrsMatrix here instead.)</td></tr>
  </table>
  </dd>
</dl>
<p>The factorization will <em>not</em> modify the input matrix. It stores the L and U factors in the incomplete factorization separately. </p>

</div>
</div>
<a id="adaff355371748c8bb16541c707c5d4fe" name="adaff355371748c8bb16541c707c5d4fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaff355371748c8bb16541c707c5d4fe">&#9670;&#160;</a></span>~ILUT()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::~<a class="el" href="classIfpack2_1_1ILUT.html">ILUT</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aee2011b313e3070ee43b2cfc2d183634" name="aee2011b313e3070ee43b2cfc2d183634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee2011b313e3070ee43b2cfc2d183634">&#9670;&#160;</a></span>setParameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::setParameters </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set preconditioner parameters. </p>
<p><a class="el" href="classIfpack2_1_1ILUT.html" title="ILUT (incomplete LU factorization with threshold) of a Tpetra sparse matrix.">ILUT</a> implements the following parameters: </p><ul>
<li>
"fact: ilut level-of-fill" (<code>double</code>) </li>
<li>
"fact: drop tolerance" (<code>magnitude_type</code>) </li>
<li>
"fact: absolute threshold" (<code>magnitude_type</code>) </li>
<li>
"fact: relative threshold" (<code>magnitude_type</code>) </li>
<li>
"fact: relax value" (<code>magnitude_type</code>) </li>
</ul>
<p>"fact: drop tolerance" is the magnitude threshold for dropping entries. It corresponds to the \(\tau\) parameter in Saad's original description of <a class="el" href="classIfpack2_1_1ILUT.html" title="ILUT (incomplete LU factorization with threshold) of a Tpetra sparse matrix.">ILUT</a>. "fact: ilut level-of-fill" controls the number of entries to keep in the strict upper triangle of the current row, and in the strict lower triangle of the current row. It does <b>not</b> correspond to the \(p\) parameter in Saad's original description. This parameter represents a maximum fill fraction. In this implementation, the L and U factors always contains nonzeros corresponding to the original sparsity pattern of A, so this value should be &gt;= 1.0. Letting \(fill = \frac{(level-of-fill - 1)*nnz(A)}{2*N}\), each row of the computed L and U factors contains at most \(fill\) nonzero elements in addition to those from the sparsity pattern of A. <a class="el" href="classIfpack2_1_1ILUT.html" title="ILUT (incomplete LU factorization with threshold) of a Tpetra sparse matrix.">ILUT</a> always keeps the diagonal entry in the current row, regardless of the drop tolerance or fill level.</p>
<p>The absolute and relative threshold parameters affect how this code modifies the diagonal entry of the output factor. These parameters are not part of the original <a class="el" href="classIfpack2_1_1ILUT.html" title="ILUT (incomplete LU factorization with threshold) of a Tpetra sparse matrix.">ILUT</a> algorithm, but we include them for consistency with other <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> preconditioners.</p>
<p>The "fact: relax value" parameter currently has no effect. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a60340992fc1b9eac82ef35333bee6efd">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="ad1213bdd746d0570905d9fe1b0728ba7" name="ad1213bdd746d0570905d9fe1b0728ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1213bdd746d0570905d9fe1b0728ba7">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear any previously computed factors, and potentially compute sparsity patterns of factors. </p>
<p>You may call this before calling <a class="el" href="classIfpack2_1_1ILUT.html#a2dcabf60eecf315f70448ebc4140a7f9" title="Compute factors L and U using the specified diagonal perturbation thresholds and relaxation parameter...">compute()</a>. The <a class="el" href="classIfpack2_1_1ILUT.html#a2dcabf60eecf315f70448ebc4140a7f9" title="Compute factors L and U using the specified diagonal perturbation thresholds and relaxation parameter...">compute()</a> method will call this automatically if it has not yet been called. If you call this after calling <a class="el" href="classIfpack2_1_1ILUT.html#a2dcabf60eecf315f70448ebc4140a7f9" title="Compute factors L and U using the specified diagonal perturbation thresholds and relaxation parameter...">compute()</a>, you must recompute the factorization (by calling <a class="el" href="classIfpack2_1_1ILUT.html#a2dcabf60eecf315f70448ebc4140a7f9" title="Compute factors L and U using the specified diagonal perturbation thresholds and relaxation parameter...">compute()</a> again) before you may call <a class="el" href="classIfpack2_1_1ILUT.html#a54af762015cf342c91927b5cdee96fd6" title="Apply the ILUT preconditioner to X, resulting in Y.">apply()</a>.</p>
<p>If your are using Par_ILUT from Kokkos Kernels, <a class="el" href="classIfpack2_1_1ILUT.html#ad1213bdd746d0570905d9fe1b0728ba7" title="Clear any previously computed factors, and potentially compute sparsity patterns of factors.">initialize()</a> will also perform a symbolic factorization (i.e., compute sparsity patterns of factors). </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#ad3aefd6f16e8ef4cddb696cd23f160b0">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a35a0505c1317c69d5493fad610eaecb7" name="a35a0505c1317c69d5493fad610eaecb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a0505c1317c69d5493fad610eaecb7">&#9670;&#160;</a></span>isInitialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::isInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the preconditioner has been successfully initialized. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a180c876ccf7af87f10a1c1d08ba2dc01">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a2dcabf60eecf315f70448ebc4140a7f9" name="a2dcabf60eecf315f70448ebc4140a7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dcabf60eecf315f70448ebc4140a7f9">&#9670;&#160;</a></span>compute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::compute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute factors L and U using the specified diagonal perturbation thresholds and relaxation parameters. </p>
<p>This function computes the <a class="el" href="classIfpack2_1_1ILUT.html" title="ILUT (incomplete LU factorization with threshold) of a Tpetra sparse matrix.">ILUT</a> factors L and U using the current: </p><ol>
<li>
Value for the drop tolerance </li>
<li>
Value for the level of fill </li>
<li>
Value for the <em>a</em> <em>priori</em> diagonal threshold values. </li>
</ol>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a23954dd69f62b56455a9c0988bbe9e67">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a6bacdc07510138336b50e2657bcbec7c" name="a6bacdc07510138336b50e2657bcbec7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bacdc07510138336b50e2657bcbec7c">&#9670;&#160;</a></span>isComputed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::isComputed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If <a class="el" href="classIfpack2_1_1ILUT.html#a2dcabf60eecf315f70448ebc4140a7f9" title="Compute factors L and U using the specified diagonal perturbation thresholds and relaxation parameter...">compute()</a> is completed, this query returns true, otherwise it returns false. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#abb5af77756a7488ab636dbd97483ca66">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a9bc97476985a4cba606bc078d0a71986" name="a9bc97476985a4cba606bc078d0a71986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc97476985a4cba606bc078d0a71986">&#9670;&#160;</a></span>setMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::setMatrix </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1ILUT.html#aced9b631138a06261d685b1e50d44b9c">row_matrix_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the matrix to be preconditioned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>[in] The new matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>! isInitialized ()</code> </dd>
<dd>
<code>! isComputed ()</code></dd></dl>
<p>Calling this method resets the preconditioner's state. After calling this method with a nonnull input, you must first call <a class="el" href="classIfpack2_1_1ILUT.html#ad1213bdd746d0570905d9fe1b0728ba7" title="Clear any previously computed factors, and potentially compute sparsity patterns of factors.">initialize()</a> and <a class="el" href="classIfpack2_1_1ILUT.html#a2dcabf60eecf315f70448ebc4140a7f9" title="Compute factors L and U using the specified diagonal perturbation thresholds and relaxation parameter...">compute()</a> (in that order) before you may call <a class="el" href="classIfpack2_1_1ILUT.html#a54af762015cf342c91927b5cdee96fd6" title="Apply the ILUT preconditioner to X, resulting in Y.">apply()</a>.</p>
<p>You may call this method with a null input. If A is null, then you may not call <a class="el" href="classIfpack2_1_1ILUT.html#ad1213bdd746d0570905d9fe1b0728ba7" title="Clear any previously computed factors, and potentially compute sparsity patterns of factors.">initialize()</a> or <a class="el" href="classIfpack2_1_1ILUT.html#a2dcabf60eecf315f70448ebc4140a7f9" title="Compute factors L and U using the specified diagonal perturbation thresholds and relaxation parameter...">compute()</a> until you first call this method again with a nonnull input. This method invalidates any previous factorization whether or not A is null, so calling <a class="el" href="classIfpack2_1_1ILUT.html#a9bc97476985a4cba606bc078d0a71986" title="Change the matrix to be preconditioned.">setMatrix()</a> with a null input is one way to clear the preconditioner's state (and free any memory that it may be using).</p>
<p>The new matrix A need not necessarily have the same Maps or even the same communicator as the original matrix. </p>

</div>
</div>
<a id="a54af762015cf342c91927b5cdee96fd6" name="a54af762015cf342c91927b5cdee96fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54af762015cf342c91927b5cdee96fd6">&#9670;&#160;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1ILUT.html#a75e04d08a9999eeb484d884a93f0dac7">scalar_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a508845095b28fb1dc8d06371260cd2ba">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a85dbb1441354412c67248b1caf7bc341">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a8a3f6604438174239b4fed6d925e5433">node_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1ILUT.html#a75e04d08a9999eeb484d884a93f0dac7">scalar_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a508845095b28fb1dc8d06371260cd2ba">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a85dbb1441354412c67248b1caf7bc341">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1ILUT.html#a8a3f6604438174239b4fed6d925e5433">node_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::ETransp&#160;</td>
          <td class="paramname"><em>mode</em> = <code>Teuchos::NO_TRANS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIfpack2_1_1ILUT.html#a75e04d08a9999eeb484d884a93f0dac7">scalar_type</a>&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>Teuchos::ScalarTraits&lt;<a class="el" href="classIfpack2_1_1ILUT.html#a75e04d08a9999eeb484d884a93f0dac7">scalar_type</a>&gt;::one()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIfpack2_1_1ILUT.html#a75e04d08a9999eeb484d884a93f0dac7">scalar_type</a>&#160;</td>
          <td class="paramname"><em>beta</em> = <code>Teuchos::ScalarTraits&lt;<a class="el" href="classIfpack2_1_1ILUT.html#a75e04d08a9999eeb484d884a93f0dac7">scalar_type</a>&gt;::zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the <a class="el" href="classIfpack2_1_1ILUT.html" title="ILUT (incomplete LU factorization with threshold) of a Tpetra sparse matrix.">ILUT</a> preconditioner to X, resulting in Y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>[in] Input multivector; "right-hand side" of the solve. </td></tr>
    <tr><td class="paramname">Y</td><td>[out] Output multivector; result of the solve. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a606c3f8155f67f2867fac3a7c44bd5df">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a53bd24bf3670a9ed56cecdfe04614428" name="a53bd24bf3670a9ed56cecdfe04614428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53bd24bf3670a9ed56cecdfe04614428">&#9670;&#160;</a></span>getDomainMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const typename <a class="el" href="classIfpack2_1_1ILUT.html">ILUT</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1ILUT.html#a365624414243ed090493a7d59969761b">::map_type</a> &gt; <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::getDomainMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tpetra::Map representing the domain of this operator. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#aafeb2143ff699f2289503a85f6e3523c">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="aac0d172ee1b53100a47024faac975f56" name="aac0d172ee1b53100a47024faac975f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0d172ee1b53100a47024faac975f56">&#9670;&#160;</a></span>getRangeMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const typename <a class="el" href="classIfpack2_1_1ILUT.html">ILUT</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1ILUT.html#a365624414243ed090493a7d59969761b">::map_type</a> &gt; <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::getRangeMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tpetra::Map representing the range of this operator. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a75b32e1de03024035b00cd2ee95a60da">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a8e76d9b4883663ab53dc5a0243eedb04" name="a8e76d9b4883663ab53dc5a0243eedb04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e76d9b4883663ab53dc5a0243eedb04">&#9670;&#160;</a></span>hasTransposeApply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::hasTransposeApply </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether this object's <a class="el" href="classIfpack2_1_1ILUT.html#a54af762015cf342c91927b5cdee96fd6" title="Apply the ILUT preconditioner to X, resulting in Y.">apply()</a> method can apply the transpose (or conjugate transpose, if applicable). </p>

</div>
</div>
<a id="a185c7eeff6de3770208ec2fdbfb60b48" name="a185c7eeff6de3770208ec2fdbfb60b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185c7eeff6de3770208ec2fdbfb60b48">&#9670;&#160;</a></span>getComm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const Teuchos::Comm&lt; int &gt; &gt; <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::getComm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the input matrix's communicator. </p>

</div>
</div>
<a id="a2e1b3de1c15072fc44e43c29b8740f9b" name="a2e1b3de1c15072fc44e43c29b8740f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1b3de1c15072fc44e43c29b8740f9b">&#9670;&#160;</a></span>getMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const typename <a class="el" href="classIfpack2_1_1ILUT.html">ILUT</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1ILUT.html#aced9b631138a06261d685b1e50d44b9c">::row_matrix_type</a> &gt; <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::getMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the matrix to be preconditioned. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a4258d242e7ff6003c399da8f0a11d634">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a8d489d377676783bc48ef807abd7d83f" name="a8d489d377676783bc48ef807abd7d83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d489d377676783bc48ef807abd7d83f">&#9670;&#160;</a></span>getL()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1ILUT.html#aa456d2ea5d87a29d0487477d8764f143">crs_matrix_type</a> &gt; <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::getL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the L factor. </p>

</div>
</div>
<a id="ac8f87f349351028b50a0a413d201569e" name="ac8f87f349351028b50a0a413d201569e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f87f349351028b50a0a413d201569e">&#9670;&#160;</a></span>getU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1ILUT.html#aa456d2ea5d87a29d0487477d8764f143">crs_matrix_type</a> &gt; <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::getU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the U factor. </p>

</div>
</div>
<a id="a4c0417fd932a5f551caa0c56833c84eb" name="a4c0417fd932a5f551caa0c56833c84eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0417fd932a5f551caa0c56833c84eb">&#9670;&#160;</a></span>getNumInitialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::getNumInitialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of calls to Initialize(). </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#afe6c77c5ab6da065f8dbade353e8535a">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="ae12b97d6fc1516cece5e50c9e9d2d326" name="ae12b97d6fc1516cece5e50c9e9d2d326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12b97d6fc1516cece5e50c9e9d2d326">&#9670;&#160;</a></span>getNumCompute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::getNumCompute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of calls to Compute(). </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a286b18ee0769ecc8bf992dffdc442791">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a571919cc0308a066d544030f9fc0d57b" name="a571919cc0308a066d544030f9fc0d57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571919cc0308a066d544030f9fc0d57b">&#9670;&#160;</a></span>getNumApply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::getNumApply </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of calls to <a class="el" href="classIfpack2_1_1ILUT.html#a54af762015cf342c91927b5cdee96fd6" title="Apply the ILUT preconditioner to X, resulting in Y.">apply()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a565e6c00bf14873ae7b23187c9978078">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a1ca199ff6fee711993c3c2add98b6dde" name="a1ca199ff6fee711993c3c2add98b6dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca199ff6fee711993c3c2add98b6dde">&#9670;&#160;</a></span>getInitializeTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::getInitializeTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the time spent in Initialize(). </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#aeb91a16f5544ad4efaf756b1d2a8b39d">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="afa7335dbd2122c4b7cf76e48e98ebdba" name="afa7335dbd2122c4b7cf76e48e98ebdba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7335dbd2122c4b7cf76e48e98ebdba">&#9670;&#160;</a></span>getComputeTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::getComputeTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the time spent in Compute(). </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a111d9bd4e28c0633696f271955ddcb4c">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="ae7d6bf0d3c6aa72ff5f31ad44ffa2737" name="ae7d6bf0d3c6aa72ff5f31ad44ffa2737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d6bf0d3c6aa72ff5f31ad44ffa2737">&#9670;&#160;</a></span>getApplyTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::getApplyTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the time spent in <a class="el" href="classIfpack2_1_1ILUT.html#a54af762015cf342c91927b5cdee96fd6" title="Apply the ILUT preconditioner to X, resulting in Y.">apply()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a57c2d00799de050cd2a5a75ce80f48b9">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a72c45be5ae05d178e70a1fc584248768" name="a72c45be5ae05d178e70a1fc584248768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c45be5ae05d178e70a1fc584248768">&#9670;&#160;</a></span>getNodeSmootherComplexity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::getNodeSmootherComplexity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a rough estimate of cost per iteration. </p>

</div>
</div>
<a id="a16822ca3a5cf6917784d4a258f5bb220" name="a16822ca3a5cf6917784d4a258f5bb220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16822ca3a5cf6917784d4a258f5bb220">&#9670;&#160;</a></span>getLevelOfFill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::getLevelOfFill </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The level of fill. </p>
<p>For <a class="el" href="classIfpack2_1_1ILUT.html" title="ILUT (incomplete LU factorization with threshold) of a Tpetra sparse matrix.">ILUT</a>, this means the maximum number of entries in each row of the resulting L and U factors (each considered separately), not including the diagonal entry in that row (which is always part of U). This has a different meaning for <a class="el" href="classIfpack2_1_1ILUT.html" title="ILUT (incomplete LU factorization with threshold) of a Tpetra sparse matrix.">ILUT</a> than it does for ILU(k). </p>

</div>
</div>
<a id="af4fab4771735d687e89e1acf73672fd6" name="af4fab4771735d687e89e1acf73672fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4fab4771735d687e89e1acf73672fd6">&#9670;&#160;</a></span>getAbsoluteThreshold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1ILUT.html#a15747a242b79a48129aa91cc11df8fe5">magnitude_type</a> <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::getAbsoluteThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get absolute threshold value. </p>

</div>
</div>
<a id="af226d8a8d23f77af34cd240b6f14b5cd" name="af226d8a8d23f77af34cd240b6f14b5cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af226d8a8d23f77af34cd240b6f14b5cd">&#9670;&#160;</a></span>getRelativeThreshold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1ILUT.html#a15747a242b79a48129aa91cc11df8fe5">magnitude_type</a> <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::getRelativeThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get relative threshold value. </p>

</div>
</div>
<a id="ae054799616d30e4018c15e08cba3ed47" name="ae054799616d30e4018c15e08cba3ed47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae054799616d30e4018c15e08cba3ed47">&#9670;&#160;</a></span>getRelaxValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1ILUT.html#a15747a242b79a48129aa91cc11df8fe5">magnitude_type</a> <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::getRelaxValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the relax value. </p>

</div>
</div>
<a id="a3f990ab5288fbb2bf11fa5969a95099f" name="a3f990ab5288fbb2bf11fa5969a95099f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f990ab5288fbb2bf11fa5969a95099f">&#9670;&#160;</a></span>getDropTolerance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1ILUT.html#a15747a242b79a48129aa91cc11df8fe5">magnitude_type</a> <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::getDropTolerance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the dropping tolerance. </p>

</div>
</div>
<a id="a4bafff3469d6d3c53149ef814d83240d" name="a4bafff3469d6d3c53149ef814d83240d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bafff3469d6d3c53149ef814d83240d">&#9670;&#160;</a></span>getGlobalNumEntries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">global_size_t <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::getGlobalNumEntries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of nonzero entries in the global graph. </p>

</div>
</div>
<a id="ab5b4604231d98ef76ba94dcc23ff382c" name="ab5b4604231d98ef76ba94dcc23ff382c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b4604231d98ef76ba94dcc23ff382c">&#9670;&#160;</a></span>getLocalNumEntries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::getLocalNumEntries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of nonzero entries in the local graph. </p>

</div>
</div>
<a id="a877850b48c4fdfcb4c7c310c78e92a40" name="a877850b48c4fdfcb4c7c310c78e92a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877850b48c4fdfcb4c7c310c78e92a40">&#9670;&#160;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a simple one-line description of this object. </p>

</div>
</div>
<a id="a98083c9d28fe5413863ad5eb9d38994c" name="a98083c9d28fe5413863ad5eb9d38994c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98083c9d28fe5413863ad5eb9d38994c">&#9670;&#160;</a></span>describe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1ILUT.html">Ifpack2::ILUT</a>&lt; MatrixType &gt;::describe </td>
          <td>(</td>
          <td class="paramtype">Teuchos::FancyOStream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::EVerbosityLevel&#160;</td>
          <td class="paramname"><em>verbLevel</em> = <code>Teuchos::Describable::verbLevel_default</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the object with some verbosity level to an FancyOStream object. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Ifpack2__ILUT__decl_8hpp_source.html">Ifpack2_ILUT_decl.hpp</a></li>
<li><a class="el" href="Ifpack2__ILUT__def_8hpp_source.html">Ifpack2_ILUT_def.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
