<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ifpack2 Templated Preconditioning Package: Ifpack2::Details::Chebyshev&lt; ScalarType, MV &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Ifpack2 Templated Preconditioning Package<span id="projectnumber">&#160;Version 1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceIfpack2.html">Ifpack2</a></li><li class="navelem"><b>Details</b></li><li class="navelem"><a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html">Chebyshev</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classIfpack2_1_1Details_1_1Chebyshev-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ifpack2::Details::Chebyshev&lt; ScalarType, MV &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Left-scaled <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html" title="Left-scaled Chebyshev iteration.">Chebyshev</a> iteration.  
 <a href="classIfpack2_1_1Details_1_1Chebyshev.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Ifpack2__Details__Chebyshev__decl_8hpp_source.html">Ifpack2_Details_Chebyshev_decl.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Ifpack2::Details::Chebyshev&lt; ScalarType, MV &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classIfpack2_1_1Details_1_1Chebyshev__inherit__graph.png" border="0" usemap="#aIfpack2_1_1Details_1_1Chebyshev_3_01ScalarType_00_01MV_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aIfpack2_1_1Details_1_1Chebyshev_3_01ScalarType_00_01MV_01_4_inherit__map" id="aIfpack2_1_1Details_1_1Chebyshev_3_01ScalarType_00_01MV_01_4_inherit__map">
<area shape="rect" title="Left&#45;scaled Chebyshev iteration." alt="" coords="5,5,209,45"/>
<area shape="rect" href="classIfpack2_1_1Details_1_1Chebyshev.html" title=" " alt="" coords="5,108,209,148"/>
<area shape="poly" title=" " alt="" coords="110,59,110,108,105,108,105,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Implementation of Teuchos::Describable</div></td></tr>
<tr class="memitem:a615a0d9d0bd83026606a45dd548fd3a5" id="r_a615a0d9d0bd83026606a45dd548fd3a5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a615a0d9d0bd83026606a45dd548fd3a5">description</a> () <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a></td></tr>
<tr class="memdesc:a615a0d9d0bd83026606a45dd548fd3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single-line description of the <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html" title="Left-scaled Chebyshev iteration.">Chebyshev</a> solver.  <br /></td></tr>
<tr class="separator:a615a0d9d0bd83026606a45dd548fd3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da572a81d485de4f2a7d99b58c43199" id="r_a8da572a81d485de4f2a7d99b58c43199"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a8da572a81d485de4f2a7d99b58c43199">describe</a> (Teuchos::FancyOStream &amp;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">out</a>, <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> Teuchos::EVerbosityLevel <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">verbLevel</a>=Teuchos::Describable::verbLevel_default) <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a></td></tr>
<tr class="memdesc:a8da572a81d485de4f2a7d99b58c43199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a description of the <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html" title="Left-scaled Chebyshev iteration.">Chebyshev</a> solver to <code>out</code>.  <br /></td></tr>
<tr class="separator:a8da572a81d485de4f2a7d99b58c43199"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Typedefs</h2></td></tr>
<tr class="memitem:aa9f8c60062c795afd063f6b5af6cab25" id="r_aa9f8c60062c795afd063f6b5af6cab25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typedef</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#aa9f8c60062c795afd063f6b5af6cab25">ST</a></td></tr>
<tr class="memdesc:aa9f8c60062c795afd063f6b5af6cab25"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of entries in the matrix and vectors.  <br /></td></tr>
<tr class="separator:aa9f8c60062c795afd063f6b5af6cab25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5745032cad34167f1fdfa3470278b1" id="r_a1b5745032cad34167f1fdfa3470278b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typedef</a> Teuchos::ScalarTraits&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a1b5745032cad34167f1fdfa3470278b1">STS</a></td></tr>
<tr class="memdesc:a1b5745032cad34167f1fdfa3470278b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class for ST.  <br /></td></tr>
<tr class="separator:a1b5745032cad34167f1fdfa3470278b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab184f9bcfd8652ed4f4b6d653aa91366" id="r_ab184f9bcfd8652ed4f4b6d653aa91366"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typedef</a> STS::magnitudeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#ab184f9bcfd8652ed4f4b6d653aa91366">MT</a></td></tr>
<tr class="memdesc:ab184f9bcfd8652ed4f4b6d653aa91366"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the absolute value of a ScalarType.  <br /></td></tr>
<tr class="separator:ab184f9bcfd8652ed4f4b6d653aa91366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9452980b6c2b4acf225a702efb2d2887" id="r_a9452980b6c2b4acf225a702efb2d2887"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typedef</a> Tpetra::Operator&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::scalar_type, <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::local_ordinal_type, <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::global_ordinal_type, <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::node_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a9452980b6c2b4acf225a702efb2d2887">op_type</a></td></tr>
<tr class="memdesc:a9452980b6c2b4acf225a702efb2d2887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of Tpetra::Operator.  <br /></td></tr>
<tr class="separator:a9452980b6c2b4acf225a702efb2d2887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd8ef270a333784e0f5cb0e0af91515" id="r_a7fd8ef270a333784e0f5cb0e0af91515"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typedef</a> Tpetra::RowMatrix&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::scalar_type, <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::local_ordinal_type, <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::global_ordinal_type, <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::node_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a7fd8ef270a333784e0f5cb0e0af91515">row_matrix_type</a></td></tr>
<tr class="memdesc:a7fd8ef270a333784e0f5cb0e0af91515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of Tpetra::RowMatrix.  <br /></td></tr>
<tr class="separator:a7fd8ef270a333784e0f5cb0e0af91515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04be92be96469d28d8b8febbc22d3abc" id="r_a04be92be96469d28d8b8febbc22d3abc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typedef</a> Tpetra::Vector&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::scalar_type, <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::local_ordinal_type, <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::global_ordinal_type, <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::node_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a04be92be96469d28d8b8febbc22d3abc">V</a></td></tr>
<tr class="memdesc:a04be92be96469d28d8b8febbc22d3abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of Tpetra::Vector.  <br /></td></tr>
<tr class="separator:a04be92be96469d28d8b8febbc22d3abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd6f985821a2de7b06f5f1ff58e6c0d" id="r_a7dd6f985821a2de7b06f5f1ff58e6c0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typedef</a> Tpetra::Map&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::local_ordinal_type, <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::global_ordinal_type, <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::node_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a7dd6f985821a2de7b06f5f1ff58e6c0d">map_type</a></td></tr>
<tr class="memdesc:a7dd6f985821a2de7b06f5f1ff58e6c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of Tpetra::Map.  <br /></td></tr>
<tr class="separator:a7dd6f985821a2de7b06f5f1ff58e6c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7740b42deb05384eaab1116cc7bfa632" id="r_a7740b42deb05384eaab1116cc7bfa632"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a7740b42deb05384eaab1116cc7bfa632">Chebyshev</a> (Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a7fd8ef270a333784e0f5cb0e0af91515">row_matrix_type</a> &gt; A)</td></tr>
<tr class="separator:a7740b42deb05384eaab1116cc7bfa632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f1893f0f980ec9a73b9c59cfb11712" id="r_a02f1893f0f980ec9a73b9c59cfb11712"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a02f1893f0f980ec9a73b9c59cfb11712">Chebyshev</a> (Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a7fd8ef270a333784e0f5cb0e0af91515">row_matrix_type</a> &gt; A, Teuchos::ParameterList &amp;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">params</a>)</td></tr>
<tr class="separator:a02f1893f0f980ec9a73b9c59cfb11712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532a5900166c10e0ad271fb7d2079f9f" id="r_a532a5900166c10e0ad271fb7d2079f9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a532a5900166c10e0ad271fb7d2079f9f">setParameters</a> (Teuchos::ParameterList &amp;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">plist</a>)</td></tr>
<tr class="memdesc:a532a5900166c10e0ad271fb7d2079f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set (or reset) parameters.  <br /></td></tr>
<tr class="separator:a532a5900166c10e0ad271fb7d2079f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c4870fbdc3f80d2fe3953c93cef0d6" id="r_a21c4870fbdc3f80d2fe3953c93cef0d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a21c4870fbdc3f80d2fe3953c93cef0d6">compute</a> ()</td></tr>
<tr class="memdesc:a21c4870fbdc3f80d2fe3953c93cef0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Re)compute the left scaling D_inv, and estimate min and max eigenvalues of D_inv * A.  <br /></td></tr>
<tr class="separator:a21c4870fbdc3f80d2fe3953c93cef0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6a722097482e66e1d1959a89c4caea" id="r_aba6a722097482e66e1d1959a89c4caea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#ab184f9bcfd8652ed4f4b6d653aa91366">MT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#aba6a722097482e66e1d1959a89c4caea">apply</a> (<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> MV &amp;B, MV &amp;X)</td></tr>
<tr class="memdesc:aba6a722097482e66e1d1959a89c4caea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve Ax=b for x with <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html" title="Left-scaled Chebyshev iteration.">Chebyshev</a> iteration with left diagonal scaling.  <br /></td></tr>
<tr class="separator:aba6a722097482e66e1d1959a89c4caea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7ef097589dbfe2fb1c1ce82148708e" id="r_adc7ef097589dbfe2fb1c1ce82148708e"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a7fd8ef270a333784e0f5cb0e0af91515">row_matrix_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#adc7ef097589dbfe2fb1c1ce82148708e">getMatrix</a> () <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a></td></tr>
<tr class="memdesc:adc7ef097589dbfe2fb1c1ce82148708e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the matrix given to the constructor.  <br /></td></tr>
<tr class="separator:adc7ef097589dbfe2fb1c1ce82148708e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e82e09f5a03e71d1cdf7cf126987b6" id="r_a59e82e09f5a03e71d1cdf7cf126987b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a59e82e09f5a03e71d1cdf7cf126987b6">setMatrix</a> (<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a7fd8ef270a333784e0f5cb0e0af91515">row_matrix_type</a> &gt; &amp;A)</td></tr>
<tr class="memdesc:a59e82e09f5a03e71d1cdf7cf126987b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the matrix.  <br /></td></tr>
<tr class="separator:a59e82e09f5a03e71d1cdf7cf126987b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1645eea01434b8ebfebc97c99efdfa1" id="r_ad1645eea01434b8ebfebc97c99efdfa1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#ad1645eea01434b8ebfebc97c99efdfa1">hasTransposeApply</a> () <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a></td></tr>
<tr class="memdesc:ad1645eea01434b8ebfebc97c99efdfa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether it's possible to apply the transpose of this operator.  <br /></td></tr>
<tr class="separator:ad1645eea01434b8ebfebc97c99efdfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a7e7d2e1a1d6b33f2a1f5d25325f97" id="r_a91a7e7d2e1a1d6b33f2a1f5d25325f97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a91a7e7d2e1a1d6b33f2a1f5d25325f97">print</a> (std::ostream &amp;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">out</a>)</td></tr>
<tr class="memdesc:a91a7e7d2e1a1d6b33f2a1f5d25325f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print instance data to the given output stream.  <br /></td></tr>
<tr class="separator:a91a7e7d2e1a1d6b33f2a1f5d25325f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a>, <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> MV&gt;<br />
class Ifpack2::Details::Chebyshev&lt; ScalarType, MV &gt;</div><p>Left-scaled <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html" title="Left-scaled Chebyshev iteration.">Chebyshev</a> iteration. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScalarType</td><td>The type of entries in the matrix and vectors. </td></tr>
    <tr><td class="paramname">MV</td><td>Specialization of Tpetra::MultiVector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This class is NOT for users; it is an implementation detail of <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a>. Users should use <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Ifpack2::Chebyshev</a> instead.</dd></dl>
<p>This class implements two variants of <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html" title="Left-scaled Chebyshev iteration.">Chebyshev</a> iteration: </p><ol>
<li>
A direct imitation of Ifpack's implementation  </li>
<li>
A textbook version of the algorithm  </li>
<li>
<a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html" title="Left-scaled Chebyshev iteration.">Chebyshev</a> polynomials of the 4th kind, using optimal coefficients  </li>
</ol>
<p>All implemented variants use the diagonal of the matrix to precondition the linear system on the left. Diagonal entries less than machine precision are replaced with machine precision.</p>
<p>The first version imitates Ifpack_Chebyshev, both in how it sets parameters and in the actual iteration (ApplyInverse()). The "textbook" in variant #2 above is "Templates for the Solution of
Linear Systems," 2nd edition. Experiments show that the Ifpack imitation is much less sensitive to the eigenvalue bounds than the textbook version, so users should prefer it. (In fact, it is the default.) Variant #3 is an experimental implementation of <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html" title="Left-scaled Chebyshev iteration.">Chebyshev</a> polynomials of the 4th kind with optimal coefficients, from <a href="https://arxiv.org/pdf/2202.08830.pdf">https://arxiv.org/pdf/2202.08830.pdf</a>.</p>
<p>We require that the matrix A be real valued and symmetric positive definite. If users could provide the ellipse parameters ("d" and "c" in the literature, where d is the real-valued center of the ellipse, and d-c and d+c the two foci), the iteration itself would work fine with nonsymmetric real-valued A, as long as the eigenvalues of A can be bounded in an ellipse that is entirely to the right of the origin.</p>
<p>There is also dead code for imitating ML's <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html" title="Left-scaled Chebyshev iteration.">Chebyshev</a> implementation (ML_Cheby(), in packages/ml/src/Smoother/ml_smoother.c). I couldn't get it to converge in time to be useful for testing, so it is disabled. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa9f8c60062c795afd063f6b5af6cab25" name="aa9f8c60062c795afd063f6b5af6cab25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f8c60062c795afd063f6b5af6cab25">&#9670;&#160;</a></span>ST</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a> , <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> MV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typedef</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a> <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html">Ifpack2::Details::Chebyshev</a>&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a>, MV &gt;::ST</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of entries in the matrix and vectors. </p>

</div>
</div>
<a id="a1b5745032cad34167f1fdfa3470278b1" name="a1b5745032cad34167f1fdfa3470278b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5745032cad34167f1fdfa3470278b1">&#9670;&#160;</a></span>STS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a> , <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> MV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typedef</a> Teuchos::ScalarTraits&lt;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a>&gt; <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html">Ifpack2::Details::Chebyshev</a>&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a>, MV &gt;::STS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traits class for ST. </p>

</div>
</div>
<a id="ab184f9bcfd8652ed4f4b6d653aa91366" name="ab184f9bcfd8652ed4f4b6d653aa91366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab184f9bcfd8652ed4f4b6d653aa91366">&#9670;&#160;</a></span>MT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a> , <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> MV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typedef</a> STS::magnitudeType <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html">Ifpack2::Details::Chebyshev</a>&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a>, MV &gt;::MT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the absolute value of a ScalarType. </p>

</div>
</div>
<a id="a9452980b6c2b4acf225a702efb2d2887" name="a9452980b6c2b4acf225a702efb2d2887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9452980b6c2b4acf225a702efb2d2887">&#9670;&#160;</a></span>op_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a> , <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> MV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typedef</a> Tpetra::Operator&lt;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::scalar_type, <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::local_ordinal_type, <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::global_ordinal_type, <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::node_type&gt; <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html">Ifpack2::Details::Chebyshev</a>&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a>, MV &gt;::op_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialization of Tpetra::Operator. </p>

</div>
</div>
<a id="a7fd8ef270a333784e0f5cb0e0af91515" name="a7fd8ef270a333784e0f5cb0e0af91515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd8ef270a333784e0f5cb0e0af91515">&#9670;&#160;</a></span>row_matrix_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a> , <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> MV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typedef</a> Tpetra::RowMatrix&lt;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::scalar_type, <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::local_ordinal_type, <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::global_ordinal_type, <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::node_type&gt; <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html">Ifpack2::Details::Chebyshev</a>&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a>, MV &gt;::row_matrix_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialization of Tpetra::RowMatrix. </p>

</div>
</div>
<a id="a04be92be96469d28d8b8febbc22d3abc" name="a04be92be96469d28d8b8febbc22d3abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04be92be96469d28d8b8febbc22d3abc">&#9670;&#160;</a></span>V</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a> , <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> MV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typedef</a> Tpetra::Vector&lt;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::scalar_type, <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::local_ordinal_type, <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::global_ordinal_type, <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::node_type&gt; <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html">Ifpack2::Details::Chebyshev</a>&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a>, MV &gt;::V</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialization of Tpetra::Vector. </p>

</div>
</div>
<a id="a7dd6f985821a2de7b06f5f1ff58e6c0d" name="a7dd6f985821a2de7b06f5f1ff58e6c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd6f985821a2de7b06f5f1ff58e6c0d">&#9670;&#160;</a></span>map_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a> , <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> MV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typedef</a> Tpetra::Map&lt;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::local_ordinal_type, <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::global_ordinal_type, <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> MV::node_type&gt; <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html">Ifpack2::Details::Chebyshev</a>&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a>, MV &gt;::map_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialization of Tpetra::Map. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7740b42deb05384eaab1116cc7bfa632" name="a7740b42deb05384eaab1116cc7bfa632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7740b42deb05384eaab1116cc7bfa632">&#9670;&#160;</a></span>Chebyshev() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a> , <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> MV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html">Ifpack2::Details::Chebyshev</a>&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a>, MV &gt;::Chebyshev </td>
          <td>(</td>
          <td class="paramtype">Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a7fd8ef270a333784e0f5cb0e0af91515">row_matrix_type</a> &gt;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor that takes a sparse matrix and sets default parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>[in] The matrix A in the linear system to solve. If A is nonnull, it must be real-valued and symmetric positive definite. The input A may be null. In that case, you must call <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a59e82e09f5a03e71d1cdf7cf126987b6" title="Set the matrix.">setMatrix()</a> with a nonnull input before you may call <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a21c4870fbdc3f80d2fe3953c93cef0d6" title="(Re)compute the left scaling D_inv, and estimate min and max eigenvalues of D_inv * A.">compute()</a> or <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#aba6a722097482e66e1d1959a89c4caea" title="Solve Ax=b for x with Chebyshev iteration with left diagonal scaling.">apply()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02f1893f0f980ec9a73b9c59cfb11712" name="a02f1893f0f980ec9a73b9c59cfb11712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f1893f0f980ec9a73b9c59cfb11712">&#9670;&#160;</a></span>Chebyshev() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a> , <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> MV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html">Ifpack2::Details::Chebyshev</a>&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a>, MV &gt;::Chebyshev </td>
          <td>(</td>
          <td class="paramtype">Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a7fd8ef270a333784e0f5cb0e0af91515">row_matrix_type</a> &gt;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor that takes a sparse matrix and sets the user's parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>[in] The matrix A in the linear system to solve. If A is nonnull, it must be real-valued and symmetric positive definite. The input A may be null. In that case, you must call <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a59e82e09f5a03e71d1cdf7cf126987b6" title="Set the matrix.">setMatrix()</a> with a nonnull input before you may call <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a21c4870fbdc3f80d2fe3953c93cef0d6" title="(Re)compute the left scaling D_inv, and estimate min and max eigenvalues of D_inv * A.">compute()</a> or <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#aba6a722097482e66e1d1959a89c4caea" title="Solve Ax=b for x with Chebyshev iteration with left diagonal scaling.">apply()</a>. </td></tr>
    <tr><td class="paramname">params</td><td>[in/out] On input: the parameters. On output: filled with the current parameter settings. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a532a5900166c10e0ad271fb7d2079f9f" name="a532a5900166c10e0ad271fb7d2079f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532a5900166c10e0ad271fb7d2079f9f">&#9670;&#160;</a></span>setParameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a> , <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> MV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">void</a> <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html">Ifpack2::Details::Chebyshev</a>&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a>, MV &gt;::setParameters </td>
          <td>(</td>
          <td class="paramtype">Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>plist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set (or reset) parameters. </p>
<p>This method fills in the input ParameterList with missing parameters set to their default values. You may call this method as many times as you want. On each call, the input ParameterList is treated as a complete list of the desired parameters, not as a "delta" or change list from the current set of parameters. (That is, if you remove parameters from the list that were there in the last call to <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a532a5900166c10e0ad271fb7d2079f9f" title="Set (or reset) parameters.">setParameters()</a> and call <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a532a5900166c10e0ad271fb7d2079f9f" title="Set (or reset) parameters.">setParameters()</a> again with the revised list, this method will use default values for the removed parameters, rather than letting the current settings remain.) However, since the method fills in missing parameters, you may keep calling it with the ParameterList used in the previous call in order to get the same behavior as before.</p>
<h1><a class="anchor" id="Ifpack2_Details_Chebyshev_setParameters_List"></a>
List of parameters</h1>
<p>Parameters that govern spectral bounds of the matrix:</p><ul>
<li>"chebyshev: max eigenvalue" (<code>ScalarType</code>): lambdaMax, an upper bound of the bounding ellipse of the eigenvalues of the matrix A. If you do not set this parameter, we will compute an approximation. See "Parameters that govern eigenvalue
  analysis" to control this approximation process.</li>
<li>"chebyshev: ratio eigenvalue" (<code>ScalarType</code>): eigRatio, the ratio of lambdaMax to the lower bound of the bounding ellipse of the eigenvalues of A. We use lambdaMax and eigRatio to determine the <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html" title="Left-scaled Chebyshev iteration.">Chebyshev</a> iteration coefficients. This parameter is optional and defaults to 30.</li>
<li>"chebyshev: min eigenvalue" (<code>ScalarType</code>): lambdaMin, a lower bound of real part of bounding ellipse of eigenvalues of the matrix A. This parameter is optional and only used for a quick check if the matrix is the identity matrix (if lambdaMax == lambdaMin == 1).</li>
</ul>
<p>Parameters that govern the number of <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html" title="Left-scaled Chebyshev iteration.">Chebyshev</a> iterations:</p><ul>
<li>"chebyshev: degree" (<code>int</code>): numIters, the number of iterations. This overrides "relaxation: sweeps" and "smoother: sweeps" (see below).</li>
<li>"relaxation: sweeps" (<code>int</code>): numIters, the number of iterations. We include this for compatibility with Ifpack. This overrides "smoother: sweeps" (see below).</li>
<li>"smoother: sweeps" (<code>int</code>): numIters, as above. We include this for compatibility with ML.</li>
</ul>
<p>Parameters that govern eigenvalue analysis:</p><ul>
<li>"chebyshev: eigenvalue max iterations" (<code>int</code>): eigMaxIters, the number of power method iterations used to compute the maximum eigenvalue. This overrides "eigen-analysis:
  iterations" (see below).</li>
<li>"eigen-analysis: iterations" (<code>int</code>): eigMaxIters, as above. We include this parameter for compatibility with ML.</li>
<li>"eigen-analysis: type" (<code>std::string</code>): The algorithm to use for estimating the max eigenvalue. This parameter is optional. Currently, we only support "power-method" (or "power method"), which is what Ifpack::Chebyshev uses for eigenanalysis. We include this parameter for compatibility with ML.</li>
</ul>
<p>Parameters that govern other algorithmic details:</p><ul>
<li>"chebyshev: assume matrix does not change": Whether <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a21c4870fbdc3f80d2fe3953c93cef0d6" title="(Re)compute the left scaling D_inv, and estimate min and max eigenvalues of D_inv * A.">compute()</a> should always assume that the matrix has not changed since the last call to <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a21c4870fbdc3f80d2fe3953c93cef0d6" title="(Re)compute the left scaling D_inv, and estimate min and max eigenvalues of D_inv * A.">compute()</a>. The default is false. If true, <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a21c4870fbdc3f80d2fe3953c93cef0d6" title="(Re)compute the left scaling D_inv, and estimate min and max eigenvalues of D_inv * A.">compute()</a> will not recompute the inverse diagonal or the estimates of the max and min eigenvalues. <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a21c4870fbdc3f80d2fe3953c93cef0d6" title="(Re)compute the left scaling D_inv, and estimate min and max eigenvalues of D_inv * A.">compute()</a> will always compute any quantity which the user did not provide and which we have not yet computed before.</li>
<li>"chebyshev: operator inv diagonal" (<code>RCP&lt;const V&gt;</code> or <code>const V*</code>): If nonnull, we will use a deep copy of this vector for left scaling as the inverse diagonal of the matrix A, instead of computing the inverse diagonal ourselves. We will make a copy every time you call <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a532a5900166c10e0ad271fb7d2079f9f" title="Set (or reset) parameters.">setParameters()</a>. If you ever call <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a532a5900166c10e0ad271fb7d2079f9f" title="Set (or reset) parameters.">setParameters()</a> without this parameter, we will clear our copy and compute the inverse diagonal ourselves again. If you choose to provide this parameter, you are responsible for updating this if the matrix has changed.</li>
<li>"chebyshev: min diagonal value" (<code>ST</code>): minDiagVal. If any entry of the diagonal of the matrix is less than this in magnitude, it will be replaced with this value in the inverse diagonal used for left scaling.</li>
<li>"chebyshev: zero starting solution" (<code>bool</code>): If true, then always use the zero vector(s) as the initial guess(es). If false, then <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#aba6a722097482e66e1d1959a89c4caea" title="Solve Ax=b for x with Chebyshev iteration with left diagonal scaling.">apply()</a> will use X on input as the initial guess(es).</li>
<li>"chebyshev: compute spectral radius" (<code>bool</code>): If true, the power method will compute the spectral radius of the operator. If false, it will compute the dominant eigenvalue.</li>
</ul>
<p>Parameters that govern backwards compatibility:</p><ul>
<li>"chebyshev: textbook algorithm" (<code>bool</code>): If true, use the textbook version of <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html" title="Left-scaled Chebyshev iteration.">Chebyshev</a> iteration. We recommend against this, since the default algorithm is less sensitive to the quality of the eigenvalue bounds.</li>
<li>"chebyshev: compute max residual norm" (<code>bool</code>): If true, <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#aba6a722097482e66e1d1959a89c4caea" title="Solve Ax=b for x with Chebyshev iteration with left diagonal scaling.">apply()</a> will compute and return the max (absolute) residual norm. Otherwise, <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#aba6a722097482e66e1d1959a89c4caea" title="Solve Ax=b for x with Chebyshev iteration with left diagonal scaling.">apply()</a> returns 0. This defaults to false.</li>
</ul>
<p>The above compatibility parameters are not exposed in the documentation of <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Ifpack2::Chebyshev</a>, because they are more useful to <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> developers than to users.</p>
<dl class="section pre"><dt>Precondition</dt><dd>lambdaMin, lambdaMax, and eigRatio are real </dd>
<dd>
0 &lt; lambdaMin &lt;= lambdaMax </dd>
<dd>
numIters &gt;= 0 </dd>
<dd>
eigMaxIters &gt;= 0</dd></dl>
<p>Default settings for parameters relating to spectral bounds come from Ifpack. </p>

</div>
</div>
<a id="a21c4870fbdc3f80d2fe3953c93cef0d6" name="a21c4870fbdc3f80d2fe3953c93cef0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c4870fbdc3f80d2fe3953c93cef0d6">&#9670;&#160;</a></span>compute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a> , <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> MV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">void</a> <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html">Ifpack2::Details::Chebyshev</a>&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a>, MV &gt;::compute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Re)compute the left scaling D_inv, and estimate min and max eigenvalues of D_inv * A. </p>
<p>You must call this method before calling <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#aba6a722097482e66e1d1959a89c4caea" title="Solve Ax=b for x with Chebyshev iteration with left diagonal scaling.">apply()</a>,</p><ul>
<li>if you have not yet called this method,</li>
<li>if the matrix (either its values or its structure) has changed, or</li>
<li>any time after you call <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a532a5900166c10e0ad271fb7d2079f9f" title="Set (or reset) parameters.">setParameters()</a>.</li>
</ul>
<p>The input matrix must be nonnull before you may call this method. If the input matrix is null, you must first call <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a59e82e09f5a03e71d1cdf7cf126987b6" title="Set the matrix.">setMatrix()</a> with a nonnull input matrix before you may call this method.</p>
<p>Users have the option to supply the left scaling vector <code>D_inv</code> and estimates of the min and max eigenvalues of <code>D_inv * A</code> as parameters to <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a532a5900166c10e0ad271fb7d2079f9f" title="Set (or reset) parameters.">setParameters()</a>. If users did <em>not</em> supply a left scaling, then this method will compute it by default (if assumeMatrixUnchanged is false). Likewise, if users did <em>not</em> supply at least an estimate of the max eigenvalue, this method will estimate it by default. If estimation of the eigenvalues is required, this method may take as long as several <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html" title="Left-scaled Chebyshev iteration.">Chebyshev</a> iterations.</p>
<p>Advanced users may avoid recomputing the left scaling vector and eigenvalue estimates by setting the "chebyshev: assume matrix
does not change" parameter of <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a532a5900166c10e0ad271fb7d2079f9f" title="Set (or reset) parameters.">setParameters()</a> to <code>true</code>. The left scaling vector and eigenvalue estimates will always be computed if the user did not provide them and we have not yet computed them. Any changes to parameters that affect computation of the inverse diagonal or estimation of the eigenvalue bounds will not affect subsequent <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#aba6a722097482e66e1d1959a89c4caea" title="Solve Ax=b for x with Chebyshev iteration with left diagonal scaling.">apply()</a> operations, until the "chebyshev: assume matrix does not change" parameter is set back to <code>false</code> (its default value). </p>

</div>
</div>
<a id="aba6a722097482e66e1d1959a89c4caea" name="aba6a722097482e66e1d1959a89c4caea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6a722097482e66e1d1959a89c4caea">&#9670;&#160;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a> , <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> MV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html">Chebyshev</a>&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a>, MV &gt;<a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#ab184f9bcfd8652ed4f4b6d653aa91366">::MT</a> <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html">Ifpack2::Details::Chebyshev</a>&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a>, MV &gt;::apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> MV &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MV &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve Ax=b for x with <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html" title="Left-scaled Chebyshev iteration.">Chebyshev</a> iteration with left diagonal scaling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td>[in] Right-hand side(s) in the linear system to solve. </td></tr>
    <tr><td class="paramname">X</td><td>[in] Initial guess(es) for the linear system to solve.</td></tr>
  </table>
  </dd>
</dl>
<p>If the "chebyshev: compute max residual norm" parameter is true (not the default), then this method returns the maximum (over all columns) absolute residual 2-norm after iterating. Otherwise, it returns zero.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you did not set the "chebyshev: zero starting
  solution" parameter to true, then this method will use X as the starting guess for <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html" title="Left-scaled Chebyshev iteration.">Chebyshev</a> iteration. If you did not initialize X before calling this method, then the resulting solution will be undefined, since it will be computed using uninitialized data. </dd></dl>

</div>
</div>
<a id="adc7ef097589dbfe2fb1c1ce82148708e" name="adc7ef097589dbfe2fb1c1ce82148708e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7ef097589dbfe2fb1c1ce82148708e">&#9670;&#160;</a></span>getMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a> , <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> MV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">typename</a> <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html">Chebyshev</a>&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a>, MV &gt;<a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a7fd8ef270a333784e0f5cb0e0af91515">::row_matrix_type</a> &gt; <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html">Ifpack2::Details::Chebyshev</a>&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a>, MV &gt;::getMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the matrix given to the constructor. </p>

</div>
</div>
<a id="a59e82e09f5a03e71d1cdf7cf126987b6" name="a59e82e09f5a03e71d1cdf7cf126987b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e82e09f5a03e71d1cdf7cf126987b6">&#9670;&#160;</a></span>setMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a> , <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> MV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">void</a> <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html">Ifpack2::Details::Chebyshev</a>&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a>, MV &gt;::setMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a7fd8ef270a333784e0f5cb0e0af91515">row_matrix_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the matrix. </p>
<p>It's legal to call this method with a null input. In that case, one must then call this method with a nonnull input before one may call <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#a21c4870fbdc3f80d2fe3953c93cef0d6" title="(Re)compute the left scaling D_inv, and estimate min and max eigenvalues of D_inv * A.">compute()</a> or <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html#aba6a722097482e66e1d1959a89c4caea" title="Solve Ax=b for x with Chebyshev iteration with left diagonal scaling.">apply()</a>. </p>

</div>
</div>
<a id="ad1645eea01434b8ebfebc97c99efdfa1" name="ad1645eea01434b8ebfebc97c99efdfa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1645eea01434b8ebfebc97c99efdfa1">&#9670;&#160;</a></span>hasTransposeApply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a> , <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> MV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">bool</a> <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html">Ifpack2::Details::Chebyshev</a>&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a>, MV &gt;::hasTransposeApply </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether it's possible to apply the transpose of this operator. </p>

</div>
</div>
<a id="a91a7e7d2e1a1d6b33f2a1f5d25325f97" name="a91a7e7d2e1a1d6b33f2a1f5d25325f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a7e7d2e1a1d6b33f2a1f5d25325f97">&#9670;&#160;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a> , <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> MV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">void</a> <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html">Ifpack2::Details::Chebyshev</a>&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a>, MV &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print instance data to the given output stream. </p>

</div>
</div>
<a id="a615a0d9d0bd83026606a45dd548fd3a5" name="a615a0d9d0bd83026606a45dd548fd3a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615a0d9d0bd83026606a45dd548fd3a5">&#9670;&#160;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a> , <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> MV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html">Ifpack2::Details::Chebyshev</a>&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a>, MV &gt;::description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A single-line description of the <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html" title="Left-scaled Chebyshev iteration.">Chebyshev</a> solver. </p>

</div>
</div>
<a id="a8da572a81d485de4f2a7d99b58c43199" name="a8da572a81d485de4f2a7d99b58c43199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da572a81d485de4f2a7d99b58c43199">&#9670;&#160;</a></span>describe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a> , <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">class</a> MV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">void</a> <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html">Ifpack2::Details::Chebyshev</a>&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">ScalarType</a>, MV &gt;::describe </td>
          <td>(</td>
          <td class="paramtype">Teuchos::FancyOStream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> Teuchos::EVerbosityLevel&#160;</td>
          <td class="paramname"><em>verbLevel</em> = <code>Teuchos::Describable::verbLevel_default</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a description of the <a class="el" href="classIfpack2_1_1Details_1_1Chebyshev.html" title="Left-scaled Chebyshev iteration.">Chebyshev</a> solver to <code>out</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Ifpack2__Details__Chebyshev__decl_8hpp_source.html">Ifpack2_Details_Chebyshev_decl.hpp</a></li>
<li><a class="el" href="Ifpack2__Details__Chebyshev__def_8hpp_source.html">Ifpack2_Details_Chebyshev_def.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
