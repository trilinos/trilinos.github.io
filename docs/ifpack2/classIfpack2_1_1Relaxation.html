<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ifpack2 Templated Preconditioning Package: Ifpack2::Relaxation&lt; MatrixType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Ifpack2 Templated Preconditioning Package<span id="projectnumber">&#160;Version 1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceIfpack2.html">Ifpack2</a></li><li class="navelem"><a class="el" href="classIfpack2_1_1Relaxation.html">Relaxation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classIfpack2_1_1Relaxation-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ifpack2::Relaxation&lt; MatrixType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classIfpack2_1_1Relaxation.html" title="Relaxation preconditioners for Tpetra::RowMatrix and Tpetra::CrsMatrix sparse matrices.">Relaxation</a> preconditioners for Tpetra::RowMatrix and Tpetra::CrsMatrix sparse matrices.  
 <a href="classIfpack2_1_1Relaxation.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Ifpack2__Relaxation__decl_8hpp_source.html">Ifpack2_Relaxation_decl.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Ifpack2::Relaxation&lt; MatrixType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classIfpack2_1_1Relaxation__inherit__graph.png" border="0" usemap="#aIfpack2_1_1Relaxation_3_01MatrixType_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aIfpack2_1_1Relaxation_3_01MatrixType_01_4_inherit__map" id="aIfpack2_1_1Relaxation_3_01MatrixType_01_4_inherit__map">
<area shape="rect" title="Relaxation preconditioners for Tpetra::RowMatrix and Tpetra::CrsMatrix sparse matrices." alt="" coords="771,117,919,157"/>
<area shape="rect" href="classIfpack2_1_1Preconditioner.html" title=" " alt="" coords="480,37,719,121"/>
<area shape="poly" title=" " alt="" coords="733,108,771,117,770,122,731,113"/>
<area shape="rect" href="classIfpack2_1_1Preconditioner.html" title="Interface for all Ifpack2 preconditioners." alt="" coords="23,50,195,105"/>
<area shape="poly" title=" " alt="" coords="209,75,480,76,480,81,209,80"/>
<area shape="rect" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html" title=" " alt="" coords="477,145,721,244"/>
<area shape="poly" title=" " alt="" coords="734,160,770,152,771,157,735,166"/>
<area shape="rect" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html" title="Mix&#45;in interface for preconditioners that can change their matrix after construction." alt="" coords="5,176,212,216"/>
<area shape="poly" title=" " alt="" coords="226,193,477,192,477,198,226,198"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Typedefs</div></td></tr>
<tr class="memitem:a9d33134c7bedaf080d2c52c0847371a5" id="r_a9d33134c7bedaf080d2c52c0847371a5"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::scalar_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#a9d33134c7bedaf080d2c52c0847371a5">scalar_type</a></td></tr>
<tr class="memdesc:a9d33134c7bedaf080d2c52c0847371a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the entries of the input MatrixType.  <br /></td></tr>
<tr class="separator:a9d33134c7bedaf080d2c52c0847371a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f68eeba3c642fd6b1e7856283759135" id="r_a9f68eeba3c642fd6b1e7856283759135"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::local_ordinal_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#a9f68eeba3c642fd6b1e7856283759135">local_ordinal_type</a></td></tr>
<tr class="memdesc:a9f68eeba3c642fd6b1e7856283759135"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of local indices in the input MatrixType.  <br /></td></tr>
<tr class="separator:a9f68eeba3c642fd6b1e7856283759135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0839c732268cbc480405aa18e4539688" id="r_a0839c732268cbc480405aa18e4539688"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::global_ordinal_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#a0839c732268cbc480405aa18e4539688">global_ordinal_type</a></td></tr>
<tr class="memdesc:a0839c732268cbc480405aa18e4539688"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of global indices in the input MatrixType.  <br /></td></tr>
<tr class="separator:a0839c732268cbc480405aa18e4539688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcabf9138ad35665f3392f2baa3388b" id="r_a0bcabf9138ad35665f3392f2baa3388b"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#a0bcabf9138ad35665f3392f2baa3388b">node_type</a></td></tr>
<tr class="memdesc:a0bcabf9138ad35665f3392f2baa3388b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Node type used by the input MatrixType.  <br /></td></tr>
<tr class="separator:a0bcabf9138ad35665f3392f2baa3388b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8951c7800fe09b0c3a6e6944f99aa47" id="r_ab8951c7800fe09b0c3a6e6944f99aa47"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::node_type::device_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#ab8951c7800fe09b0c3a6e6944f99aa47">device_type</a></td></tr>
<tr class="memdesc:ab8951c7800fe09b0c3a6e6944f99aa47"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Kokkos device type used by the input MatrixType.  <br /></td></tr>
<tr class="separator:ab8951c7800fe09b0c3a6e6944f99aa47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac874be0aca789e5a0b2209d11651e764" id="r_ac874be0aca789e5a0b2209d11651e764"><td class="memItemLeft" align="right" valign="top">typedef Teuchos::ScalarTraits&lt; <a class="el" href="classIfpack2_1_1Relaxation.html#a9d33134c7bedaf080d2c52c0847371a5">scalar_type</a> &gt;::magnitudeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#ac874be0aca789e5a0b2209d11651e764">magnitude_type</a></td></tr>
<tr class="memdesc:ac874be0aca789e5a0b2209d11651e764"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the magnitude (absolute value) of a matrix entry.  <br /></td></tr>
<tr class="separator:ac874be0aca789e5a0b2209d11651e764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57fbd1389ed7657a0d58fa886a9d29a" id="r_aa57fbd1389ed7657a0d58fa886a9d29a"><td class="memItemLeft" align="right" valign="top">typedef Tpetra::RowMatrix&lt; <a class="el" href="classIfpack2_1_1Relaxation.html#a9d33134c7bedaf080d2c52c0847371a5">scalar_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a9f68eeba3c642fd6b1e7856283759135">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0839c732268cbc480405aa18e4539688">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0bcabf9138ad35665f3392f2baa3388b">node_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#aa57fbd1389ed7657a0d58fa886a9d29a">row_matrix_type</a></td></tr>
<tr class="memdesc:aa57fbd1389ed7657a0d58fa886a9d29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tpetra::RowMatrix specialization used by this class.  <br /></td></tr>
<tr class="separator:aa57fbd1389ed7657a0d58fa886a9d29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ae0ed89e41c9e6e120e836d8008157" id="r_a77ae0ed89e41c9e6e120e836d8008157"><td class="memItemLeft" align="right" valign="top">typedef Tpetra::Operator&lt; <a class="el" href="classIfpack2_1_1Relaxation.html#a9d33134c7bedaf080d2c52c0847371a5">scalar_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a9f68eeba3c642fd6b1e7856283759135">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0839c732268cbc480405aa18e4539688">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0bcabf9138ad35665f3392f2baa3388b">node_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#a77ae0ed89e41c9e6e120e836d8008157">op_type</a></td></tr>
<tr class="memdesc:a77ae0ed89e41c9e6e120e836d8008157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tpetra::Operator specialization used by this class.  <br /></td></tr>
<tr class="separator:a77ae0ed89e41c9e6e120e836d8008157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classIfpack2_1_1Preconditioner"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classIfpack2_1_1Preconditioner')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classIfpack2_1_1Preconditioner.html">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a></td></tr>
<tr class="memitem:a222c0e260ac8dc1226573e8a0773ac63 inherit pub_types_classIfpack2_1_1Preconditioner" id="r_a222c0e260ac8dc1226573e8a0773ac63"><td class="memItemLeft" align="right" valign="top">typedef Teuchos::ScalarTraits&lt; MatrixType::scalar_type &gt;::magnitudeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Preconditioner.html#a222c0e260ac8dc1226573e8a0773ac63">magnitude_type</a></td></tr>
<tr class="memdesc:a222c0e260ac8dc1226573e8a0773ac63 inherit pub_types_classIfpack2_1_1Preconditioner"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the magnitude (absolute value) of a matrix entry.  <br /></td></tr>
<tr class="separator:a222c0e260ac8dc1226573e8a0773ac63 inherit pub_types_classIfpack2_1_1Preconditioner"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and destructors</div></td></tr>
<tr class="memitem:a0487dfeaf38e27509f775525d9052d84" id="r_a0487dfeaf38e27509f775525d9052d84"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#a0487dfeaf38e27509f775525d9052d84">Relaxation</a> (const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1Relaxation.html#aa57fbd1389ed7657a0d58fa886a9d29a">row_matrix_type</a> &gt; &amp;A)</td></tr>
<tr class="memdesc:a0487dfeaf38e27509f775525d9052d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a0487dfeaf38e27509f775525d9052d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132e828c3a0166d3b5877c3a06fe59a6" id="r_a132e828c3a0166d3b5877c3a06fe59a6"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#a132e828c3a0166d3b5877c3a06fe59a6">~Relaxation</a> ()=default</td></tr>
<tr class="memdesc:a132e828c3a0166d3b5877c3a06fe59a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a132e828c3a0166d3b5877c3a06fe59a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Preconditioner computation methods</div></td></tr>
<tr class="memitem:a08f8bb5eda400d0912efa33c552b5ce4" id="r_a08f8bb5eda400d0912efa33c552b5ce4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#a08f8bb5eda400d0912efa33c552b5ce4">setParameters</a> (const Teuchos::ParameterList &amp;params)</td></tr>
<tr class="memdesc:a08f8bb5eda400d0912efa33c552b5ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the relaxation / preconditioner parameters.  <br /></td></tr>
<tr class="separator:a08f8bb5eda400d0912efa33c552b5ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9691b22610782fc4cf4ba808295f36" id="r_a4f9691b22610782fc4cf4ba808295f36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#a4f9691b22610782fc4cf4ba808295f36">setZeroStartingSolution</a> (bool zeroStartingSolution)</td></tr>
<tr class="memdesc:a4f9691b22610782fc4cf4ba808295f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this preconditioner's parameters.  <br /></td></tr>
<tr class="separator:a4f9691b22610782fc4cf4ba808295f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b31bf6acebf637898db9c9d62de3360" id="r_a7b31bf6acebf637898db9c9d62de3360"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const Teuchos::ParameterList &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#a7b31bf6acebf637898db9c9d62de3360">getValidParameters</a> () const</td></tr>
<tr class="memdesc:a7b31bf6acebf637898db9c9d62de3360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of all the parameters that this class accepts.  <br /></td></tr>
<tr class="separator:a7b31bf6acebf637898db9c9d62de3360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fd53a77642276aecfaa51f12f3191b" id="r_a53fd53a77642276aecfaa51f12f3191b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#a53fd53a77642276aecfaa51f12f3191b">initialize</a> ()</td></tr>
<tr class="memdesc:a53fd53a77642276aecfaa51f12f3191b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the preconditioner ("symbolic setup").  <br /></td></tr>
<tr class="separator:a53fd53a77642276aecfaa51f12f3191b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6647f2e7e0f0c24a2e61e40163a1fe7" id="r_ae6647f2e7e0f0c24a2e61e40163a1fe7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#ae6647f2e7e0f0c24a2e61e40163a1fe7">isInitialized</a> () const</td></tr>
<tr class="memdesc:ae6647f2e7e0f0c24a2e61e40163a1fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the preconditioner has been successfully initialized.  <br /></td></tr>
<tr class="separator:ae6647f2e7e0f0c24a2e61e40163a1fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512bc4a35a2933356c27833b5498303c" id="r_a512bc4a35a2933356c27833b5498303c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#a512bc4a35a2933356c27833b5498303c">compute</a> ()</td></tr>
<tr class="memdesc:a512bc4a35a2933356c27833b5498303c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the preconditioner ("numeric setup");.  <br /></td></tr>
<tr class="separator:a512bc4a35a2933356c27833b5498303c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa215c0d1228236c2b58d61035f2f2718" id="r_aa215c0d1228236c2b58d61035f2f2718"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#aa215c0d1228236c2b58d61035f2f2718">isComputed</a> () const</td></tr>
<tr class="memdesc:aa215c0d1228236c2b58d61035f2f2718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <a class="el" href="classIfpack2_1_1Relaxation.html#a512bc4a35a2933356c27833b5498303c" title="Compute the preconditioner (&quot;numeric setup&quot;);.">compute()</a> has been called.  <br /></td></tr>
<tr class="separator:aa215c0d1228236c2b58d61035f2f2718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implementation of Ifpack2::Details::CanChangeMatrix</div></td></tr>
<tr class="memitem:a9a5cf060d78467a89b4fd2cb911869d7" id="r_a9a5cf060d78467a89b4fd2cb911869d7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#a9a5cf060d78467a89b4fd2cb911869d7">setMatrix</a> (const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1Relaxation.html#aa57fbd1389ed7657a0d58fa886a9d29a">row_matrix_type</a> &gt; &amp;A)</td></tr>
<tr class="memdesc:a9a5cf060d78467a89b4fd2cb911869d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the matrix to be preconditioned.  <br /></td></tr>
<tr class="separator:a9a5cf060d78467a89b4fd2cb911869d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implementation of the Tpetra::Operator interface</div></td></tr>
<tr class="memitem:a9ee4f4089ee971e71f1bc3a7d038be29" id="r_a9ee4f4089ee971e71f1bc3a7d038be29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#a9ee4f4089ee971e71f1bc3a7d038be29">apply</a> (const Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1Relaxation.html#a9d33134c7bedaf080d2c52c0847371a5">scalar_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a9f68eeba3c642fd6b1e7856283759135">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0839c732268cbc480405aa18e4539688">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0bcabf9138ad35665f3392f2baa3388b">node_type</a> &gt; &amp;X, Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1Relaxation.html#a9d33134c7bedaf080d2c52c0847371a5">scalar_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a9f68eeba3c642fd6b1e7856283759135">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0839c732268cbc480405aa18e4539688">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0bcabf9138ad35665f3392f2baa3388b">node_type</a> &gt; &amp;Y, Teuchos::ETransp mode=Teuchos::NO_TRANS, <a class="el" href="classIfpack2_1_1Relaxation.html#a9d33134c7bedaf080d2c52c0847371a5">scalar_type</a> alpha=Teuchos::ScalarTraits&lt; <a class="el" href="classIfpack2_1_1Relaxation.html#a9d33134c7bedaf080d2c52c0847371a5">scalar_type</a> &gt;::one(), <a class="el" href="classIfpack2_1_1Relaxation.html#a9d33134c7bedaf080d2c52c0847371a5">scalar_type</a> beta=Teuchos::ScalarTraits&lt; <a class="el" href="classIfpack2_1_1Relaxation.html#a9d33134c7bedaf080d2c52c0847371a5">scalar_type</a> &gt;::zero()) const</td></tr>
<tr class="memdesc:a9ee4f4089ee971e71f1bc3a7d038be29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the preconditioner to X, returning the result in Y.  <br /></td></tr>
<tr class="separator:a9ee4f4089ee971e71f1bc3a7d038be29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168ebb18d4dd62712edca7b60ed36006" id="r_a168ebb18d4dd62712edca7b60ed36006"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const Tpetra::Map&lt; <a class="el" href="classIfpack2_1_1Relaxation.html#a9f68eeba3c642fd6b1e7856283759135">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0839c732268cbc480405aa18e4539688">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0bcabf9138ad35665f3392f2baa3388b">node_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#a168ebb18d4dd62712edca7b60ed36006">getDomainMap</a> () const</td></tr>
<tr class="memdesc:a168ebb18d4dd62712edca7b60ed36006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Tpetra::Map object associated with the domain of this operator.  <br /></td></tr>
<tr class="separator:a168ebb18d4dd62712edca7b60ed36006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb8d4c2872ed2fa886fa8b872e4c30b" id="r_aecb8d4c2872ed2fa886fa8b872e4c30b"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const Tpetra::Map&lt; <a class="el" href="classIfpack2_1_1Relaxation.html#a9f68eeba3c642fd6b1e7856283759135">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0839c732268cbc480405aa18e4539688">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0bcabf9138ad35665f3392f2baa3388b">node_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#aecb8d4c2872ed2fa886fa8b872e4c30b">getRangeMap</a> () const</td></tr>
<tr class="memdesc:aecb8d4c2872ed2fa886fa8b872e4c30b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Tpetra::Map object associated with the range of this operator.  <br /></td></tr>
<tr class="separator:aecb8d4c2872ed2fa886fa8b872e4c30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2483dd71ec501eb03c0ff86daa4bcc6" id="r_ae2483dd71ec501eb03c0ff86daa4bcc6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#ae2483dd71ec501eb03c0ff86daa4bcc6">hasTransposeApply</a> () const</td></tr>
<tr class="memdesc:ae2483dd71ec501eb03c0ff86daa4bcc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether <a class="el" href="classIfpack2_1_1Relaxation.html#a9ee4f4089ee971e71f1bc3a7d038be29" title="Apply the preconditioner to X, returning the result in Y.">apply()</a> and <a class="el" href="classIfpack2_1_1Relaxation.html#aa566dba65372cc99288722dc5e07ede6" title="Apply the input matrix to X, returning the result in Y.">applyMat()</a> let you apply the transpose or conjugate transpose.  <br /></td></tr>
<tr class="separator:ae2483dd71ec501eb03c0ff86daa4bcc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa566dba65372cc99288722dc5e07ede6" id="r_aa566dba65372cc99288722dc5e07ede6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#aa566dba65372cc99288722dc5e07ede6">applyMat</a> (const Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1Relaxation.html#a9d33134c7bedaf080d2c52c0847371a5">scalar_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a9f68eeba3c642fd6b1e7856283759135">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0839c732268cbc480405aa18e4539688">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0bcabf9138ad35665f3392f2baa3388b">node_type</a> &gt; &amp;X, Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1Relaxation.html#a9d33134c7bedaf080d2c52c0847371a5">scalar_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a9f68eeba3c642fd6b1e7856283759135">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0839c732268cbc480405aa18e4539688">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0bcabf9138ad35665f3392f2baa3388b">node_type</a> &gt; &amp;Y, Teuchos::ETransp mode=Teuchos::NO_TRANS) const</td></tr>
<tr class="memdesc:aa566dba65372cc99288722dc5e07ede6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the input matrix to X, returning the result in Y.  <br /></td></tr>
<tr class="separator:aa566dba65372cc99288722dc5e07ede6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Attribute accessor methods</div></td></tr>
<tr class="memitem:a0e02ca0e321830d20fa85c2021d8b7e1" id="r_a0e02ca0e321830d20fa85c2021d8b7e1"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const Teuchos::Comm&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#a0e02ca0e321830d20fa85c2021d8b7e1">getComm</a> () const</td></tr>
<tr class="memdesc:a0e02ca0e321830d20fa85c2021d8b7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The communicator over which the matrix and vectors are distributed.  <br /></td></tr>
<tr class="separator:a0e02ca0e321830d20fa85c2021d8b7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2a1aefb06eb7a18f8e5beace869b7d" id="r_a2f2a1aefb06eb7a18f8e5beace869b7d"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1Relaxation.html#aa57fbd1389ed7657a0d58fa886a9d29a">row_matrix_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#a2f2a1aefb06eb7a18f8e5beace869b7d">getMatrix</a> () const</td></tr>
<tr class="memdesc:a2f2a1aefb06eb7a18f8e5beace869b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix to be preconditioned.  <br /></td></tr>
<tr class="separator:a2f2a1aefb06eb7a18f8e5beace869b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add20440243961459389c25fd24b811de" id="r_add20440243961459389c25fd24b811de"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#add20440243961459389c25fd24b811de">getComputeFlops</a> () const</td></tr>
<tr class="memdesc:add20440243961459389c25fd24b811de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of floating-point operations over all calls to <a class="el" href="classIfpack2_1_1Relaxation.html#a512bc4a35a2933356c27833b5498303c" title="Compute the preconditioner (&quot;numeric setup&quot;);.">compute()</a>.  <br /></td></tr>
<tr class="separator:add20440243961459389c25fd24b811de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9bdc241d9e05fb786c3990c03561c4" id="r_aee9bdc241d9e05fb786c3990c03561c4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#aee9bdc241d9e05fb786c3990c03561c4">getApplyFlops</a> () const</td></tr>
<tr class="memdesc:aee9bdc241d9e05fb786c3990c03561c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of floating-point operations over all calls to <a class="el" href="classIfpack2_1_1Relaxation.html#a9ee4f4089ee971e71f1bc3a7d038be29" title="Apply the preconditioner to X, returning the result in Y.">apply()</a>.  <br /></td></tr>
<tr class="separator:aee9bdc241d9e05fb786c3990c03561c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c9ece5ee732600b3ca28a03a49c6a4" id="r_ad9c9ece5ee732600b3ca28a03a49c6a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#ad9c9ece5ee732600b3ca28a03a49c6a4">getNumInitialize</a> () const</td></tr>
<tr class="memdesc:ad9c9ece5ee732600b3ca28a03a49c6a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of calls to <a class="el" href="classIfpack2_1_1Relaxation.html#a53fd53a77642276aecfaa51f12f3191b" title="Initialize the preconditioner (&quot;symbolic setup&quot;).">initialize()</a>.  <br /></td></tr>
<tr class="separator:ad9c9ece5ee732600b3ca28a03a49c6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b82f78c73d895b957ce154b6554da0" id="r_a26b82f78c73d895b957ce154b6554da0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#a26b82f78c73d895b957ce154b6554da0">getNumCompute</a> () const</td></tr>
<tr class="memdesc:a26b82f78c73d895b957ce154b6554da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of calls to <a class="el" href="classIfpack2_1_1Relaxation.html#a512bc4a35a2933356c27833b5498303c" title="Compute the preconditioner (&quot;numeric setup&quot;);.">compute()</a>.  <br /></td></tr>
<tr class="separator:a26b82f78c73d895b957ce154b6554da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44ade4183940d5718cc445d85b47ac1" id="r_ad44ade4183940d5718cc445d85b47ac1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#ad44ade4183940d5718cc445d85b47ac1">getNumApply</a> () const</td></tr>
<tr class="memdesc:ad44ade4183940d5718cc445d85b47ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of calls to <a class="el" href="classIfpack2_1_1Relaxation.html#a9ee4f4089ee971e71f1bc3a7d038be29" title="Apply the preconditioner to X, returning the result in Y.">apply()</a>.  <br /></td></tr>
<tr class="separator:ad44ade4183940d5718cc445d85b47ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cb45c4249534063b3a8a695b748a34" id="r_a90cb45c4249534063b3a8a695b748a34"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#a90cb45c4249534063b3a8a695b748a34">getInitializeTime</a> () const</td></tr>
<tr class="memdesc:a90cb45c4249534063b3a8a695b748a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total time in seconds spent in all calls to <a class="el" href="classIfpack2_1_1Relaxation.html#a53fd53a77642276aecfaa51f12f3191b" title="Initialize the preconditioner (&quot;symbolic setup&quot;).">initialize()</a>.  <br /></td></tr>
<tr class="separator:a90cb45c4249534063b3a8a695b748a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5758312d2fe95c8813f70a8d95b321e5" id="r_a5758312d2fe95c8813f70a8d95b321e5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#a5758312d2fe95c8813f70a8d95b321e5">getComputeTime</a> () const</td></tr>
<tr class="memdesc:a5758312d2fe95c8813f70a8d95b321e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total time in seconds spent in all calls to <a class="el" href="classIfpack2_1_1Relaxation.html#a512bc4a35a2933356c27833b5498303c" title="Compute the preconditioner (&quot;numeric setup&quot;);.">compute()</a>.  <br /></td></tr>
<tr class="separator:a5758312d2fe95c8813f70a8d95b321e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188742424420d33b97bd230e93fef895" id="r_a188742424420d33b97bd230e93fef895"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#a188742424420d33b97bd230e93fef895">getApplyTime</a> () const</td></tr>
<tr class="memdesc:a188742424420d33b97bd230e93fef895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total time in seconds spent in all calls to <a class="el" href="classIfpack2_1_1Relaxation.html#a9ee4f4089ee971e71f1bc3a7d038be29" title="Apply the preconditioner to X, returning the result in Y.">apply()</a>.  <br /></td></tr>
<tr class="separator:a188742424420d33b97bd230e93fef895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9eae63ee56659fd92dbf19ba433ddf5" id="r_ac9eae63ee56659fd92dbf19ba433ddf5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#ac9eae63ee56659fd92dbf19ba433ddf5">getNodeSmootherComplexity</a> () const</td></tr>
<tr class="memdesc:ac9eae63ee56659fd92dbf19ba433ddf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a rough estimate of cost per iteration.  <br /></td></tr>
<tr class="separator:ac9eae63ee56659fd92dbf19ba433ddf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implementation of Teuchos::Describable interface</div></td></tr>
<tr class="memitem:a782c980f4c6054a27efa3f2e64b17bde" id="r_a782c980f4c6054a27efa3f2e64b17bde"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#a782c980f4c6054a27efa3f2e64b17bde">description</a> () const</td></tr>
<tr class="memdesc:a782c980f4c6054a27efa3f2e64b17bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple one-line description of this object.  <br /></td></tr>
<tr class="separator:a782c980f4c6054a27efa3f2e64b17bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c86d85d7f8bef954238410ae2e6d082" id="r_a6c86d85d7f8bef954238410ae2e6d082"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Relaxation.html#a6c86d85d7f8bef954238410ae2e6d082">describe</a> (Teuchos::FancyOStream &amp;out, const Teuchos::EVerbosityLevel verbLevel=Teuchos::Describable::verbLevel_default) const</td></tr>
<tr class="memdesc:a6c86d85d7f8bef954238410ae2e6d082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the object's attributes to the given output stream.  <br /></td></tr>
<tr class="separator:a6c86d85d7f8bef954238410ae2e6d082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classIfpack2_1_1Preconditioner"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classIfpack2_1_1Preconditioner')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classIfpack2_1_1Preconditioner.html">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a></td></tr>
<tr class="memitem:a637973211128e0c09db53772df0f345d inherit pub_methods_classIfpack2_1_1Preconditioner" id="r_a637973211128e0c09db53772df0f345d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Preconditioner.html#a637973211128e0c09db53772df0f345d">~Preconditioner</a> ()</td></tr>
<tr class="memdesc:a637973211128e0c09db53772df0f345d inherit pub_methods_classIfpack2_1_1Preconditioner"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a637973211128e0c09db53772df0f345d inherit pub_methods_classIfpack2_1_1Preconditioner"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html">Ifpack2::Details::CanChangeMatrix&lt; Tpetra::RowMatrix&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt; &gt;</a></td></tr>
<tr class="memitem:acad726ffa06a9eef5d675364f996101a inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix" id="r_acad726ffa06a9eef5d675364f996101a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">virtual</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html#acad726ffa06a9eef5d675364f996101a">setMatrix</a> (<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> Tpetra::RowMatrix&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt; &gt; &amp;A)=0</td></tr>
<tr class="memdesc:acad726ffa06a9eef5d675364f996101a inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the new matrix.  <br /></td></tr>
<tr class="separator:acad726ffa06a9eef5d675364f996101a inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad9626e6fa50980dc192a4a63341c12 inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix" id="r_abad9626e6fa50980dc192a4a63341c12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">virtual</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html#abad9626e6fa50980dc192a4a63341c12">~CanChangeMatrix</a> ()</td></tr>
<tr class="memdesc:abad9626e6fa50980dc192a4a63341c12 inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:abad9626e6fa50980dc192a4a63341c12 inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class MatrixType&gt;<br />
class Ifpack2::Relaxation&lt; MatrixType &gt;</div><p><a class="el" href="classIfpack2_1_1Relaxation.html" title="Relaxation preconditioners for Tpetra::RowMatrix and Tpetra::CrsMatrix sparse matrices.">Relaxation</a> preconditioners for Tpetra::RowMatrix and Tpetra::CrsMatrix sparse matrices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>A specialization of Tpetra::RowMatrix.</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Ifpack_Relaxation_Summary"></a>
Summary</h1>
<p>This class implements several different relaxation preconditioners for Tpetra::RowMatrix or its subclass Tpetra::CrsMatrix. <a class="el" href="classIfpack2_1_1Relaxation.html" title="Relaxation preconditioners for Tpetra::RowMatrix and Tpetra::CrsMatrix sparse matrices.">Relaxation</a> is derived from <a class="el" href="classIfpack2_1_1Preconditioner.html" title="Interface for all Ifpack2 preconditioners.">Preconditioner</a>, which is itself derived from Tpetra::Operator. Therefore this object may be used as a preconditioner for <a class="elRef" href="../../../belos/doc/html/namespaceBelos.html">Belos</a> linear solvers, and for any linear solver that treats preconditioners as instances of Tpetra::Operator.</p>
<p>This class implements the following relaxation methods:</p><ul>
<li>Richardson</li>
<li>Jacobi</li>
<li>Gauss-Seidel</li>
<li>Symmetric Gauss-Seidel</li>
</ul>
<p>All methods allow you to set an optional damping parameter. The "Gauss-Seidel" methods technically only perform Gauss-Seidel within an MPI process, but Jacobi between processes. To compensate, these methods include an "L1" option, which can improve convergence by weighting contributions near process boundaries differently. For more details, please refer to the following publication:</p>
<p>A. H. Baker, R. D. Falgout, T. V. Kolev, and U. M. Yang. "Multigrid Smoothers for Ultraparallel Computing." <em>SIAM J. Sci. Comput.</em>, Vol. 33, No. 5. (2011), pp. 2864-2887.</p>
<h1><a class="anchor" id="Ifpack_Relaxation_Performance"></a>
Performance</h1>
<p>Richardson and Jacobi will always use your matrix's native sparse matrix-vector multiply kernel. This should give good performance, since we have spent a lot of effort tuning Tpetra's kernels. Depending on the Node type of your Tpetra matrix, it may also exploit threads for additional parallelism within each MPI process. In contrast, Gauss-Seidel and symmetric Gauss-Seidel are intrinsically sequential methods within an MPI process. This prevents us from exposing more parallelism via threads. The difference should become more apparent as your code moves away from a "one MPI process per core" model, to a "one MPI
process per socket or node" model, assuming that you are using a thread-parallel Node type.</p>
<p><a class="el" href="classIfpack2_1_1Relaxation.html" title="Relaxation preconditioners for Tpetra::RowMatrix and Tpetra::CrsMatrix sparse matrices.">Relaxation</a> works with any Tpetra::RowMatrix input. If your Tpetra::RowMatrix happens to be a Tpetra::CrsMatrix, the Gauss-Seidel and symmetric Gauss-Seidel relaxations may be able to exploit this for better performance. You don't have to do anything to figure this out (we test via <code>dynamic_cast</code>).</p>
<h1><a class="anchor" id="Ifpack_Relaxation_Create"></a>
Creating a Relaxation preconditioner</h1>
<p>The following code snippet shows how to create a <a class="el" href="classIfpack2_1_1Relaxation.html" title="Relaxation preconditioners for Tpetra::RowMatrix and Tpetra::CrsMatrix sparse matrices.">Relaxation</a> preconditioner.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Ifpack2_Relaxation.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line">using Teuchos::ParameterList;</div>
<div class="line"><span class="keyword">using </span>Teuchos::RCP;</div>
<div class="line"><span class="keyword">typedef</span> Tpetra::CrsMatrix&lt;double&gt; crs_matrix_type;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classIfpack2_1_1Preconditioner.html">Ifpack2::Preconditioner&lt;double&gt;</a> precond_type;</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the sparse matrix A somehow.  It must be fill complete</span></div>
<div class="line"><span class="comment">// before you may create an Ifpack2 preconditioner from it.</span></div>
<div class="line">RCP&lt;crs_matrix_type&gt; A = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the relaxation.  You could also do this using</span></div>
<div class="line"><span class="comment">// Ifpack2::Factory (the preconditioner factory) if you like.</span></div>
<div class="line">precond_type prec (A);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Make the list of relaxation parameters.</span></div>
<div class="line">Teuchos::ParameterList params;</div>
<div class="line"><span class="comment">// Do symmetric SOR / Gauss-Seidel.</span></div>
<div class="line">params.set (<span class="stringliteral">&quot;relaxation: type&quot;</span>, <span class="stringliteral">&quot;Symmetric Gauss-Seidel&quot;</span>);</div>
<div class="line"><span class="comment">// Two sweeps (of symmetric SOR / Gauss-Seidel) per apply() call.</span></div>
<div class="line">params.set (<span class="stringliteral">&quot;relaxation: sweeps&quot;</span>, 2);</div>
<div class="line"><span class="comment">// ... Set any other parameters you want to set ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set parameters.</span></div>
<div class="line">prec.setParameters (params);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prepare the relaxation instance for use.</span></div>
<div class="line">prec.initialize ();</div>
<div class="line">prec.compute ();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now prec may be used as a preconditioner or smoother,</span></div>
<div class="line"><span class="comment">// by calling its apply() method, just like any Tpetra::Operator.</span></div>
<div class="ttc" id="aclassIfpack2_1_1Preconditioner_html"><div class="ttname"><a href="classIfpack2_1_1Preconditioner.html">Ifpack2::Preconditioner</a></div><div class="ttdoc">Interface for all Ifpack2 preconditioners.</div><div class="ttdef"><b>Definition</b> Ifpack2_Preconditioner.hpp:74</div></div>
</div><!-- fragment --><h1><a class="anchor" id="Ifpack_Relaxation_Algorithms"></a>
Algorithms</h1>
<p>We now briefly describe the relaxation algorithms this class implements. Consider the linear system \(Ax=b\), where \(A\) is a square matrix, and \(x\) and \(b\) are two vectors of compatible dimensions. Suppose that \(x^{(0)}\) is the starting vector and \(x^{(k)}\) is the approximate solution for \(x\) computed by iteration $k+1$ of whatever relaxation method we are using. Here, \(x^{(k)}_i\) is the $i$-th element of vector \(x^{(k)}\).</p>
<p>The Richardson method computes  </p><p class="formulaDsp">
\[
x^{(k+1)}_i = x^{(k)}_i + alpha ( b_i - \sum_{j} A_{ij} x^{(k)}_j ).
\]
</p>
<p>The Jacobi method computes  </p><p class="formulaDsp">
\[
x^{(k+1)}_i = A_{ii}^{-1} ( b_i - \sum_{j \neq i} A_{ij} x^{(k)}_j ).
\]
</p>
<p> The "damped" Jacobi method generalizes Jacobi. It introduces a damping parameter \(\omega \), and computes  </p><p class="formulaDsp">
\[
x^{(k+1)}_i = (1 - \omega) x^{(k)}_i + \omega A_{ii}^{-1} ( b_i - \sum_{j \neq i} A_{ij} x^{(k)}_j ).
\]
</p>
<p>The "damped Gauss-Seidel method" is actually successive over-relaxation (SOR), with Gauss-Seidel as a special case when the damping parameter \(\omega = 1\). We implement has two different sweep directions: Forward and Backward. The Forward sweep direction computes  </p><p class="formulaDsp">
\[
x^{(k+1)}_i = (1 - \omega) x^{(k)}_i + \omega A_{ii}^{-1} ( b_i - \sum_{j &lt; i} A_{ij} x^{(k+1)}_j - \sum_{j &gt; i} A_{ij} x^{(k)}_j ),
\]
</p>
<p> and the Backward sweep direction computes  </p><p class="formulaDsp">
\[
x^{(k+1)}_i = (1 - \omega) x^{(k)}_i + \omega A_{ii}^{-1} ( b_i - \sum_{j &gt; i} A_{ij} x^{(k+1)}_j - \sum_{j &lt; i} A_{ij} x^{(k)}_j ),
\]
</p>
<p> Users may set the sweep direction via the "relaxation: backward mode" option. See the documentation of <a class="el" href="classIfpack2_1_1Relaxation.html#a08f8bb5eda400d0912efa33c552b5ce4" title="Set the relaxation / preconditioner parameters.">setParameters()</a> for details.</p>
<p>Gauss-Seidel / SOR also comes in a symmetric version. This method first does a Forward sweep, then a Backward sweep. Only the symmetric version of this preconditioner is guaranteed to be symmetric (or Hermitian, if the matrix data are complex).</p>
<p>Users may set the relaxation method via the "relaxation: type" parameter. For all relaxation methods, users may specify the number of sweeps per call to <a class="el" href="classIfpack2_1_1Relaxation.html#a9ee4f4089ee971e71f1bc3a7d038be29" title="Apply the preconditioner to X, returning the result in Y.">apply()</a> and the damping parameter \(\omega \). For a list of all supported parameters, please refer to the documentation of the <a class="el" href="classIfpack2_1_1Relaxation.html#a08f8bb5eda400d0912efa33c552b5ce4" title="Set the relaxation / preconditioner parameters.">setParameters()</a> method. For advice on picking \(\omega \) for a preconditioner, please refer to the following book: "Templates for the Solution of Linear Systems: Building Blocks
for Iterative Methods, 2nd Edition," R. Barrett et al., SIAM, 1994.</p>
<dl class="section note"><dt>Note</dt><dd>This class does not actually use the formulae above to apply Jacobi or SOR. For example, the computational kernels for the above SOR sweeps actually do not require branches in the inner loop to distinguish between the lower triangle, diagonal, and upper triangle of A. One can see this by multiplying through the forward sweep expression by \(A_{ii}\) and combining terms, then dividing through again by \(A_{ii}\). This results in the expression  <p class="formulaDsp">
\[
x^{(k+1)}_i = x^{(k)}_i + \omega b_i - \frac{\omega}{A_{ii}} ( \sum_{j \geq i} A_{ij} x^{(k)}_j + \sum_{j &lt; i} x^{(k+1)}_j ).
\]
</p>
 Executing this expression in a forward sweep does not require distinguishing between the lower and upper triangle of A. The same thing holds for the backward sweep. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9d33134c7bedaf080d2c52c0847371a5" name="a9d33134c7bedaf080d2c52c0847371a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d33134c7bedaf080d2c52c0847371a5">&#9670;&#160;</a></span>scalar_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::scalar_type <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::scalar_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the entries of the input MatrixType. </p>

</div>
</div>
<a id="a9f68eeba3c642fd6b1e7856283759135" name="a9f68eeba3c642fd6b1e7856283759135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f68eeba3c642fd6b1e7856283759135">&#9670;&#160;</a></span>local_ordinal_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::local_ordinal_type <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::local_ordinal_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of local indices in the input MatrixType. </p>

</div>
</div>
<a id="a0839c732268cbc480405aa18e4539688" name="a0839c732268cbc480405aa18e4539688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0839c732268cbc480405aa18e4539688">&#9670;&#160;</a></span>global_ordinal_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::global_ordinal_type <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::global_ordinal_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of global indices in the input MatrixType. </p>

</div>
</div>
<a id="a0bcabf9138ad35665f3392f2baa3388b" name="a0bcabf9138ad35665f3392f2baa3388b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bcabf9138ad35665f3392f2baa3388b">&#9670;&#160;</a></span>node_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::node_type <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::node_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Node type used by the input MatrixType. </p>

</div>
</div>
<a id="ab8951c7800fe09b0c3a6e6944f99aa47" name="ab8951c7800fe09b0c3a6e6944f99aa47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8951c7800fe09b0c3a6e6944f99aa47">&#9670;&#160;</a></span>device_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::node_type::device_type <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::device_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Kokkos device type used by the input MatrixType. </p>

</div>
</div>
<a id="ac874be0aca789e5a0b2209d11651e764" name="ac874be0aca789e5a0b2209d11651e764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac874be0aca789e5a0b2209d11651e764">&#9670;&#160;</a></span>magnitude_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Teuchos::ScalarTraits&lt;<a class="el" href="classIfpack2_1_1Relaxation.html#a9d33134c7bedaf080d2c52c0847371a5">scalar_type</a>&gt;::magnitudeType <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::magnitude_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the magnitude (absolute value) of a matrix entry. </p>

</div>
</div>
<a id="aa57fbd1389ed7657a0d58fa886a9d29a" name="aa57fbd1389ed7657a0d58fa886a9d29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57fbd1389ed7657a0d58fa886a9d29a">&#9670;&#160;</a></span>row_matrix_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Tpetra::RowMatrix&lt;<a class="el" href="classIfpack2_1_1Relaxation.html#a9d33134c7bedaf080d2c52c0847371a5">scalar_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a9f68eeba3c642fd6b1e7856283759135">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0839c732268cbc480405aa18e4539688">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0bcabf9138ad35665f3392f2baa3388b">node_type</a>&gt; <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::row_matrix_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tpetra::RowMatrix specialization used by this class. </p>

</div>
</div>
<a id="a77ae0ed89e41c9e6e120e836d8008157" name="a77ae0ed89e41c9e6e120e836d8008157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ae0ed89e41c9e6e120e836d8008157">&#9670;&#160;</a></span>op_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Tpetra::Operator&lt;<a class="el" href="classIfpack2_1_1Relaxation.html#a9d33134c7bedaf080d2c52c0847371a5">scalar_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a9f68eeba3c642fd6b1e7856283759135">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0839c732268cbc480405aa18e4539688">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0bcabf9138ad35665f3392f2baa3388b">node_type</a>&gt; <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::op_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tpetra::Operator specialization used by this class. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0487dfeaf38e27509f775525d9052d84" name="a0487dfeaf38e27509f775525d9052d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0487dfeaf38e27509f775525d9052d84">&#9670;&#160;</a></span>Relaxation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::Relaxation </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1Relaxation.html#aa57fbd1389ed7657a0d58fa886a9d29a">row_matrix_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>[in] The matrix for which to make the constructor. Tpetra::RowMatrix is the base class of Tpetra::CrsMatrix, so you may give either a Tpetra::RowMatrix or a Tpetra::CrsMatrix here.</td></tr>
  </table>
  </dd>
</dl>
<p>The results of <a class="el" href="classIfpack2_1_1Relaxation.html#a9ee4f4089ee971e71f1bc3a7d038be29" title="Apply the preconditioner to X, returning the result in Y.">apply()</a> are undefined if you change the diagonal entries of the sparse matrix after invoking this constructor, without first calling <a class="el" href="classIfpack2_1_1Relaxation.html#a512bc4a35a2933356c27833b5498303c" title="Compute the preconditioner (&quot;numeric setup&quot;);.">compute()</a>. In particular, the <a class="el" href="classIfpack2_1_1Relaxation.html#a512bc4a35a2933356c27833b5498303c" title="Compute the preconditioner (&quot;numeric setup&quot;);.">compute()</a> method may extract the diagonal entries and precompute their inverses, in order to speed up any of the relaxation methods that this class implements.</p>
<p>The "explicit" keyword just means that you must invoke the <a class="el" href="classIfpack2_1_1Relaxation.html" title="Relaxation preconditioners for Tpetra::RowMatrix and Tpetra::CrsMatrix sparse matrices.">Relaxation</a> constructor explicitly; you aren't allowed to use it as an implicit conversion ("cast"). For example, you may do this (namespaces and Tpetra template parameters omitted for brevity): </p><div class="fragment"><div class="line">RCP&lt;<span class="keyword">const</span> CrsMatrix&lt;...&gt; &gt; A = ...;</div>
<div class="line"><a class="code hl_class" href="classIfpack2_1_1Relaxation.html">Relaxation</a>&lt;CrsMatrix&lt;...&gt; &gt; R (A);</div>
<div class="ttc" id="aclassIfpack2_1_1Relaxation_html"><div class="ttname"><a href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a></div><div class="ttdoc">Relaxation preconditioners for Tpetra::RowMatrix and Tpetra::CrsMatrix sparse matrices.</div><div class="ttdef"><b>Definition</b> Ifpack2_Relaxation_decl.hpp:215</div></div>
</div><!-- fragment --><p> but you may not do this: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo (<span class="keyword">const</span> <a class="code hl_class" href="classIfpack2_1_1Relaxation.html">Relaxation</a>&lt;CrsMatrix&lt;...&gt; &gt;&amp; R);</div>
<div class="line"> </div>
<div class="line">RCP&lt;<span class="keyword">const</span> CrsMatrix&lt;...&gt; &gt; A = ...;</div>
<div class="line">foo (A);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a132e828c3a0166d3b5877c3a06fe59a6" name="a132e828c3a0166d3b5877c3a06fe59a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132e828c3a0166d3b5877c3a06fe59a6">&#9670;&#160;</a></span>~Relaxation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::~<a class="el" href="classIfpack2_1_1Relaxation.html">Relaxation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a08f8bb5eda400d0912efa33c552b5ce4" name="a08f8bb5eda400d0912efa33c552b5ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f8bb5eda400d0912efa33c552b5ce4">&#9670;&#160;</a></span>setParameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::setParameters </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the relaxation / preconditioner parameters. </p>
<dl class="section warning"><dt>Warning</dt><dd>All parameters are case sensitive. We make no attempt to check the spelling of parameter names in your input list.</dd></dl>
<p>The "relaxation: type" (string) parameter sets the relaxation / preconditioner method you want to use. It currently accepts the following values (the default is "Jacobi"):</p><ul>
<li>"Richardson"</li>
<li>"Jacobi"</li>
<li>"Gauss-Seidel"</li>
<li>"Symmetric Gauss-Seidel"</li>
</ul>
<p>The "relaxation: sweeps" (int) parameter sets the number of sweeps, that is, the number of times to apply the relaxation on each invocation of <a class="el" href="classIfpack2_1_1Relaxation.html#a9ee4f4089ee971e71f1bc3a7d038be29" title="Apply the preconditioner to X, returning the result in Y.">apply()</a>. The default number of sweeps is 1.</p>
<p>The "relaxation: damping factor" (scalar_type &ndash; the type of the entries of the matrix) parameter is the value of the damping factor \(\omega \). The main documentation of this class explains how we use this value. The default value is 1.0.</p>
<p>The "relaxation: zero starting solution" (bool) parameter governs whether or not we use the existing values in the output multivector Y when applying the relaxation. Its default value is true, meaning that we fill Y with zeros before applying relaxation sweeps. If false, we use the existing values in Y.</p>
<p>If the "relaxation: backward mode" (bool) parameter is true, we perform Gauss-Seidel in reverse mode. The default value is false, meaning that we do forward-mode Gauss-Seidel. This only affects standard Gauss-Seidel, not symmetric Gauss-Seidel.</p>
<p>The "relaxation: fix tiny diagonal entries" (bool) parameter defaults to false. If true, the <a class="el" href="classIfpack2_1_1Relaxation.html#a512bc4a35a2933356c27833b5498303c" title="Compute the preconditioner (&quot;numeric setup&quot;);.">compute()</a> method will do extra work (computation only, no MPI communication) to "fix" diagonal entries that are less than or equal to the threshold given by the (magnitude of the) "relaxation: min diagonal value" parameter. The default behavior imitates that of Aztec, which does not do any special modification of the diagonal.</p>
<p>The "relaxation: min diagonal value" (scalar_type) parameter only matters if "relaxation: fix tiny diagonal entries" (see above) is true. This parameter limits how close to zero the diagonal elements of the matrix are allowed to be. If the magnitude of a diagonal element of the matrix is less than the magnitude of this value, then we set that diagonal element to this value. (We don't actually modify the matrix; we just remember the diagonal values.) The use of magnitude rather than the value itself makes this well defined if scalar_type is complex. The default value of this parameter is zero, in which case we will replace diagonal entries that are exactly equal to zero with a small nonzero value (machine precision for the given <code>Scalar</code> type) before inverting them. Note that if "relaxation: fix tiny diagonal entries" is false, the default value, this parameter does nothing.)</p>
<p>The "relaxation: check diagonal entries" (bool) parameter defaults to false. If true, the <a class="el" href="classIfpack2_1_1Relaxation.html#a512bc4a35a2933356c27833b5498303c" title="Compute the preconditioner (&quot;numeric setup&quot;);.">compute()</a> method will do extra work (both computation and communication) to count diagonal entries that are zero, have negative real part, or are small in magnitude. The <a class="el" href="classIfpack2_1_1Relaxation.html#a6c86d85d7f8bef954238410ae2e6d082" title="Print the object&#39;s attributes to the given output stream.">describe()</a> method will then print this information for you. You may find this useful for checking whether your input matrix has issues that make Jacobi or Gauss-Seidel a poor choice of preconditioner.</p>
<p>The last two parameters govern the L1 variant of Gauss-Seidel. The "relaxation: use l1" (bool) parameter, if true, turns on the L1 variant. (In "l1", the first character is a lower-case L, and the second character is the numeral 1 (one).) This parameter's value is false by default. The "relaxation: l1 eta" (magnitude_type) parameter is the \(\eta \) parameter associated with that method; its default value is 1.5. Recall that "magnitude_type" is the type of the absolute value of a scalar_type value. This is the same as scalar_type for real-valued floating-point types (like <code>float</code> and <code>double</code>). If scalar_type is <code>std::complex&lt;T&gt;</code> for some type <code>T</code>, then magnitude_type is <code>T</code>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a60340992fc1b9eac82ef35333bee6efd">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a4f9691b22610782fc4cf4ba808295f36" name="a4f9691b22610782fc4cf4ba808295f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f9691b22610782fc4cf4ba808295f36">&#9670;&#160;</a></span>setZeroStartingSolution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::setZeroStartingSolution </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zeroStartingSolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this preconditioner's parameters. </p>

<p>Reimplemented from <a class="el" href="classIfpack2_1_1Preconditioner.html#a12495acd22d15212241c0d518d7f6536">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a7b31bf6acebf637898db9c9d62de3360" name="a7b31bf6acebf637898db9c9d62de3360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b31bf6acebf637898db9c9d62de3360">&#9670;&#160;</a></span>getValidParameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const Teuchos::ParameterList &gt; <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::getValidParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of all the parameters that this class accepts. </p>

</div>
</div>
<a id="a53fd53a77642276aecfaa51f12f3191b" name="a53fd53a77642276aecfaa51f12f3191b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53fd53a77642276aecfaa51f12f3191b">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the preconditioner ("symbolic setup"). </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#ad3aefd6f16e8ef4cddb696cd23f160b0">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="ae6647f2e7e0f0c24a2e61e40163a1fe7" name="ae6647f2e7e0f0c24a2e61e40163a1fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6647f2e7e0f0c24a2e61e40163a1fe7">&#9670;&#160;</a></span>isInitialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::isInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the preconditioner has been successfully initialized. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a180c876ccf7af87f10a1c1d08ba2dc01">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a512bc4a35a2933356c27833b5498303c" name="a512bc4a35a2933356c27833b5498303c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512bc4a35a2933356c27833b5498303c">&#9670;&#160;</a></span>compute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::compute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the preconditioner ("numeric setup");. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a23954dd69f62b56455a9c0988bbe9e67">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="aa215c0d1228236c2b58d61035f2f2718" name="aa215c0d1228236c2b58d61035f2f2718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa215c0d1228236c2b58d61035f2f2718">&#9670;&#160;</a></span>isComputed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::isComputed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if <a class="el" href="classIfpack2_1_1Relaxation.html#a512bc4a35a2933356c27833b5498303c" title="Compute the preconditioner (&quot;numeric setup&quot;);.">compute()</a> has been called. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#abb5af77756a7488ab636dbd97483ca66">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a9a5cf060d78467a89b4fd2cb911869d7" name="a9a5cf060d78467a89b4fd2cb911869d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5cf060d78467a89b4fd2cb911869d7">&#9670;&#160;</a></span>setMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::setMatrix </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1Relaxation.html#aa57fbd1389ed7657a0d58fa886a9d29a">row_matrix_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the matrix to be preconditioned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>[in] The new matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>! isInitialized ()</code> </dd>
<dd>
<code>! isComputed ()</code></dd></dl>
<p>Calling this method with a matrix different than the current matrix resets the preconditioner's state. After calling this method with a nonnull input, you must first call <a class="el" href="classIfpack2_1_1Relaxation.html#a53fd53a77642276aecfaa51f12f3191b" title="Initialize the preconditioner (&quot;symbolic setup&quot;).">initialize()</a> and <a class="el" href="classIfpack2_1_1Relaxation.html#a512bc4a35a2933356c27833b5498303c" title="Compute the preconditioner (&quot;numeric setup&quot;);.">compute()</a> (in that order) before you may call <a class="el" href="classIfpack2_1_1Relaxation.html#a9ee4f4089ee971e71f1bc3a7d038be29" title="Apply the preconditioner to X, returning the result in Y.">apply()</a>.</p>
<p>You may call this method with a null input. If A is null, then you may not call <a class="el" href="classIfpack2_1_1Relaxation.html#a53fd53a77642276aecfaa51f12f3191b" title="Initialize the preconditioner (&quot;symbolic setup&quot;).">initialize()</a> or <a class="el" href="classIfpack2_1_1Relaxation.html#a512bc4a35a2933356c27833b5498303c" title="Compute the preconditioner (&quot;numeric setup&quot;);.">compute()</a> until you first call this method again with a nonnull input. This method invalidates any previous factorization whether or not A is null, so calling <a class="el" href="classIfpack2_1_1Relaxation.html#a9a5cf060d78467a89b4fd2cb911869d7" title="Change the matrix to be preconditioned.">setMatrix()</a> with a null input is one way to clear the preconditioner's state (and free any memory that it may be using).</p>
<p>The new matrix A need not necessarily have the same Maps or even the same communicator as the original matrix. </p>

</div>
</div>
<a id="a9ee4f4089ee971e71f1bc3a7d038be29" name="a9ee4f4089ee971e71f1bc3a7d038be29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee4f4089ee971e71f1bc3a7d038be29">&#9670;&#160;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1Relaxation.html#a9d33134c7bedaf080d2c52c0847371a5">scalar_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a9f68eeba3c642fd6b1e7856283759135">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0839c732268cbc480405aa18e4539688">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0bcabf9138ad35665f3392f2baa3388b">node_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1Relaxation.html#a9d33134c7bedaf080d2c52c0847371a5">scalar_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a9f68eeba3c642fd6b1e7856283759135">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0839c732268cbc480405aa18e4539688">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0bcabf9138ad35665f3392f2baa3388b">node_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::ETransp&#160;</td>
          <td class="paramname"><em>mode</em> = <code>Teuchos::NO_TRANS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIfpack2_1_1Relaxation.html#a9d33134c7bedaf080d2c52c0847371a5">scalar_type</a>&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>Teuchos::ScalarTraits&lt;<a class="el" href="classIfpack2_1_1Relaxation.html#a9d33134c7bedaf080d2c52c0847371a5">scalar_type</a>&gt;::one()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIfpack2_1_1Relaxation.html#a9d33134c7bedaf080d2c52c0847371a5">scalar_type</a>&#160;</td>
          <td class="paramname"><em>beta</em> = <code>Teuchos::ScalarTraits&lt;<a class="el" href="classIfpack2_1_1Relaxation.html#a9d33134c7bedaf080d2c52c0847371a5">scalar_type</a>&gt;::zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the preconditioner to X, returning the result in Y. </p>
<p>This method computes Y = beta*Y + alpha*M*X, where M*X represents the action of the preconditioner on the input multivector X.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>[in] The multivector input of the preconditioner. </td></tr>
    <tr><td class="paramname">Y</td><td>[in/out] The multivector output of the preconditioner. </td></tr>
    <tr><td class="paramname">mode</td><td>[in] Whether to apply the transpose or conjugate transpose of the preconditioner. Not all preconditioners support options other than the default (no transpose); please call <a class="el" href="classIfpack2_1_1Relaxation.html#ae2483dd71ec501eb03c0ff86daa4bcc6" title="Whether apply() and applyMat() let you apply the transpose or conjugate transpose.">hasTransposeApply()</a> to determine whether nondefault options are supported. </td></tr>
    <tr><td class="paramname">alpha</td><td>[in] Scaling factor for the preconditioned input. </td></tr>
    <tr><td class="paramname">beta</td><td>[in] Scaling factor for the output. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a606c3f8155f67f2867fac3a7c44bd5df">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a168ebb18d4dd62712edca7b60ed36006" name="a168ebb18d4dd62712edca7b60ed36006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168ebb18d4dd62712edca7b60ed36006">&#9670;&#160;</a></span>getDomainMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const Tpetra::Map&lt; typename MatrixType::local_ordinal_type, typename MatrixType::global_ordinal_type, typename MatrixType::node_type &gt; &gt; <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::getDomainMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Tpetra::Map object associated with the domain of this operator. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#aafeb2143ff699f2289503a85f6e3523c">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="aecb8d4c2872ed2fa886fa8b872e4c30b" name="aecb8d4c2872ed2fa886fa8b872e4c30b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb8d4c2872ed2fa886fa8b872e4c30b">&#9670;&#160;</a></span>getRangeMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const Tpetra::Map&lt; typename MatrixType::local_ordinal_type, typename MatrixType::global_ordinal_type, typename MatrixType::node_type &gt; &gt; <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::getRangeMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Tpetra::Map object associated with the range of this operator. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a75b32e1de03024035b00cd2ee95a60da">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="ae2483dd71ec501eb03c0ff86daa4bcc6" name="ae2483dd71ec501eb03c0ff86daa4bcc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2483dd71ec501eb03c0ff86daa4bcc6">&#9670;&#160;</a></span>hasTransposeApply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::hasTransposeApply </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether <a class="el" href="classIfpack2_1_1Relaxation.html#a9ee4f4089ee971e71f1bc3a7d038be29" title="Apply the preconditioner to X, returning the result in Y.">apply()</a> and <a class="el" href="classIfpack2_1_1Relaxation.html#aa566dba65372cc99288722dc5e07ede6" title="Apply the input matrix to X, returning the result in Y.">applyMat()</a> let you apply the transpose or conjugate transpose. </p>

</div>
</div>
<a id="aa566dba65372cc99288722dc5e07ede6" name="aa566dba65372cc99288722dc5e07ede6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa566dba65372cc99288722dc5e07ede6">&#9670;&#160;</a></span>applyMat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::applyMat </td>
          <td>(</td>
          <td class="paramtype">const Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1Relaxation.html#a9d33134c7bedaf080d2c52c0847371a5">scalar_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a9f68eeba3c642fd6b1e7856283759135">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0839c732268cbc480405aa18e4539688">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0bcabf9138ad35665f3392f2baa3388b">node_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1Relaxation.html#a9d33134c7bedaf080d2c52c0847371a5">scalar_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a9f68eeba3c642fd6b1e7856283759135">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0839c732268cbc480405aa18e4539688">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Relaxation.html#a0bcabf9138ad35665f3392f2baa3388b">node_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::ETransp&#160;</td>
          <td class="paramname"><em>mode</em> = <code>Teuchos::NO_TRANS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the input matrix to X, returning the result in Y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>[in] The multivector input of the preconditioner. </td></tr>
    <tr><td class="paramname">Y</td><td>[in/out] The multivector output of the preconditioner. </td></tr>
    <tr><td class="paramname">mode</td><td>[in] Whether to apply the transpose or conjugate transpose of the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e02ca0e321830d20fa85c2021d8b7e1" name="a0e02ca0e321830d20fa85c2021d8b7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e02ca0e321830d20fa85c2021d8b7e1">&#9670;&#160;</a></span>getComm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const Teuchos::Comm&lt; int &gt; &gt; <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::getComm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The communicator over which the matrix and vectors are distributed. </p>

</div>
</div>
<a id="a2f2a1aefb06eb7a18f8e5beace869b7d" name="a2f2a1aefb06eb7a18f8e5beace869b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2a1aefb06eb7a18f8e5beace869b7d">&#9670;&#160;</a></span>getMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const typename <a class="el" href="classIfpack2_1_1Relaxation.html">Relaxation</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1Relaxation.html#aa57fbd1389ed7657a0d58fa886a9d29a">::row_matrix_type</a> &gt; <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::getMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The matrix to be preconditioned. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a4258d242e7ff6003c399da8f0a11d634">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="add20440243961459389c25fd24b811de" name="add20440243961459389c25fd24b811de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add20440243961459389c25fd24b811de">&#9670;&#160;</a></span>getComputeFlops()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::getComputeFlops </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total number of floating-point operations over all calls to <a class="el" href="classIfpack2_1_1Relaxation.html#a512bc4a35a2933356c27833b5498303c" title="Compute the preconditioner (&quot;numeric setup&quot;);.">compute()</a>. </p>

</div>
</div>
<a id="aee9bdc241d9e05fb786c3990c03561c4" name="aee9bdc241d9e05fb786c3990c03561c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9bdc241d9e05fb786c3990c03561c4">&#9670;&#160;</a></span>getApplyFlops()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::getApplyFlops </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total number of floating-point operations over all calls to <a class="el" href="classIfpack2_1_1Relaxation.html#a9ee4f4089ee971e71f1bc3a7d038be29" title="Apply the preconditioner to X, returning the result in Y.">apply()</a>. </p>

</div>
</div>
<a id="ad9c9ece5ee732600b3ca28a03a49c6a4" name="ad9c9ece5ee732600b3ca28a03a49c6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c9ece5ee732600b3ca28a03a49c6a4">&#9670;&#160;</a></span>getNumInitialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::getNumInitialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total number of calls to <a class="el" href="classIfpack2_1_1Relaxation.html#a53fd53a77642276aecfaa51f12f3191b" title="Initialize the preconditioner (&quot;symbolic setup&quot;).">initialize()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#afe6c77c5ab6da065f8dbade353e8535a">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a26b82f78c73d895b957ce154b6554da0" name="a26b82f78c73d895b957ce154b6554da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b82f78c73d895b957ce154b6554da0">&#9670;&#160;</a></span>getNumCompute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::getNumCompute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total number of calls to <a class="el" href="classIfpack2_1_1Relaxation.html#a512bc4a35a2933356c27833b5498303c" title="Compute the preconditioner (&quot;numeric setup&quot;);.">compute()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a286b18ee0769ecc8bf992dffdc442791">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="ad44ade4183940d5718cc445d85b47ac1" name="ad44ade4183940d5718cc445d85b47ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad44ade4183940d5718cc445d85b47ac1">&#9670;&#160;</a></span>getNumApply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::getNumApply </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total number of calls to <a class="el" href="classIfpack2_1_1Relaxation.html#a9ee4f4089ee971e71f1bc3a7d038be29" title="Apply the preconditioner to X, returning the result in Y.">apply()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a565e6c00bf14873ae7b23187c9978078">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a90cb45c4249534063b3a8a695b748a34" name="a90cb45c4249534063b3a8a695b748a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90cb45c4249534063b3a8a695b748a34">&#9670;&#160;</a></span>getInitializeTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::getInitializeTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total time in seconds spent in all calls to <a class="el" href="classIfpack2_1_1Relaxation.html#a53fd53a77642276aecfaa51f12f3191b" title="Initialize the preconditioner (&quot;symbolic setup&quot;).">initialize()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#aeb91a16f5544ad4efaf756b1d2a8b39d">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a5758312d2fe95c8813f70a8d95b321e5" name="a5758312d2fe95c8813f70a8d95b321e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5758312d2fe95c8813f70a8d95b321e5">&#9670;&#160;</a></span>getComputeTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::getComputeTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total time in seconds spent in all calls to <a class="el" href="classIfpack2_1_1Relaxation.html#a512bc4a35a2933356c27833b5498303c" title="Compute the preconditioner (&quot;numeric setup&quot;);.">compute()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a111d9bd4e28c0633696f271955ddcb4c">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a188742424420d33b97bd230e93fef895" name="a188742424420d33b97bd230e93fef895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188742424420d33b97bd230e93fef895">&#9670;&#160;</a></span>getApplyTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::getApplyTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total time in seconds spent in all calls to <a class="el" href="classIfpack2_1_1Relaxation.html#a9ee4f4089ee971e71f1bc3a7d038be29" title="Apply the preconditioner to X, returning the result in Y.">apply()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a57c2d00799de050cd2a5a75ce80f48b9">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="ac9eae63ee56659fd92dbf19ba433ddf5" name="ac9eae63ee56659fd92dbf19ba433ddf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9eae63ee56659fd92dbf19ba433ddf5">&#9670;&#160;</a></span>getNodeSmootherComplexity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::getNodeSmootherComplexity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a rough estimate of cost per iteration. </p>

</div>
</div>
<a id="a782c980f4c6054a27efa3f2e64b17bde" name="a782c980f4c6054a27efa3f2e64b17bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782c980f4c6054a27efa3f2e64b17bde">&#9670;&#160;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple one-line description of this object. </p>
<p>Be aware that this will print a very long line, because some users really like to see all the attributes of the object in a single line. If you prefer multiple lines of output, you should call <a class="el" href="classIfpack2_1_1Relaxation.html#a6c86d85d7f8bef954238410ae2e6d082" title="Print the object&#39;s attributes to the given output stream.">describe()</a> instead. </p>

</div>
</div>
<a id="a6c86d85d7f8bef954238410ae2e6d082" name="a6c86d85d7f8bef954238410ae2e6d082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c86d85d7f8bef954238410ae2e6d082">&#9670;&#160;</a></span>describe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1Relaxation.html">Ifpack2::Relaxation</a>&lt; MatrixType &gt;::describe </td>
          <td>(</td>
          <td class="paramtype">Teuchos::FancyOStream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::EVerbosityLevel&#160;</td>
          <td class="paramname"><em>verbLevel</em> = <code>Teuchos::Describable::verbLevel_default</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the object's attributes to the given output stream. </p>
<p>This method will print a constant amount of information (not proportional to the matrix's dimensions or number of entries) on Process 0 of the communicator over which this object is distributed.</p>
<p>You may wrap an std::ostream in a Teuchos::FancyOStream by including "Teuchos_FancyOStream.hpp" and calling Teuchos::getFancyOStream(). For example: </p><div class="fragment"><div class="line"><span class="keyword">using </span>Teuchos::RCP;</div>
<div class="line"><span class="keyword">using </span>Teuchos::rcpFromRef;</div>
<div class="line"><span class="keyword">using </span>Teuchos::FancyOStream;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Wrap std::cout in a FancyOStream.</span></div>
<div class="line">RCP&lt;FancyOStream&gt; wrappedCout = getFancyOStream (rcpFromRef (std::cout));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Wrap an output file in a FancyOStream.</span></div>
<div class="line">RCP&lt;std::ofstream&gt; outFile (<span class="keyword">new</span> std::ofstream (<span class="stringliteral">&quot;myFile.txt&quot;</span>));</div>
<div class="line">RCP&lt;FancyOStream&gt; wrappedFile = getFancyOStream (outFile);</div>
</div><!-- fragment --> 
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Ifpack2__Relaxation__decl_8hpp_source.html">Ifpack2_Relaxation_decl.hpp</a></li>
<li><a class="el" href="Ifpack2__Relaxation__def_8hpp_source.html">Ifpack2_Relaxation_def.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
