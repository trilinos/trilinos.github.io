<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ifpack2 Templated Preconditioning Package: Ifpack2::AdditiveSchwarz&lt; MatrixType, LocalInverseType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Ifpack2 Templated Preconditioning Package<span id="projectnumber">&#160;Version 1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceIfpack2.html">Ifpack2</a></li><li class="navelem"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">AdditiveSchwarz</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classIfpack2_1_1AdditiveSchwarz-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ifpack2::AdditiveSchwarz&lt; MatrixType, LocalInverseType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Additive Schwarz domain decomposition for Tpetra sparse matrices.  
 <a href="classIfpack2_1_1AdditiveSchwarz.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Ifpack2__AdditiveSchwarz__decl_8hpp_source.html">Ifpack2_AdditiveSchwarz_decl.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Ifpack2::AdditiveSchwarz&lt; MatrixType, LocalInverseType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classIfpack2_1_1AdditiveSchwarz__inherit__graph.png" border="0" usemap="#aIfpack2_1_1AdditiveSchwarz_3_01MatrixType_00_01LocalInverseType_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aIfpack2_1_1AdditiveSchwarz_3_01MatrixType_00_01LocalInverseType_01_4_inherit__map" id="aIfpack2_1_1AdditiveSchwarz_3_01MatrixType_00_01LocalInverseType_01_4_inherit__map">
<area shape="rect" title="Additive Schwarz domain decomposition for Tpetra sparse matrices." alt="" coords="771,176,1015,216"/>
<area shape="rect" href="classIfpack2_1_1Preconditioner.html" title=" " alt="" coords="480,37,719,121"/>
<area shape="poly" title=" " alt="" coords="718,123,843,173,841,178,716,128"/>
<area shape="rect" href="classIfpack2_1_1Preconditioner.html" title="Interface for all Ifpack2 preconditioners." alt="" coords="23,51,195,106"/>
<area shape="poly" title=" " alt="" coords="209,76,480,76,480,81,209,81"/>
<area shape="rect" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html" title=" " alt="" coords="477,147,721,245"/>
<area shape="poly" title=" " alt="" coords="735,193,770,193,770,199,735,199"/>
<area shape="rect" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html" title="Mix&#45;in interface for preconditioners that can change their matrix after construction." alt="" coords="5,177,212,217"/>
<area shape="poly" title=" " alt="" coords="226,194,477,194,477,199,226,200"/>
<area shape="rect" href="classIfpack2_1_1Details_1_1NestedPreconditioner.html" title=" " alt="" coords="480,269,719,368"/>
<area shape="poly" title=" " alt="" coords="729,262,843,214,845,218,731,266"/>
<area shape="rect" href="classIfpack2_1_1Details_1_1NestedPreconditioner.html" title="Mix&#45;in interface for nested preconditioners." alt="" coords="7,299,211,339"/>
<area shape="poly" title=" " alt="" coords="225,316,480,316,480,321,225,321"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Implementation of Tpetra::Operator</div></td></tr>
<tr class="memitem:abdb0838020aa181c7908fbc8bf351b19" id="r_abdb0838020aa181c7908fbc8bf351b19"><td class="memItemLeft" align="right" valign="top">virtual Teuchos::RCP&lt; const Tpetra::Map&lt; <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a03cd0d9306aa5b0c198b290c22c55bd4">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a40f0a86bb9aa205906c0f8bb969652f1">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a91956faa61adf87bd84fdd10d1262bba">node_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#abdb0838020aa181c7908fbc8bf351b19">getDomainMap</a> () const</td></tr>
<tr class="memdesc:abdb0838020aa181c7908fbc8bf351b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">The domain Map of this operator.  <br /></td></tr>
<tr class="separator:abdb0838020aa181c7908fbc8bf351b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce3edc4f76be4e46908df68e2a6f8be" id="r_abce3edc4f76be4e46908df68e2a6f8be"><td class="memItemLeft" align="right" valign="top">virtual Teuchos::RCP&lt; const Tpetra::Map&lt; <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a03cd0d9306aa5b0c198b290c22c55bd4">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a40f0a86bb9aa205906c0f8bb969652f1">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a91956faa61adf87bd84fdd10d1262bba">node_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#abce3edc4f76be4e46908df68e2a6f8be">getRangeMap</a> () const</td></tr>
<tr class="memdesc:abce3edc4f76be4e46908df68e2a6f8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">The range Map of this operator.  <br /></td></tr>
<tr class="separator:abce3edc4f76be4e46908df68e2a6f8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae463a2043410145bf10070f5a9791120" id="r_ae463a2043410145bf10070f5a9791120"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#ae463a2043410145bf10070f5a9791120">apply</a> (const Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#acf7c70ef80e46563df3dce419a942c12">scalar_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a03cd0d9306aa5b0c198b290c22c55bd4">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a40f0a86bb9aa205906c0f8bb969652f1">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a91956faa61adf87bd84fdd10d1262bba">node_type</a> &gt; &amp;X, Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#acf7c70ef80e46563df3dce419a942c12">scalar_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a03cd0d9306aa5b0c198b290c22c55bd4">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a40f0a86bb9aa205906c0f8bb969652f1">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a91956faa61adf87bd84fdd10d1262bba">node_type</a> &gt; &amp;Y, Teuchos::ETransp mode=Teuchos::NO_TRANS, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#acf7c70ef80e46563df3dce419a942c12">scalar_type</a> alpha=Teuchos::ScalarTraits&lt; <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#acf7c70ef80e46563df3dce419a942c12">scalar_type</a> &gt;::one(), <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#acf7c70ef80e46563df3dce419a942c12">scalar_type</a> beta=Teuchos::ScalarTraits&lt; <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#acf7c70ef80e46563df3dce419a942c12">scalar_type</a> &gt;::zero()) const</td></tr>
<tr class="memdesc:ae463a2043410145bf10070f5a9791120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the preconditioner to X, putting the result in Y.  <br /></td></tr>
<tr class="separator:ae463a2043410145bf10070f5a9791120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implementation of Ifpack2::Details::NestedPreconditioner</div></td></tr>
<tr class="memitem:aae1e81fa9b86f093f5a235073083a4bf" id="r_aae1e81fa9b86f093f5a235073083a4bf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#aae1e81fa9b86f093f5a235073083a4bf">setInnerPreconditioner</a> (const Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1Preconditioner.html">Preconditioner</a>&lt; <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#acf7c70ef80e46563df3dce419a942c12">scalar_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a03cd0d9306aa5b0c198b290c22c55bd4">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a40f0a86bb9aa205906c0f8bb969652f1">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a91956faa61adf87bd84fdd10d1262bba">node_type</a> &gt; &gt; &amp;innerPrec)</td></tr>
<tr class="memdesc:aae1e81fa9b86f093f5a235073083a4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the inner preconditioner.  <br /></td></tr>
<tr class="separator:aae1e81fa9b86f093f5a235073083a4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implementation of Ifpack2::Details::CanChangeMatrix</div></td></tr>
<tr class="memitem:a8e80b7fc9b9922b44ec8e364800bc24b" id="r_a8e80b7fc9b9922b44ec8e364800bc24b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a8e80b7fc9b9922b44ec8e364800bc24b">setMatrix</a> (const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#afc8280a3834b6ab4cb867c1b11c9bf40">row_matrix_type</a> &gt; &amp;A)</td></tr>
<tr class="memdesc:a8e80b7fc9b9922b44ec8e364800bc24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the matrix to be preconditioned.  <br /></td></tr>
<tr class="separator:a8e80b7fc9b9922b44ec8e364800bc24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34796005a5e5998796bde799f71fbbe" id="r_ae34796005a5e5998796bde799f71fbbe"><td class="memItemLeft" align="right" valign="top">virtual Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#afc8280a3834b6ab4cb867c1b11c9bf40">row_matrix_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#ae34796005a5e5998796bde799f71fbbe">getMatrix</a> () const</td></tr>
<tr class="memdesc:ae34796005a5e5998796bde799f71fbbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input matrix.  <br /></td></tr>
<tr class="separator:ae34796005a5e5998796bde799f71fbbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5bfd4d070f5a609550fb8db7eaa6bd" id="r_add5bfd4d070f5a609550fb8db7eaa6bd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#add5bfd4d070f5a609550fb8db7eaa6bd">setParameters</a> (const Teuchos::ParameterList &amp;plist)</td></tr>
<tr class="memdesc:add5bfd4d070f5a609550fb8db7eaa6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the preconditioner's parameters.  <br /></td></tr>
<tr class="separator:add5bfd4d070f5a609550fb8db7eaa6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0c04a63398a027d1f6786cb1c18fd3" id="r_a9f0c04a63398a027d1f6786cb1c18fd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a9f0c04a63398a027d1f6786cb1c18fd3">setParameterList</a> (const Teuchos::RCP&lt; Teuchos::ParameterList &gt; &amp;plist)</td></tr>
<tr class="memdesc:a9f0c04a63398a027d1f6786cb1c18fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the preconditioner's parameters.  <br /></td></tr>
<tr class="separator:a9f0c04a63398a027d1f6786cb1c18fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642638dae0dc2ec78f51441bcbe69e48" id="r_a642638dae0dc2ec78f51441bcbe69e48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a642638dae0dc2ec78f51441bcbe69e48">setZeroStartingSolution</a> (bool zeroStartingSolution)</td></tr>
<tr class="memdesc:a642638dae0dc2ec78f51441bcbe69e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this preconditioner's parameters.  <br /></td></tr>
<tr class="separator:a642638dae0dc2ec78f51441bcbe69e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e74ce0ff0ff76f91f8dbadb0b6e35fd" id="r_a1e74ce0ff0ff76f91f8dbadb0b6e35fd"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const Teuchos::ParameterList &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a1e74ce0ff0ff76f91f8dbadb0b6e35fd">getValidParameters</a> () const</td></tr>
<tr class="memdesc:a1e74ce0ff0ff76f91f8dbadb0b6e35fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of the preconditioner's default parameters.  <br /></td></tr>
<tr class="separator:a1e74ce0ff0ff76f91f8dbadb0b6e35fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0b6817bd8d40a9f42c20a68c2a2ff8" id="r_a9e0b6817bd8d40a9f42c20a68c2a2ff8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a9e0b6817bd8d40a9f42c20a68c2a2ff8">initialize</a> ()</td></tr>
<tr class="memdesc:a9e0b6817bd8d40a9f42c20a68c2a2ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes all (graph-related) data necessary to initialize the preconditioner.  <br /></td></tr>
<tr class="separator:a9e0b6817bd8d40a9f42c20a68c2a2ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158c27f6228e9d204859c5f9f1a8f11d" id="r_a158c27f6228e9d204859c5f9f1a8f11d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a158c27f6228e9d204859c5f9f1a8f11d">isInitialized</a> () const</td></tr>
<tr class="memdesc:a158c27f6228e9d204859c5f9f1a8f11d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the preconditioner has been successfully initialized, false otherwise.  <br /></td></tr>
<tr class="separator:a158c27f6228e9d204859c5f9f1a8f11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b1933ab6e91582cf7cec4ab5754a0b" id="r_ac9b1933ab6e91582cf7cec4ab5754a0b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#ac9b1933ab6e91582cf7cec4ab5754a0b">compute</a> ()</td></tr>
<tr class="memdesc:ac9b1933ab6e91582cf7cec4ab5754a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes all (coefficient) data necessary to apply the preconditioner.  <br /></td></tr>
<tr class="separator:ac9b1933ab6e91582cf7cec4ab5754a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67c73bf1ec2bd0bba141dda7276cf32" id="r_ae67c73bf1ec2bd0bba141dda7276cf32"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#ae67c73bf1ec2bd0bba141dda7276cf32">isComputed</a> () const</td></tr>
<tr class="memdesc:ae67c73bf1ec2bd0bba141dda7276cf32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the preconditioner has been successfully computed, false otherwise.  <br /></td></tr>
<tr class="separator:ae67c73bf1ec2bd0bba141dda7276cf32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a700f20c633523e88248af48db6b46" id="r_ae9a700f20c633523e88248af48db6b46"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#ae9a700f20c633523e88248af48db6b46">getNumInitialize</a> () const</td></tr>
<tr class="memdesc:ae9a700f20c633523e88248af48db6b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of calls to <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a9e0b6817bd8d40a9f42c20a68c2a2ff8" title="Computes all (graph-related) data necessary to initialize the preconditioner.">initialize()</a>.  <br /></td></tr>
<tr class="separator:ae9a700f20c633523e88248af48db6b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74982fef4a6fab41e5f60b14949284d7" id="r_a74982fef4a6fab41e5f60b14949284d7"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a74982fef4a6fab41e5f60b14949284d7">getNumCompute</a> () const</td></tr>
<tr class="memdesc:a74982fef4a6fab41e5f60b14949284d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of calls to <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#ac9b1933ab6e91582cf7cec4ab5754a0b" title="Computes all (coefficient) data necessary to apply the preconditioner.">compute()</a>.  <br /></td></tr>
<tr class="separator:a74982fef4a6fab41e5f60b14949284d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8982a6cbd5a98f4f44072b9768c050d4" id="r_a8982a6cbd5a98f4f44072b9768c050d4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a8982a6cbd5a98f4f44072b9768c050d4">getNumApply</a> () const</td></tr>
<tr class="memdesc:a8982a6cbd5a98f4f44072b9768c050d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of calls to <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#ae463a2043410145bf10070f5a9791120" title="Apply the preconditioner to X, putting the result in Y.">apply()</a>.  <br /></td></tr>
<tr class="separator:a8982a6cbd5a98f4f44072b9768c050d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab012cc08c468e42c77b94c2fb473a3b1" id="r_ab012cc08c468e42c77b94c2fb473a3b1"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#ab012cc08c468e42c77b94c2fb473a3b1">getInitializeTime</a> () const</td></tr>
<tr class="memdesc:ab012cc08c468e42c77b94c2fb473a3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time spent in <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a9e0b6817bd8d40a9f42c20a68c2a2ff8" title="Computes all (graph-related) data necessary to initialize the preconditioner.">initialize()</a>.  <br /></td></tr>
<tr class="separator:ab012cc08c468e42c77b94c2fb473a3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a77b9d54b2f9bd97cce1ac532ed90f3" id="r_a8a77b9d54b2f9bd97cce1ac532ed90f3"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a8a77b9d54b2f9bd97cce1ac532ed90f3">getComputeTime</a> () const</td></tr>
<tr class="memdesc:a8a77b9d54b2f9bd97cce1ac532ed90f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time spent in <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#ac9b1933ab6e91582cf7cec4ab5754a0b" title="Computes all (coefficient) data necessary to apply the preconditioner.">compute()</a>.  <br /></td></tr>
<tr class="separator:a8a77b9d54b2f9bd97cce1ac532ed90f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9b4d764071db9b6f4c5fcfb563dd12" id="r_a8c9b4d764071db9b6f4c5fcfb563dd12"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a8c9b4d764071db9b6f4c5fcfb563dd12">getApplyTime</a> () const</td></tr>
<tr class="memdesc:a8c9b4d764071db9b6f4c5fcfb563dd12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time spent in <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#ae463a2043410145bf10070f5a9791120" title="Apply the preconditioner to X, putting the result in Y.">apply()</a>.  <br /></td></tr>
<tr class="separator:a8c9b4d764071db9b6f4c5fcfb563dd12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classIfpack2_1_1Preconditioner"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classIfpack2_1_1Preconditioner')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classIfpack2_1_1Preconditioner.html">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a></td></tr>
<tr class="memitem:a637973211128e0c09db53772df0f345d inherit pub_methods_classIfpack2_1_1Preconditioner" id="r_a637973211128e0c09db53772df0f345d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Preconditioner.html#a637973211128e0c09db53772df0f345d">~Preconditioner</a> ()</td></tr>
<tr class="memdesc:a637973211128e0c09db53772df0f345d inherit pub_methods_classIfpack2_1_1Preconditioner"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a637973211128e0c09db53772df0f345d inherit pub_methods_classIfpack2_1_1Preconditioner"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html">Ifpack2::Details::CanChangeMatrix&lt; Tpetra::RowMatrix&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt; &gt;</a></td></tr>
<tr class="memitem:acad726ffa06a9eef5d675364f996101a inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix" id="r_acad726ffa06a9eef5d675364f996101a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">virtual</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html#acad726ffa06a9eef5d675364f996101a">setMatrix</a> (<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> Tpetra::RowMatrix&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt; &gt; &amp;A)=0</td></tr>
<tr class="memdesc:acad726ffa06a9eef5d675364f996101a inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the new matrix.  <br /></td></tr>
<tr class="separator:acad726ffa06a9eef5d675364f996101a inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad9626e6fa50980dc192a4a63341c12 inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix" id="r_abad9626e6fa50980dc192a4a63341c12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">virtual</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html#abad9626e6fa50980dc192a4a63341c12">~CanChangeMatrix</a> ()</td></tr>
<tr class="memdesc:abad9626e6fa50980dc192a4a63341c12 inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:abad9626e6fa50980dc192a4a63341c12 inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Typedefs</h2></td></tr>
<tr class="memitem:acf7c70ef80e46563df3dce419a942c12" id="r_acf7c70ef80e46563df3dce419a942c12"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#acf7c70ef80e46563df3dce419a942c12">scalar_type</a> = typename MatrixType::scalar_type</td></tr>
<tr class="memdesc:acf7c70ef80e46563df3dce419a942c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the entries of the input MatrixType.  <br /></td></tr>
<tr class="separator:acf7c70ef80e46563df3dce419a942c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03cd0d9306aa5b0c198b290c22c55bd4" id="r_a03cd0d9306aa5b0c198b290c22c55bd4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a03cd0d9306aa5b0c198b290c22c55bd4">local_ordinal_type</a> = typename MatrixType::local_ordinal_type</td></tr>
<tr class="memdesc:a03cd0d9306aa5b0c198b290c22c55bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of local indices in the input MatrixType.  <br /></td></tr>
<tr class="separator:a03cd0d9306aa5b0c198b290c22c55bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f0a86bb9aa205906c0f8bb969652f1" id="r_a40f0a86bb9aa205906c0f8bb969652f1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a40f0a86bb9aa205906c0f8bb969652f1">global_ordinal_type</a> = typename MatrixType::global_ordinal_type</td></tr>
<tr class="memdesc:a40f0a86bb9aa205906c0f8bb969652f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of global indices in the input MatrixType.  <br /></td></tr>
<tr class="separator:a40f0a86bb9aa205906c0f8bb969652f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91956faa61adf87bd84fdd10d1262bba" id="r_a91956faa61adf87bd84fdd10d1262bba"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a91956faa61adf87bd84fdd10d1262bba">node_type</a> = typename MatrixType::node_type</td></tr>
<tr class="memdesc:a91956faa61adf87bd84fdd10d1262bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Node type used by the input MatrixType.  <br /></td></tr>
<tr class="separator:a91956faa61adf87bd84fdd10d1262bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1d91a1a28979d99448e8ae1f0d7510" id="r_a8e1d91a1a28979d99448e8ae1f0d7510"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a8e1d91a1a28979d99448e8ae1f0d7510">magnitude_type</a> = typename Teuchos::ScalarTraits&lt; <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#acf7c70ef80e46563df3dce419a942c12">scalar_type</a> &gt;::magnitudeType</td></tr>
<tr class="memdesc:a8e1d91a1a28979d99448e8ae1f0d7510"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the magnitude (absolute value) of a matrix entry.  <br /></td></tr>
<tr class="separator:a8e1d91a1a28979d99448e8ae1f0d7510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8280a3834b6ab4cb867c1b11c9bf40" id="r_afc8280a3834b6ab4cb867c1b11c9bf40"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#afc8280a3834b6ab4cb867c1b11c9bf40">row_matrix_type</a> = Tpetra::RowMatrix&lt; <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#acf7c70ef80e46563df3dce419a942c12">scalar_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a03cd0d9306aa5b0c198b290c22c55bd4">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a40f0a86bb9aa205906c0f8bb969652f1">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a91956faa61adf87bd84fdd10d1262bba">node_type</a> &gt;</td></tr>
<tr class="memdesc:afc8280a3834b6ab4cb867c1b11c9bf40"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Tpetra::RowMatrix specialization matching MatrixType.  <br /></td></tr>
<tr class="separator:afc8280a3834b6ab4cb867c1b11c9bf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d2b3d548504428b223de6304ca7082" id="r_a45d2b3d548504428b223de6304ca7082"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a45d2b3d548504428b223de6304ca7082">crs_matrix_type</a> = Tpetra::CrsMatrix&lt; <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#acf7c70ef80e46563df3dce419a942c12">scalar_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a03cd0d9306aa5b0c198b290c22c55bd4">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a40f0a86bb9aa205906c0f8bb969652f1">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a91956faa61adf87bd84fdd10d1262bba">node_type</a> &gt;</td></tr>
<tr class="memdesc:a45d2b3d548504428b223de6304ca7082"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Tpetra::CrsMatrix specialization that is a subclass of MatrixType.  <br /></td></tr>
<tr class="separator:a45d2b3d548504428b223de6304ca7082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af180875edc793d4d6d7055b78d3817aa" id="r_af180875edc793d4d6d7055b78d3817aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#af180875edc793d4d6d7055b78d3817aa">AdditiveSchwarz</a> (const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#afc8280a3834b6ab4cb867c1b11c9bf40">row_matrix_type</a> &gt; &amp;A)</td></tr>
<tr class="memdesc:af180875edc793d4d6d7055b78d3817aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that takes a matrix.  <br /></td></tr>
<tr class="separator:af180875edc793d4d6d7055b78d3817aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f313179d5e076ec15bef4a4266082e2" id="r_a8f313179d5e076ec15bef4a4266082e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a8f313179d5e076ec15bef4a4266082e2">AdditiveSchwarz</a> (const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#afc8280a3834b6ab4cb867c1b11c9bf40">row_matrix_type</a> &gt; &amp;A, const int overlapLevel)</td></tr>
<tr class="memdesc:a8f313179d5e076ec15bef4a4266082e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that takes a matrix and the level of overlap.  <br /></td></tr>
<tr class="separator:a8f313179d5e076ec15bef4a4266082e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8233805f2ea4655356addc78611aebbd" id="r_a8233805f2ea4655356addc78611aebbd"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a8233805f2ea4655356addc78611aebbd">~AdditiveSchwarz</a> ()=default</td></tr>
<tr class="memdesc:a8233805f2ea4655356addc78611aebbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a8233805f2ea4655356addc78611aebbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Implementation of Teuchos::Describable</h2></td></tr>
<tr class="memitem:a12f06f14dd801f34b3a14827264bf867" id="r_a12f06f14dd801f34b3a14827264bf867"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a12f06f14dd801f34b3a14827264bf867">description</a> () const</td></tr>
<tr class="memdesc:a12f06f14dd801f34b3a14827264bf867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a simple one-line description of this object.  <br /></td></tr>
<tr class="separator:a12f06f14dd801f34b3a14827264bf867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8633421325c240c8f53b6a644e30daa" id="r_ad8633421325c240c8f53b6a644e30daa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#ad8633421325c240c8f53b6a644e30daa">describe</a> (Teuchos::FancyOStream &amp;out, const Teuchos::EVerbosityLevel verbLevel=Teuchos::Describable::verbLevel_default) const</td></tr>
<tr class="memdesc:ad8633421325c240c8f53b6a644e30daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the object with some verbosity level to an FancyOStream object.  <br /></td></tr>
<tr class="separator:ad8633421325c240c8f53b6a644e30daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb92f2748a154a18e722910911240088" id="r_acb92f2748a154a18e722910911240088"><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#acb92f2748a154a18e722910911240088">print</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:acb92f2748a154a18e722910911240088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints basic information on iostream. This function is used by operator&lt;&lt;.  <br /></td></tr>
<tr class="separator:acb92f2748a154a18e722910911240088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9d71df75e7174419f10838a1b341b8" id="r_a1d9d71df75e7174419f10838a1b341b8"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a1d9d71df75e7174419f10838a1b341b8">getOverlapLevel</a> () const</td></tr>
<tr class="memdesc:a1d9d71df75e7174419f10838a1b341b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the level of overlap.  <br /></td></tr>
<tr class="separator:a1d9d71df75e7174419f10838a1b341b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classIfpack2_1_1Preconditioner"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classIfpack2_1_1Preconditioner')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classIfpack2_1_1Preconditioner.html">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a></td></tr>
<tr class="memitem:a222c0e260ac8dc1226573e8a0773ac63 inherit pub_types_classIfpack2_1_1Preconditioner" id="r_a222c0e260ac8dc1226573e8a0773ac63"><td class="memItemLeft" align="right" valign="top">typedef Teuchos::ScalarTraits&lt; MatrixType::scalar_type &gt;::magnitudeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Preconditioner.html#a222c0e260ac8dc1226573e8a0773ac63">magnitude_type</a></td></tr>
<tr class="memdesc:a222c0e260ac8dc1226573e8a0773ac63 inherit pub_types_classIfpack2_1_1Preconditioner"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the magnitude (absolute value) of a matrix entry.  <br /></td></tr>
<tr class="separator:a222c0e260ac8dc1226573e8a0773ac63 inherit pub_types_classIfpack2_1_1Preconditioner"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class MatrixType, class LocalInverseType = Preconditioner&lt;typename MatrixType::scalar_type,                             typename MatrixType::local_ordinal_type,                             typename MatrixType::global_ordinal_type,                             typename MatrixType::node_type&gt;&gt;<br />
class Ifpack2::AdditiveSchwarz&lt; MatrixType, LocalInverseType &gt;</div><p>Additive Schwarz domain decomposition for Tpetra sparse matrices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>A specialization of Tpetra::RowMatrix </td></tr>
    <tr><td class="paramname">LocalInverseType</td><td>The type of the solver for the local (subdomain) problem. DO NOT USE ANY TYPE HERE OTHER THAN <a class="el" href="classIfpack2_1_1Preconditioner.html" title="Interface for all Ifpack2 preconditioners.">Ifpack2::Preconditioner</a>. The default is perfectly fine. This template parameter only exists for backwards compatibility.</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Ifpack2_AdditiveSchwarz_Summary"></a>
Summary</h1>
<p>This class implements Additive Schwarz domain decomposition, with optional overlap. It operates on a given Tpetra::RowMatrix. Each subdomain corresponds to exactly one MPI process in the given matrix's MPI communicator. For nonoverlapping domain decomposition <em>within</em> an MPI process, please use <a class="el" href="classIfpack2_1_1BlockRelaxation.html" title="Block relaxation preconditioners (or smoothers) for Tpetra::RowMatrix and Tpetra::CrsMatrix sparse ma...">BlockRelaxation</a>.</p>
<p>This class is a subclass of Tpetra::Operator, like all other subclasses of <a class="el" href="classIfpack2_1_1Preconditioner.html" title="Interface for all Ifpack2 preconditioners.">Preconditioner</a>. Thus, the <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#ae463a2043410145bf10070f5a9791120" title="Apply the preconditioner to X, putting the result in Y.">apply()</a> method applies the preconditioner to a multivector.</p>
<h1><a class="anchor" id="Ifpack2_AdditiveSchwarz_Alg"></a>
Algorithm</h1>
<p>One-level overlapping domain decomposition preconditioners use local solvers of Dirichlet type. This means that the solver effectively applies the inverse of the local matrix (possibly with overlap) to the residual to be preconditioned.</p>
<p>The preconditioner can be written as:  </p><p class="formulaDsp">
\[
P_{AS}^{-1} = \sum_{i=1}^M P_i A_i^{-1} R_i,
\]
</p>
<p> where \(M\) is the number of subdomains (in this case, the number of (MPI) processes in the computation), \(R_i\) is an operator that restricts the global vector to the vector lying on subdomain \(i\), \(P_i\) is the prolongator operator, and  </p><p class="formulaDsp">
\[
A_i = R_i A P_i.
\]
</p>
<p>Constructing a Schwarz preconditioner takes two steps: </p><ol>
<li>
Definition of the restriction and prolongation operators  </li>
<li>
Definition of a solver for linear systems involving \(A_i\)  </li>
</ol>
<p>The definition of the restriction and prolongation operators \(R_i\) and \(R_i^T\) depends on the level of overlap. If the overlap level is zero (no overlap), their implementation is trivial; \(R_i\) will return all the local components. For nonzero overlap, Tpetra's data redistribution facilities (Tpetra::Import) will be used to bring in the required data. Users may control how these data are combined with existing data, by setting the combine mode parameter. Valid combine modes include "ADD", "INSERT", "REPLACE", "ABSMAX", and "ZERO". These correspond to the valid values of Tpetra::CombineMode.</p>
<p>To solve linear systems involving \(A_i\) on each subdomain, the user can adopt any subclass of <a class="el" href="classIfpack2_1_1Preconditioner.html" title="Interface for all Ifpack2 preconditioners.">Preconditioner</a>. Users must set this at run time by specifying the inner solver in the ParameterList, or by setting the inner solver instance explicitly.</p>
<p>The local matrix \(A_i\) can be filtered, to eliminate singletons, and reordered. At the present time, the only available reordering algorithm is RCM (reverse Cuthill-Mckee). Other orderings will be supported by the Zoltan2 package in the future.</p>
<h1><a class="anchor" id="Additive"></a>
Schwarz algorithms supported</h1>
<p>The default is Restricted Additive Schwarz (RAS), which uses CombineMode Zero, see discussion below. Note that RAS does not preserve symmetry, so is generally not suitable as a preconditioner for CG. Classical Additive Schwarz is supported by setting the CombineMode to Add.</p>
<h1><a class="anchor" id="Ifpack2_AdditiveSchwarz_CombineMode"></a>
Combine modes</h1>
<p><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html" title="Additive Schwarz domain decomposition for Tpetra sparse matrices.">AdditiveSchwarz</a> supports different <em>combine modes</em>. These are rules for combining overlapping entries from the subdomain solves' results, to form the final additive Schwarz result. The two modes that users will likely find most useful are "Add" and "Zero". "Add" sums overlapping results, and "Zero" ignores them.</p>
<p>The Zero combine mode can be a bit confusing. It helps to compare the Add combine mode without overlap, to the Zero combine mode with overlap. Consider the following 4 x 4 linear system \(Ax = b\), where  </p><p class="formulaDsp">
\[
A =
\left(
\begin{array}{rrrr}
  2 &amp; -1 &amp;  0 &amp;  0 \\
 -1 &amp;  2 &amp; -1 &amp;  0 \\
  0 &amp; -1 &amp;  2 &amp; -1 \\
  0 &amp;  0 &amp; -1 &amp;  2
\end{array} \right)
\]
</p>
<p> and  </p><p class="formulaDsp">
\[
b =
\left(
\begin{array}{rrrr}
  1 \\
  4 \\
  9 \\
 16
\end{array} \right)
.
\]
</p>
<p> Suppose that we give the first two rows of A and b to Process 0, and the last two rows of A and b to Process 1.</p>
<p>If we use additive Schwarz without overlap, and use the Add combine mode, then each process must solve a linear system with the following 2 x 2 matrix:  </p><p class="formulaDsp">
\[
A_{local} =
\left(
\begin{array}{rr}
  2 &amp; -1 \\
 -1 &amp;  2
\end{array} \right).
\]
</p>
<p> The inverse of this matrix is  </p><p class="formulaDsp">
\[
A_{local}^{-1} =
\frac{1}{3} \cdot
\left(
\begin{array}{rr}
  2 &amp;  1 \\
  1 &amp;  2
\end{array} \right).
\]
</p>
<p>Process 0 gets the right-hand side \((1, 4)^T\) and thus the local solution \((2, 3)^T\). Process 1 gets the right-hand side \((9,
16)^T\) and thus the local solution \((34/3, 41/3)^T\). The Add combine mode sums entries corresponding to overlap, but in this case there is no overlap, so we just concatenate the local results. Thus, the result of applying additive Schwarz once is  </p><p class="formulaDsp">
\[
x_{Add} =
\begin{array}{r}
   2 \\
   3 \\
34/3 \\
41/3
\end{array}.
\]
</p>
<p>If we introduce one level of overlap on each of these processes, and use the Zero combine mode with additive Schwarz, then each process has to solve a linear system with the following 3 x 3 matrix:  </p><p class="formulaDsp">
\[
A_{local} =
\left(
\begin{array}{rrr}
  2 &amp; -1 &amp;  0 \\
 -1 &amp;  2 &amp; -1 \\
  0 &amp; -1 &amp;  2
\end{array} \right).
\]
</p>
<p> The inverse of this matrix is  </p><p class="formulaDsp">
\[
A_{local}^{-1} =
\frac{1}{4} \cdot
\left(
\begin{array}{rrr}
  3 &amp;  2 &amp;  1 \\
  2 &amp;  4 &amp;  2 \\
  1 &amp;  2 &amp;  3
\end{array} \right).
\]
</p>
<p> Process 0 gets the right-hand side \((1, 4, 9)^T\) and thus the local solution \((5, 9, 9)^T\). Process 1 gets the right-hand side \((4, 9, 16)^T\) and thus the local solution \((23/2, 19,
35/2)^T\). The Zero combine mode ignores "remote entries," so that the result of applying additive Schwarz once is  </p><p class="formulaDsp">
\[
x_{Zero} =
\begin{array}{r}
   5 \\
   9 \\
  19 \\
35/2
\end{array}.
\]
</p>
<p>Even though both of the above examples combine the local results in the same way, Zero produces a different final result than Add, because the Zero example uses overlap 1, whereas the Add example uses overlap 0.</p>
<h1><a class="anchor" id="Ifpack2_AdditiveSchwarz_subdomain"></a>
Subdomain solver</h1>
<p>This class gives you two ways to specify the subdomain solver. First, you may set the "subdomain solver name" or "inner preconditioner name" parameters in the input to <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#add5bfd4d070f5a609550fb8db7eaa6bd" title="Set the preconditioner&#39;s parameters.">setParameters()</a> or <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a9f0c04a63398a027d1f6786cb1c18fd3" title="Set the preconditioner&#39;s parameters.">setParameterList()</a>. Second, you may construct the subdomain solver yourself, as an <a class="el" href="classIfpack2_1_1Preconditioner.html" title="Interface for all Ifpack2 preconditioners.">Ifpack2::Preconditioner</a> instance, and give it to <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#aae1e81fa9b86f093f5a235073083a4bf" title="Set the inner preconditioner.">setInnerPreconditioner()</a>.</p>
<p>Please refer to the documentation of setParameters for a complete discussion of subdomain solvers and their parameters. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="acf7c70ef80e46563df3dce419a942c12" name="acf7c70ef80e46563df3dce419a942c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf7c70ef80e46563df3dce419a942c12">&#9670;&#160;</a></span>scalar_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType  = Preconditioner&lt;typename MatrixType::scalar_type,                             typename MatrixType::local_ordinal_type,                             typename MatrixType::global_ordinal_type,                             typename MatrixType::node_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::scalar_type =  typename MatrixType::scalar_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the entries of the input MatrixType. </p>

</div>
</div>
<a id="a03cd0d9306aa5b0c198b290c22c55bd4" name="a03cd0d9306aa5b0c198b290c22c55bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03cd0d9306aa5b0c198b290c22c55bd4">&#9670;&#160;</a></span>local_ordinal_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType  = Preconditioner&lt;typename MatrixType::scalar_type,                             typename MatrixType::local_ordinal_type,                             typename MatrixType::global_ordinal_type,                             typename MatrixType::node_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::local_ordinal_type =  typename MatrixType::local_ordinal_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of local indices in the input MatrixType. </p>

</div>
</div>
<a id="a40f0a86bb9aa205906c0f8bb969652f1" name="a40f0a86bb9aa205906c0f8bb969652f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f0a86bb9aa205906c0f8bb969652f1">&#9670;&#160;</a></span>global_ordinal_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType  = Preconditioner&lt;typename MatrixType::scalar_type,                             typename MatrixType::local_ordinal_type,                             typename MatrixType::global_ordinal_type,                             typename MatrixType::node_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::global_ordinal_type =  typename MatrixType::global_ordinal_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of global indices in the input MatrixType. </p>

</div>
</div>
<a id="a91956faa61adf87bd84fdd10d1262bba" name="a91956faa61adf87bd84fdd10d1262bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91956faa61adf87bd84fdd10d1262bba">&#9670;&#160;</a></span>node_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType  = Preconditioner&lt;typename MatrixType::scalar_type,                             typename MatrixType::local_ordinal_type,                             typename MatrixType::global_ordinal_type,                             typename MatrixType::node_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::node_type =  typename MatrixType::node_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Node type used by the input MatrixType. </p>

</div>
</div>
<a id="a8e1d91a1a28979d99448e8ae1f0d7510" name="a8e1d91a1a28979d99448e8ae1f0d7510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1d91a1a28979d99448e8ae1f0d7510">&#9670;&#160;</a></span>magnitude_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType  = Preconditioner&lt;typename MatrixType::scalar_type,                             typename MatrixType::local_ordinal_type,                             typename MatrixType::global_ordinal_type,                             typename MatrixType::node_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::magnitude_type =  typename Teuchos::ScalarTraits&lt;<a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#acf7c70ef80e46563df3dce419a942c12">scalar_type</a>&gt;::magnitudeType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the magnitude (absolute value) of a matrix entry. </p>

</div>
</div>
<a id="afc8280a3834b6ab4cb867c1b11c9bf40" name="afc8280a3834b6ab4cb867c1b11c9bf40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8280a3834b6ab4cb867c1b11c9bf40">&#9670;&#160;</a></span>row_matrix_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType  = Preconditioner&lt;typename MatrixType::scalar_type,                             typename MatrixType::local_ordinal_type,                             typename MatrixType::global_ordinal_type,                             typename MatrixType::node_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::row_matrix_type =  Tpetra::RowMatrix&lt;<a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#acf7c70ef80e46563df3dce419a942c12">scalar_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a03cd0d9306aa5b0c198b290c22c55bd4">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a40f0a86bb9aa205906c0f8bb969652f1">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a91956faa61adf87bd84fdd10d1262bba">node_type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Tpetra::RowMatrix specialization matching MatrixType. </p>

</div>
</div>
<a id="a45d2b3d548504428b223de6304ca7082" name="a45d2b3d548504428b223de6304ca7082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d2b3d548504428b223de6304ca7082">&#9670;&#160;</a></span>crs_matrix_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType  = Preconditioner&lt;typename MatrixType::scalar_type,                             typename MatrixType::local_ordinal_type,                             typename MatrixType::global_ordinal_type,                             typename MatrixType::node_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::crs_matrix_type =  Tpetra::CrsMatrix&lt;<a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#acf7c70ef80e46563df3dce419a942c12">scalar_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a03cd0d9306aa5b0c198b290c22c55bd4">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a40f0a86bb9aa205906c0f8bb969652f1">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a91956faa61adf87bd84fdd10d1262bba">node_type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Tpetra::CrsMatrix specialization that is a subclass of MatrixType. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af180875edc793d4d6d7055b78d3817aa" name="af180875edc793d4d6d7055b78d3817aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af180875edc793d4d6d7055b78d3817aa">&#9670;&#160;</a></span>AdditiveSchwarz() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::AdditiveSchwarz </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#afc8280a3834b6ab4cb867c1b11c9bf40">row_matrix_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor that takes a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>[in] The matrix to be preconditioned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f313179d5e076ec15bef4a4266082e2" name="a8f313179d5e076ec15bef4a4266082e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f313179d5e076ec15bef4a4266082e2">&#9670;&#160;</a></span>AdditiveSchwarz() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::AdditiveSchwarz </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#afc8280a3834b6ab4cb867c1b11c9bf40">row_matrix_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>overlapLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor that takes a matrix and the level of overlap. </p>
<dl class="section warning"><dt>Warning</dt><dd>This version of the constructor is DEPRECATED, because the single-argument version suffices; users may specify the overlap level via the "schwarz: overlap level" parameter.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>[in] The matrix to be preconditioned. </td></tr>
    <tr><td class="paramname">overlapLevel</td><td>[in] The level of overlap. Must be nonnegative. Zero means no overlap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8233805f2ea4655356addc78611aebbd" name="a8233805f2ea4655356addc78611aebbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8233805f2ea4655356addc78611aebbd">&#9670;&#160;</a></span>~AdditiveSchwarz()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType  = Preconditioner&lt;typename MatrixType::scalar_type,                             typename MatrixType::local_ordinal_type,                             typename MatrixType::global_ordinal_type,                             typename MatrixType::node_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::~<a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">AdditiveSchwarz</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abdb0838020aa181c7908fbc8bf351b19" name="abdb0838020aa181c7908fbc8bf351b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdb0838020aa181c7908fbc8bf351b19">&#9670;&#160;</a></span>getDomainMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const Tpetra::Map&lt; typename MatrixType::local_ordinal_type, typename MatrixType::global_ordinal_type, typename MatrixType::node_type &gt; &gt; <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::getDomainMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The domain Map of this operator. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#aafeb2143ff699f2289503a85f6e3523c">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="abce3edc4f76be4e46908df68e2a6f8be" name="abce3edc4f76be4e46908df68e2a6f8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce3edc4f76be4e46908df68e2a6f8be">&#9670;&#160;</a></span>getRangeMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const Tpetra::Map&lt; typename MatrixType::local_ordinal_type, typename MatrixType::global_ordinal_type, typename MatrixType::node_type &gt; &gt; <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::getRangeMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The range Map of this operator. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a75b32e1de03024035b00cd2ee95a60da">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="ae463a2043410145bf10070f5a9791120" name="ae463a2043410145bf10070f5a9791120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae463a2043410145bf10070f5a9791120">&#9670;&#160;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#acf7c70ef80e46563df3dce419a942c12">scalar_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a03cd0d9306aa5b0c198b290c22c55bd4">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a40f0a86bb9aa205906c0f8bb969652f1">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a91956faa61adf87bd84fdd10d1262bba">node_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#acf7c70ef80e46563df3dce419a942c12">scalar_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a03cd0d9306aa5b0c198b290c22c55bd4">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a40f0a86bb9aa205906c0f8bb969652f1">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a91956faa61adf87bd84fdd10d1262bba">node_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::ETransp&#160;</td>
          <td class="paramname"><em>mode</em> = <code>Teuchos::NO_TRANS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#acf7c70ef80e46563df3dce419a942c12">scalar_type</a>&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>Teuchos::ScalarTraits&lt;<a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#acf7c70ef80e46563df3dce419a942c12">scalar_type</a>&gt;::one()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#acf7c70ef80e46563df3dce419a942c12">scalar_type</a>&#160;</td>
          <td class="paramname"><em>beta</em> = <code>Teuchos::ScalarTraits&lt;<a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#acf7c70ef80e46563df3dce419a942c12">scalar_type</a>&gt;::zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the preconditioner to X, putting the result in Y. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a606c3f8155f67f2867fac3a7c44bd5df">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="aae1e81fa9b86f093f5a235073083a4bf" name="aae1e81fa9b86f093f5a235073083a4bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae1e81fa9b86f093f5a235073083a4bf">&#9670;&#160;</a></span>setInnerPreconditioner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::setInnerPreconditioner </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1Preconditioner.html">Preconditioner</a>&lt; <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#acf7c70ef80e46563df3dce419a942c12">scalar_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a03cd0d9306aa5b0c198b290c22c55bd4">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a40f0a86bb9aa205906c0f8bb969652f1">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a91956faa61adf87bd84fdd10d1262bba">node_type</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>innerPrec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the inner preconditioner. </p>
<p>Most users do not need to call this method. <a class="el" href="classIfpack2_1_1Factory.html" title="&quot;Factory&quot; for creating Ifpack2 preconditioners.">Factory</a> will handle calling this method if necessary. One case in which users might need to call this method, is if they implement their own subdomain solver as a subclass of <a class="el" href="classIfpack2_1_1Preconditioner.html" title="Interface for all Ifpack2 preconditioners.">Preconditioner</a>, and want to use that subdomain solver in this class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">innerPrec</td><td>[in/out] The inner preconditioner. Its matrix (if it has one) may be replaced by a matrix specified by the outer (this) preconditioner.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>CYCLIC DEPENDENCIES ARE FORBIDDEN. You may NOT give this object (<code>*this</code>) to itself as an inner solver, or otherwise set up a cyclic dependency between preconditioner instances. You MAY use an inner solver of the same TYPE as this object (as long as this makes sense mathematically), but it must be a different instance of that type.</dd></dl>
<p>It does not make sense to nest different instances of <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html" title="Additive Schwarz domain decomposition for Tpetra sparse matrices.">AdditiveSchwarz</a>, since it currently only sets up one subdomain per MPI process in the input matrix's communicator. Thus, if you were to use another <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html" title="Additive Schwarz domain decomposition for Tpetra sparse matrices.">AdditiveSchwarz</a> instance as the inner preconditioner for <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html" title="Additive Schwarz domain decomposition for Tpetra sparse matrices.">AdditiveSchwarz</a>, it would not do anything, since the inner preconditioner's input matrix would only have one process in its communicator. (<a class="el" href="classIfpack2_1_1AdditiveSchwarz.html" title="Additive Schwarz domain decomposition for Tpetra sparse matrices.">AdditiveSchwarz</a> does nothing in that case.)</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>&amp;*innerPrec != this</code>.</dd></dl>
<p>This method has collective semantics, because it may call <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a9e0b6817bd8d40a9f42c20a68c2a2ff8" title="Computes all (graph-related) data necessary to initialize the preconditioner.">initialize()</a> or <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#ac9b1933ab6e91582cf7cec4ab5754a0b" title="Computes all (coefficient) data necessary to apply the preconditioner.">compute()</a> on <code>innerPrec</code>, in order to synchronize the inner preconditioner's state with that of the <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html" title="Additive Schwarz domain decomposition for Tpetra sparse matrices.">AdditiveSchwarz</a> instance. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Details_1_1NestedPreconditioner.html#af189d08e80917acc9c2bb65a81563c38">Ifpack2::Details::NestedPreconditioner&lt; Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt; &gt;</a>.</p>

</div>
</div>
<a id="a8e80b7fc9b9922b44ec8e364800bc24b" name="a8e80b7fc9b9922b44ec8e364800bc24b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e80b7fc9b9922b44ec8e364800bc24b">&#9670;&#160;</a></span>setMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::setMatrix </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#afc8280a3834b6ab4cb867c1b11c9bf40">row_matrix_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the matrix to be preconditioned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>The new matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>! isInitialized ()</code> </dd>
<dd>
<code>! isComputed ()</code></dd></dl>
<p>Calling this method resets the preconditioner's state. After calling this method with a nonnull input, you must first call <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a9e0b6817bd8d40a9f42c20a68c2a2ff8" title="Computes all (graph-related) data necessary to initialize the preconditioner.">initialize()</a> and <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#ac9b1933ab6e91582cf7cec4ab5754a0b" title="Computes all (coefficient) data necessary to apply the preconditioner.">compute()</a> (in that order) before you may call <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#ae463a2043410145bf10070f5a9791120" title="Apply the preconditioner to X, putting the result in Y.">apply()</a>.</p>
<p>You may call this method with a null input. If A is null, then you may not call <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a9e0b6817bd8d40a9f42c20a68c2a2ff8" title="Computes all (graph-related) data necessary to initialize the preconditioner.">initialize()</a> or <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#ac9b1933ab6e91582cf7cec4ab5754a0b" title="Computes all (coefficient) data necessary to apply the preconditioner.">compute()</a> until you first call this method again with a nonnull input. This method invalidates any previous factorization whether or not A is null, so calling <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a8e80b7fc9b9922b44ec8e364800bc24b" title="Change the matrix to be preconditioned.">setMatrix()</a> with a null input is one way to clear the preconditioner's state (and free any memory that it may be using).</p>
<p>The new matrix A need not necessarily have the same Maps or even the same communicator as the original matrix. </p>

</div>
</div>
<a id="ae34796005a5e5998796bde799f71fbbe" name="ae34796005a5e5998796bde799f71fbbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34796005a5e5998796bde799f71fbbe">&#9670;&#160;</a></span>getMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const Tpetra::RowMatrix&lt; typename MatrixType::scalar_type, typename MatrixType::local_ordinal_type, typename MatrixType::global_ordinal_type, typename MatrixType::node_type &gt; &gt; <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::getMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The input matrix. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a4258d242e7ff6003c399da8f0a11d634">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="add5bfd4d070f5a609550fb8db7eaa6bd" name="add5bfd4d070f5a609550fb8db7eaa6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5bfd4d070f5a609550fb8db7eaa6bd">&#9670;&#160;</a></span>setParameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::setParameters </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>plist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the preconditioner's parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plist</td><td>[in] List of parameters.</td></tr>
  </table>
  </dd>
</dl>
<p>This version of the method takes a const list, as required by the <a class="el" href="classIfpack2_1_1Preconditioner.html" title="Interface for all Ifpack2 preconditioners.">Preconditioner</a> interface. <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a9f0c04a63398a027d1f6786cb1c18fd3" title="Set the preconditioner&#39;s parameters.">setParameterList()</a> takes a nonconst pointer to a list, in order to match the Teuchos::ParameterListAcceptor interface.</p>
<p>Both this method and <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a9f0c04a63398a027d1f6786cb1c18fd3" title="Set the preconditioner&#39;s parameters.">setParameterList()</a> have "delta" behavior. That is, if called twice with two different lists, any unspecified parameters in the new list retain their values in the old list.</p>
<p>In many cases, calling this method may require calling <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a9e0b6817bd8d40a9f42c20a68c2a2ff8" title="Computes all (graph-related) data necessary to initialize the preconditioner.">initialize()</a> and <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#ac9b1933ab6e91582cf7cec4ab5754a0b" title="Computes all (coefficient) data necessary to apply the preconditioner.">compute()</a> to recompute the preconditioner.</p>
<p>Accepted parameters include the following:</p><ul>
<li>"inner preconditioner name" or "subdomain solver name" or "schwarz: subdomain solver name" or "schwarz: inner
    preconditioner name" (<code>std::string</code>): the name of the subdomain solver. See discussion below.</li>
<li>"inner preconditioner parameters" or "subdomain solver
    parameters" or "schwarz: subdomain solver parameters" or "schwarz: inner preconditioner parameters" (sublist): parameters for the subdomain solver. If not provided, the subdomain solver will use its specific default parameters. See discussion below.</li>
<li>"schwarz: combine mode" (<code>std::string</code>): The rule for combining incoming data with existing data in overlap regions. Valid values include "ADD", "INSERT", "REPLACE", "ABSMAX", and "ZERO". These correspond to the valid values of Tpetra::CombineMode. The default combine mode is "ZERO", meaning that overlapping incoming entries from different processes are not combined. (See the class documentation for an explanation and example of the "ZERO" vs. "ADD" combine modes.)</li>
<li>"schwarz: overlap level" (<code>int</code>): The level of overlap. The default is zero, meaning no overlap.</li>
<li>"schwarz: use reordering" (<code>bool</code>): Whether to use Zoltan2 to do reordering. If true, then Trilinos must have been built with Zoltan2 and Xpetra enabled. Default is false.</li>
<li>"schwarz: subdomain id" (<code>int</code>): This option does not currently work.</li>
<li>"schwarz: filter singletons" (<code>bool</code>): If true, exclude rows with just a single entry on the calling process. Default is false.</li>
<li>"schwarz: num iterations" (<code>int</code>): Numter of iterations to perform. Default is 1.</li>
</ul>
<h1><a class="anchor" id="Ifpack2_AS_setParams_subd"></a>
Subdomain solver parameters</h1>
<h2><a class="anchor" id="Ifpack2_AS_setParams_subd_dflt"></a>
Default subdomain solver</h2>
<p>This class lets users specify any subdomain solver they want, by calling <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#aae1e81fa9b86f093f5a235073083a4bf" title="Set the inner preconditioner.">setInnerPreconditioner()</a>. However, users may instead specify the subdomain solver by setting the "inner
preconditioner name" parameter (or any of its aliases). If they choose to do so, they may use any <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> preconditioner. These include but are not necessarily limited to the following:</p>
<ul>
<li>"AMESOS2": Use Amesos2's interface to sparse direct solvers. This is only allowed if Trilinos was built with the Amesos2 package enabled. Otherwise, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html" title="Additive Schwarz domain decomposition for Tpetra sparse matrices.">AdditiveSchwarz</a> will throw an exception with an informative message.</li>
<li>"CHEBYSHEV": <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> iteration, implemented with Ifpack::Chebyshev. WARNING: This currently only works if the subdomain problem is real and symmetric positive definite.</li>
<li>"DENSE" or "LAPACK": Convert the subdomain matrix to a dense matrix, and use LAPACK's LU factorization with partial pivoting to factor it and solve subdomain problems. WARNING: This will take a lot of memory if the subdomain problem is large!</li>
<li>"DIAGONAL": <a class="el" href="classIfpack2_1_1Diagonal.html" title="Diagonal preconditioner.">Diagonal</a> scaling, implemented through <a class="el" href="classIfpack2_1_1Diagonal.html" title="Diagonal preconditioner.">Ifpack2::Diagonal</a></li>
<li>"ILUT": <a class="el" href="classIfpack2_1_1ILUT.html" title="ILUT (incomplete LU factorization with threshold) of a Tpetra sparse matrix.">ILUT</a> (incomplete LU with threshold), implemented with <a class="el" href="classIfpack2_1_1ILUT.html" title="ILUT (incomplete LU factorization with threshold) of a Tpetra sparse matrix.">Ifpack2::ILUT</a></li>
<li>"RELAXATION": Point relaxation (Jacobi, Gauss-Seidel, or symmetric Gauss-Seidel), implemented with <a class="el" href="classIfpack2_1_1Relaxation.html" title="Relaxation preconditioners for Tpetra::RowMatrix and Tpetra::CrsMatrix sparse matrices.">Ifpack2::Relaxation</a></li>
<li>"RILUK": ILU(k) (incomplete LU with fill level k), implemented with <a class="el" href="classIfpack2_1_1RILUK.html" title="ILU(k) factorization of a given Tpetra::RowMatrix.">Ifpack2::RILUK</a></li>
</ul>
<p>This name <em>need not necessarily</em> correspond with <code>LocalInverseType</code>. If the user does <em>not</em> specify this parameter, the following procedure specifies the default: </p><ol>
<li>
If <code>LocalInverseType</code> is just <a class="el" href="classIfpack2_1_1Preconditioner.html" title="Interface for all Ifpack2 preconditioners.">Preconditioner</a>, then this class uses a default, which is currently "ILUT".  </li>
<li>
If <code>LocalInverseType</code> is a concrete <a class="el" href="classIfpack2_1_1Preconditioner.html" title="Interface for all Ifpack2 preconditioners.">Preconditioner</a> subclass, and if that subclass is in the above supported list of subdomain solver types, then this class uses that subclass as the subdomain solver.  </li>
<li>
If <code>LocalInverseType</code> is a concrete <a class="el" href="classIfpack2_1_1Preconditioner.html" title="Interface for all Ifpack2 preconditioners.">Preconditioner</a> subclass, and if that subclass is <em>not</em> in the above supported list of subdomain solver types, then users have one of two options, both of which we discuss below.  </li>
</ol>
<p>The subdomain solver names "INVALID" and "CUSTOM" are reserved for internal use.</p>
<h2><a class="anchor" id="Ifpack2_AS_setParams_subd_arb"></a>
Arbitrary subdomain solvers</h2>
<p><a class="el" href="classIfpack2_1_1AdditiveSchwarz.html" title="Additive Schwarz domain decomposition for Tpetra sparse matrices.">AdditiveSchwarz</a> only knows, on its own, how to create "non-nested" preconditioners as inner preconditioners (i.e., subdomain solvers). It can't create nested preconditioners (e.g., <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html" title="Additive Schwarz domain decomposition for Tpetra sparse matrices.">AdditiveSchwarz</a> and SupportGraph) on its own as inner preconditioners, and it doesn't know how to create arbitrary subclasses of <a class="el" href="classIfpack2_1_1Preconditioner.html" title="Interface for all Ifpack2 preconditioners.">Ifpack2::Preconditioner</a> unless <a class="el" href="classIfpack2_1_1Factory.html" title="&quot;Factory&quot; for creating Ifpack2 preconditioners.">Ifpack2::Factory</a> knows how to create them.</p>
<p>This leaves users two options in order to have any preconditioner as <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html" title="Additive Schwarz domain decomposition for Tpetra sparse matrices.">AdditiveSchwarz</a>'s inner preconditioner: </p><ol>
<li>
If <a class="el" href="classIfpack2_1_1Factory.html" title="&quot;Factory&quot; for creating Ifpack2 preconditioners.">Ifpack2::Factory</a> knows how to create a preconditioner whose string name is <code>prec</code>, then users who don't want to create the inner preconditioner themselves must create <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html" title="Additive Schwarz domain decomposition for Tpetra sparse matrices.">AdditiveSchwarz</a> using <a class="el" href="classIfpack2_1_1Factory.html" title="&quot;Factory&quot; for creating Ifpack2 preconditioners.">Factory</a>, <em>not</em> by invoking <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html" title="Additive Schwarz domain decomposition for Tpetra sparse matrices.">AdditiveSchwarz</a>'s constructor themselves. <a class="el" href="classIfpack2_1_1Factory.html" title="&quot;Factory&quot; for creating Ifpack2 preconditioners.">Factory</a> will set up the inner preconditioner for them before it returns the <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html" title="Additive Schwarz domain decomposition for Tpetra sparse matrices.">AdditiveSchwarz</a> instance.  </li>
<li>
If <a class="el" href="classIfpack2_1_1Factory.html" title="&quot;Factory&quot; for creating Ifpack2 preconditioners.">Ifpack2::Factory</a> does <em>not</em> know how to create a preconditioner <code>prec</code> (for example, if it is not even implemented in <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a>), then users must create the inner preconditioner instance themselves, and give it to <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html" title="Additive Schwarz domain decomposition for Tpetra sparse matrices.">AdditiveSchwarz</a> using setInnerPreconditioner. In this case, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html" title="Additive Schwarz domain decomposition for Tpetra sparse matrices.">AdditiveSchwarz</a>'s ParameterList must not specify the inner preconditioner's name.  </li>
</ol>
<h2><a class="anchor" id="Ifpack2_AS_setParams_subd_inner"></a>
Subdomain solver parameters and setInnerPreconditioner</h2>
<p>Users are responsible for ensuring that the parameters they provide to <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#add5bfd4d070f5a609550fb8db7eaa6bd" title="Set the preconditioner&#39;s parameters.">setParameters()</a> are up to date. For example, if the users first set an inner preconditioner using <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#aae1e81fa9b86f093f5a235073083a4bf" title="Set the inner preconditioner.">setInnerPreconditioner()</a>, and then call <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#add5bfd4d070f5a609550fb8db7eaa6bd" title="Set the preconditioner&#39;s parameters.">setParameters()</a> with the "inner preconditioner name" parameter set, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html" title="Additive Schwarz domain decomposition for Tpetra sparse matrices.">AdditiveSchwarz</a> will get rid of the users' inner preconditioner and attempt to create a new inner preconditioner itself. Remember that <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html" title="Additive Schwarz domain decomposition for Tpetra sparse matrices.">AdditiveSchwarz</a>'s ParameterList has "delta" (relative) semantics! If you don't specify a parameter, the current state is not changed.</p>
<p>If you specify a sublist of parameters to give to the subdomain solver, <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#aae1e81fa9b86f093f5a235073083a4bf" title="Set the inner preconditioner.">setInnerPreconditioner()</a> does <em>not</em> pass that sublist to its argument. This is because we presume that if you call <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#aae1e81fa9b86f093f5a235073083a4bf" title="Set the inner preconditioner.">setInnerPreconditioner()</a>, the input subdomain solver probably has a type that <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html" title="Additive Schwarz domain decomposition for Tpetra sparse matrices.">AdditiveSchwarz</a> does not know how to create by itself, so the existing parameter list cannot apply.</p>
<p>On the other hand, if, after calling <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#aae1e81fa9b86f093f5a235073083a4bf" title="Set the inner preconditioner.">setInnerPreconditioner()</a>, you then call <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#add5bfd4d070f5a609550fb8db7eaa6bd" title="Set the preconditioner&#39;s parameters.">setParameters()</a>, we <em>do</em> pass any provided sublist of subdomain solver parameters to the inner solver. If no such sublist was provided, we do <em>not</em> call <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#add5bfd4d070f5a609550fb8db7eaa6bd" title="Set the preconditioner&#39;s parameters.">setParameters()</a> on the inner solver.</p>
<p>The reason the last sentence matters is because not every inner solver necessarily has "delta" semantics for <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#add5bfd4d070f5a609550fb8db7eaa6bd" title="Set the preconditioner&#39;s parameters.">setParameters()</a>. "Delta" or "relative" semantics means that an empty input ParameterList doesn't change any existing parameters. "Non-delta" or "absolute" semantics means that an empty input ParameterList causes all parameters to be set to their default values. (The difference matters if the user has called <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#add5bfd4d070f5a609550fb8db7eaa6bd" title="Set the preconditioner&#39;s parameters.">setParameters()</a> before on the subdomain solver, with nondefault values.) If the user didn't specify a sublist for the inner solver, we assume that the user doesn't want to change the inner solver's parameters. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a60340992fc1b9eac82ef35333bee6efd">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a9f0c04a63398a027d1f6786cb1c18fd3" name="a9f0c04a63398a027d1f6786cb1c18fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0c04a63398a027d1f6786cb1c18fd3">&#9670;&#160;</a></span>setParameterList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::setParameterList </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::RCP&lt; Teuchos::ParameterList &gt; &amp;&#160;</td>
          <td class="paramname"><em>plist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the preconditioner's parameters. </p>
<p>This version of the method takes a nonconst pointer to a list, in order to match the Teuchos::ParameterListAcceptor interface. <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#add5bfd4d070f5a609550fb8db7eaa6bd" title="Set the preconditioner&#39;s parameters.">setParameters()</a> takes a const list, as required by the <a class="el" href="classIfpack2_1_1Preconditioner.html" title="Interface for all Ifpack2 preconditioners.">Preconditioner</a> interface.</p>
<p>Both this method and <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a9f0c04a63398a027d1f6786cb1c18fd3" title="Set the preconditioner&#39;s parameters.">setParameterList()</a> have "delta" behavior. That is, if called twice with two different lists, any unspecified parameters in the new list retain their values in the old list.</p>
<p>In many cases, calling this method may require calling <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a9e0b6817bd8d40a9f42c20a68c2a2ff8" title="Computes all (graph-related) data necessary to initialize the preconditioner.">initialize()</a> and <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#ac9b1933ab6e91582cf7cec4ab5754a0b" title="Computes all (coefficient) data necessary to apply the preconditioner.">compute()</a> to recompute the preconditioner.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plist</td><td>[in/out] On input: List of parameters, or Teuchos::null (meaning "do not change the current parameter
  values"). On output: If nonnull, any missing parameters are filled in with their current values (or their default values, if they have not yet been set).</td></tr>
  </table>
  </dd>
</dl>
<p>See the documentation of <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#add5bfd4d070f5a609550fb8db7eaa6bd" title="Set the preconditioner&#39;s parameters.">setParameters()</a> for a list of the parameters this method accepts, and their default values. </p>

</div>
</div>
<a id="a642638dae0dc2ec78f51441bcbe69e48" name="a642638dae0dc2ec78f51441bcbe69e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642638dae0dc2ec78f51441bcbe69e48">&#9670;&#160;</a></span>setZeroStartingSolution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType  = Preconditioner&lt;typename MatrixType::scalar_type,                             typename MatrixType::local_ordinal_type,                             typename MatrixType::global_ordinal_type,                             typename MatrixType::node_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::setZeroStartingSolution </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zeroStartingSolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this preconditioner's parameters. </p>

<p>Reimplemented from <a class="el" href="classIfpack2_1_1Preconditioner.html#a12495acd22d15212241c0d518d7f6536">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a1e74ce0ff0ff76f91f8dbadb0b6e35fd" name="a1e74ce0ff0ff76f91f8dbadb0b6e35fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e74ce0ff0ff76f91f8dbadb0b6e35fd">&#9670;&#160;</a></span>getValidParameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const Teuchos::ParameterList &gt; <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::getValidParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of the preconditioner's default parameters. </p>
<p>See the documentation of <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#add5bfd4d070f5a609550fb8db7eaa6bd" title="Set the preconditioner&#39;s parameters.">setParameters()</a> for a list of the parameters that <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html" title="Additive Schwarz domain decomposition for Tpetra sparse matrices.">AdditiveSchwarz</a> accepts. </p>

</div>
</div>
<a id="a9e0b6817bd8d40a9f42c20a68c2a2ff8" name="a9e0b6817bd8d40a9f42c20a68c2a2ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0b6817bd8d40a9f42c20a68c2a2ff8">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes all (graph-related) data necessary to initialize the preconditioner. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#ad3aefd6f16e8ef4cddb696cd23f160b0">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a158c27f6228e9d204859c5f9f1a8f11d" name="a158c27f6228e9d204859c5f9f1a8f11d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158c27f6228e9d204859c5f9f1a8f11d">&#9670;&#160;</a></span>isInitialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::isInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the preconditioner has been successfully initialized, false otherwise. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a180c876ccf7af87f10a1c1d08ba2dc01">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="ac9b1933ab6e91582cf7cec4ab5754a0b" name="ac9b1933ab6e91582cf7cec4ab5754a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b1933ab6e91582cf7cec4ab5754a0b">&#9670;&#160;</a></span>compute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::compute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes all (coefficient) data necessary to apply the preconditioner. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a23954dd69f62b56455a9c0988bbe9e67">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="ae67c73bf1ec2bd0bba141dda7276cf32" name="ae67c73bf1ec2bd0bba141dda7276cf32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67c73bf1ec2bd0bba141dda7276cf32">&#9670;&#160;</a></span>isComputed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::isComputed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the preconditioner has been successfully computed, false otherwise. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#abb5af77756a7488ab636dbd97483ca66">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="ae9a700f20c633523e88248af48db6b46" name="ae9a700f20c633523e88248af48db6b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a700f20c633523e88248af48db6b46">&#9670;&#160;</a></span>getNumInitialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::getNumInitialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of calls to <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a9e0b6817bd8d40a9f42c20a68c2a2ff8" title="Computes all (graph-related) data necessary to initialize the preconditioner.">initialize()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#afe6c77c5ab6da065f8dbade353e8535a">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a74982fef4a6fab41e5f60b14949284d7" name="a74982fef4a6fab41e5f60b14949284d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74982fef4a6fab41e5f60b14949284d7">&#9670;&#160;</a></span>getNumCompute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::getNumCompute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of calls to <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#ac9b1933ab6e91582cf7cec4ab5754a0b" title="Computes all (coefficient) data necessary to apply the preconditioner.">compute()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a286b18ee0769ecc8bf992dffdc442791">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a8982a6cbd5a98f4f44072b9768c050d4" name="a8982a6cbd5a98f4f44072b9768c050d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8982a6cbd5a98f4f44072b9768c050d4">&#9670;&#160;</a></span>getNumApply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::getNumApply </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of calls to <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#ae463a2043410145bf10070f5a9791120" title="Apply the preconditioner to X, putting the result in Y.">apply()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a565e6c00bf14873ae7b23187c9978078">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="ab012cc08c468e42c77b94c2fb473a3b1" name="ab012cc08c468e42c77b94c2fb473a3b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab012cc08c468e42c77b94c2fb473a3b1">&#9670;&#160;</a></span>getInitializeTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::getInitializeTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the time spent in <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#a9e0b6817bd8d40a9f42c20a68c2a2ff8" title="Computes all (graph-related) data necessary to initialize the preconditioner.">initialize()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#aeb91a16f5544ad4efaf756b1d2a8b39d">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a8a77b9d54b2f9bd97cce1ac532ed90f3" name="a8a77b9d54b2f9bd97cce1ac532ed90f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a77b9d54b2f9bd97cce1ac532ed90f3">&#9670;&#160;</a></span>getComputeTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::getComputeTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the time spent in <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#ac9b1933ab6e91582cf7cec4ab5754a0b" title="Computes all (coefficient) data necessary to apply the preconditioner.">compute()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a111d9bd4e28c0633696f271955ddcb4c">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a8c9b4d764071db9b6f4c5fcfb563dd12" name="a8c9b4d764071db9b6f4c5fcfb563dd12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9b4d764071db9b6f4c5fcfb563dd12">&#9670;&#160;</a></span>getApplyTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::getApplyTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the time spent in <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html#ae463a2043410145bf10070f5a9791120" title="Apply the preconditioner to X, putting the result in Y.">apply()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a57c2d00799de050cd2a5a75ce80f48b9">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a12f06f14dd801f34b3a14827264bf867" name="a12f06f14dd801f34b3a14827264bf867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f06f14dd801f34b3a14827264bf867">&#9670;&#160;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a simple one-line description of this object. </p>

</div>
</div>
<a id="ad8633421325c240c8f53b6a644e30daa" name="ad8633421325c240c8f53b6a644e30daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8633421325c240c8f53b6a644e30daa">&#9670;&#160;</a></span>describe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::describe </td>
          <td>(</td>
          <td class="paramtype">Teuchos::FancyOStream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::EVerbosityLevel&#160;</td>
          <td class="paramname"><em>verbLevel</em> = <code>Teuchos::Describable::verbLevel_default</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the object with some verbosity level to an FancyOStream object. </p>

</div>
</div>
<a id="acb92f2748a154a18e722910911240088" name="acb92f2748a154a18e722910911240088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb92f2748a154a18e722910911240088">&#9670;&#160;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints basic information on iostream. This function is used by operator&lt;&lt;. </p>

</div>
</div>
<a id="a1d9d71df75e7174419f10838a1b341b8" name="a1d9d71df75e7174419f10838a1b341b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9d71df75e7174419f10838a1b341b8">&#9670;&#160;</a></span>getOverlapLevel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class LocalInverseType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html">Ifpack2::AdditiveSchwarz</a>&lt; MatrixType, LocalInverseType &gt;::getOverlapLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the level of overlap. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Ifpack2__AdditiveSchwarz__decl_8hpp_source.html">Ifpack2_AdditiveSchwarz_decl.hpp</a></li>
<li><a class="el" href="Ifpack2__AdditiveSchwarz__def_8hpp_source.html">Ifpack2_AdditiveSchwarz_def.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
