<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ifpack2 Templated Preconditioning Package: Ifpack2::Chebyshev&lt; MatrixType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Ifpack2 Templated Preconditioning Package<span id="projectnumber">&#160;Version 1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceIfpack2.html">Ifpack2</a></li><li class="navelem"><a class="el" href="classIfpack2_1_1Chebyshev.html">Chebyshev</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classIfpack2_1_1Chebyshev-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ifpack2::Chebyshev&lt; MatrixType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Diagonally scaled <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> iteration for Tpetra sparse matrices.  
 <a href="classIfpack2_1_1Chebyshev.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Ifpack2__Chebyshev__decl_8hpp_source.html">Ifpack2_Chebyshev_decl.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Ifpack2::Chebyshev&lt; MatrixType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classIfpack2_1_1Chebyshev__inherit__graph.png" border="0" usemap="#aIfpack2_1_1Chebyshev_3_01MatrixType_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aIfpack2_1_1Chebyshev_3_01MatrixType_01_4_inherit__map" id="aIfpack2_1_1Chebyshev_3_01MatrixType_01_4_inherit__map">
<area shape="rect" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices." alt="" coords="771,117,921,157"/>
<area shape="rect" href="classIfpack2_1_1Preconditioner.html" title=" " alt="" coords="480,37,719,121"/>
<area shape="poly" title=" " alt="" coords="733,108,771,117,770,122,731,113"/>
<area shape="rect" href="classIfpack2_1_1Preconditioner.html" title="Interface for all Ifpack2 preconditioners." alt="" coords="23,50,195,105"/>
<area shape="poly" title=" " alt="" coords="209,75,480,76,480,81,209,80"/>
<area shape="rect" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html" title=" " alt="" coords="477,145,721,244"/>
<area shape="poly" title=" " alt="" coords="734,161,770,152,771,157,735,166"/>
<area shape="rect" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html" title="Mix&#45;in interface for preconditioners that can change their matrix after construction." alt="" coords="5,176,212,216"/>
<area shape="poly" title=" " alt="" coords="226,193,477,192,477,198,226,198"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Preconditioner computation methods</div></td></tr>
<tr class="memitem:ab0c464ffa718435c0dd10966647beda0" id="r_ab0c464ffa718435c0dd10966647beda0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#ab0c464ffa718435c0dd10966647beda0">setParameters</a> (const Teuchos::ParameterList &amp;params)</td></tr>
<tr class="memdesc:ab0c464ffa718435c0dd10966647beda0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set (or reset) parameters.  <br /></td></tr>
<tr class="separator:ab0c464ffa718435c0dd10966647beda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e182a4895893ccf12c294695d8c6fb" id="r_ac8e182a4895893ccf12c294695d8c6fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#ac8e182a4895893ccf12c294695d8c6fb">setZeroStartingSolution</a> (bool zeroStartingSolution)</td></tr>
<tr class="memdesc:ac8e182a4895893ccf12c294695d8c6fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this preconditioner's parameters.  <br /></td></tr>
<tr class="separator:ac8e182a4895893ccf12c294695d8c6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58de3ab7b5dc7fefd2f3f51e1dcef561" id="r_a58de3ab7b5dc7fefd2f3f51e1dcef561"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#a58de3ab7b5dc7fefd2f3f51e1dcef561">initialize</a> ()</td></tr>
<tr class="memdesc:a58de3ab7b5dc7fefd2f3f51e1dcef561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the preconditioner.  <br /></td></tr>
<tr class="separator:a58de3ab7b5dc7fefd2f3f51e1dcef561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8062a720fe81d7b03314563bda688004" id="r_a8062a720fe81d7b03314563bda688004"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#a8062a720fe81d7b03314563bda688004">isInitialized</a> () const</td></tr>
<tr class="separator:a8062a720fe81d7b03314563bda688004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231f970f4a6176a460ae39f57a2b3f90" id="r_a231f970f4a6176a460ae39f57a2b3f90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#a231f970f4a6176a460ae39f57a2b3f90">compute</a> ()</td></tr>
<tr class="memdesc:a231f970f4a6176a460ae39f57a2b3f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.  <br /></td></tr>
<tr class="separator:a231f970f4a6176a460ae39f57a2b3f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57e121528cf89f94b78989304a03799" id="r_aa57e121528cf89f94b78989304a03799"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#aa57e121528cf89f94b78989304a03799">isComputed</a> () const</td></tr>
<tr class="separator:aa57e121528cf89f94b78989304a03799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implementation of Ifpack2::Details::CanChangeMatrix</div></td></tr>
<tr class="memitem:aa078a4a23a56f937646695f2df5b4723" id="r_aa078a4a23a56f937646695f2df5b4723"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#aa078a4a23a56f937646695f2df5b4723">setMatrix</a> (const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1Chebyshev.html#aa548468ec7dec28155b23446c71063b0">row_matrix_type</a> &gt; &amp;A)</td></tr>
<tr class="memdesc:aa078a4a23a56f937646695f2df5b4723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the matrix to be preconditioned.  <br /></td></tr>
<tr class="separator:aa078a4a23a56f937646695f2df5b4723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implementation of Tpetra::Operator</div></td></tr>
<tr class="memitem:aee64f2426f179132accffdbf2965c067" id="r_aee64f2426f179132accffdbf2965c067"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#aee64f2426f179132accffdbf2965c067">apply</a> (const Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1Chebyshev.html#a908f442a4de43415096f9dbc581882c4">scalar_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a7ef60eeebf197b3a86cc169a1fa1d782">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a13aa7bd78c460ca85646f1e3b5d0d297">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a84cd81072767003ae25ac21110700221">node_type</a> &gt; &amp;X, Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1Chebyshev.html#a908f442a4de43415096f9dbc581882c4">scalar_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a7ef60eeebf197b3a86cc169a1fa1d782">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a13aa7bd78c460ca85646f1e3b5d0d297">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a84cd81072767003ae25ac21110700221">node_type</a> &gt; &amp;Y, Teuchos::ETransp mode=Teuchos::NO_TRANS, <a class="el" href="classIfpack2_1_1Chebyshev.html#a908f442a4de43415096f9dbc581882c4">scalar_type</a> alpha=Teuchos::ScalarTraits&lt; <a class="el" href="classIfpack2_1_1Chebyshev.html#a908f442a4de43415096f9dbc581882c4">scalar_type</a> &gt;::one(), <a class="el" href="classIfpack2_1_1Chebyshev.html#a908f442a4de43415096f9dbc581882c4">scalar_type</a> beta=Teuchos::ScalarTraits&lt; <a class="el" href="classIfpack2_1_1Chebyshev.html#a908f442a4de43415096f9dbc581882c4">scalar_type</a> &gt;::zero()) const</td></tr>
<tr class="memdesc:aee64f2426f179132accffdbf2965c067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the preconditioner to X, returning the result in Y.  <br /></td></tr>
<tr class="separator:aee64f2426f179132accffdbf2965c067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8df20e9f6448c81be19a2a0ed73616" id="r_acb8df20e9f6448c81be19a2a0ed73616"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1Chebyshev.html#a2bfd428bc4ed3a516ae523675ad669ad">map_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#acb8df20e9f6448c81be19a2a0ed73616">getDomainMap</a> () const</td></tr>
<tr class="memdesc:acb8df20e9f6448c81be19a2a0ed73616"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Tpetra::Map representing the domain of this operator.  <br /></td></tr>
<tr class="separator:acb8df20e9f6448c81be19a2a0ed73616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a081978b3ef23b90ee096e9cbe3d672" id="r_a4a081978b3ef23b90ee096e9cbe3d672"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1Chebyshev.html#a2bfd428bc4ed3a516ae523675ad669ad">map_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#a4a081978b3ef23b90ee096e9cbe3d672">getRangeMap</a> () const</td></tr>
<tr class="memdesc:a4a081978b3ef23b90ee096e9cbe3d672"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Tpetra::Map representing the range of this operator.  <br /></td></tr>
<tr class="separator:a4a081978b3ef23b90ee096e9cbe3d672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c1b16f881ce04b4ad1fdbac8d54026" id="r_af6c1b16f881ce04b4ad1fdbac8d54026"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#af6c1b16f881ce04b4ad1fdbac8d54026">hasTransposeApply</a> () const</td></tr>
<tr class="memdesc:af6c1b16f881ce04b4ad1fdbac8d54026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether it's possible to apply the transpose of this operator.  <br /></td></tr>
<tr class="separator:af6c1b16f881ce04b4ad1fdbac8d54026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c59c14e1181e832896b69eef334e377" id="r_a4c59c14e1181e832896b69eef334e377"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#a4c59c14e1181e832896b69eef334e377">applyMat</a> (const Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1Chebyshev.html#a908f442a4de43415096f9dbc581882c4">scalar_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a7ef60eeebf197b3a86cc169a1fa1d782">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a13aa7bd78c460ca85646f1e3b5d0d297">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a84cd81072767003ae25ac21110700221">node_type</a> &gt; &amp;X, Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1Chebyshev.html#a908f442a4de43415096f9dbc581882c4">scalar_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a7ef60eeebf197b3a86cc169a1fa1d782">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a13aa7bd78c460ca85646f1e3b5d0d297">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a84cd81072767003ae25ac21110700221">node_type</a> &gt; &amp;Y, Teuchos::ETransp mode=Teuchos::NO_TRANS) const</td></tr>
<tr class="memdesc:a4c59c14e1181e832896b69eef334e377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Y = Op(A)*X, where Op(A) is either A, \(A^T\), or \(A^H\).  <br /></td></tr>
<tr class="separator:a4c59c14e1181e832896b69eef334e377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Attribute accessor methods</div></td></tr>
<tr class="memitem:ad6b3aa8cf647dbe31fb30ab3a8327653" id="r_ad6b3aa8cf647dbe31fb30ab3a8327653"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const Teuchos::Comm&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#ad6b3aa8cf647dbe31fb30ab3a8327653">getComm</a> () const</td></tr>
<tr class="memdesc:ad6b3aa8cf647dbe31fb30ab3a8327653"><td class="mdescLeft">&#160;</td><td class="mdescRight">The communicator over which the matrix is distributed.  <br /></td></tr>
<tr class="separator:ad6b3aa8cf647dbe31fb30ab3a8327653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec9e73341c7ccc9db054564f2f62916" id="r_a5ec9e73341c7ccc9db054564f2f62916"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1Chebyshev.html#aa548468ec7dec28155b23446c71063b0">row_matrix_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#a5ec9e73341c7ccc9db054564f2f62916">getMatrix</a> () const</td></tr>
<tr class="memdesc:a5ec9e73341c7ccc9db054564f2f62916"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix for which this is a preconditioner.  <br /></td></tr>
<tr class="separator:a5ec9e73341c7ccc9db054564f2f62916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecf9825fa3117131b61ccb35ebef73b" id="r_abecf9825fa3117131b61ccb35ebef73b"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const Tpetra::CrsMatrix&lt; <a class="el" href="classIfpack2_1_1Chebyshev.html#a908f442a4de43415096f9dbc581882c4">scalar_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a7ef60eeebf197b3a86cc169a1fa1d782">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a13aa7bd78c460ca85646f1e3b5d0d297">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a84cd81072767003ae25ac21110700221">node_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#abecf9825fa3117131b61ccb35ebef73b">getCrsMatrix</a> () const</td></tr>
<tr class="memdesc:abecf9825fa3117131b61ccb35ebef73b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to return the matrix A as a Tpetra::CrsMatrix.  <br /></td></tr>
<tr class="separator:abecf9825fa3117131b61ccb35ebef73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d29ff0fd2bd08834f8772b1990614c" id="r_ab0d29ff0fd2bd08834f8772b1990614c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#ab0d29ff0fd2bd08834f8772b1990614c">getComputeFlops</a> () const</td></tr>
<tr class="memdesc:ab0d29ff0fd2bd08834f8772b1990614c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of floating-point operations taken by all calls to <a class="el" href="classIfpack2_1_1Chebyshev.html#a231f970f4a6176a460ae39f57a2b3f90" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a>.  <br /></td></tr>
<tr class="separator:ab0d29ff0fd2bd08834f8772b1990614c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada00143f807ef74c8fef36e88472c38d" id="r_ada00143f807ef74c8fef36e88472c38d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#ada00143f807ef74c8fef36e88472c38d">getApplyFlops</a> () const</td></tr>
<tr class="memdesc:ada00143f807ef74c8fef36e88472c38d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of floating-point operations taken by all calls to <a class="el" href="classIfpack2_1_1Chebyshev.html#aee64f2426f179132accffdbf2965c067" title="Apply the preconditioner to X, returning the result in Y.">apply()</a>.  <br /></td></tr>
<tr class="separator:ada00143f807ef74c8fef36e88472c38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b53ee539d2e01dc591a6b9a4f6a840" id="r_ad3b53ee539d2e01dc591a6b9a4f6a840"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#ad3b53ee539d2e01dc591a6b9a4f6a840">getNumInitialize</a> () const</td></tr>
<tr class="memdesc:ad3b53ee539d2e01dc591a6b9a4f6a840"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of successful calls to <a class="el" href="classIfpack2_1_1Chebyshev.html#a58de3ab7b5dc7fefd2f3f51e1dcef561" title="Initialize the preconditioner.">initialize()</a>.  <br /></td></tr>
<tr class="separator:ad3b53ee539d2e01dc591a6b9a4f6a840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4a28567fe2a27f10a89b4931046490" id="r_aaa4a28567fe2a27f10a89b4931046490"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#aaa4a28567fe2a27f10a89b4931046490">getNumCompute</a> () const</td></tr>
<tr class="memdesc:aaa4a28567fe2a27f10a89b4931046490"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of successful calls to <a class="el" href="classIfpack2_1_1Chebyshev.html#a231f970f4a6176a460ae39f57a2b3f90" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a>.  <br /></td></tr>
<tr class="separator:aaa4a28567fe2a27f10a89b4931046490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f8171b602bf9aa3e4cee96ed9a4563" id="r_a69f8171b602bf9aa3e4cee96ed9a4563"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#a69f8171b602bf9aa3e4cee96ed9a4563">getNumApply</a> () const</td></tr>
<tr class="memdesc:a69f8171b602bf9aa3e4cee96ed9a4563"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of successful calls to <a class="el" href="classIfpack2_1_1Chebyshev.html#aee64f2426f179132accffdbf2965c067" title="Apply the preconditioner to X, returning the result in Y.">apply()</a>.  <br /></td></tr>
<tr class="separator:a69f8171b602bf9aa3e4cee96ed9a4563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eaeaaf30327f0a75870ed650191a903" id="r_a1eaeaaf30327f0a75870ed650191a903"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#a1eaeaaf30327f0a75870ed650191a903">getInitializeTime</a> () const</td></tr>
<tr class="memdesc:a1eaeaaf30327f0a75870ed650191a903"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total time spent in all calls to <a class="el" href="classIfpack2_1_1Chebyshev.html#a58de3ab7b5dc7fefd2f3f51e1dcef561" title="Initialize the preconditioner.">initialize()</a>.  <br /></td></tr>
<tr class="separator:a1eaeaaf30327f0a75870ed650191a903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab905b21ad57ecf9bb26259336d4cbfd4" id="r_ab905b21ad57ecf9bb26259336d4cbfd4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#ab905b21ad57ecf9bb26259336d4cbfd4">getComputeTime</a> () const</td></tr>
<tr class="memdesc:ab905b21ad57ecf9bb26259336d4cbfd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total time spent in all calls to <a class="el" href="classIfpack2_1_1Chebyshev.html#a231f970f4a6176a460ae39f57a2b3f90" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a>.  <br /></td></tr>
<tr class="separator:ab905b21ad57ecf9bb26259336d4cbfd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a90ada6216fa6a59d96884c7710119" id="r_af7a90ada6216fa6a59d96884c7710119"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#af7a90ada6216fa6a59d96884c7710119">getApplyTime</a> () const</td></tr>
<tr class="memdesc:af7a90ada6216fa6a59d96884c7710119"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total time spent in all calls to <a class="el" href="classIfpack2_1_1Chebyshev.html#aee64f2426f179132accffdbf2965c067" title="Apply the preconditioner to X, returning the result in Y.">apply()</a>.  <br /></td></tr>
<tr class="separator:af7a90ada6216fa6a59d96884c7710119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8709e5192d9516c89c08b332aad497b3" id="r_a8709e5192d9516c89c08b332aad497b3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#a8709e5192d9516c89c08b332aad497b3">getNodeSmootherComplexity</a> () const</td></tr>
<tr class="memdesc:a8709e5192d9516c89c08b332aad497b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a rough estimate of cost per iteration.  <br /></td></tr>
<tr class="separator:a8709e5192d9516c89c08b332aad497b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b15bf3d958954fc0250f24b620b5e9" id="r_af1b15bf3d958954fc0250f24b620b5e9"><td class="memItemLeft" align="right" valign="top">MatrixType::scalar_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#af1b15bf3d958954fc0250f24b620b5e9">getLambdaMaxForApply</a> () const</td></tr>
<tr class="memdesc:af1b15bf3d958954fc0250f24b620b5e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The estimate of the maximum eigenvalue used in the <a class="el" href="classIfpack2_1_1Chebyshev.html#aee64f2426f179132accffdbf2965c067" title="Apply the preconditioner to X, returning the result in Y.">apply()</a>.  <br /></td></tr>
<tr class="separator:af1b15bf3d958954fc0250f24b620b5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classIfpack2_1_1Preconditioner"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classIfpack2_1_1Preconditioner')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classIfpack2_1_1Preconditioner.html">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a></td></tr>
<tr class="memitem:a637973211128e0c09db53772df0f345d inherit pub_methods_classIfpack2_1_1Preconditioner" id="r_a637973211128e0c09db53772df0f345d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Preconditioner.html#a637973211128e0c09db53772df0f345d">~Preconditioner</a> ()</td></tr>
<tr class="memdesc:a637973211128e0c09db53772df0f345d inherit pub_methods_classIfpack2_1_1Preconditioner"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a637973211128e0c09db53772df0f345d inherit pub_methods_classIfpack2_1_1Preconditioner"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html">Ifpack2::Details::CanChangeMatrix&lt; Tpetra::RowMatrix&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt; &gt;</a></td></tr>
<tr class="memitem:acad726ffa06a9eef5d675364f996101a inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix" id="r_acad726ffa06a9eef5d675364f996101a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">virtual</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html#acad726ffa06a9eef5d675364f996101a">setMatrix</a> (<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> Tpetra::RowMatrix&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt; &gt; &amp;A)=0</td></tr>
<tr class="memdesc:acad726ffa06a9eef5d675364f996101a inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the new matrix.  <br /></td></tr>
<tr class="separator:acad726ffa06a9eef5d675364f996101a inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad9626e6fa50980dc192a4a63341c12 inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix" id="r_abad9626e6fa50980dc192a4a63341c12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">virtual</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html#abad9626e6fa50980dc192a4a63341c12">~CanChangeMatrix</a> ()</td></tr>
<tr class="memdesc:abad9626e6fa50980dc192a4a63341c12 inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:abad9626e6fa50980dc192a4a63341c12 inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Typedefs</h2></td></tr>
<tr class="memitem:ae5eaa929f865a23caffe4cd962a1fa48" id="r_ae5eaa929f865a23caffe4cd962a1fa48"><td class="memItemLeft" align="right" valign="top">typedef MatrixType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#ae5eaa929f865a23caffe4cd962a1fa48">matrix_type</a></td></tr>
<tr class="memdesc:ae5eaa929f865a23caffe4cd962a1fa48"><td class="mdescLeft">&#160;</td><td class="mdescRight">The template parameter of this class.  <br /></td></tr>
<tr class="separator:ae5eaa929f865a23caffe4cd962a1fa48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908f442a4de43415096f9dbc581882c4" id="r_a908f442a4de43415096f9dbc581882c4"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::scalar_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#a908f442a4de43415096f9dbc581882c4">scalar_type</a></td></tr>
<tr class="memdesc:a908f442a4de43415096f9dbc581882c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the entries of the input MatrixType.  <br /></td></tr>
<tr class="separator:a908f442a4de43415096f9dbc581882c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef60eeebf197b3a86cc169a1fa1d782" id="r_a7ef60eeebf197b3a86cc169a1fa1d782"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::local_ordinal_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#a7ef60eeebf197b3a86cc169a1fa1d782">local_ordinal_type</a></td></tr>
<tr class="memdesc:a7ef60eeebf197b3a86cc169a1fa1d782"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of local indices in the input MatrixType.  <br /></td></tr>
<tr class="separator:a7ef60eeebf197b3a86cc169a1fa1d782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13aa7bd78c460ca85646f1e3b5d0d297" id="r_a13aa7bd78c460ca85646f1e3b5d0d297"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::global_ordinal_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#a13aa7bd78c460ca85646f1e3b5d0d297">global_ordinal_type</a></td></tr>
<tr class="memdesc:a13aa7bd78c460ca85646f1e3b5d0d297"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of global indices in the input MatrixType.  <br /></td></tr>
<tr class="separator:a13aa7bd78c460ca85646f1e3b5d0d297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762e5876f65d67574031dab28501f784" id="r_a762e5876f65d67574031dab28501f784"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::node_type::device_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#a762e5876f65d67574031dab28501f784">device_type</a></td></tr>
<tr class="memdesc:a762e5876f65d67574031dab28501f784"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Kokkos::Device specialization used by the input MatrixType.  <br /></td></tr>
<tr class="separator:a762e5876f65d67574031dab28501f784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84cd81072767003ae25ac21110700221" id="r_a84cd81072767003ae25ac21110700221"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#a84cd81072767003ae25ac21110700221">node_type</a></td></tr>
<tr class="memdesc:a84cd81072767003ae25ac21110700221"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Node type used by the input MatrixType.  <br /></td></tr>
<tr class="separator:a84cd81072767003ae25ac21110700221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72dd7061e0a4904416ffd6211c734cb5" id="r_a72dd7061e0a4904416ffd6211c734cb5"><td class="memItemLeft" align="right" valign="top">typedef Teuchos::ScalarTraits&lt; <a class="el" href="classIfpack2_1_1Chebyshev.html#a908f442a4de43415096f9dbc581882c4">scalar_type</a> &gt;::magnitudeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#a72dd7061e0a4904416ffd6211c734cb5">magnitude_type</a></td></tr>
<tr class="memdesc:a72dd7061e0a4904416ffd6211c734cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the magnitude (absolute value) of a matrix entry.  <br /></td></tr>
<tr class="separator:a72dd7061e0a4904416ffd6211c734cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa548468ec7dec28155b23446c71063b0" id="r_aa548468ec7dec28155b23446c71063b0"><td class="memItemLeft" align="right" valign="top">typedef Tpetra::RowMatrix&lt; <a class="el" href="classIfpack2_1_1Chebyshev.html#a908f442a4de43415096f9dbc581882c4">scalar_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a7ef60eeebf197b3a86cc169a1fa1d782">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a13aa7bd78c460ca85646f1e3b5d0d297">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a84cd81072767003ae25ac21110700221">node_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#aa548468ec7dec28155b23446c71063b0">row_matrix_type</a></td></tr>
<tr class="memdesc:aa548468ec7dec28155b23446c71063b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Tpetra::RowMatrix specialization matching MatrixType.  <br /></td></tr>
<tr class="separator:aa548468ec7dec28155b23446c71063b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfd428bc4ed3a516ae523675ad669ad" id="r_a2bfd428bc4ed3a516ae523675ad669ad"><td class="memItemLeft" align="right" valign="top">typedef Tpetra::Map&lt; <a class="el" href="classIfpack2_1_1Chebyshev.html#a7ef60eeebf197b3a86cc169a1fa1d782">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a13aa7bd78c460ca85646f1e3b5d0d297">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a84cd81072767003ae25ac21110700221">node_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#a2bfd428bc4ed3a516ae523675ad669ad">map_type</a></td></tr>
<tr class="memdesc:a2bfd428bc4ed3a516ae523675ad669ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Tpetra::Map specialization matching MatrixType.  <br /></td></tr>
<tr class="separator:a2bfd428bc4ed3a516ae523675ad669ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871acaa13016b68ef0abc8b7264c67b0" id="r_a871acaa13016b68ef0abc8b7264c67b0"><td class="memItemLeft" align="right" valign="top">typedef Tpetra::Vector&lt; <a class="el" href="classIfpack2_1_1Chebyshev.html#a908f442a4de43415096f9dbc581882c4">scalar_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a7ef60eeebf197b3a86cc169a1fa1d782">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a13aa7bd78c460ca85646f1e3b5d0d297">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a84cd81072767003ae25ac21110700221">node_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#a871acaa13016b68ef0abc8b7264c67b0">vector_type</a></td></tr>
<tr class="memdesc:a871acaa13016b68ef0abc8b7264c67b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Tpetra::Vector specialization matching MatrixType.  <br /></td></tr>
<tr class="separator:a871acaa13016b68ef0abc8b7264c67b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fad3440becb8a500dce47a785471089" id="r_a2fad3440becb8a500dce47a785471089"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#a2fad3440becb8a500dce47a785471089">Chebyshev</a> (const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1Chebyshev.html#aa548468ec7dec28155b23446c71063b0">row_matrix_type</a> &gt; &amp;A)</td></tr>
<tr class="memdesc:a2fad3440becb8a500dce47a785471089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a2fad3440becb8a500dce47a785471089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e41b18f36837c00587356b65cb9cc8" id="r_ad4e41b18f36837c00587356b65cb9cc8"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#ad4e41b18f36837c00587356b65cb9cc8">~Chebyshev</a> ()</td></tr>
<tr class="memdesc:ad4e41b18f36837c00587356b65cb9cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:ad4e41b18f36837c00587356b65cb9cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Implementation of Teuchos::Describable</h2></td></tr>
<tr class="memitem:a258d89a2a10da59034d64b9772353bec" id="r_a258d89a2a10da59034d64b9772353bec"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#a258d89a2a10da59034d64b9772353bec">description</a> () const</td></tr>
<tr class="memdesc:a258d89a2a10da59034d64b9772353bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple one-line description of this object.  <br /></td></tr>
<tr class="separator:a258d89a2a10da59034d64b9772353bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a704f09f720e53104126b0e51dedf8e" id="r_a3a704f09f720e53104126b0e51dedf8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Chebyshev.html#a3a704f09f720e53104126b0e51dedf8e">describe</a> (Teuchos::FancyOStream &amp;out, const Teuchos::EVerbosityLevel verbLevel=Teuchos::Describable::verbLevel_default) const</td></tr>
<tr class="memdesc:a3a704f09f720e53104126b0e51dedf8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the object with some verbosity level to a Teuchos::FancyOStream.  <br /></td></tr>
<tr class="separator:a3a704f09f720e53104126b0e51dedf8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classIfpack2_1_1Preconditioner"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classIfpack2_1_1Preconditioner')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classIfpack2_1_1Preconditioner.html">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a></td></tr>
<tr class="memitem:a222c0e260ac8dc1226573e8a0773ac63 inherit pub_types_classIfpack2_1_1Preconditioner" id="r_a222c0e260ac8dc1226573e8a0773ac63"><td class="memItemLeft" align="right" valign="top">typedef Teuchos::ScalarTraits&lt; MatrixType::scalar_type &gt;::magnitudeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Preconditioner.html#a222c0e260ac8dc1226573e8a0773ac63">magnitude_type</a></td></tr>
<tr class="memdesc:a222c0e260ac8dc1226573e8a0773ac63 inherit pub_types_classIfpack2_1_1Preconditioner"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the magnitude (absolute value) of a matrix entry.  <br /></td></tr>
<tr class="separator:a222c0e260ac8dc1226573e8a0773ac63 inherit pub_types_classIfpack2_1_1Preconditioner"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class MatrixType&gt;<br />
class Ifpack2::Chebyshev&lt; MatrixType &gt;</div><p>Diagonally scaled <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> iteration for Tpetra sparse matrices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>A specialization of Tpetra::RowMatrix.</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Ifpack_Chebyshev_Summary"></a>
Summary</h1>
<p>This class implements a <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> polynomial preconditioner or smoother for a Tpetra sparse matrix. Given a matrix A, it applies <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> iteration to the left-scaled matrix \(D^{-1} A\), where D = diag(A) is the matrix of the diagonal entries of A. This class' constructor accepts a Tpetra::RowMatrix or any subclass thereof (including Tpetra::CrsMatrix). Its template parameter may be a specialization of either class.</p>
<p><a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> is derived from <a class="el" href="classIfpack2_1_1Preconditioner.html" title="Interface for all Ifpack2 preconditioners.">Preconditioner</a>, which itself is derived from Tpetra::Operator. Therefore, a <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> instance may be used as an operator in any code that invokes the operator as <a class="el" href="classIfpack2_1_1Chebyshev.html#aee64f2426f179132accffdbf2965c067" title="Apply the preconditioner to X, returning the result in Y.">apply()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Our implementation currently <em>only</em> works with a real symmetric positive definite (SPD) matrix. Results for matrices that are not SPD, or for complex-valued Scalar types, are not defined.</dd></dl>
<h1><a class="anchor" id="Ifpack_Chebyshev_Algorithm"></a>
Algorithm</h1>
<p>Given a matrix A, a right-hand side X, and an initial guess Y, this class computes an approximate solution to \(AY=X\) via <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> iteration using the left-scaled matrix \(D^{-1} A\), where D is the matrix of the diagonal elements of A. (You may control left scaling yourself if you wish, by providing an optional vector of the entries of \(D^{-1}\).) While <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> iteration works for any matrix, we have chosen only to allow real-valued, symmetric positive definite matrices.</p>
<p><a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> iteration was originally intended as an iterative solver for linear systems. See the following publication (the spelling of "Chebyshev" in Latin characters differs in some publications):</p>
<p>T. Manteuffel, "The Tchebychev iteration for nonsymmetric linear
systems," Numer. Math., 28 (1977), pp. 307-327.</p>
<p>It also works as a smoother for algebraic multigrid, which is the target use case of this implementation.</p>
<h1><a class="anchor" id="Ifpack_Chebyshev_Eig"></a>
Eigenvalue bounds</h1>
<p>We require that the input matrix A be real-valued and symmetric positive definite. Thus, all of its eigenvalues must lie in a positive interval on the real line. Furthermore, if D is the matrix of the diagonal elements of A, then the same is true of \(D^{-1} A\).</p>
<p>Suppose \([\lambda_{min}, \lambda_{max}]\) is the interval of the eigenvalues of \(D^{-1} A\). Users may either give us an estimate of the maximum eigenvalue \(\lambda_{max}\), or let us compute it (which we do with a few power iterations). They may optionally also give us the (estimated) ratio \(\eta =
\lambda_{max} / \lambda_{min}\), or (an estimate of) the minimum eigenvalue \(\lambda_{min}\). The \(\eta\) parameter corresponds to the "smoother: Chebyshev alpha" parameter of ML. (We use "eta" instead of "alpha" to avoid confusion with the "alpha" argument of the <a class="el" href="classIfpack2_1_1Chebyshev.html#aee64f2426f179132accffdbf2965c067" title="Apply the preconditioner to X, returning the result in Y.">apply()</a> method of Tpetra::Operator.)</p>
<p>When using <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> iteration by itself to solve linear systems, it is important to have good estimates of both the minimum and maximum eigenvalues. However, when using a small number of <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> iterations as a smoother in multigrid, the maximum eigenvalue estimate is more important. (The point of a smoother is to smooth out the high-frequency components of the error, that is, those that correspond to the largest eigenvalues. The coarser grids below the current grid will take care of the lower-frequency components of the error.) This is why we use a ratio \(\eta = \lambda_{max} / \lambda_{min}\), rather than requiring a guess for \(\lambda_{min}\). In fact, we only use \(\lambda_{min}\) for error checking, not when determining the <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> coefficients. Often, if users give us \(\lambda_{max}\), our default value of \(\eta\) suffices.</p>
<p>Underestimating \(\lambda_{min}\) may make <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> fail to converge, or fail to reduce the highest-frequency components of the error, if used as a smoother. Thus, we always multiply the given \(\lambda_{min}\) by a small factor (1.1). This heuristic accounts for the fact that typical methods for estimating extremal eigenvalues (like Lanczos or CG) underestimate them.</p>
<p>If you do not give us an estimate for the maximum eigenvalue, we estimate it using a few iterations of the power method in the <a class="el" href="classIfpack2_1_1Chebyshev.html#a231f970f4a6176a460ae39f57a2b3f90" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a> method. We do not attempt to refine the eigenvalue bounds over <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> iterations, as the typical smoother case does not use very many iterations. For an example of a <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> implementation that updates eigenvalue bound estimates, see Steve Ashby's CHEBYCODE:</p>
<p>S. ASHBY, "CHEBYCODE: A Fortran implementation of Manteuffel's
adaptive Chebyshev algorithm," Tech. Rep. UIUCDCS-R-85-1203, University of Illinois, 1985.</p>
<h1><a class="anchor" id="Ifpack_Chebyshev_Params"></a>
Setting parameters</h1>
<p>Call the <a class="el" href="classIfpack2_1_1Chebyshev.html#ab0c464ffa718435c0dd10966647beda0" title="Set (or reset) parameters.">setParameters()</a> method to give this instance your eigenvalue bound estimates (if you have them), as well as to set other options controlling the behavior of <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> iteration. The documentation of <a class="el" href="classIfpack2_1_1Chebyshev.html#ab0c464ffa718435c0dd10966647beda0" title="Set (or reset) parameters.">setParameters()</a> lists all the parameters that this class accepts. Where possible, we list comparable parameters in the Ifpack package and the ML multigrid package.</p>
<h1><a class="anchor" id="Ifpack_Chebyshev_Performance"></a>
Performance</h1>
<p><a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> should spend most of its time in Tpetra's native sparse matrix-vector multiply kernel. This should give good performance, since we have spent a lot of effort tuning that kernel. Depending on the Node type of your Tpetra matrix, the kernel may also exploit threads for additional parallelism within each MPI process ("hybrid parallelism" a.k.a. "MPI + X"). If your application depends on hybrid parallelism for performance, you should favor <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> smoothers whenever possible over "serial within a
process" smoothers like Gauss-Seidel or SOR (Symmetric Over-Relaxation).</p>
<h1><a class="anchor" id="Ifpack_Chebyshev_History"></a>
History</h1>
<p>The original implementation of this class was an adaptation of ML's ML_Cheby routine. The original author was Ulrich Hetmaniuk, a Sandia employee in what was then (2006) Org 1416. <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> has seen significant development since then. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae5eaa929f865a23caffe4cd962a1fa48" name="ae5eaa929f865a23caffe4cd962a1fa48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5eaa929f865a23caffe4cd962a1fa48">&#9670;&#160;</a></span>matrix_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::matrix_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The template parameter of this class. </p>

</div>
</div>
<a id="a908f442a4de43415096f9dbc581882c4" name="a908f442a4de43415096f9dbc581882c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908f442a4de43415096f9dbc581882c4">&#9670;&#160;</a></span>scalar_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::scalar_type <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::scalar_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the entries of the input MatrixType. </p>

</div>
</div>
<a id="a7ef60eeebf197b3a86cc169a1fa1d782" name="a7ef60eeebf197b3a86cc169a1fa1d782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef60eeebf197b3a86cc169a1fa1d782">&#9670;&#160;</a></span>local_ordinal_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::local_ordinal_type <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::local_ordinal_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of local indices in the input MatrixType. </p>

</div>
</div>
<a id="a13aa7bd78c460ca85646f1e3b5d0d297" name="a13aa7bd78c460ca85646f1e3b5d0d297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13aa7bd78c460ca85646f1e3b5d0d297">&#9670;&#160;</a></span>global_ordinal_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::global_ordinal_type <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::global_ordinal_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of global indices in the input MatrixType. </p>

</div>
</div>
<a id="a762e5876f65d67574031dab28501f784" name="a762e5876f65d67574031dab28501f784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762e5876f65d67574031dab28501f784">&#9670;&#160;</a></span>device_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::node_type::device_type <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::device_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Kokkos::Device specialization used by the input MatrixType. </p>

</div>
</div>
<a id="a84cd81072767003ae25ac21110700221" name="a84cd81072767003ae25ac21110700221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84cd81072767003ae25ac21110700221">&#9670;&#160;</a></span>node_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::node_type <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::node_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Node type used by the input MatrixType. </p>

</div>
</div>
<a id="a72dd7061e0a4904416ffd6211c734cb5" name="a72dd7061e0a4904416ffd6211c734cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72dd7061e0a4904416ffd6211c734cb5">&#9670;&#160;</a></span>magnitude_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Teuchos::ScalarTraits&lt;<a class="el" href="classIfpack2_1_1Chebyshev.html#a908f442a4de43415096f9dbc581882c4">scalar_type</a>&gt;::magnitudeType <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::magnitude_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the magnitude (absolute value) of a matrix entry. </p>

</div>
</div>
<a id="aa548468ec7dec28155b23446c71063b0" name="aa548468ec7dec28155b23446c71063b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa548468ec7dec28155b23446c71063b0">&#9670;&#160;</a></span>row_matrix_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Tpetra::RowMatrix&lt;<a class="el" href="classIfpack2_1_1Chebyshev.html#a908f442a4de43415096f9dbc581882c4">scalar_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a7ef60eeebf197b3a86cc169a1fa1d782">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a13aa7bd78c460ca85646f1e3b5d0d297">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a84cd81072767003ae25ac21110700221">node_type</a>&gt; <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::row_matrix_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Tpetra::RowMatrix specialization matching MatrixType. </p>
<p>MatrixType must be a Tpetra::RowMatrix specialization. This typedef will always be a Tpetra::RowMatrix specialization. </p>

</div>
</div>
<a id="a2bfd428bc4ed3a516ae523675ad669ad" name="a2bfd428bc4ed3a516ae523675ad669ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bfd428bc4ed3a516ae523675ad669ad">&#9670;&#160;</a></span>map_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Tpetra::Map&lt;<a class="el" href="classIfpack2_1_1Chebyshev.html#a7ef60eeebf197b3a86cc169a1fa1d782">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a13aa7bd78c460ca85646f1e3b5d0d297">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a84cd81072767003ae25ac21110700221">node_type</a>&gt; <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::map_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Tpetra::Map specialization matching MatrixType. </p>

</div>
</div>
<a id="a871acaa13016b68ef0abc8b7264c67b0" name="a871acaa13016b68ef0abc8b7264c67b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871acaa13016b68ef0abc8b7264c67b0">&#9670;&#160;</a></span>vector_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Tpetra::Vector&lt;<a class="el" href="classIfpack2_1_1Chebyshev.html#a908f442a4de43415096f9dbc581882c4">scalar_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a7ef60eeebf197b3a86cc169a1fa1d782">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a13aa7bd78c460ca85646f1e3b5d0d297">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a84cd81072767003ae25ac21110700221">node_type</a>&gt; <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::vector_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Tpetra::Vector specialization matching MatrixType. </p>
<p>If you wish to supply <a class="el" href="classIfpack2_1_1Chebyshev.html#ab0c464ffa718435c0dd10966647beda0" title="Set (or reset) parameters.">setParameters()</a> a precomputed vector of diagonal entries of the matrix, use a pointer to an object of this type. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2fad3440becb8a500dce47a785471089" name="a2fad3440becb8a500dce47a785471089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fad3440becb8a500dce47a785471089">&#9670;&#160;</a></span>Chebyshev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::Chebyshev </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1Chebyshev.html#aa548468ec7dec28155b23446c71063b0">row_matrix_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>The sparse matrix to which to apply <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> iteration. The matrix A must be square, and its domain Map and range Map must be the same. The latter means that the vectors x and y in the sparse matrix-vector product y = A*x must both have the same distribution over process(es).</td></tr>
  </table>
  </dd>
</dl>
<p>We do <em>not</em> require that the row Map and the range Map of A be the same. However, set-up will take less time if they are identical (in terms of pointer equality). This is because we have to extract the diagonal entries of A as a row Map vector: if the row and range Maps are not identical, we have to redistribute the vector from the row Map to the range Map.</p>
<p>The constructor will only check the requirements on the various Maps of A if the CMake configuration option <code>Teuchos_ENABLE_DEBUG</code> was set to <code>ON</code> before building Trilinos. The checks require \(O(1)\) global reductions over all processes in A's communicator, so we prefer to avoid them if we can. </p>

</div>
</div>
<a id="ad4e41b18f36837c00587356b65cb9cc8" name="ad4e41b18f36837c00587356b65cb9cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e41b18f36837c00587356b65cb9cc8">&#9670;&#160;</a></span>~Chebyshev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::~<a class="el" href="classIfpack2_1_1Chebyshev.html">Chebyshev</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab0c464ffa718435c0dd10966647beda0" name="ab0c464ffa718435c0dd10966647beda0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c464ffa718435c0dd10966647beda0">&#9670;&#160;</a></span>setParameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::setParameters </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set (or reset) parameters. </p>
<p>This method fills in the input ParameterList with missing parameters set to their default values. You may call this method as many times as you want. On each call, the input ParameterList is treated as a complete list of the desired parameters, not as a "delta" or change list from the current set of parameters. (That is, if you remove parameters from the list that were there in the last call to <a class="el" href="classIfpack2_1_1Chebyshev.html#ab0c464ffa718435c0dd10966647beda0" title="Set (or reset) parameters.">setParameters()</a> and call <a class="el" href="classIfpack2_1_1Chebyshev.html#ab0c464ffa718435c0dd10966647beda0" title="Set (or reset) parameters.">setParameters()</a> again with the revised list, this method will use default values for the removed parameters, rather than letting the current settings remain.) However, since the method fills in missing parameters, you may keep calling it with the ParameterList used in the previous call in order to get the same behavior as before.</p>
<h1><a class="anchor" id="Ifpack2_Chebyshev_setParameters_List"></a>
List of parameters</h1>
<p>Parameters that govern spectral bounds of the matrix:</p><ul>
<li>"chebyshev: max eigenvalue" (<code>ScalarType</code>): lambdaMax, an upper bound of the bounding ellipse of the eigenvalues of the matrix A. If you do not set this parameter, we will compute an approximation. See "Parameters that govern eigenvalue
  analysis" to control this approximation process.</li>
<li>"chebyshev: ratio eigenvalue" (<code>ScalarType</code>): eigRatio, the ratio of lambdaMax to the lower bound of the bounding ellipse of the eigenvalues of A. We use lambdaMax and eigRatio to determine the <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> iteration coefficients. This parameter is optional and defaults to 30.</li>
<li>"chebyshev: min eigenvalue" (<code>ScalarType</code>): lambdaMin, a lower bound of real part of bounding ellipse of eigenvalues of the matrix A. This parameter is optional and only used for a quick check if the matrix is the identity matrix (if lambdaMax == lambdaMin == 1).</li>
</ul>
<p>Parameters that govern the number of <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> iterations:</p><ul>
<li>"chebyshev: degree" (<code>int</code>): numIters, the number of iterations. This overrides "relaxation: sweeps" and "smoother: sweeps" (see below).</li>
<li>"relaxation: sweeps" (<code>int</code>): numIters, the number of iterations. We include this for compatibility with Ifpack. This overrides "smoother: sweeps" (see below).</li>
<li>"smoother: sweeps" (<code>int</code>): numIters, as above. We include this for compatibility with ML.</li>
</ul>
<p>Parameters that govern eigenvalue analysis:</p><ul>
<li>"chebyshev: eigenvalue max iterations" (<code>int</code>): eigMaxIters, the number of power method iterations used to compute the maximum eigenvalue. This overrides "eigen-analysis:
  iterations" (see below).</li>
<li>"eigen-analysis: iterations" (<code>int</code>): eigMaxIters, as above. We include this parameter for compatibility with ML.</li>
<li>"eigen-analysis: type" (<code>std::string</code>): The algorithm to use for estimating the max eigenvalue. This parameter is optional. Currently, we only support "power-method" (or "power method"), which is what Ifpack::Chebyshev uses for eigenanalysis. We include this parameter for compatibility with ML.</li>
</ul>
<p>Parameters that govern other algorithmic details:</p><ul>
<li>"chebyshev: assume matrix does not change": Whether <a class="el" href="classIfpack2_1_1Chebyshev.html#a231f970f4a6176a460ae39f57a2b3f90" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a> should always assume that the matrix has not changed since the last call to <a class="el" href="classIfpack2_1_1Chebyshev.html#a231f970f4a6176a460ae39f57a2b3f90" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a>. The default is false. If true, <a class="el" href="classIfpack2_1_1Chebyshev.html#a231f970f4a6176a460ae39f57a2b3f90" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a> will not recompute the inverse diagonal or the estimates of the max and min eigenvalues. <a class="el" href="classIfpack2_1_1Chebyshev.html#a231f970f4a6176a460ae39f57a2b3f90" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a> will always compute any quantity which the user did not provide and which we have not yet computed before.</li>
<li>"chebyshev: operator inv diagonal" (<code>RCP&lt;const V&gt;</code> or <code>const V*</code>): If nonnull, we will use a deep copy of this vector for left scaling as the inverse diagonal of the matrix A, instead of computing the inverse diagonal ourselves. We will make a copy every time you call <a class="el" href="classIfpack2_1_1Chebyshev.html#ab0c464ffa718435c0dd10966647beda0" title="Set (or reset) parameters.">setParameters()</a>. If you ever call <a class="el" href="classIfpack2_1_1Chebyshev.html#ab0c464ffa718435c0dd10966647beda0" title="Set (or reset) parameters.">setParameters()</a> without this parameter, we will clear our copy and compute the inverse diagonal ourselves again. If you choose to provide this parameter, you are responsible for updating this if the matrix has changed.</li>
<li>"chebyshev: min diagonal value" (<code>ST</code>): minDiagVal. If any entry of the diagonal of the matrix is less than this in magnitude, it will be replaced with this value in the inverse diagonal used for left scaling.</li>
<li>"chebyshev: zero starting solution" (<code>bool</code>): If true, then always use the zero vector(s) as the initial guess(es). If false, then <a class="el" href="classIfpack2_1_1Chebyshev.html#aee64f2426f179132accffdbf2965c067" title="Apply the preconditioner to X, returning the result in Y.">apply()</a> will use X on input as the initial guess(es).</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>lambdaMin, lambdaMax, and eigRatio are real </dd>
<dd>
0 &lt; lambdaMin &lt;= lambdaMax </dd>
<dd>
numIters &gt;= 0 </dd>
<dd>
eigMaxIters &gt;= 0</dd></dl>
<h1><a class="anchor" id="Ifpack2_Chebyshev_setParameters_compat"></a>
Note on compatibility with Ifpack and ML</h1>
<p>Both the Ifpack and ML packages implement a <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> smoother. We accept Ifpack and ML names for parameters whenever <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> has an equivalent parameter. Default settings for parameters relating to spectral bounds come from Ifpack.</p>
<p>The following list maps from an ML parameter to its corresponding <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> parameter.</p><ul>
<li>"smoother: Chebyshev alpha": "chebyshev: ratio eigenvalue"</li>
<li>"smoother: sweeps": "chebyshev: degree"</li>
</ul>
<p>ML does not have a parameter corresponding to "chebyshev: max
eigenvalue", because ML estimates the spectral radius automatically. Ifpack and <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> both can estimate this automatically, but also let the user provide an estimate. Similarly, ML does not have a parameter corresponding to "chebyshev: min eigenvalue".</p>
<p>The following list maps from an Ifpack parameter to its corresponding <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> parameter. Many of the parameters have the same names, in which case we simply write <em>same</em>.</p><ul>
<li>"chebyshev: max eigenvalue": same</li>
<li>"chebyshev: ratio eigenvalue": same</li>
<li>"chebyshev: min eigenvalue": same</li>
<li>"chebyshev: degree": same</li>
<li>"relaxation: sweeps": "chebyshev: degree"</li>
<li>"chebyshev: min diagonal value": same</li>
<li>"relaxation: min diagonal value": "chebyshev: min diagonal value"</li>
<li>"chebyshev: zero starting solution": same</li>
<li>"relaxation: zero starting solution": "chebyshev: zero starting solution"</li>
<li>"chebyshev: operator inv diagonal": same</li>
</ul>
<h1><a class="anchor" id="Ifpack2_Chebyshev_setParameters_details"></a>
Details on parameters</h1>
<p>The optional user-provided vector of diagonal entries of the matrix may have any distribution for which an Export to the range Map of the matrix is legal. However, if the vector is already distributed according to the range Map, that saves us the communication cost of an Export. We also avoid the Export in case the row Map and the range Map of the matrix are the same. If they are not the same, and if the vector is distributed according to the row Map, we will reuse the Export from the matrix. Otherwise, we have to make a fresh Export object, which is more expensive. To avoid this cost, you should always provide a row Map or range Map vector for this parameter. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a60340992fc1b9eac82ef35333bee6efd">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="ac8e182a4895893ccf12c294695d8c6fb" name="ac8e182a4895893ccf12c294695d8c6fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e182a4895893ccf12c294695d8c6fb">&#9670;&#160;</a></span>setZeroStartingSolution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::setZeroStartingSolution </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zeroStartingSolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this preconditioner's parameters. </p>

<p>Reimplemented from <a class="el" href="classIfpack2_1_1Preconditioner.html#a12495acd22d15212241c0d518d7f6536">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a58de3ab7b5dc7fefd2f3f51e1dcef561" name="a58de3ab7b5dc7fefd2f3f51e1dcef561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58de3ab7b5dc7fefd2f3f51e1dcef561">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the preconditioner. </p>
<p>The <a class="el" href="classIfpack2_1_1Chebyshev.html#a231f970f4a6176a460ae39f57a2b3f90" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a> method will call <a class="el" href="classIfpack2_1_1Chebyshev.html#a58de3ab7b5dc7fefd2f3f51e1dcef561" title="Initialize the preconditioner.">initialize()</a> automatically if it has not yet been called, so you do not normally need to call this. However, it is correct to call <a class="el" href="classIfpack2_1_1Chebyshev.html#a58de3ab7b5dc7fefd2f3f51e1dcef561" title="Initialize the preconditioner.">initialize()</a> yourself, and <a class="el" href="classIfpack2_1_1Chebyshev.html#a231f970f4a6176a460ae39f57a2b3f90" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a> will not call it again if it already has been called. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#ad3aefd6f16e8ef4cddb696cd23f160b0">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a8062a720fe81d7b03314563bda688004" name="a8062a720fe81d7b03314563bda688004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8062a720fe81d7b03314563bda688004">&#9670;&#160;</a></span>isInitialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::isInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether the preconditioner has been successfully initialized (by calling <a class="el" href="classIfpack2_1_1Chebyshev.html#a58de3ab7b5dc7fefd2f3f51e1dcef561" title="Initialize the preconditioner.">initialize()</a>). </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a180c876ccf7af87f10a1c1d08ba2dc01">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a231f970f4a6176a460ae39f57a2b3f90" name="a231f970f4a6176a460ae39f57a2b3f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231f970f4a6176a460ae39f57a2b3f90">&#9670;&#160;</a></span>compute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::compute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A. </p>
<p>You must call this method before calling <a class="el" href="classIfpack2_1_1Chebyshev.html#aee64f2426f179132accffdbf2965c067" title="Apply the preconditioner to X, returning the result in Y.">apply()</a>,</p><ul>
<li>if you have not yet called this method,</li>
<li>if the matrix (either its values or its structure) has changed, or</li>
<li>any time after you call <a class="el" href="classIfpack2_1_1Chebyshev.html#ab0c464ffa718435c0dd10966647beda0" title="Set (or reset) parameters.">setParameters()</a>.</li>
</ul>
<p>Users have the option to supply the left scaling vector D_inv and estimates of the min and max eigenvalues of D_inv * A as parameters to <a class="el" href="classIfpack2_1_1Chebyshev.html#ab0c464ffa718435c0dd10966647beda0" title="Set (or reset) parameters.">setParameters()</a>. If users did <em>not</em> supply a left scaling, then this method will compute it by default (if assumeMatrixUnchanged is false). Likewise, if users did <em>not</em> supply at least an estimate of the max eigenvalue, this method will estimate it by default. If estimation of the eigenvalues is required, this method may take as long as several <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> iterations.</p>
<p>Advanced users may avoid recomputing the left scaling vector and eigenvalue estimates by setting the "chebyshev: assume matrix
does not change" parameter of <a class="el" href="classIfpack2_1_1Chebyshev.html#ab0c464ffa718435c0dd10966647beda0" title="Set (or reset) parameters.">setParameters()</a> to <code>true</code>. The left scaling vector and eigenvalue estimates will always be computed if the user did not provide them and we have not yet computed them. Any changes to parameters that affect computation of the inverse diagonal or estimation of the eigenvalue bounds will not affect subsequent <a class="el" href="classIfpack2_1_1Chebyshev.html#aee64f2426f179132accffdbf2965c067" title="Apply the preconditioner to X, returning the result in Y.">apply()</a> operations, until the "chebyshev: assume matrix does not change" parameter is set back to <code>false</code> (its default value).</p>
<p>This method will call <a class="el" href="classIfpack2_1_1Chebyshev.html#a58de3ab7b5dc7fefd2f3f51e1dcef561" title="Initialize the preconditioner.">initialize()</a> if it has not already been called. However, you may call <a class="el" href="classIfpack2_1_1Chebyshev.html#a58de3ab7b5dc7fefd2f3f51e1dcef561" title="Initialize the preconditioner.">initialize()</a> before calling this method if you wish. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a23954dd69f62b56455a9c0988bbe9e67">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="aa57e121528cf89f94b78989304a03799" name="aa57e121528cf89f94b78989304a03799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57e121528cf89f94b78989304a03799">&#9670;&#160;</a></span>isComputed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::isComputed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether <a class="el" href="classIfpack2_1_1Chebyshev.html#a231f970f4a6176a460ae39f57a2b3f90" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a> has been called at least once.</p>
<p>Note that you must <em>always</em> call <a class="el" href="classIfpack2_1_1Chebyshev.html#a231f970f4a6176a460ae39f57a2b3f90" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a> if the matrix has changed, if you have called <a class="el" href="classIfpack2_1_1Chebyshev.html#ab0c464ffa718435c0dd10966647beda0" title="Set (or reset) parameters.">setParameters()</a>, or if you have not yet called <a class="el" href="classIfpack2_1_1Chebyshev.html#a231f970f4a6176a460ae39f57a2b3f90" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a>. This method only tells you if <a class="el" href="classIfpack2_1_1Chebyshev.html#a231f970f4a6176a460ae39f57a2b3f90" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a> has been called at least once, not if you need to call <a class="el" href="classIfpack2_1_1Chebyshev.html#a231f970f4a6176a460ae39f57a2b3f90" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a>. <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> doesn't have an efficient way to tell if the matrix has changed, so we ask users to tell <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> if the matrix has changed. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#abb5af77756a7488ab636dbd97483ca66">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="aa078a4a23a56f937646695f2df5b4723" name="aa078a4a23a56f937646695f2df5b4723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa078a4a23a56f937646695f2df5b4723">&#9670;&#160;</a></span>setMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::setMatrix </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1Chebyshev.html#aa548468ec7dec28155b23446c71063b0">row_matrix_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the matrix to be preconditioned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>The new matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>! isInitialized ()</code> </dd>
<dd>
<code>! isComputed ()</code></dd></dl>
<p>Calling this method resets the preconditioner's state. After calling this method with a nonnull input, you must first call <a class="el" href="classIfpack2_1_1Chebyshev.html#a58de3ab7b5dc7fefd2f3f51e1dcef561" title="Initialize the preconditioner.">initialize()</a> and <a class="el" href="classIfpack2_1_1Chebyshev.html#a231f970f4a6176a460ae39f57a2b3f90" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a> (in that order) before you may call <a class="el" href="classIfpack2_1_1Chebyshev.html#aee64f2426f179132accffdbf2965c067" title="Apply the preconditioner to X, returning the result in Y.">apply()</a>.</p>
<p>You may call this method with a null input. If A is null, then you may not call <a class="el" href="classIfpack2_1_1Chebyshev.html#a58de3ab7b5dc7fefd2f3f51e1dcef561" title="Initialize the preconditioner.">initialize()</a> or <a class="el" href="classIfpack2_1_1Chebyshev.html#a231f970f4a6176a460ae39f57a2b3f90" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a> until you first call this method again with a nonnull input. This method invalidates any previous factorization whether or not A is null, so calling <a class="el" href="classIfpack2_1_1Chebyshev.html#aa078a4a23a56f937646695f2df5b4723" title="Change the matrix to be preconditioned.">setMatrix()</a> with a null input is one way to clear the preconditioner's state (and free any memory that it may be using).</p>
<p>The new matrix A need not necessarily have the same Maps or even the same communicator as the original matrix. </p>

</div>
</div>
<a id="aee64f2426f179132accffdbf2965c067" name="aee64f2426f179132accffdbf2965c067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee64f2426f179132accffdbf2965c067">&#9670;&#160;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1Chebyshev.html#a908f442a4de43415096f9dbc581882c4">scalar_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a7ef60eeebf197b3a86cc169a1fa1d782">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a13aa7bd78c460ca85646f1e3b5d0d297">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a84cd81072767003ae25ac21110700221">node_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1Chebyshev.html#a908f442a4de43415096f9dbc581882c4">scalar_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a7ef60eeebf197b3a86cc169a1fa1d782">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a13aa7bd78c460ca85646f1e3b5d0d297">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a84cd81072767003ae25ac21110700221">node_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::ETransp&#160;</td>
          <td class="paramname"><em>mode</em> = <code>Teuchos::NO_TRANS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIfpack2_1_1Chebyshev.html#a908f442a4de43415096f9dbc581882c4">scalar_type</a>&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>Teuchos::ScalarTraits&lt;<a class="el" href="classIfpack2_1_1Chebyshev.html#a908f442a4de43415096f9dbc581882c4">scalar_type</a>&gt;::one()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIfpack2_1_1Chebyshev.html#a908f442a4de43415096f9dbc581882c4">scalar_type</a>&#160;</td>
          <td class="paramname"><em>beta</em> = <code>Teuchos::ScalarTraits&lt;<a class="el" href="classIfpack2_1_1Chebyshev.html#a908f442a4de43415096f9dbc581882c4">scalar_type</a>&gt;::zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the preconditioner to X, returning the result in Y. </p>
<p>This method actually computes Y = beta*Y + alpha*(M*X), where M*X represents the result of <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> iteration on X, using the matrix Op(A). Op(A) is either A itself, its transpose \(A^T\), or its Hermitian transpose \(A^H\), depending on the <code>mode</code> argument. Since this class currently requires A to be real and symmetric positive definite, it should always be the case that \(A = A^T = A^H\), but we will still respect the <code>mode</code> argument.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you did not set the "chebyshev: zero starting
  solution" parameter to true, then this method will use X as the starting guess for <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> iteration. If you did not initialize X before calling this method, then the resulting solution will be undefined, since it will be computed using uninitialized data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>A (multi)vector to which to apply the preconditioner. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Y</td><td>A (multi)vector containing the result of applying the preconditioner to X. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>If <code>Teuchos::NO_TRANS</code>, apply the matrix A. If <code>mode</code> is <code>Teuchos::NO_TRANS</code>, apply its transpose \(A^T\). If <code>Teuchos::CONJ_TRANS</code>, apply its Hermitian transpose \(A^H\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scaling factor for the result of <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Chebyshev</a> iteration. The default is 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>Scaling factor for Y. The default is 0. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a606c3f8155f67f2867fac3a7c44bd5df">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="acb8df20e9f6448c81be19a2a0ed73616" name="acb8df20e9f6448c81be19a2a0ed73616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb8df20e9f6448c81be19a2a0ed73616">&#9670;&#160;</a></span>getDomainMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const typename <a class="el" href="classIfpack2_1_1Chebyshev.html">Chebyshev</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1Chebyshev.html#a2bfd428bc4ed3a516ae523675ad669ad">::map_type</a> &gt; <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::getDomainMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Tpetra::Map representing the domain of this operator. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#aafeb2143ff699f2289503a85f6e3523c">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a4a081978b3ef23b90ee096e9cbe3d672" name="a4a081978b3ef23b90ee096e9cbe3d672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a081978b3ef23b90ee096e9cbe3d672">&#9670;&#160;</a></span>getRangeMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const typename <a class="el" href="classIfpack2_1_1Chebyshev.html">Chebyshev</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1Chebyshev.html#a2bfd428bc4ed3a516ae523675ad669ad">::map_type</a> &gt; <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::getRangeMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Tpetra::Map representing the range of this operator. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a75b32e1de03024035b00cd2ee95a60da">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="af6c1b16f881ce04b4ad1fdbac8d54026" name="af6c1b16f881ce04b4ad1fdbac8d54026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c1b16f881ce04b4ad1fdbac8d54026">&#9670;&#160;</a></span>hasTransposeApply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::hasTransposeApply </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether it's possible to apply the transpose of this operator. </p>

</div>
</div>
<a id="a4c59c14e1181e832896b69eef334e377" name="a4c59c14e1181e832896b69eef334e377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c59c14e1181e832896b69eef334e377">&#9670;&#160;</a></span>applyMat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::applyMat </td>
          <td>(</td>
          <td class="paramtype">const Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1Chebyshev.html#a908f442a4de43415096f9dbc581882c4">scalar_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a7ef60eeebf197b3a86cc169a1fa1d782">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a13aa7bd78c460ca85646f1e3b5d0d297">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a84cd81072767003ae25ac21110700221">node_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1Chebyshev.html#a908f442a4de43415096f9dbc581882c4">scalar_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a7ef60eeebf197b3a86cc169a1fa1d782">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a13aa7bd78c460ca85646f1e3b5d0d297">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1Chebyshev.html#a84cd81072767003ae25ac21110700221">node_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::ETransp&#160;</td>
          <td class="paramname"><em>mode</em> = <code>Teuchos::NO_TRANS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Y = Op(A)*X, where Op(A) is either A, \(A^T\), or \(A^H\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>Input (multi)vector of sparse matrix-vector multiply. If mode == Teuchos::NO_TRANS, X must be in the domain Map of the matrix A. Otherwise, X must be in the range Map of A. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>Output (multi)vector of sparse matrix-vector multiply. If mode == Teuchos::NO_TRANS, Y must be in the range Map of the matrix A. Otherwise, Y must be in the domain Map of A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Whether to apply the matrix A, its transpose \(A^T\), or its conjugate transpose \(A^H\). This method applies A if <code>mode</code> is <code>Teuchos::NO_TRANS</code>, \(A^T\) if <code>mode</code> is <code>Teuchos::TRANS</code>, and \(A^H\) (the Hermitian transpose) if <code>mode</code> is <code>Teuchos::CONJ_TRANS</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>Since this class currently requires A to be real and symmetric positive definite, setting <code>mode</code> should not affect the result. </p>

</div>
</div>
<a id="ad6b3aa8cf647dbe31fb30ab3a8327653" name="ad6b3aa8cf647dbe31fb30ab3a8327653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b3aa8cf647dbe31fb30ab3a8327653">&#9670;&#160;</a></span>getComm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const Teuchos::Comm&lt; int &gt; &gt; <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::getComm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The communicator over which the matrix is distributed. </p>

</div>
</div>
<a id="a5ec9e73341c7ccc9db054564f2f62916" name="a5ec9e73341c7ccc9db054564f2f62916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec9e73341c7ccc9db054564f2f62916">&#9670;&#160;</a></span>getMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const typename <a class="el" href="classIfpack2_1_1Chebyshev.html">Chebyshev</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1Chebyshev.html#aa548468ec7dec28155b23446c71063b0">::row_matrix_type</a> &gt; <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::getMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The matrix for which this is a preconditioner. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a4258d242e7ff6003c399da8f0a11d634">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="abecf9825fa3117131b61ccb35ebef73b" name="abecf9825fa3117131b61ccb35ebef73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abecf9825fa3117131b61ccb35ebef73b">&#9670;&#160;</a></span>getCrsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const Tpetra::CrsMatrix&lt; typename MatrixType::scalar_type, typename MatrixType::local_ordinal_type, typename MatrixType::global_ordinal_type, typename MatrixType::node_type &gt; &gt; <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::getCrsMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to return the matrix A as a Tpetra::CrsMatrix. </p>
<p>This class does not require that A be a Tpetra::CrsMatrix. If it is NOT, this method will return Teuchos::null. </p>

</div>
</div>
<a id="ab0d29ff0fd2bd08834f8772b1990614c" name="ab0d29ff0fd2bd08834f8772b1990614c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0d29ff0fd2bd08834f8772b1990614c">&#9670;&#160;</a></span>getComputeFlops()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::getComputeFlops </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The total number of floating-point operations taken by all calls to <a class="el" href="classIfpack2_1_1Chebyshev.html#a231f970f4a6176a460ae39f57a2b3f90" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a>. </p>

</div>
</div>
<a id="ada00143f807ef74c8fef36e88472c38d" name="ada00143f807ef74c8fef36e88472c38d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada00143f807ef74c8fef36e88472c38d">&#9670;&#160;</a></span>getApplyFlops()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::getApplyFlops </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The total number of floating-point operations taken by all calls to <a class="el" href="classIfpack2_1_1Chebyshev.html#aee64f2426f179132accffdbf2965c067" title="Apply the preconditioner to X, returning the result in Y.">apply()</a>. </p>

</div>
</div>
<a id="ad3b53ee539d2e01dc591a6b9a4f6a840" name="ad3b53ee539d2e01dc591a6b9a4f6a840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b53ee539d2e01dc591a6b9a4f6a840">&#9670;&#160;</a></span>getNumInitialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::getNumInitialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of successful calls to <a class="el" href="classIfpack2_1_1Chebyshev.html#a58de3ab7b5dc7fefd2f3f51e1dcef561" title="Initialize the preconditioner.">initialize()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#afe6c77c5ab6da065f8dbade353e8535a">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="aaa4a28567fe2a27f10a89b4931046490" name="aaa4a28567fe2a27f10a89b4931046490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4a28567fe2a27f10a89b4931046490">&#9670;&#160;</a></span>getNumCompute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::getNumCompute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of successful calls to <a class="el" href="classIfpack2_1_1Chebyshev.html#a231f970f4a6176a460ae39f57a2b3f90" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a286b18ee0769ecc8bf992dffdc442791">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a69f8171b602bf9aa3e4cee96ed9a4563" name="a69f8171b602bf9aa3e4cee96ed9a4563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f8171b602bf9aa3e4cee96ed9a4563">&#9670;&#160;</a></span>getNumApply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::getNumApply </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of successful calls to <a class="el" href="classIfpack2_1_1Chebyshev.html#aee64f2426f179132accffdbf2965c067" title="Apply the preconditioner to X, returning the result in Y.">apply()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a565e6c00bf14873ae7b23187c9978078">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a1eaeaaf30327f0a75870ed650191a903" name="a1eaeaaf30327f0a75870ed650191a903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eaeaaf30327f0a75870ed650191a903">&#9670;&#160;</a></span>getInitializeTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::getInitializeTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total time spent in all calls to <a class="el" href="classIfpack2_1_1Chebyshev.html#a58de3ab7b5dc7fefd2f3f51e1dcef561" title="Initialize the preconditioner.">initialize()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#aeb91a16f5544ad4efaf756b1d2a8b39d">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="ab905b21ad57ecf9bb26259336d4cbfd4" name="ab905b21ad57ecf9bb26259336d4cbfd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab905b21ad57ecf9bb26259336d4cbfd4">&#9670;&#160;</a></span>getComputeTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::getComputeTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total time spent in all calls to <a class="el" href="classIfpack2_1_1Chebyshev.html#a231f970f4a6176a460ae39f57a2b3f90" title="(Re)compute the left scaling, and (if applicable) estimate max and min eigenvalues of D_inv * A.">compute()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a111d9bd4e28c0633696f271955ddcb4c">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="af7a90ada6216fa6a59d96884c7710119" name="af7a90ada6216fa6a59d96884c7710119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a90ada6216fa6a59d96884c7710119">&#9670;&#160;</a></span>getApplyTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::getApplyTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total time spent in all calls to <a class="el" href="classIfpack2_1_1Chebyshev.html#aee64f2426f179132accffdbf2965c067" title="Apply the preconditioner to X, returning the result in Y.">apply()</a>. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a57c2d00799de050cd2a5a75ce80f48b9">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a8709e5192d9516c89c08b332aad497b3" name="a8709e5192d9516c89c08b332aad497b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8709e5192d9516c89c08b332aad497b3">&#9670;&#160;</a></span>getNodeSmootherComplexity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::getNodeSmootherComplexity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a rough estimate of cost per iteration. </p>

</div>
</div>
<a id="af1b15bf3d958954fc0250f24b620b5e9" name="af1b15bf3d958954fc0250f24b620b5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b15bf3d958954fc0250f24b620b5e9">&#9670;&#160;</a></span>getLambdaMaxForApply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixType::scalar_type <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::getLambdaMaxForApply </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The estimate of the maximum eigenvalue used in the <a class="el" href="classIfpack2_1_1Chebyshev.html#aee64f2426f179132accffdbf2965c067" title="Apply the preconditioner to X, returning the result in Y.">apply()</a>. </p>

</div>
</div>
<a id="a258d89a2a10da59034d64b9772353bec" name="a258d89a2a10da59034d64b9772353bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258d89a2a10da59034d64b9772353bec">&#9670;&#160;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple one-line description of this object. </p>

</div>
</div>
<a id="a3a704f09f720e53104126b0e51dedf8e" name="a3a704f09f720e53104126b0e51dedf8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a704f09f720e53104126b0e51dedf8e">&#9670;&#160;</a></span>describe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1Chebyshev.html">Ifpack2::Chebyshev</a>&lt; MatrixType &gt;::describe </td>
          <td>(</td>
          <td class="paramtype">Teuchos::FancyOStream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::EVerbosityLevel&#160;</td>
          <td class="paramname"><em>verbLevel</em> = <code>Teuchos::Describable::verbLevel_default</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the object with some verbosity level to a Teuchos::FancyOStream. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Ifpack2__Chebyshev__decl_8hpp_source.html">Ifpack2_Chebyshev_decl.hpp</a></li>
<li><a class="el" href="Ifpack2__Chebyshev__def_8hpp_source.html">Ifpack2_Chebyshev_def.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
