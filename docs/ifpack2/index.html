<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ifpack2 Templated Preconditioning Package: Trilinos/Ifpack2: Incomplete factorizations, relaxations, and domain decomposition for Tpetra objects</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Ifpack2 Templated Preconditioning Package<span id="projectnumber">&#160;Version 1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Trilinos/Ifpack2: Incomplete factorizations, relaxations, and domain decomposition for Tpetra objects </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Ifpack2_intro"></a>
What is Ifpack2?</h1>
<p><a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> provides incomplete factorizations, relaxations, and domain decomposition operators for linear algebra objects (sparse matrices, operators, and dense vectors and multivectors) provided by the Tpetra package. You may use these operators however you wish: for example as preconditioners in an iterative solver, or as smoothers for algebraic multigrid.</p>
<p><a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> aims at offering the same functionality as the Ifpack package, though it does not promise backwards compatibility. Ifpack only works for Epetra linear algebra objects; <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> only works for Tpetra objects.</p>
<h1><a class="anchor" id="Ifpack2_why"></a>
Why Ifpack2?</h1>
<p>Why do you want to use <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a>? First, if you are using Tpetra, you need to use <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> if you want incomplete factorizations, relaxations, or domain decomposition. Second, <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> gives you the same advantages as Tpetra. You can solve problems with more than two billion unknowns, by using 64-bit global indices, yet save memory at the same time by only storing 32-bit local indices. You can use matrices and vectors with any sensible data type, not just <code>double</code>. For example, you can use <code>float</code> to save memory, or an extended-precision type like <code>dd_real</code> or <code>qd_real</code> to improve robustness for difficult problems. <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> even works with complex-valued data, like <code>std::complex&lt;float&gt;</code> and <code>std::complex&lt;double&gt;</code>. Finally, <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a>'s algorithms use and produce Tpetra objects, so you can exploit Tpetra's hybrid (MPI + threads) parallelism features without effort.</p>
<h1><a class="anchor" id="Ifpack2_methods"></a>
Methods that Ifpack2 implements</h1>
<h2><a class="anchor" id="Ifpack2_methods_relax"></a>
Relaxations and smoothers</h2>
<p><a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> implements the following relaxations, smoothers, and related preconditioners: </p><ul>
<li>
Diagonal scaling </li>
<li>
Jacobi (with optional damping) </li>
<li>
Gauss-Seidel </li>
<li>
Successive Over-Relaxation (SOR) </li>
<li>
Symmetric versions of Gauss-Seidel and SOR </li>
<li>
Chebyshev iteration (as a smoother) </li>
</ul>
<p>Gauss-Seidel is actually a special case of SOR, when the damping parameter \(\omega = 1\). <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> calls them both "Gauss-Seidel." You may specify the sweep direction: forward, backward, or symmetric (first forward, then backward). We do not currently implement other sweep directions or parallelization schemes (such as red-black ordering), but you may reorder the rows yourself if you have a specific sweep direction in mind.</p>
<p><a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a>'s implementation of (Gauss-Seidel and) SOR is actually a "hybrid" relaxation. This means that it only performs SOR within an MPI process, but does Jacobi-type updates between MPI processes. While this can reduce effectiveness of the algorithms as preconditioners or smoothers, <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> implements an "L1" option to improve convergence despite this. For details, please refer to the following publication:</p>
<p>A. H. Baker, R. D. Falgout, T. V. Kolev, and U. M. Yang. "Multigrid Smoothers for Ultraparallel Computing." <em>SIAM J. Sci. Comput.</em>, Vol. 33, No. 5 (2011), pp. 2864-2887.</p>
<p>For diagonal scaling, see the <a class="el" href="classIfpack2_1_1Diagonal.html" title="Diagonal preconditioner.">Ifpack2::Diagonal</a> class. The <a class="el" href="classIfpack2_1_1Relaxation.html" title="Relaxation preconditioners for Tpetra::RowMatrix and Tpetra::CrsMatrix sparse matrices.">Ifpack2::Relaxation</a> class implements Jacobi, Gauss-Seidel, SOR, and the symmetric variants of the latter two. The <a class="el" href="classIfpack2_1_1Chebyshev.html" title="Diagonally scaled Chebyshev iteration for Tpetra sparse matrices.">Ifpack2::Chebyshev</a> class implements Chebyshev iteration.</p>
<h2><a class="anchor" id="Ifpack2_methods_fact"></a>
Incomplete factorizations</h2>
<p><a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> implements two different incomplete factorizations: ILUT (<a class="el" href="classIfpack2_1_1ILUT.html" title="ILUT (incomplete LU factorization with threshold) of a Tpetra sparse matrix.">Ifpack2::ILUT</a>) and RILU(k) (<a class="el" href="classIfpack2_1_1RILUK.html" title="ILU(k) factorization of a given Tpetra::RowMatrix.">Ifpack2::RILUK</a>). ILUT is a threshold-based incomplete LU factorization, and RILU(k) is a "relaxed" incomplete LU with level k fill. <br  />
</p>
<p>Both of these only perform the factorization on a matrix in a single MPI process.</p>
<p>Our ILUT implementation factors each MPI process' part of the matrix independently, and treats multiple processes via nonoverlapping domain decomposition. Our RILU(k) implementation's factorization reaches across processes by overlapping off-process entries up to a specified integer level of overlap, and factoring them redundantly on each process. For details on each algorithm and its options, please refer to the specific class' documentation. Also, for ILUT, please refer to the following publication:</p>
<p>Youcef Saad, "ILUT: A dual threshold incomplete LU factorization," Numer. Linear Algebra Appl., Vol. 1 (1994), pp. 387-402.</p>
<h2><a class="anchor" id="Ifpack2_methods_dom"></a>
Domain decomposition</h2>
<p>Finally, <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> implements additive Schwarz domain decomposition, via the <a class="el" href="classIfpack2_1_1AdditiveSchwarz.html" title="Additive Schwarz domain decomposition for Tpetra sparse matrices.">Ifpack2::AdditiveSchwarz</a> class. The user may specify any subdomain solver they wish.</p>
<h1><a class="anchor" id="Ifpack2_interface"></a>
Interface to Ifpack2 methods</h1>
<p>All <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> operators inherit from the base class <a class="el" href="classIfpack2_1_1Preconditioner.html" title="Interface for all Ifpack2 preconditioners.">Ifpack2::Preconditioner</a>. This in turn inherits from Tpetra::Operator. Thus, you may use an <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> operator anywhere that a Tpetra::Operator works. For example, you may use <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> operators directly as preconditioners in Trilinos' <a class="elRef" href="../../../belos/doc/html/namespaceBelos.html">Belos</a> package of iterative solvers.</p>
<p>You may either create an <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> operator directly, by using the class and options that you want, or by using <a class="el" href="classIfpack2_1_1Factory.html" title="&quot;Factory&quot; for creating Ifpack2 preconditioners.">Ifpack2::Factory</a>. <a class="el" href="classIfpack2_1_1Factory.html" title="&quot;Factory&quot; for creating Ifpack2 preconditioners.">Ifpack2::Factory</a> is templated on a specialization of Tpetra::RowMatrix. The Factory will use that template parameter to get all the information that it needs to make a preconditioner of the right type. All the specific <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> preconditioners are also templated on a specialization of Tpetra::RowMatrix. Some of them only accept a Tpetra::CrsMatrix instance as input, while others also may accept a Tpetra::RowMatrix (the base class of Tpetra::CrsMatrix). They will decide at run time whether the input Tpetra::RowMatrix is an instance of the right subclass.</p>
<h1><a class="anchor" id="Ifpack2_examples"></a>
Examples</h1>
<p>The ifpack2/test/belos directory includes a test program which shows how to create <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> operators and use them as preconditioners with <a class="elRef" href="../../../belos/doc/html/namespaceBelos.html">Belos</a> iterative solvers. See belos_solve.cpp and belos_extprec_solve.cpp in that directory. The test program is entirely driven by XML input files, which specify the matrix file to be used, as well as parameters for the preconditioner, and the <a class="elRef" href="../../../belos/doc/html/namespaceBelos.html">Belos</a> iterative solver type to use.</p>
<p>If you build <a class="elRef" href="../../../belos/doc/html/namespaceBelos.html">Belos</a> with examples enabled, the example will build as Ifpack2_tif_belos.exe and will be installed in the packages/ifpack2/test/belos directory.</p>
<h1><a class="anchor" id="Ifpack2_AddPrec"></a>
How do I add a preconditioner?</h1>
<h2><a class="anchor" id="Ifpack2_AddPrec_ClassName"></a>
How do I name my new class?</h2>
<p>Use CamelCase, with the first character upper case. Do <em>not</em> prefix with <code>Ifpack2_</code> or any other indication of the namespace. That prefix exists in Epetra and IFPACK only because the compilers that those packages had to support did not implement namespaces. <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> requires C++11, so there is no question that namespaces work.</p>
<p>Suppose that you wanted to add a block symmetric \(LDL^T\) incomplete factorization to <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a>. You might call the class <code>BlockILDL</code> or <code>BlockIncompleteSymmetricIndefiniteFactorization</code>.</p>
<h2><a class="anchor" id="Ifpack2_AddPrec_FuncName"></a>
Naming functions, methods, etc.</h2>
<p>Use camelCase, with the first character lower case.</p>
<h2><a class="anchor" id="Ifpack2_AddPrec_TmplParams"></a>
Template parameters</h2>
<p>There is some debate over the correct template parameters for <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> preconditioners. I would prefer that they use the same four template parameters as <a class="el" href="classIfpack2_1_1Preconditioner.html" title="Interface for all Ifpack2 preconditioners.">Ifpack2::Preconditioner</a>, but unfortunately they don't. Templating on <code>MatrixType</code> confuses users and complicates <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a>'s implementation of explicit template instantiation (ETI), but it's the convention. Regardless, <code>MatrixType</code> <em>MUST</em> be a specialization of Tpetra::RowMatrix. If the preconditioner only works for Tpetra::CrsMatrix, accept the matrix as a Tpetra::RowMatrix and check at run time with a <code>dynamic_cast</code> whether it is a Tpetra::CrsMatrix.</p>
<h2><a class="anchor" id="Ifpack2_AddPrec_InitFini"></a>
Initialization and finalization</h2>
<p>Life is easier when <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> preconditioners implement the <a class="el" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html" title="Mix-in interface for preconditioners that can change their matrix after construction.">Ifpack2::Details::CanChangeMatrix</a> interface (see <code><a class="el" href="Ifpack2__Details__CanChangeMatrix_8hpp.html" title="Declaration of interface for preconditioners that can change their matrix after construction.">ifpack2/src/Ifpack2_Details_CanChangeMatrix.hpp</a></code>). Changing the matrix undoes all initialization. My convention is that changing the matrix to null makes the preconditioner release all matrix-specific allocated state.</p>
<p>This implies that the preconditioner's constructor shouldn't actually do anything, other than set the matrix. Any initialization that depends on the graph structure or communication patterns (Maps, Import/Export, etc.) should happen in <code>initialize()</code>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
