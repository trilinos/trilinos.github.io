<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ifpack2 Templated Preconditioning Package: Ifpack2::RILUK&lt; MatrixType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Ifpack2 Templated Preconditioning Package<span id="projectnumber">&#160;Version 1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceIfpack2.html">Ifpack2</a></li><li class="navelem"><a class="el" href="classIfpack2_1_1RILUK.html">RILUK</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="classIfpack2_1_1RILUK-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ifpack2::RILUK&lt; MatrixType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>ILU(k) factorization of a given Tpetra::RowMatrix.  
 <a href="classIfpack2_1_1RILUK.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Ifpack2__RILUK__decl_8hpp_source.html">Ifpack2_RILUK_decl.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Ifpack2::RILUK&lt; MatrixType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classIfpack2_1_1RILUK__inherit__graph.png" border="0" usemap="#aIfpack2_1_1RILUK_3_01MatrixType_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aIfpack2_1_1RILUK_3_01MatrixType_01_4_inherit__map" id="aIfpack2_1_1RILUK_3_01MatrixType_01_4_inherit__map">
<area shape="rect" title="ILU(k) factorization of a given Tpetra::RowMatrix." alt="" coords="771,125,989,150"/>
<area shape="rect" href="classIfpack2_1_1RILUK.html" title=" " alt="" coords="1255,88,1493,187"/>
<area shape="poly" title=" " alt="" coords="1003,135,1255,135,1255,140,1003,140"/>
<area shape="rect" href="classIfpack2_1_1Preconditioner.html" title=" " alt="" coords="480,37,719,121"/>
<area shape="poly" title=" " alt="" coords="733,104,819,122,818,127,732,109"/>
<area shape="rect" href="classIfpack2_1_1Preconditioner.html" title="Interface for all Ifpack2 preconditioners." alt="" coords="23,50,195,105"/>
<area shape="poly" title=" " alt="" coords="209,75,480,76,480,81,209,80"/>
<area shape="rect" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html" title=" " alt="" coords="477,145,721,244"/>
<area shape="poly" title=" " alt="" coords="734,164,816,147,817,153,735,170"/>
<area shape="rect" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html" title="Mix&#45;in interface for preconditioners that can change their matrix after construction." alt="" coords="5,176,212,216"/>
<area shape="poly" title=" " alt="" coords="226,193,477,192,477,198,226,198"/>
<area shape="rect" href="classIfpack2_1_1Experimental_1_1RBILUK.html" title="ILU(k) factorization of a given Tpetra::BlockCrsMatrix." alt="" coords="1543,117,1723,157"/>
<area shape="poly" title=" " alt="" coords="1507,135,1543,135,1543,140,1507,140"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5be3334c12cccb16ef56bdf8bb9c91e9" id="r_a5be3334c12cccb16ef56bdf8bb9c91e9"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::scalar_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a5be3334c12cccb16ef56bdf8bb9c91e9">scalar_type</a></td></tr>
<tr class="memdesc:a5be3334c12cccb16ef56bdf8bb9c91e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the entries of the input MatrixType.  <br /></td></tr>
<tr class="separator:a5be3334c12cccb16ef56bdf8bb9c91e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36f2189fbed534cbbdea630aa74e1aa" id="r_ab36f2189fbed534cbbdea630aa74e1aa"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::local_ordinal_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#ab36f2189fbed534cbbdea630aa74e1aa">local_ordinal_type</a></td></tr>
<tr class="memdesc:ab36f2189fbed534cbbdea630aa74e1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of local indices in the input MatrixType.  <br /></td></tr>
<tr class="separator:ab36f2189fbed534cbbdea630aa74e1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ada3f6fe8e8480258a3000eb3afee4" id="r_ac2ada3f6fe8e8480258a3000eb3afee4"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::global_ordinal_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#ac2ada3f6fe8e8480258a3000eb3afee4">global_ordinal_type</a></td></tr>
<tr class="memdesc:ac2ada3f6fe8e8480258a3000eb3afee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of global indices in the input MatrixType.  <br /></td></tr>
<tr class="separator:ac2ada3f6fe8e8480258a3000eb3afee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747a932722227155880d659b8d996944" id="r_a747a932722227155880d659b8d996944"><td class="memItemLeft" align="right" valign="top">typedef MatrixType::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a747a932722227155880d659b8d996944">node_type</a></td></tr>
<tr class="memdesc:a747a932722227155880d659b8d996944"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Node type used by the input MatrixType.  <br /></td></tr>
<tr class="separator:a747a932722227155880d659b8d996944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c661b390233d88d32774cd8fd428d5" id="r_a23c661b390233d88d32774cd8fd428d5"><td class="memItemLeft" align="right" valign="top">typedef Teuchos::ScalarTraits&lt; <a class="el" href="classIfpack2_1_1RILUK.html#a5be3334c12cccb16ef56bdf8bb9c91e9">scalar_type</a> &gt;::magnitudeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a23c661b390233d88d32774cd8fd428d5">magnitude_type</a></td></tr>
<tr class="memdesc:a23c661b390233d88d32774cd8fd428d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the magnitude (absolute value) of a matrix entry.  <br /></td></tr>
<tr class="separator:a23c661b390233d88d32774cd8fd428d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4cef7ea67194cca8e6b919ce9012dc2" id="r_ac4cef7ea67194cca8e6b919ce9012dc2"><td class="memItemLeft" align="right" valign="top">typedef node_type::device_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#ac4cef7ea67194cca8e6b919ce9012dc2">device_type</a></td></tr>
<tr class="memdesc:ac4cef7ea67194cca8e6b919ce9012dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Kokkos device type of the input MatrixType.  <br /></td></tr>
<tr class="separator:ac4cef7ea67194cca8e6b919ce9012dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d119055541094930905ef6137410fe" id="r_ac9d119055541094930905ef6137410fe"><td class="memItemLeft" align="right" valign="top">typedef node_type::execution_space&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#ac9d119055541094930905ef6137410fe">execution_space</a></td></tr>
<tr class="memdesc:ac9d119055541094930905ef6137410fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Kokkos execution space of the input MatrixType.  <br /></td></tr>
<tr class="separator:ac9d119055541094930905ef6137410fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d08264f25ccadf5a202c604f0f99ac" id="r_af1d08264f25ccadf5a202c604f0f99ac"><td class="memItemLeft" align="right" valign="top">typedef Tpetra::RowMatrix&lt; <a class="el" href="classIfpack2_1_1RILUK.html#a5be3334c12cccb16ef56bdf8bb9c91e9">scalar_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#ab36f2189fbed534cbbdea630aa74e1aa">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#ac2ada3f6fe8e8480258a3000eb3afee4">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#a747a932722227155880d659b8d996944">node_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#af1d08264f25ccadf5a202c604f0f99ac">row_matrix_type</a></td></tr>
<tr class="memdesc:af1d08264f25ccadf5a202c604f0f99ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tpetra::RowMatrix specialization used by this class.  <br /></td></tr>
<tr class="separator:af1d08264f25ccadf5a202c604f0f99ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ec31dfcd53096c3143aa7ecaa04853" id="r_a11ec31dfcd53096c3143aa7ecaa04853"><td class="memItemLeft" align="right" valign="top">typedef Tpetra::CrsMatrix&lt; <a class="el" href="classIfpack2_1_1RILUK.html#a5be3334c12cccb16ef56bdf8bb9c91e9">scalar_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#ab36f2189fbed534cbbdea630aa74e1aa">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#ac2ada3f6fe8e8480258a3000eb3afee4">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#a747a932722227155880d659b8d996944">node_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a11ec31dfcd53096c3143aa7ecaa04853">crs_matrix_type</a></td></tr>
<tr class="memdesc:a11ec31dfcd53096c3143aa7ecaa04853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tpetra::CrsMatrix specialization used by this class for representing L and U.  <br /></td></tr>
<tr class="separator:a11ec31dfcd53096c3143aa7ecaa04853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013fa638900f40d39012393b0494d910" id="r_a013fa638900f40d39012393b0494d910"><td class="memItemLeft" align="right" valign="top">typedef crs_matrix_type::impl_scalar_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a013fa638900f40d39012393b0494d910">impl_scalar_type</a></td></tr>
<tr class="memdesc:a013fa638900f40d39012393b0494d910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar type stored in Kokkos::Views (CrsMatrix and MultiVector)  <br /></td></tr>
<tr class="separator:a013fa638900f40d39012393b0494d910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classIfpack2_1_1Preconditioner"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classIfpack2_1_1Preconditioner')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classIfpack2_1_1Preconditioner.html">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a></td></tr>
<tr class="memitem:a222c0e260ac8dc1226573e8a0773ac63 inherit pub_types_classIfpack2_1_1Preconditioner" id="r_a222c0e260ac8dc1226573e8a0773ac63"><td class="memItemLeft" align="right" valign="top">typedef Teuchos::ScalarTraits&lt; MatrixType::scalar_type &gt;::magnitudeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Preconditioner.html#a222c0e260ac8dc1226573e8a0773ac63">magnitude_type</a></td></tr>
<tr class="memdesc:a222c0e260ac8dc1226573e8a0773ac63 inherit pub_types_classIfpack2_1_1Preconditioner"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the magnitude (absolute value) of a matrix entry.  <br /></td></tr>
<tr class="separator:a222c0e260ac8dc1226573e8a0773ac63 inherit pub_types_classIfpack2_1_1Preconditioner"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Implementation of Ifpack2::Details::CanChangeMatrix</div></td></tr>
<tr class="memitem:a512635465b0b40588793f1891b45a91e" id="r_a512635465b0b40588793f1891b45a91e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a512635465b0b40588793f1891b45a91e">setMatrix</a> (const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1RILUK.html#af1d08264f25ccadf5a202c604f0f99ac">row_matrix_type</a> &gt; &amp;A)</td></tr>
<tr class="memdesc:a512635465b0b40588793f1891b45a91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the matrix to be preconditioned.  <br /></td></tr>
<tr class="separator:a512635465b0b40588793f1891b45a91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implementation of Teuchos::Describable interface</div></td></tr>
<tr class="memitem:a4ccdc58864f256fa85b6fb14a25c22f8" id="r_a4ccdc58864f256fa85b6fb14a25c22f8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a4ccdc58864f256fa85b6fb14a25c22f8">description</a> () const</td></tr>
<tr class="memdesc:a4ccdc58864f256fa85b6fb14a25c22f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A one-line description of this object.  <br /></td></tr>
<tr class="separator:a4ccdc58864f256fa85b6fb14a25c22f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classIfpack2_1_1Preconditioner"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classIfpack2_1_1Preconditioner')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classIfpack2_1_1Preconditioner.html">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a></td></tr>
<tr class="memitem:a637973211128e0c09db53772df0f345d inherit pub_methods_classIfpack2_1_1Preconditioner" id="r_a637973211128e0c09db53772df0f345d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Preconditioner.html#a637973211128e0c09db53772df0f345d">~Preconditioner</a> ()</td></tr>
<tr class="memdesc:a637973211128e0c09db53772df0f345d inherit pub_methods_classIfpack2_1_1Preconditioner"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a637973211128e0c09db53772df0f345d inherit pub_methods_classIfpack2_1_1Preconditioner"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12495acd22d15212241c0d518d7f6536 inherit pub_methods_classIfpack2_1_1Preconditioner" id="r_a12495acd22d15212241c0d518d7f6536"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Preconditioner.html#a12495acd22d15212241c0d518d7f6536">setZeroStartingSolution</a> (bool zeroStartingSolution)</td></tr>
<tr class="memdesc:a12495acd22d15212241c0d518d7f6536 inherit pub_methods_classIfpack2_1_1Preconditioner"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this preconditioner's parameters.  <br /></td></tr>
<tr class="separator:a12495acd22d15212241c0d518d7f6536 inherit pub_methods_classIfpack2_1_1Preconditioner"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html">Ifpack2::Details::CanChangeMatrix&lt; Tpetra::RowMatrix&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt; &gt;</a></td></tr>
<tr class="memitem:acad726ffa06a9eef5d675364f996101a inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix" id="r_acad726ffa06a9eef5d675364f996101a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">virtual</a> <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html#acad726ffa06a9eef5d675364f996101a">setMatrix</a> (<a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">const</a> Tpetra::RowMatrix&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt; &gt; &amp;A)=0</td></tr>
<tr class="memdesc:acad726ffa06a9eef5d675364f996101a inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the new matrix.  <br /></td></tr>
<tr class="separator:acad726ffa06a9eef5d675364f996101a inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad9626e6fa50980dc192a4a63341c12 inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix" id="r_abad9626e6fa50980dc192a4a63341c12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1Details_1_1LinearSolver.html">virtual</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1Details_1_1CanChangeMatrix.html#abad9626e6fa50980dc192a4a63341c12">~CanChangeMatrix</a> ()</td></tr>
<tr class="memdesc:abad9626e6fa50980dc192a4a63341c12 inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:abad9626e6fa50980dc192a4a63341c12 inherit pub_methods_classIfpack2_1_1Details_1_1CanChangeMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Implementation of Kokkos Kernels ILU(k).</h2></td></tr>
<tr class="memitem:acf5cac91aeab107501fb7fd7d0627bae" id="r_acf5cac91aeab107501fb7fd7d0627bae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#acf5cac91aeab107501fb7fd7d0627bae">RILUK</a> (const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1RILUK.html#af1d08264f25ccadf5a202c604f0f99ac">row_matrix_type</a> &gt; &amp;A_in)</td></tr>
<tr class="memdesc:acf5cac91aeab107501fb7fd7d0627bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that takes a Tpetra::RowMatrix.  <br /></td></tr>
<tr class="separator:acf5cac91aeab107501fb7fd7d0627bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164b7f3e56288379e054371852be215d" id="r_a164b7f3e56288379e054371852be215d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a164b7f3e56288379e054371852be215d">RILUK</a> (const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1RILUK.html#a11ec31dfcd53096c3143aa7ecaa04853">crs_matrix_type</a> &gt; &amp;A_in)</td></tr>
<tr class="memdesc:a164b7f3e56288379e054371852be215d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that takes a Tpetra::CrsMatrix.  <br /></td></tr>
<tr class="separator:a164b7f3e56288379e054371852be215d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bf0fe45360dd7ffad930f7e9ff7e81" id="r_a14bf0fe45360dd7ffad930f7e9ff7e81"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a14bf0fe45360dd7ffad930f7e9ff7e81">~RILUK</a> ()</td></tr>
<tr class="memdesc:a14bf0fe45360dd7ffad930f7e9ff7e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor (declared virtual for memory safety).  <br /></td></tr>
<tr class="separator:a14bf0fe45360dd7ffad930f7e9ff7e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98b7ed700c803c8aea80eec12c96ca7" id="r_aa98b7ed700c803c8aea80eec12c96ca7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#aa98b7ed700c803c8aea80eec12c96ca7">setParameters</a> (const Teuchos::ParameterList &amp;params)</td></tr>
<tr class="separator:aa98b7ed700c803c8aea80eec12c96ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f4f95081fcbf5eb8f5a5d18d0c717b" id="r_a06f4f95081fcbf5eb8f5a5d18d0c717b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a06f4f95081fcbf5eb8f5a5d18d0c717b">initialize</a> ()</td></tr>
<tr class="memdesc:a06f4f95081fcbf5eb8f5a5d18d0c717b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize by computing the symbolic incomplete factorization.  <br /></td></tr>
<tr class="separator:a06f4f95081fcbf5eb8f5a5d18d0c717b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6975338fab389e7c2a9bede6162b85a" id="r_ad6975338fab389e7c2a9bede6162b85a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#ad6975338fab389e7c2a9bede6162b85a">compute</a> ()</td></tr>
<tr class="memdesc:ad6975338fab389e7c2a9bede6162b85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (numeric) incomplete factorization.  <br /></td></tr>
<tr class="separator:ad6975338fab389e7c2a9bede6162b85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf03ca56c60a928138c2a77e5394165" id="r_aeaf03ca56c60a928138c2a77e5394165"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#aeaf03ca56c60a928138c2a77e5394165">isInitialized</a> () const</td></tr>
<tr class="memdesc:aeaf03ca56c60a928138c2a77e5394165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether <a class="el" href="classIfpack2_1_1RILUK.html#a06f4f95081fcbf5eb8f5a5d18d0c717b" title="Initialize by computing the symbolic incomplete factorization.">initialize()</a> has been called on this object.  <br /></td></tr>
<tr class="separator:aeaf03ca56c60a928138c2a77e5394165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c83210a2a5dcd83d8b126ec84c9e6e5" id="r_a5c83210a2a5dcd83d8b126ec84c9e6e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a5c83210a2a5dcd83d8b126ec84c9e6e5">isComputed</a> () const</td></tr>
<tr class="memdesc:a5c83210a2a5dcd83d8b126ec84c9e6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether <a class="el" href="classIfpack2_1_1RILUK.html#ad6975338fab389e7c2a9bede6162b85a" title="Compute the (numeric) incomplete factorization.">compute()</a> has been called on this object.  <br /></td></tr>
<tr class="separator:a5c83210a2a5dcd83d8b126ec84c9e6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab97a9734e005ca38ef37d957fdc615b" id="r_aab97a9734e005ca38ef37d957fdc615b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#aab97a9734e005ca38ef37d957fdc615b">getNumInitialize</a> () const</td></tr>
<tr class="memdesc:aab97a9734e005ca38ef37d957fdc615b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of successful <a class="el" href="classIfpack2_1_1RILUK.html#a06f4f95081fcbf5eb8f5a5d18d0c717b" title="Initialize by computing the symbolic incomplete factorization.">initialize()</a> calls for this object.  <br /></td></tr>
<tr class="separator:aab97a9734e005ca38ef37d957fdc615b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328038b9f826473acf632010a1a334f7" id="r_a328038b9f826473acf632010a1a334f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a328038b9f826473acf632010a1a334f7">getNumCompute</a> () const</td></tr>
<tr class="memdesc:a328038b9f826473acf632010a1a334f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of successful <a class="el" href="classIfpack2_1_1RILUK.html#ad6975338fab389e7c2a9bede6162b85a" title="Compute the (numeric) incomplete factorization.">compute()</a> calls for this object.  <br /></td></tr>
<tr class="separator:a328038b9f826473acf632010a1a334f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b701e279c2a70d62df07ff160708035" id="r_a2b701e279c2a70d62df07ff160708035"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a2b701e279c2a70d62df07ff160708035">getNumApply</a> () const</td></tr>
<tr class="memdesc:a2b701e279c2a70d62df07ff160708035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of successful <a class="el" href="classIfpack2_1_1RILUK.html#a2203f315f98c6555df9cedd98266138e" title="Apply the (inverse of the) incomplete factorization to X, resulting in Y.">apply()</a> calls for this object.  <br /></td></tr>
<tr class="separator:a2b701e279c2a70d62df07ff160708035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0365418e0b4120d5508b0d94984be2a" id="r_af0365418e0b4120d5508b0d94984be2a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#af0365418e0b4120d5508b0d94984be2a">getInitializeTime</a> () const</td></tr>
<tr class="memdesc:af0365418e0b4120d5508b0d94984be2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total time in seconds taken by all successful <a class="el" href="classIfpack2_1_1RILUK.html#a06f4f95081fcbf5eb8f5a5d18d0c717b" title="Initialize by computing the symbolic incomplete factorization.">initialize()</a> calls for this object.  <br /></td></tr>
<tr class="separator:af0365418e0b4120d5508b0d94984be2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283fd039d9ac66e32e2c71a02d32eb35" id="r_a283fd039d9ac66e32e2c71a02d32eb35"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a283fd039d9ac66e32e2c71a02d32eb35">getComputeTime</a> () const</td></tr>
<tr class="memdesc:a283fd039d9ac66e32e2c71a02d32eb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total time in seconds taken by all successful <a class="el" href="classIfpack2_1_1RILUK.html#ad6975338fab389e7c2a9bede6162b85a" title="Compute the (numeric) incomplete factorization.">compute()</a> calls for this object.  <br /></td></tr>
<tr class="separator:a283fd039d9ac66e32e2c71a02d32eb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c44c72c54e4d8f97b3e6e2096393a3e" id="r_a1c44c72c54e4d8f97b3e6e2096393a3e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a1c44c72c54e4d8f97b3e6e2096393a3e">getApplyTime</a> () const</td></tr>
<tr class="memdesc:a1c44c72c54e4d8f97b3e6e2096393a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total time in seconds taken by all successful <a class="el" href="classIfpack2_1_1RILUK.html#a2203f315f98c6555df9cedd98266138e" title="Apply the (inverse of the) incomplete factorization to X, resulting in Y.">apply()</a> calls for this object.  <br /></td></tr>
<tr class="separator:a1c44c72c54e4d8f97b3e6e2096393a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39b821cbf0c776d2b65fdad45a7e679" id="r_ad39b821cbf0c776d2b65fdad45a7e679"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#ad39b821cbf0c776d2b65fdad45a7e679">getNodeSmootherComplexity</a> () const</td></tr>
<tr class="memdesc:ad39b821cbf0c776d2b65fdad45a7e679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a rough estimate of cost per iteration.  <br /></td></tr>
<tr class="separator:ad39b821cbf0c776d2b65fdad45a7e679"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Implementation of Tpetra::Operator</h2></td></tr>
<tr class="memitem:a4342e474a2f9ed45ef7a853739abe950" id="r_a4342e474a2f9ed45ef7a853739abe950"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1RILUK.html#af1d08264f25ccadf5a202c604f0f99ac">row_matrix_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a4342e474a2f9ed45ef7a853739abe950">A_</a></td></tr>
<tr class="memdesc:a4342e474a2f9ed45ef7a853739abe950"><td class="mdescLeft">&#160;</td><td class="mdescRight">The (original) input matrix for which to compute ILU(k).  <br /></td></tr>
<tr class="separator:a4342e474a2f9ed45ef7a853739abe950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1f2f9e47d8fbac26dcf29d1f683bdc" id="r_acf1f2f9e47d8fbac26dcf29d1f683bdc"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1IlukGraph.html">iluk_graph_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#acf1f2f9e47d8fbac26dcf29d1f683bdc">Graph_</a></td></tr>
<tr class="memdesc:acf1f2f9e47d8fbac26dcf29d1f683bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ILU(k) graph.  <br /></td></tr>
<tr class="separator:acf1f2f9e47d8fbac26dcf29d1f683bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb557987a77e8f5e30595288640fa45" id="r_a7eb557987a77e8f5e30595288640fa45"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1RILUK.html#af1d08264f25ccadf5a202c604f0f99ac">row_matrix_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a7eb557987a77e8f5e30595288640fa45">A_local_</a></td></tr>
<tr class="memdesc:a7eb557987a77e8f5e30595288640fa45"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix whos numbers are used to to compute ILU(k). The graph may be computed using a crs_matrix_type that <a class="el" href="classIfpack2_1_1RILUK.html#a06f4f95081fcbf5eb8f5a5d18d0c717b" title="Initialize by computing the symbolic incomplete factorization.">initialize()</a> constructs temporarily.  <br /></td></tr>
<tr class="separator:a7eb557987a77e8f5e30595288640fa45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff9857962fd3e6c90b36dc688201cc3" id="r_abff9857962fd3e6c90b36dc688201cc3"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1RILUK.html#a11ec31dfcd53096c3143aa7ecaa04853">crs_matrix_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#abff9857962fd3e6c90b36dc688201cc3">L_</a></td></tr>
<tr class="memdesc:abff9857962fd3e6c90b36dc688201cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The L (lower triangular) factor of ILU(k).  <br /></td></tr>
<tr class="separator:abff9857962fd3e6c90b36dc688201cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec4302094c82208f237a2898fc6dfec" id="r_a8ec4302094c82208f237a2898fc6dfec"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1LocalSparseTriangularSolver.html">LocalSparseTriangularSolver</a>&lt; <a class="el" href="classIfpack2_1_1RILUK.html#af1d08264f25ccadf5a202c604f0f99ac">row_matrix_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a8ec4302094c82208f237a2898fc6dfec">L_solver_</a></td></tr>
<tr class="memdesc:a8ec4302094c82208f237a2898fc6dfec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse triangular solver for L.  <br /></td></tr>
<tr class="separator:a8ec4302094c82208f237a2898fc6dfec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490bafd1705f15b4dc921bc42aa68908" id="r_a490bafd1705f15b4dc921bc42aa68908"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1RILUK.html#a11ec31dfcd53096c3143aa7ecaa04853">crs_matrix_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a490bafd1705f15b4dc921bc42aa68908">U_</a></td></tr>
<tr class="memdesc:a490bafd1705f15b4dc921bc42aa68908"><td class="mdescLeft">&#160;</td><td class="mdescRight">The U (upper triangular) factor of ILU(k).  <br /></td></tr>
<tr class="separator:a490bafd1705f15b4dc921bc42aa68908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab5ae258e10efbc97be037c1e15309d" id="r_acab5ae258e10efbc97be037c1e15309d"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1LocalSparseTriangularSolver.html">LocalSparseTriangularSolver</a>&lt; <a class="el" href="classIfpack2_1_1RILUK.html#af1d08264f25ccadf5a202c604f0f99ac">row_matrix_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#acab5ae258e10efbc97be037c1e15309d">U_solver_</a></td></tr>
<tr class="memdesc:acab5ae258e10efbc97be037c1e15309d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse triangular solver for U.  <br /></td></tr>
<tr class="separator:acab5ae258e10efbc97be037c1e15309d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add271641a94f776edd0c0222b6b32c36" id="r_add271641a94f776edd0c0222b6b32c36"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; vec_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#add271641a94f776edd0c0222b6b32c36">D_</a></td></tr>
<tr class="memdesc:add271641a94f776edd0c0222b6b32c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">The diagonal entries of the ILU(k) factorization.  <br /></td></tr>
<tr class="separator:add271641a94f776edd0c0222b6b32c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3641218a3995552f47e32befa628e97" id="r_ae3641218a3995552f47e32befa628e97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#ae3641218a3995552f47e32befa628e97">isKokkosKernelsSpiluk_</a></td></tr>
<tr class="memdesc:ae3641218a3995552f47e32befa628e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional KokkosKernels implementation.  <br /></td></tr>
<tr class="separator:ae3641218a3995552f47e32befa628e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e226fe0ba0141e2dc89cbba00a75075" id="r_a9e226fe0ba0141e2dc89cbba00a75075"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const Tpetra::Map&lt; <a class="el" href="classIfpack2_1_1RILUK.html#ab36f2189fbed534cbbdea630aa74e1aa">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#ac2ada3f6fe8e8480258a3000eb3afee4">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#a747a932722227155880d659b8d996944">node_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a9e226fe0ba0141e2dc89cbba00a75075">getDomainMap</a> () const</td></tr>
<tr class="memdesc:a9e226fe0ba0141e2dc89cbba00a75075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Tpetra::Map object associated with the domain of this operator.  <br /></td></tr>
<tr class="separator:a9e226fe0ba0141e2dc89cbba00a75075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e65d7235e7e6beaed8b04a507ee327a" id="r_a2e65d7235e7e6beaed8b04a507ee327a"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const Tpetra::Map&lt; <a class="el" href="classIfpack2_1_1RILUK.html#ab36f2189fbed534cbbdea630aa74e1aa">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#ac2ada3f6fe8e8480258a3000eb3afee4">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#a747a932722227155880d659b8d996944">node_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a2e65d7235e7e6beaed8b04a507ee327a">getRangeMap</a> () const</td></tr>
<tr class="memdesc:a2e65d7235e7e6beaed8b04a507ee327a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Tpetra::Map object associated with the range of this operator.  <br /></td></tr>
<tr class="separator:a2e65d7235e7e6beaed8b04a507ee327a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2203f315f98c6555df9cedd98266138e" id="r_a2203f315f98c6555df9cedd98266138e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a2203f315f98c6555df9cedd98266138e">apply</a> (const Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1RILUK.html#a5be3334c12cccb16ef56bdf8bb9c91e9">scalar_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#ab36f2189fbed534cbbdea630aa74e1aa">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#ac2ada3f6fe8e8480258a3000eb3afee4">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#a747a932722227155880d659b8d996944">node_type</a> &gt; &amp;X, Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1RILUK.html#a5be3334c12cccb16ef56bdf8bb9c91e9">scalar_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#ab36f2189fbed534cbbdea630aa74e1aa">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#ac2ada3f6fe8e8480258a3000eb3afee4">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#a747a932722227155880d659b8d996944">node_type</a> &gt; &amp;Y, Teuchos::ETransp mode=Teuchos::NO_TRANS, <a class="el" href="classIfpack2_1_1RILUK.html#a5be3334c12cccb16ef56bdf8bb9c91e9">scalar_type</a> alpha=Teuchos::ScalarTraits&lt; <a class="el" href="classIfpack2_1_1RILUK.html#a5be3334c12cccb16ef56bdf8bb9c91e9">scalar_type</a> &gt;::one(), <a class="el" href="classIfpack2_1_1RILUK.html#a5be3334c12cccb16ef56bdf8bb9c91e9">scalar_type</a> beta=Teuchos::ScalarTraits&lt; <a class="el" href="classIfpack2_1_1RILUK.html#a5be3334c12cccb16ef56bdf8bb9c91e9">scalar_type</a> &gt;::zero()) const</td></tr>
<tr class="memdesc:a2203f315f98c6555df9cedd98266138e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the (inverse of the) incomplete factorization to X, resulting in Y.  <br /></td></tr>
<tr class="separator:a2203f315f98c6555df9cedd98266138e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d8f0552971c5364d0d5c9adb9f900b" id="r_a86d8f0552971c5364d0d5c9adb9f900b"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1RILUK.html#af1d08264f25ccadf5a202c604f0f99ac">row_matrix_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a86d8f0552971c5364d0d5c9adb9f900b">getMatrix</a> () const</td></tr>
<tr class="memdesc:a86d8f0552971c5364d0d5c9adb9f900b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the input matrix.  <br /></td></tr>
<tr class="separator:a86d8f0552971c5364d0d5c9adb9f900b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8b0355a6235ec92501709a7a6c9c9f" id="r_a2f8b0355a6235ec92501709a7a6c9c9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1RILUK.html#a23c661b390233d88d32774cd8fd428d5">magnitude_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a2f8b0355a6235ec92501709a7a6c9c9f">getRelaxValue</a> () const</td></tr>
<tr class="memdesc:a2f8b0355a6235ec92501709a7a6c9c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get RILU(k) relaxation parameter.  <br /></td></tr>
<tr class="separator:a2f8b0355a6235ec92501709a7a6c9c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c39986f4750fecfe93bb13df8b3c988" id="r_a8c39986f4750fecfe93bb13df8b3c988"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1RILUK.html#a23c661b390233d88d32774cd8fd428d5">magnitude_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a8c39986f4750fecfe93bb13df8b3c988">getAbsoluteThreshold</a> () const</td></tr>
<tr class="memdesc:a8c39986f4750fecfe93bb13df8b3c988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get absolute threshold value.  <br /></td></tr>
<tr class="separator:a8c39986f4750fecfe93bb13df8b3c988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5fc5262f3e737cbd4a1225a4394fc0" id="r_aab5fc5262f3e737cbd4a1225a4394fc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIfpack2_1_1RILUK.html#a23c661b390233d88d32774cd8fd428d5">magnitude_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#aab5fc5262f3e737cbd4a1225a4394fc0">getRelativeThreshold</a> () const</td></tr>
<tr class="memdesc:aab5fc5262f3e737cbd4a1225a4394fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get relative threshold value.  <br /></td></tr>
<tr class="separator:aab5fc5262f3e737cbd4a1225a4394fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93948a07296db69b5e571d4bc97052cb" id="r_a93948a07296db69b5e571d4bc97052cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a93948a07296db69b5e571d4bc97052cb">getLevelOfFill</a> () const</td></tr>
<tr class="memdesc:a93948a07296db69b5e571d4bc97052cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get level of fill (the "k" in ILU(k)).  <br /></td></tr>
<tr class="separator:a93948a07296db69b5e571d4bc97052cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ca1a51f7aade5b91c06165332b65a8" id="r_a44ca1a51f7aade5b91c06165332b65a8"><td class="memItemLeft" align="right" valign="top">Tpetra::CombineMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a44ca1a51f7aade5b91c06165332b65a8">getOverlapMode</a> ()</td></tr>
<tr class="memdesc:a44ca1a51f7aade5b91c06165332b65a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get overlap mode type.  <br /></td></tr>
<tr class="separator:a44ca1a51f7aade5b91c06165332b65a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f57f9606851298d7d537eccfd3a0233" id="r_a4f57f9606851298d7d537eccfd3a0233"><td class="memItemLeft" align="right" valign="top">Tpetra::global_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a4f57f9606851298d7d537eccfd3a0233">getGlobalNumEntries</a> () const</td></tr>
<tr class="memdesc:a4f57f9606851298d7d537eccfd3a0233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nonzero entries in the global graph.  <br /></td></tr>
<tr class="separator:a4f57f9606851298d7d537eccfd3a0233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafdb766d0f777341b5eb78961afd32b" id="r_afafdb766d0f777341b5eb78961afd32b"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1IlukGraph.html">Ifpack2::IlukGraph</a>&lt; Tpetra::CrsGraph&lt; <a class="el" href="classIfpack2_1_1RILUK.html#ab36f2189fbed534cbbdea630aa74e1aa">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#ac2ada3f6fe8e8480258a3000eb3afee4">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#a747a932722227155880d659b8d996944">node_type</a> &gt;, kk_handle_type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#afafdb766d0f777341b5eb78961afd32b">getGraph</a> () const</td></tr>
<tr class="memdesc:afafdb766d0f777341b5eb78961afd32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classIfpack2_1_1IlukGraph.html" title="Construct a level filled graph for use in computing an ILU(k) incomplete factorization.">Ifpack2::IlukGraph</a> associated with this factored matrix.  <br /></td></tr>
<tr class="separator:afafdb766d0f777341b5eb78961afd32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac424fa5b1329c32acac930bbbc6404ee" id="r_ac424fa5b1329c32acac930bbbc6404ee"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIfpack2_1_1RILUK.html#a11ec31dfcd53096c3143aa7ecaa04853">crs_matrix_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#ac424fa5b1329c32acac930bbbc6404ee">getL</a> () const</td></tr>
<tr class="memdesc:ac424fa5b1329c32acac930bbbc6404ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the L factor of the ILU factorization.  <br /></td></tr>
<tr class="separator:ac424fa5b1329c32acac930bbbc6404ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc10d1da5014a97178bb6f282bfaad7" id="r_a6dc10d1da5014a97178bb6f282bfaad7"><td class="memItemLeft" align="right" valign="top">const Tpetra::Vector&lt; <a class="el" href="classIfpack2_1_1RILUK.html#a5be3334c12cccb16ef56bdf8bb9c91e9">scalar_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#ab36f2189fbed534cbbdea630aa74e1aa">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#ac2ada3f6fe8e8480258a3000eb3afee4">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#a747a932722227155880d659b8d996944">node_type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a6dc10d1da5014a97178bb6f282bfaad7">getD</a> () const</td></tr>
<tr class="memdesc:a6dc10d1da5014a97178bb6f282bfaad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the diagonal entries of the ILU factorization.  <br /></td></tr>
<tr class="separator:a6dc10d1da5014a97178bb6f282bfaad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495b63b256d506c21441ce869ce43edb" id="r_a495b63b256d506c21441ce869ce43edb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIfpack2_1_1RILUK.html#a11ec31dfcd53096c3143aa7ecaa04853">crs_matrix_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a495b63b256d506c21441ce869ce43edb">getU</a> () const</td></tr>
<tr class="memdesc:a495b63b256d506c21441ce869ce43edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the U factor of the ILU factorization.  <br /></td></tr>
<tr class="separator:a495b63b256d506c21441ce869ce43edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8715d62198c0c45e77ef3606c03b6c" id="r_a9d8715d62198c0c45e77ef3606c03b6c"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1RILUK.html#a11ec31dfcd53096c3143aa7ecaa04853">crs_matrix_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#a9d8715d62198c0c45e77ef3606c03b6c">getCrsMatrix</a> () const</td></tr>
<tr class="memdesc:a9d8715d62198c0c45e77ef3606c03b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the input matrix A as a Tpetra::CrsMatrix, if possible; else throws.  <br /></td></tr>
<tr class="separator:a9d8715d62198c0c45e77ef3606c03b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72cc0cd0b359d14b345d58d07449610" id="r_ad72cc0cd0b359d14b345d58d07449610"><td class="memItemLeft" align="right" valign="top">static Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1RILUK.html#af1d08264f25ccadf5a202c604f0f99ac">row_matrix_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIfpack2_1_1RILUK.html#ad72cc0cd0b359d14b345d58d07449610">makeLocalFilter</a> (const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1RILUK.html#af1d08264f25ccadf5a202c604f0f99ac">row_matrix_type</a> &gt; &amp;A)</td></tr>
<tr class="memdesc:ad72cc0cd0b359d14b345d58d07449610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return A, wrapped in a <a class="el" href="classIfpack2_1_1LocalFilter.html" title="Access only local rows and columns of a sparse matrix.">LocalFilter</a>, if necessary.  <br /></td></tr>
<tr class="separator:ad72cc0cd0b359d14b345d58d07449610"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class MatrixType&gt;<br />
class Ifpack2::RILUK&lt; MatrixType &gt;</div><p>ILU(k) factorization of a given Tpetra::RowMatrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>A specialization of Tpetra::RowMatrix.</td></tr>
  </table>
  </dd>
</dl>
<p>This class implements a "relaxed" incomplete ILU (ILU) factorization with level k fill. It is based upon the ILU algorithms outlined in Yousef Saad's "Iterative Methods for Sparse Linear Systems", 2nd edition, Chapter 10.</p>
<h1><a class="anchor" id="Ifpack2_RILUK_Parameters"></a>
Parameters</h1>
<p>For a complete list of valid parameters, see the documentation of <a class="el" href="classIfpack2_1_1RILUK.html#aa98b7ed700c803c8aea80eec12c96ca7">setParameters()</a>.</p>
<p>The computed factorization is a function of several parameters: </p><ul>
<li>
<p class="startli">The graph structure (sparsity pattern) of the matrix: All fill is derived from the original matrix nonzero structure. Level zero fill is defined as the original matrix pattern (nonzero structure), even if the matrix value at an entry is stored as a zero. (Thus it is possible to add entries to the ILU factors by adding zero entries to the original matrix.) </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Level of fill: Starting with the original matrix pattern as level fill of zero, the next level of fill is determined by analyzing the graph of the previous level and determining nonzero fill that is a result of combining entries that were from previous level only (not the current level). This rule limits fill to entries that are direct decendents from the previous level graph. Fill for level k is determined by applying this rule recursively. For sufficiently large values of k, the fill would eventually be complete and an exact LU factorization would be computed. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Fraction of relaxation: <a class="el" href="classIfpack2_1_1RILUK.html" title="ILU(k) factorization of a given Tpetra::RowMatrix.">Ifpack2::RILUK</a> computes the ILU factorization row-by-row. As entries at a given row are computed, some number of them will be dropped because they do match the prescribed sparsity pattern. The relaxation factor determines how these dropped values will be handled. If the factor is zero, then these extra entries will by dropped. This is a classical ILU approach. If the RelaxValue is 1, then the sum of the extra entries will be added to the diagonal. This is a classical Modified ILU (MILU) approach. If RelaxValue is between 0 and 1, then the factor times the sum of extra entries will be added to the diagonal.</p>
<p class="interli">For most situations, the relaxation factor should be set to zero. For certain kinds of problems, e.g., reservoir modeling, there is a conservation principle involved such that any operator should obey a zero row-sum property. MILU was designed for these cases and you should set the relaxation factor to 1. For other situations, setting RelaxValue to some nonzero value may improve the stability of factorization, and can be used if the computed ILU factors are poorly conditioned. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classIfpack2_1_1Diagonal.html" title="Diagonal preconditioner.">Diagonal</a> perturbation: Prior to computing the factorization, it is possible to modify the diagonal entries of the matrix for which the factorization will be computing. If the absolute and relative perturbation values are zero and one, respectively, the factorization will be compute for the original user matrix A. Otherwise, the factorization will computed for a matrix that differs from the original user matrix in the diagonal values only. Below we discuss the details of diagonal perturbations. </p>
<p class="endli"></p>
</li>
</ul>
<h1><a class="anchor" id="Ifpack2_RILUK_GlobalOrdering"></a>
An important note about ordering</h1>
<p>Note that the factorization is calculated based upon local ordering. This means that the ordering of the GIDs in the row map is ignored. Initial entries in \(L\), the strictly lower triangular part of A, and \(U\), the strictly upper triangular part of A, are given by</p>
<p>\(L(i,j) = A(i,j)\) if \(j &lt; i\), for local IDs \(i\) and \(j\), even if GID \((j)\) \(&gt;\) GID \((i)\),</p>
<p>and</p>
<p>\(U(i,j) = A(i,j)\) if \(i &lt; j\), for local IDs \(i\) and \(j\), even if GID \((j)\) \(&lt;\) GID \((i)\).</p>
<p>In particular, if the row map GIDs are not in ascending order on processor, then the incomplete factors will be different than those produced by ILU(k) using global IDs. If the row map GIDs are in ascending order, then the factors produced based on LID and GID ordering are the same.</p>
<h1><a class="anchor" id="Ifpack2_RILUK_CondEst"></a>
Estimating preconditioner condition numbers</h1>
<p>For ill-conditioned matrices, we often have difficulty computing usable incomplete factorizations. The most common source of problems is that the factorization may encounter a small or zero pivot. In that case, the factorization may fail. Even if the factorization succeeds, the factors may be so poorly conditioned that use of them in the iterative phase produces meaningless results. Before we can fix this problem, we must be able to detect it. To this end, we use a simple but effective condition number estimate for \((LU)^{-1}\).</p>
<p>The condition number of a matrix \(B\), called \(cond_p(B)\), is defined as \(cond_p(B) = \|B\|_p\|B^{-1}\|_p\) in some appropriate norm \(p\). \(cond_p(B)\) gives some indication of how many accurate floating point digits can be expected from operations involving the matrix and its inverse. A condition number approaching the accuracy of a given floating point number system, about 15 decimal digits in IEEE double precision, means that any results involving \(B\) or \(B^{-1}\) may be meaningless.</p>
<p>The \(\infty\)-norm of a vector \(y\) is defined as the maximum of the absolute values of the vector entries, and the \(\infty\)-norm of a matrix C is defined as \(\|C\|_\infty = \max_{\|y\|_\infty = 1}
\|Cy\|_\infty\). A crude lower bound for the \(cond_\infty(C)\) is \(\|C^{-1}e\|_\infty\) where \(e = (1, 1, \ldots, 1)^T\). It is a lower bound because \(cond_\infty(C) = \|C\|_\infty\|C^{-1}\|_\infty
\ge \|C^{-1}\|_\infty \ge |C^{-1}e\|_\infty\).</p>
<p>For our purposes, we want to estimate \(cond_\infty(LU)\), where \(L\) and \(U\) are our incomplete factors. Edmond in his Ph.D. thesis demonstrates that \(\|(LU)^{-1}e\|_\infty\) provides an effective estimate for \(cond_\infty(LU)\). Furthermore, since finding \(z\) such that \(LUz = y\) is a basic kernel for applying the preconditioner, computing this estimate of \(cond_\infty(LU)\) is performed by setting \(y = e\), calling the solve kernel to compute \(z\) and then computing \(\|z\|_\infty\).</p>
<h1><a class="anchor" id="Ifpack2_RILUK_DiagPerturb"></a>
A priori diagonal perturbations</h1>
<p>If we detect using the above method that our factorization is too ill-conditioned, we can improve the conditioning by perturbing the matrix diagonal and restarting the factorization using this more diagonally dominant matrix. In order to apply perturbation, prior to starting the factorization, we compute a diagonal perturbation of our matrix \(A\) and perform the factorization on this perturbed matrix. The overhead cost of perturbing the diagonal is minimal since the first step in computing the incomplete factors is to copy the matrix \(A\) into the memory space for the incomplete factors. We simply compute the perturbed diagonal at this point.</p>
<p>The actual perturbation values we use are the diagonal values \((d_1,
d_2, \ldots, d_n)\) with \(d_i = sgn(d_i)\alpha + d_i\rho\), \(i=1, 2, \ldots, n\), where \(n\) is the matrix dimension and \(sgn(d_i)\) returns the sign of the diagonal entry. This has the effect of forcing the diagonal values to have minimal magnitude of \(\alpha\) and to increase each by an amount proportional to \(\rho\), and still keep the sign of the original diagonal entry.</p>
<h1><a class="anchor" id="Ifpack2_RILUK_Phases"></a>
Phases of computation</h1>
<p>Every <a class="el" href="namespaceIfpack2.html" title="Preconditioners and smoothers for Tpetra sparse matrices.">Ifpack2</a> preconditioner has the following phases of computation: </p><ol>
<li>
<a class="el" href="classIfpack2_1_1RILUK.html#a06f4f95081fcbf5eb8f5a5d18d0c717b" title="Initialize by computing the symbolic incomplete factorization.">initialize()</a>  </li>
<li>
<a class="el" href="classIfpack2_1_1RILUK.html#ad6975338fab389e7c2a9bede6162b85a" title="Compute the (numeric) incomplete factorization.">compute()</a>  </li>
<li>
<a class="el" href="classIfpack2_1_1RILUK.html#a2203f315f98c6555df9cedd98266138e" title="Apply the (inverse of the) incomplete factorization to X, resulting in Y.">apply()</a>  </li>
</ol>
<p><a class="el" href="classIfpack2_1_1RILUK.html" title="ILU(k) factorization of a given Tpetra::RowMatrix.">RILUK</a> constructs the symbolic incomplete factorization (that is, the structure of the incomplete factors) in the <a class="el" href="classIfpack2_1_1RILUK.html#a06f4f95081fcbf5eb8f5a5d18d0c717b" title="Initialize by computing the symbolic incomplete factorization.">initialize()</a> phase. It computes the numerical incomplete factorization (that is, it fills in the factors' entries with their correct values) in the <a class="el" href="classIfpack2_1_1RILUK.html#ad6975338fab389e7c2a9bede6162b85a" title="Compute the (numeric) incomplete factorization.">compute()</a> phase. The <a class="el" href="classIfpack2_1_1RILUK.html#a2203f315f98c6555df9cedd98266138e" title="Apply the (inverse of the) incomplete factorization to X, resulting in Y.">apply()</a> phase applies the incomplete factorization to a given multivector using two triangular solves.</p>
<h1><a class="anchor" id="Ifpack2_RILUK_Measuring"></a>
Measuring performance</h1>
<p>Each <a class="el" href="classIfpack2_1_1RILUK.html" title="ILU(k) factorization of a given Tpetra::RowMatrix.">RILUK</a> object keeps track of both the time required for various operations, and the number of times those operations have been applied for that object. The operations tracked include:</p><ul>
<li><a class="el" href="classIfpack2_1_1RILUK.html#a06f4f95081fcbf5eb8f5a5d18d0c717b" title="Initialize by computing the symbolic incomplete factorization.">initialize()</a> (via <a class="el" href="classIfpack2_1_1RILUK.html#aab97a9734e005ca38ef37d957fdc615b" title="Number of successful initialize() calls for this object.">getNumInitialize()</a> and <a class="el" href="classIfpack2_1_1RILUK.html#af0365418e0b4120d5508b0d94984be2a" title="Total time in seconds taken by all successful initialize() calls for this object.">getInitializeTime()</a>)</li>
<li><a class="el" href="classIfpack2_1_1RILUK.html#ad6975338fab389e7c2a9bede6162b85a" title="Compute the (numeric) incomplete factorization.">compute()</a> (via <a class="el" href="classIfpack2_1_1RILUK.html#a328038b9f826473acf632010a1a334f7" title="Number of successful compute() calls for this object.">getNumCompute()</a> and <a class="el" href="classIfpack2_1_1RILUK.html#a283fd039d9ac66e32e2c71a02d32eb35" title="Total time in seconds taken by all successful compute() calls for this object.">getComputeTime()</a>)</li>
<li><a class="el" href="classIfpack2_1_1RILUK.html#a2203f315f98c6555df9cedd98266138e" title="Apply the (inverse of the) incomplete factorization to X, resulting in Y.">apply()</a> (via <a class="el" href="classIfpack2_1_1RILUK.html#a2b701e279c2a70d62df07ff160708035" title="Number of successful apply() calls for this object.">getNumApply()</a> and <a class="el" href="classIfpack2_1_1RILUK.html#a1c44c72c54e4d8f97b3e6e2096393a3e" title="Total time in seconds taken by all successful apply() calls for this object.">getApplyTime()</a>)</li>
</ul>
<p>The <code>getNum*</code> methods return the number of times that operation was called. The <code>get*Time</code> methods return the total number of seconds spent in <em>all</em> invocations of that operation. For example, <a class="el" href="classIfpack2_1_1RILUK.html#a1c44c72c54e4d8f97b3e6e2096393a3e" title="Total time in seconds taken by all successful apply() calls for this object.">getApplyTime()</a> returns the number of seconds spent in all <a class="el" href="classIfpack2_1_1RILUK.html#a2203f315f98c6555df9cedd98266138e" title="Apply the (inverse of the) incomplete factorization to X, resulting in Y.">apply()</a> calls. For an average time per <a class="el" href="classIfpack2_1_1RILUK.html#a2203f315f98c6555df9cedd98266138e" title="Apply the (inverse of the) incomplete factorization to X, resulting in Y.">apply()</a> call, divide by <a class="el" href="classIfpack2_1_1RILUK.html#a2b701e279c2a70d62df07ff160708035" title="Number of successful apply() calls for this object.">getNumApply()</a>, the total number of calls to <a class="el" href="classIfpack2_1_1RILUK.html#a2203f315f98c6555df9cedd98266138e" title="Apply the (inverse of the) incomplete factorization to X, resulting in Y.">apply()</a>. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5be3334c12cccb16ef56bdf8bb9c91e9" name="a5be3334c12cccb16ef56bdf8bb9c91e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be3334c12cccb16ef56bdf8bb9c91e9">&#9670;&#160;</a></span>scalar_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::scalar_type <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::scalar_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the entries of the input MatrixType. </p>

</div>
</div>
<a id="ab36f2189fbed534cbbdea630aa74e1aa" name="ab36f2189fbed534cbbdea630aa74e1aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab36f2189fbed534cbbdea630aa74e1aa">&#9670;&#160;</a></span>local_ordinal_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::local_ordinal_type <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::local_ordinal_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of local indices in the input MatrixType. </p>

</div>
</div>
<a id="ac2ada3f6fe8e8480258a3000eb3afee4" name="ac2ada3f6fe8e8480258a3000eb3afee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ada3f6fe8e8480258a3000eb3afee4">&#9670;&#160;</a></span>global_ordinal_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::global_ordinal_type <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::global_ordinal_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of global indices in the input MatrixType. </p>

</div>
</div>
<a id="a747a932722227155880d659b8d996944" name="a747a932722227155880d659b8d996944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747a932722227155880d659b8d996944">&#9670;&#160;</a></span>node_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType::node_type <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::node_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Node type used by the input MatrixType. </p>

</div>
</div>
<a id="a23c661b390233d88d32774cd8fd428d5" name="a23c661b390233d88d32774cd8fd428d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23c661b390233d88d32774cd8fd428d5">&#9670;&#160;</a></span>magnitude_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Teuchos::ScalarTraits&lt;<a class="el" href="classIfpack2_1_1RILUK.html#a5be3334c12cccb16ef56bdf8bb9c91e9">scalar_type</a>&gt;::magnitudeType <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::magnitude_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the magnitude (absolute value) of a matrix entry. </p>

</div>
</div>
<a id="ac4cef7ea67194cca8e6b919ce9012dc2" name="ac4cef7ea67194cca8e6b919ce9012dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4cef7ea67194cca8e6b919ce9012dc2">&#9670;&#160;</a></span>device_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef node_type::device_type <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::device_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Kokkos device type of the input MatrixType. </p>

</div>
</div>
<a id="ac9d119055541094930905ef6137410fe" name="ac9d119055541094930905ef6137410fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d119055541094930905ef6137410fe">&#9670;&#160;</a></span>execution_space</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef node_type::execution_space <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::execution_space</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Kokkos execution space of the input MatrixType. </p>

</div>
</div>
<a id="af1d08264f25ccadf5a202c604f0f99ac" name="af1d08264f25ccadf5a202c604f0f99ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d08264f25ccadf5a202c604f0f99ac">&#9670;&#160;</a></span>row_matrix_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Tpetra::RowMatrix&lt;<a class="el" href="classIfpack2_1_1RILUK.html#a5be3334c12cccb16ef56bdf8bb9c91e9">scalar_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#ab36f2189fbed534cbbdea630aa74e1aa">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#ac2ada3f6fe8e8480258a3000eb3afee4">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#a747a932722227155880d659b8d996944">node_type</a>&gt; <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::row_matrix_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tpetra::RowMatrix specialization used by this class. </p>

</div>
</div>
<a id="a11ec31dfcd53096c3143aa7ecaa04853" name="a11ec31dfcd53096c3143aa7ecaa04853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ec31dfcd53096c3143aa7ecaa04853">&#9670;&#160;</a></span>crs_matrix_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Tpetra::CrsMatrix&lt;<a class="el" href="classIfpack2_1_1RILUK.html#a5be3334c12cccb16ef56bdf8bb9c91e9">scalar_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#ab36f2189fbed534cbbdea630aa74e1aa">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#ac2ada3f6fe8e8480258a3000eb3afee4">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#a747a932722227155880d659b8d996944">node_type</a>&gt; <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::crs_matrix_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tpetra::CrsMatrix specialization used by this class for representing L and U. </p>

</div>
</div>
<a id="a013fa638900f40d39012393b0494d910" name="a013fa638900f40d39012393b0494d910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013fa638900f40d39012393b0494d910">&#9670;&#160;</a></span>impl_scalar_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef crs_matrix_type::impl_scalar_type <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::impl_scalar_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scalar type stored in Kokkos::Views (CrsMatrix and MultiVector) </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acf5cac91aeab107501fb7fd7d0627bae" name="acf5cac91aeab107501fb7fd7d0627bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5cac91aeab107501fb7fd7d0627bae">&#9670;&#160;</a></span>RILUK() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::RILUK </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1RILUK.html#af1d08264f25ccadf5a202c604f0f99ac">row_matrix_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor that takes a Tpetra::RowMatrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_in</td><td>[in] The input matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a164b7f3e56288379e054371852be215d" name="a164b7f3e56288379e054371852be215d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164b7f3e56288379e054371852be215d">&#9670;&#160;</a></span>RILUK() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::RILUK </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1RILUK.html#a11ec31dfcd53096c3143aa7ecaa04853">crs_matrix_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor that takes a Tpetra::CrsMatrix. </p>
<p>This constructor exists to avoid "ambiguous constructor" warnings. It does the same thing as the constructor that takes a Tpetra::RowMatrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_in</td><td>[in] The input matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14bf0fe45360dd7ffad930f7e9ff7e81" name="a14bf0fe45360dd7ffad930f7e9ff7e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bf0fe45360dd7ffad930f7e9ff7e81">&#9670;&#160;</a></span>~RILUK()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::~<a class="el" href="classIfpack2_1_1RILUK.html">RILUK</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor (declared virtual for memory safety). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa98b7ed700c803c8aea80eec12c96ca7" name="aa98b7ed700c803c8aea80eec12c96ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa98b7ed700c803c8aea80eec12c96ca7">&#9670;&#160;</a></span>setParameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::setParameters </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set parameters for the incomplete factorization.</p>
<p>This preconditioner supports the following parameters:</p><ul>
<li>"fact: iluk level-of-fill" (int)</li>
<li>"fact: absolute threshold" (magnitude_type)</li>
<li>"fact: relative threshold" (magnitude_type)</li>
<li>"fact: relax value" (magnitude_type)</li>
<li>"fact: iluk overalloc" (double) </li>
</ul>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a60340992fc1b9eac82ef35333bee6efd">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a06f4f95081fcbf5eb8f5a5d18d0c717b" name="a06f4f95081fcbf5eb8f5a5d18d0c717b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f4f95081fcbf5eb8f5a5d18d0c717b">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize by computing the symbolic incomplete factorization. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#ad3aefd6f16e8ef4cddb696cd23f160b0">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="ad6975338fab389e7c2a9bede6162b85a" name="ad6975338fab389e7c2a9bede6162b85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6975338fab389e7c2a9bede6162b85a">&#9670;&#160;</a></span>compute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::compute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the (numeric) incomplete factorization. </p>
<p>This function computes the RILU(k) factors L and U using the current:</p><ul>
<li>Ifpack2_IlukGraph specifying the structure of L and U.</li>
<li>Value for the RILU(k) relaxation parameter.</li>
<li>Value for the a priori diagonal threshold values.</li>
</ul>
<p><a class="el" href="classIfpack2_1_1RILUK.html#a06f4f95081fcbf5eb8f5a5d18d0c717b" title="Initialize by computing the symbolic incomplete factorization.">initialize()</a> must be called first, before this method may be called. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a23954dd69f62b56455a9c0988bbe9e67">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="aeaf03ca56c60a928138c2a77e5394165" name="aeaf03ca56c60a928138c2a77e5394165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf03ca56c60a928138c2a77e5394165">&#9670;&#160;</a></span>isInitialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::isInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether <a class="el" href="classIfpack2_1_1RILUK.html#a06f4f95081fcbf5eb8f5a5d18d0c717b" title="Initialize by computing the symbolic incomplete factorization.">initialize()</a> has been called on this object. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a180c876ccf7af87f10a1c1d08ba2dc01">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a5c83210a2a5dcd83d8b126ec84c9e6e5" name="a5c83210a2a5dcd83d8b126ec84c9e6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c83210a2a5dcd83d8b126ec84c9e6e5">&#9670;&#160;</a></span>isComputed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::isComputed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether <a class="el" href="classIfpack2_1_1RILUK.html#ad6975338fab389e7c2a9bede6162b85a" title="Compute the (numeric) incomplete factorization.">compute()</a> has been called on this object. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#abb5af77756a7488ab636dbd97483ca66">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="aab97a9734e005ca38ef37d957fdc615b" name="aab97a9734e005ca38ef37d957fdc615b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab97a9734e005ca38ef37d957fdc615b">&#9670;&#160;</a></span>getNumInitialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::getNumInitialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of successful <a class="el" href="classIfpack2_1_1RILUK.html#a06f4f95081fcbf5eb8f5a5d18d0c717b" title="Initialize by computing the symbolic incomplete factorization.">initialize()</a> calls for this object. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#afe6c77c5ab6da065f8dbade353e8535a">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a328038b9f826473acf632010a1a334f7" name="a328038b9f826473acf632010a1a334f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328038b9f826473acf632010a1a334f7">&#9670;&#160;</a></span>getNumCompute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::getNumCompute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of successful <a class="el" href="classIfpack2_1_1RILUK.html#ad6975338fab389e7c2a9bede6162b85a" title="Compute the (numeric) incomplete factorization.">compute()</a> calls for this object. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a286b18ee0769ecc8bf992dffdc442791">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a2b701e279c2a70d62df07ff160708035" name="a2b701e279c2a70d62df07ff160708035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b701e279c2a70d62df07ff160708035">&#9670;&#160;</a></span>getNumApply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::getNumApply </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of successful <a class="el" href="classIfpack2_1_1RILUK.html#a2203f315f98c6555df9cedd98266138e" title="Apply the (inverse of the) incomplete factorization to X, resulting in Y.">apply()</a> calls for this object. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a565e6c00bf14873ae7b23187c9978078">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="af0365418e0b4120d5508b0d94984be2a" name="af0365418e0b4120d5508b0d94984be2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0365418e0b4120d5508b0d94984be2a">&#9670;&#160;</a></span>getInitializeTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::getInitializeTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total time in seconds taken by all successful <a class="el" href="classIfpack2_1_1RILUK.html#a06f4f95081fcbf5eb8f5a5d18d0c717b" title="Initialize by computing the symbolic incomplete factorization.">initialize()</a> calls for this object. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#aeb91a16f5544ad4efaf756b1d2a8b39d">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a283fd039d9ac66e32e2c71a02d32eb35" name="a283fd039d9ac66e32e2c71a02d32eb35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283fd039d9ac66e32e2c71a02d32eb35">&#9670;&#160;</a></span>getComputeTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::getComputeTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total time in seconds taken by all successful <a class="el" href="classIfpack2_1_1RILUK.html#ad6975338fab389e7c2a9bede6162b85a" title="Compute the (numeric) incomplete factorization.">compute()</a> calls for this object. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a111d9bd4e28c0633696f271955ddcb4c">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a1c44c72c54e4d8f97b3e6e2096393a3e" name="a1c44c72c54e4d8f97b3e6e2096393a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c44c72c54e4d8f97b3e6e2096393a3e">&#9670;&#160;</a></span>getApplyTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::getApplyTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total time in seconds taken by all successful <a class="el" href="classIfpack2_1_1RILUK.html#a2203f315f98c6555df9cedd98266138e" title="Apply the (inverse of the) incomplete factorization to X, resulting in Y.">apply()</a> calls for this object. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a57c2d00799de050cd2a5a75ce80f48b9">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="ad39b821cbf0c776d2b65fdad45a7e679" name="ad39b821cbf0c776d2b65fdad45a7e679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39b821cbf0c776d2b65fdad45a7e679">&#9670;&#160;</a></span>getNodeSmootherComplexity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::getNodeSmootherComplexity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a rough estimate of cost per iteration. </p>

</div>
</div>
<a id="a512635465b0b40588793f1891b45a91e" name="a512635465b0b40588793f1891b45a91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512635465b0b40588793f1891b45a91e">&#9670;&#160;</a></span>setMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::setMatrix </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1RILUK.html#af1d08264f25ccadf5a202c604f0f99ac">row_matrix_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the matrix to be preconditioned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>[in] The new matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>! isInitialized ()</code> </dd>
<dd>
<code>! isComputed ()</code></dd></dl>
<p>Calling this method resets the preconditioner's state. After calling this method with a nonnull input, you must first call <a class="el" href="classIfpack2_1_1RILUK.html#a06f4f95081fcbf5eb8f5a5d18d0c717b" title="Initialize by computing the symbolic incomplete factorization.">initialize()</a> and <a class="el" href="classIfpack2_1_1RILUK.html#ad6975338fab389e7c2a9bede6162b85a" title="Compute the (numeric) incomplete factorization.">compute()</a> (in that order) before you may call <a class="el" href="classIfpack2_1_1RILUK.html#a2203f315f98c6555df9cedd98266138e" title="Apply the (inverse of the) incomplete factorization to X, resulting in Y.">apply()</a>.</p>
<p>You may call this method with a null input. If A is null, then you may not call <a class="el" href="classIfpack2_1_1RILUK.html#a06f4f95081fcbf5eb8f5a5d18d0c717b" title="Initialize by computing the symbolic incomplete factorization.">initialize()</a> or <a class="el" href="classIfpack2_1_1RILUK.html#ad6975338fab389e7c2a9bede6162b85a" title="Compute the (numeric) incomplete factorization.">compute()</a> until you first call this method again with a nonnull input. This method invalidates any previous factorization whether or not A is null, so calling <a class="el" href="classIfpack2_1_1RILUK.html#a512635465b0b40588793f1891b45a91e" title="Change the matrix to be preconditioned.">setMatrix()</a> with a null input is one way to clear the preconditioner's state (and free any memory that it may be using).</p>
<p>The new matrix A need not necessarily have the same Maps or even the same communicator as the original matrix. </p>

</div>
</div>
<a id="a4ccdc58864f256fa85b6fb14a25c22f8" name="a4ccdc58864f256fa85b6fb14a25c22f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ccdc58864f256fa85b6fb14a25c22f8">&#9670;&#160;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A one-line description of this object. </p>

</div>
</div>
<a id="a9e226fe0ba0141e2dc89cbba00a75075" name="a9e226fe0ba0141e2dc89cbba00a75075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e226fe0ba0141e2dc89cbba00a75075">&#9670;&#160;</a></span>getDomainMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const Tpetra::Map&lt; typename <a class="el" href="classIfpack2_1_1RILUK.html">RILUK</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1RILUK.html#ab36f2189fbed534cbbdea630aa74e1aa">::local_ordinal_type</a>, typename <a class="el" href="classIfpack2_1_1RILUK.html">RILUK</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1RILUK.html#ac2ada3f6fe8e8480258a3000eb3afee4">::global_ordinal_type</a>, typename <a class="el" href="classIfpack2_1_1RILUK.html">RILUK</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1RILUK.html#a747a932722227155880d659b8d996944">::node_type</a> &gt; &gt; <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::getDomainMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Tpetra::Map object associated with the domain of this operator. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#aafeb2143ff699f2289503a85f6e3523c">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a2e65d7235e7e6beaed8b04a507ee327a" name="a2e65d7235e7e6beaed8b04a507ee327a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e65d7235e7e6beaed8b04a507ee327a">&#9670;&#160;</a></span>getRangeMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const Tpetra::Map&lt; typename <a class="el" href="classIfpack2_1_1RILUK.html">RILUK</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1RILUK.html#ab36f2189fbed534cbbdea630aa74e1aa">::local_ordinal_type</a>, typename <a class="el" href="classIfpack2_1_1RILUK.html">RILUK</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1RILUK.html#ac2ada3f6fe8e8480258a3000eb3afee4">::global_ordinal_type</a>, typename <a class="el" href="classIfpack2_1_1RILUK.html">RILUK</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1RILUK.html#a747a932722227155880d659b8d996944">::node_type</a> &gt; &gt; <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::getRangeMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Tpetra::Map object associated with the range of this operator. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a75b32e1de03024035b00cd2ee95a60da">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a2203f315f98c6555df9cedd98266138e" name="a2203f315f98c6555df9cedd98266138e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2203f315f98c6555df9cedd98266138e">&#9670;&#160;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1RILUK.html#a5be3334c12cccb16ef56bdf8bb9c91e9">scalar_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#ab36f2189fbed534cbbdea630aa74e1aa">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#ac2ada3f6fe8e8480258a3000eb3afee4">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#a747a932722227155880d659b8d996944">node_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tpetra::MultiVector&lt; <a class="el" href="classIfpack2_1_1RILUK.html#a5be3334c12cccb16ef56bdf8bb9c91e9">scalar_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#ab36f2189fbed534cbbdea630aa74e1aa">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#ac2ada3f6fe8e8480258a3000eb3afee4">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#a747a932722227155880d659b8d996944">node_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::ETransp&#160;</td>
          <td class="paramname"><em>mode</em> = <code>Teuchos::NO_TRANS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIfpack2_1_1RILUK.html#a5be3334c12cccb16ef56bdf8bb9c91e9">scalar_type</a>&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>Teuchos::ScalarTraits&lt;<a class="el" href="classIfpack2_1_1RILUK.html#a5be3334c12cccb16ef56bdf8bb9c91e9">scalar_type</a>&gt;::one()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIfpack2_1_1RILUK.html#a5be3334c12cccb16ef56bdf8bb9c91e9">scalar_type</a>&#160;</td>
          <td class="paramname"><em>beta</em> = <code>Teuchos::ScalarTraits&lt;<a class="el" href="classIfpack2_1_1RILUK.html#a5be3334c12cccb16ef56bdf8bb9c91e9">scalar_type</a>&gt;::zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the (inverse of the) incomplete factorization to X, resulting in Y. </p>
<p>For an incomplete factorization \(A \approx LDU\), this method computes the following, depending on the value of <code>mode:</code> </p><ul>
<li>
If mode = Teuchos::NO_TRANS, it computes <code>Y = beta*Y + alpha*(U \ (D \ (L \ X)))</code>  </li>
<li>
If mode = Teuchos::TRANS, it computes <code>Y = beta*Y + alpha*(L^T \ (D^T \ (U^T \ X)))</code>  </li>
<li>
If mode = Teuchos::CONJ_TRANS, it computes <code>Y = beta*Y + alpha*(L^* \ (D^* \ (U^* \ X)))</code>, where the asterisk indicates the conjugate transpose.  </li>
</ul>
<p>If alpha is zero, then the result of applying the operator to a vector is ignored. This matters because zero times NaN (not a number) is NaN, not zero. Analogously, if beta is zero, then any values in Y on input are ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>[in] The input multivector.</td></tr>
    <tr><td class="paramname">Y</td><td>[in/out] The output multivector.</td></tr>
    <tr><td class="paramname">mode</td><td>[in] If Teuchos::TRANS resp. Teuchos::CONJ_TRANS, apply the transpose resp. conjugate transpose of the incomplete factorization. Otherwise, don't apply the tranpose.</td></tr>
    <tr><td class="paramname">alpha</td><td>[in] Scaling factor for the result of applying the preconditioner.</td></tr>
    <tr><td class="paramname">beta</td><td>[in] Scaling factor for the initial value of Y. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a606c3f8155f67f2867fac3a7c44bd5df">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a86d8f0552971c5364d0d5c9adb9f900b" name="a86d8f0552971c5364d0d5c9adb9f900b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d8f0552971c5364d0d5c9adb9f900b">&#9670;&#160;</a></span>getMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const typename <a class="el" href="classIfpack2_1_1RILUK.html">RILUK</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1RILUK.html#af1d08264f25ccadf5a202c604f0f99ac">::row_matrix_type</a> &gt; <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::getMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the input matrix. </p>

<p>Implements <a class="el" href="classIfpack2_1_1Preconditioner.html#a4258d242e7ff6003c399da8f0a11d634">Ifpack2::Preconditioner&lt; MatrixType::scalar_type, MatrixType::local_ordinal_type, MatrixType::global_ordinal_type, MatrixType::node_type &gt;</a>.</p>

</div>
</div>
<a id="a2f8b0355a6235ec92501709a7a6c9c9f" name="a2f8b0355a6235ec92501709a7a6c9c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8b0355a6235ec92501709a7a6c9c9f">&#9670;&#160;</a></span>getRelaxValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1RILUK.html#a23c661b390233d88d32774cd8fd428d5">magnitude_type</a> <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::getRelaxValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get RILU(k) relaxation parameter. </p>

</div>
</div>
<a id="a8c39986f4750fecfe93bb13df8b3c988" name="a8c39986f4750fecfe93bb13df8b3c988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c39986f4750fecfe93bb13df8b3c988">&#9670;&#160;</a></span>getAbsoluteThreshold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1RILUK.html#a23c661b390233d88d32774cd8fd428d5">magnitude_type</a> <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::getAbsoluteThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get absolute threshold value. </p>

</div>
</div>
<a id="aab5fc5262f3e737cbd4a1225a4394fc0" name="aab5fc5262f3e737cbd4a1225a4394fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5fc5262f3e737cbd4a1225a4394fc0">&#9670;&#160;</a></span>getRelativeThreshold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIfpack2_1_1RILUK.html#a23c661b390233d88d32774cd8fd428d5">magnitude_type</a> <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::getRelativeThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get relative threshold value. </p>

</div>
</div>
<a id="a93948a07296db69b5e571d4bc97052cb" name="a93948a07296db69b5e571d4bc97052cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93948a07296db69b5e571d4bc97052cb">&#9670;&#160;</a></span>getLevelOfFill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::getLevelOfFill </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get level of fill (the "k" in ILU(k)). </p>

</div>
</div>
<a id="a44ca1a51f7aade5b91c06165332b65a8" name="a44ca1a51f7aade5b91c06165332b65a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ca1a51f7aade5b91c06165332b65a8">&#9670;&#160;</a></span>getOverlapMode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tpetra::CombineMode <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::getOverlapMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get overlap mode type. </p>

</div>
</div>
<a id="a4f57f9606851298d7d537eccfd3a0233" name="a4f57f9606851298d7d537eccfd3a0233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f57f9606851298d7d537eccfd3a0233">&#9670;&#160;</a></span>getGlobalNumEntries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tpetra::global_size_t <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::getGlobalNumEntries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of nonzero entries in the global graph. </p>

</div>
</div>
<a id="afafdb766d0f777341b5eb78961afd32b" name="afafdb766d0f777341b5eb78961afd32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afafdb766d0f777341b5eb78961afd32b">&#9670;&#160;</a></span>getGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; <a class="el" href="classIfpack2_1_1IlukGraph.html">Ifpack2::IlukGraph</a>&lt; Tpetra::CrsGraph&lt; <a class="el" href="classIfpack2_1_1RILUK.html#ab36f2189fbed534cbbdea630aa74e1aa">local_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#ac2ada3f6fe8e8480258a3000eb3afee4">global_ordinal_type</a>, <a class="el" href="classIfpack2_1_1RILUK.html#a747a932722227155880d659b8d996944">node_type</a> &gt;, kk_handle_type &gt; &gt; <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::getGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the <a class="el" href="classIfpack2_1_1IlukGraph.html" title="Construct a level filled graph for use in computing an ILU(k) incomplete factorization.">Ifpack2::IlukGraph</a> associated with this factored matrix. </p>

</div>
</div>
<a id="ac424fa5b1329c32acac930bbbc6404ee" name="ac424fa5b1329c32acac930bbbc6404ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac424fa5b1329c32acac930bbbc6404ee">&#9670;&#160;</a></span>getL()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIfpack2_1_1RILUK.html">RILUK</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1RILUK.html#a11ec31dfcd53096c3143aa7ecaa04853">::crs_matrix_type</a> &amp; <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::getL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the L factor of the ILU factorization. </p>

</div>
</div>
<a id="a6dc10d1da5014a97178bb6f282bfaad7" name="a6dc10d1da5014a97178bb6f282bfaad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc10d1da5014a97178bb6f282bfaad7">&#9670;&#160;</a></span>getD()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Tpetra::Vector&lt; typename <a class="el" href="classIfpack2_1_1RILUK.html">RILUK</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1RILUK.html#a5be3334c12cccb16ef56bdf8bb9c91e9">::scalar_type</a>, typename <a class="el" href="classIfpack2_1_1RILUK.html">RILUK</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1RILUK.html#ab36f2189fbed534cbbdea630aa74e1aa">::local_ordinal_type</a>, typename <a class="el" href="classIfpack2_1_1RILUK.html">RILUK</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1RILUK.html#ac2ada3f6fe8e8480258a3000eb3afee4">::global_ordinal_type</a>, typename <a class="el" href="classIfpack2_1_1RILUK.html">RILUK</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1RILUK.html#a747a932722227155880d659b8d996944">::node_type</a> &gt; &amp; <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::getD </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the diagonal entries of the ILU factorization. </p>

</div>
</div>
<a id="a495b63b256d506c21441ce869ce43edb" name="a495b63b256d506c21441ce869ce43edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495b63b256d506c21441ce869ce43edb">&#9670;&#160;</a></span>getU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIfpack2_1_1RILUK.html">RILUK</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1RILUK.html#a11ec31dfcd53096c3143aa7ecaa04853">::crs_matrix_type</a> &amp; <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::getU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the U factor of the ILU factorization. </p>

</div>
</div>
<a id="a9d8715d62198c0c45e77ef3606c03b6c" name="a9d8715d62198c0c45e77ef3606c03b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8715d62198c0c45e77ef3606c03b6c">&#9670;&#160;</a></span>getCrsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const typename <a class="el" href="classIfpack2_1_1RILUK.html">RILUK</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1RILUK.html#a11ec31dfcd53096c3143aa7ecaa04853">::crs_matrix_type</a> &gt; <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::getCrsMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the input matrix A as a Tpetra::CrsMatrix, if possible; else throws. </p>

</div>
</div>
<a id="ad72cc0cd0b359d14b345d58d07449610" name="ad72cc0cd0b359d14b345d58d07449610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad72cc0cd0b359d14b345d58d07449610">&#9670;&#160;</a></span>makeLocalFilter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const typename <a class="el" href="classIfpack2_1_1RILUK.html">RILUK</a>&lt; MatrixType &gt;<a class="el" href="classIfpack2_1_1RILUK.html#af1d08264f25ccadf5a202c604f0f99ac">::row_matrix_type</a> &gt; <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::makeLocalFilter </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classIfpack2_1_1RILUK.html#af1d08264f25ccadf5a202c604f0f99ac">row_matrix_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return A, wrapped in a <a class="el" href="classIfpack2_1_1LocalFilter.html" title="Access only local rows and columns of a sparse matrix.">LocalFilter</a>, if necessary. </p>
<p>"If necessary" means that if A is already a <a class="el" href="classIfpack2_1_1LocalFilter.html" title="Access only local rows and columns of a sparse matrix.">LocalFilter</a>, or if its communicator only has one process, then we don't need to wrap it, so we just return A. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4342e474a2f9ed45ef7a853739abe950" name="a4342e474a2f9ed45ef7a853739abe950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4342e474a2f9ed45ef7a853739abe950">&#9670;&#160;</a></span>A_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt;const <a class="el" href="classIfpack2_1_1RILUK.html#af1d08264f25ccadf5a202c604f0f99ac">row_matrix_type</a>&gt; <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::A_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The (original) input matrix for which to compute ILU(k). </p>

</div>
</div>
<a id="acf1f2f9e47d8fbac26dcf29d1f683bdc" name="acf1f2f9e47d8fbac26dcf29d1f683bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1f2f9e47d8fbac26dcf29d1f683bdc">&#9670;&#160;</a></span>Graph_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt;<a class="el" href="classIfpack2_1_1IlukGraph.html">iluk_graph_type</a>&gt; <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::Graph_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The ILU(k) graph. </p>

</div>
</div>
<a id="a7eb557987a77e8f5e30595288640fa45" name="a7eb557987a77e8f5e30595288640fa45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb557987a77e8f5e30595288640fa45">&#9670;&#160;</a></span>A_local_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt;const <a class="el" href="classIfpack2_1_1RILUK.html#af1d08264f25ccadf5a202c604f0f99ac">row_matrix_type</a>&gt; <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::A_local_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The matrix whos numbers are used to to compute ILU(k). The graph may be computed using a crs_matrix_type that <a class="el" href="classIfpack2_1_1RILUK.html#a06f4f95081fcbf5eb8f5a5d18d0c717b" title="Initialize by computing the symbolic incomplete factorization.">initialize()</a> constructs temporarily. </p>

</div>
</div>
<a id="abff9857962fd3e6c90b36dc688201cc3" name="abff9857962fd3e6c90b36dc688201cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff9857962fd3e6c90b36dc688201cc3">&#9670;&#160;</a></span>L_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt;<a class="el" href="classIfpack2_1_1RILUK.html#a11ec31dfcd53096c3143aa7ecaa04853">crs_matrix_type</a>&gt; <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::L_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The L (lower triangular) factor of ILU(k). </p>

</div>
</div>
<a id="a8ec4302094c82208f237a2898fc6dfec" name="a8ec4302094c82208f237a2898fc6dfec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec4302094c82208f237a2898fc6dfec">&#9670;&#160;</a></span>L_solver_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt;<a class="el" href="classIfpack2_1_1LocalSparseTriangularSolver.html">LocalSparseTriangularSolver</a>&lt;<a class="el" href="classIfpack2_1_1RILUK.html#af1d08264f25ccadf5a202c604f0f99ac">row_matrix_type</a>&gt; &gt; <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::L_solver_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sparse triangular solver for L. </p>

</div>
</div>
<a id="a490bafd1705f15b4dc921bc42aa68908" name="a490bafd1705f15b4dc921bc42aa68908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a490bafd1705f15b4dc921bc42aa68908">&#9670;&#160;</a></span>U_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt;<a class="el" href="classIfpack2_1_1RILUK.html#a11ec31dfcd53096c3143aa7ecaa04853">crs_matrix_type</a>&gt; <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::U_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The U (upper triangular) factor of ILU(k). </p>

</div>
</div>
<a id="acab5ae258e10efbc97be037c1e15309d" name="acab5ae258e10efbc97be037c1e15309d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab5ae258e10efbc97be037c1e15309d">&#9670;&#160;</a></span>U_solver_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt;<a class="el" href="classIfpack2_1_1LocalSparseTriangularSolver.html">LocalSparseTriangularSolver</a>&lt;<a class="el" href="classIfpack2_1_1RILUK.html#af1d08264f25ccadf5a202c604f0f99ac">row_matrix_type</a>&gt; &gt; <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::U_solver_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sparse triangular solver for U. </p>

</div>
</div>
<a id="add271641a94f776edd0c0222b6b32c36" name="add271641a94f776edd0c0222b6b32c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add271641a94f776edd0c0222b6b32c36">&#9670;&#160;</a></span>D_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt;vec_type&gt; <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::D_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The diagonal entries of the ILU(k) factorization. </p>

</div>
</div>
<a id="ae3641218a3995552f47e32befa628e97" name="ae3641218a3995552f47e32befa628e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3641218a3995552f47e32befa628e97">&#9670;&#160;</a></span>isKokkosKernelsSpiluk_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classIfpack2_1_1RILUK.html">Ifpack2::RILUK</a>&lt; MatrixType &gt;::isKokkosKernelsSpiluk_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optional KokkosKernels implementation. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Ifpack2__RILUK__decl_8hpp_source.html">Ifpack2_RILUK_decl.hpp</a></li>
<li><a class="el" href="Ifpack2__RILUK__def_8hpp_source.html">Ifpack2_RILUK_def.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
