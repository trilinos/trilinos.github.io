<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Phalanx: Users Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Phalanx<span id="projectnumber">&#160;Development</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Users Guide</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="user_guide_index"></a>
Index</h1>
<ul>
<li><a class="el" href="user_guide.html#user_guide_getting_started">Getting Started</a></li>
<li><a class="el" href="user_guide.html#user_guide_domain_model">Phalanx Domain Model</a></li>
<li><a class="el" href="user_guide.html#user_guide_mdarray_domain_model">Multi-Dimensional Array Domain Model</a></li>
<li><a class="el" href="user_guide.html#performance">Performance</a></li>
<li><a class="el" href="user_guide.html#user_guide_step1">Step 1: Configuring, Building, and installing Phalanx</a></li>
<li><a class="el" href="user_guide.html#user_guide_step2">Step 2: Determine Types</a></li>
<li><a class="el" href="user_guide.html#user_guide_step3">Step 3: Write the Traits Object</a></li>
<li><a class="el" href="user_guide.html#user_guide_step4">Step 4: Specialize the PHX::TypeString Object</a></li>
<li><a class="el" href="user_guide.html#user_guide_step5">Step 5: Write your Evaluators</a></li>
<li><a class="el" href="user_guide.html#user_guide_step6">Step 6: Implement the FieldManager in your code</a></li>
<li><a class="el" href="index.html#questions">For All Questions and Comments...</a></li>
</ul>
<h1><a class="anchor" id="user_guide_getting_started"></a>
Getting Started</h1>
<h2><a class="anchor" id="ug_dummy_1"></a>
A. Understand Templates</h2>
<p>Phalanx is a complex package that make heavy use of the C++ templating mechanism. We recommend that users of the Phalanx package first familiarize themselves with C++ templates. An excellent reference is "C++ Templates: The Complete Guide" by Vandevoorde and Josuttis, 2003. While users do not need to understand template metaprogramming to use Phalanx, the concepts underlying many operations in Phalanx can be found in "C++ Template Metaprogramming" by Abrahams and Gurtovoy, 2004 and the Boost template metaprogramming library (MPL).</p>
<p>Once Phalanx is integrated into a code by a template savvy developer, the only operation application users should perform is to extend the evaluation routines to new equations and new models by adding new Evaluators. We realize that application developers and application users typically have distictly different skill sets. Much design work has been invested in making the Evaluator implementation very clean and as template free as possible. Therefore, users of the code who only write new Evaluators DO NOT need to know templates.</p>
<h2><a class="anchor" id="ug_dummy_2"></a>
B. Learn the Phalanx Nomenclature</h2>
<p>Users should then learn the nomeclature used in the package defined in the <a class="el" href="user_guide.html#user_guide_domain_model">Phalanx Domain Model</a>.</p>
<h2><a class="anchor" id="ug_dummy_3"></a>
C. Tutorial</h2>
<p>The main concept of Phalanx is to evaluate fields typically for solving PDEs (although it is not limited to this). We demonstrate the integration process using the simple example found in phalanx/example/MultiDimensionalArray. Suppose that we want to solve the heat equation over the physical space <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \Omega $" src="form_4.png" width="9" height="10"/></picture>:</p>
<p class="formulaDsp">
<picture><source srcset="form_5_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
  \nabla \cdot (-k \nabla T) + s = 0
\]" src="form_5.png" width="109" height="14"/></picture>
</p>
<p>where <picture><source srcset="form_6_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ T $" src="form_6.png" width="10" height="9"/></picture> is the temparature (and our degree of freedom), <picture><source srcset="form_7_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ k $" src="form_7.png" width="6" height="10"/></picture> is the thermal conductivity, and <picture><source srcset="form_8_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$s$" src="form_8.png" width="5" height="6"/></picture> is a nonlinear source term. We pose this in terms of a conservation law system:</p>
<p class="formulaDsp">
<picture><source srcset="form_9_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
  \nabla \cdot (\mathbf{q}) + s = 0
\]" src="form_9.png" width="81" height="14"/></picture>
</p>
<p>where <picture><source srcset="form_10_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \mathbf{q} = -k \nabla T $" src="form_10.png" width="61" height="13"/></picture> is the heat flux. The specific discretization technique whether finite element (FE) or finite volume (FV) will ask for <picture><source srcset="form_11_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\mathbf{q}$" src="form_11.png" width="9" height="9"/></picture> and <picture><source srcset="form_8_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$s$" src="form_8.png" width="5" height="6"/></picture> at points on the cell. Phalanx will evaluate <picture><source srcset="form_11_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\mathbf{q}$" src="form_11.png" width="9" height="9"/></picture> and <picture><source srcset="form_8_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$s$" src="form_8.png" width="5" height="6"/></picture> at those points and return them to the discretization driver.</p>
<p>Using finite elements, we pose the problem in variational form: Find <picture><source srcset="form_12_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ u \in {\mathit{V^h}} $" src="form_12.png" width="41" height="13"/></picture> and <picture><source srcset="form_13_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \phi \in {\mathit{S^h}} $" src="form_13.png" width="36" height="14"/></picture> such that:</p>
<p class="formulaDsp">
<picture><source srcset="form_14_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
  - \int_{\Omega} \nabla \phi \cdot \mathbf{q} d\Omega 
  + \int_{\Gamma} \phi \mathbf{n} \cdot \mathbf{q} 
  + \int_{\Omega} \phi s d\Omega = 0 
\]" src="form_14.png" width="225" height="30"/></picture>
</p>
<p>Phalanx will evaluate <picture><source srcset="form_11_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\mathbf{q}$" src="form_11.png" width="9" height="9"/></picture> and <picture><source srcset="form_8_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$s$" src="form_8.png" width="5" height="6"/></picture> at the quadrature points of the cells and pass them off to the integrator such as <a href="http://trilinos.sandia.gov/packages/intrepid">Intrepid</a>.</p>
<p>This is a trivial example, but the dependency chains can grow quite complex if performing something such as a chemically reacting flow calculation coupled to Navier-Stokes and energy conservation.</p>
<p>Follow the steps below to integrate Phalanx into your application. The example code shown in the steps comes from the energy flux example in the directory "phalanx/example/EnergyFlux". Note that many classes are named with the word "My" such as MyWorkset, MyTraits, and MyFactory traits. Any object that starts with the word "My" denotes that this is a user defined class. The user must implement this class specific to their application. All Evaluator derived objects are additionally implemented by the user even though they do not follow the convention of starting with the word "My".</p>
<ul>
<li><a class="el" href="user_guide.html#user_guide_step1">Step 1: Configuring, Building, and installing Phalanx</a></li>
<li><a class="el" href="user_guide.html#user_guide_step2">Step 2: Determine Types</a></li>
<li><a class="el" href="user_guide.html#user_guide_step3">Step 3: Write the Traits Object</a></li>
<li><a class="el" href="user_guide.html#user_guide_step4">Step 4: Specialize the PHX::TypeString Object</a></li>
<li><a class="el" href="user_guide.html#user_guide_step5">Step 5: Write your Evaluators</a></li>
<li><a class="el" href="user_guide.html#user_guide_step6">Step 6: Implement the FieldManager in your code</a></li>
</ul>
<h1><a class="anchor" id="user_guide_domain_model"></a>
Phalanx Domain Model</h1>
<ul>
<li>
<p class="startli"><b>Cell</b></p>
<p class="interli">Partial differential equations are solved in a domain. This domain is discretized into cells (also called elements for the finite element method). This library assumes that the block of cells being iterated over is of the same type! If different evaluators (i.e. different material properties) are required in different blocks of cells, a new FieldMangager must be used for each unique block of elements. This is required for efficiency.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Parallel and Serial Architectures</b></p>
<p class="interli">Phalanx can be used on both serial and multi-processor architectures. The library is designed to perform "local" evalautions on a "local" set of cells. The term local means that all cell and field data required for an evaluation is on the processor that the evaluation is executed. So for parallel runs, the cells are distributed over the processors and a FieldManager is built on each processor to evaluate only the cells that are assigned to that processor. If there is any data distributed to another processor that is required for the evaluation, the user must handle pulling that information on to the evaluation processor. The design of Phalanx will also allow for users to take advantage of multi-core architectures through a variety of implementations.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Workset</b></p>
<p class="interli">For performance and memory limitations, the evaluation of fields can be divided into worksets. While Phalanx does not require the use of worksets, we recomend their use for controlling the memory footprint (this can be important when offloading the kernels onto an accelerator and even for host node memory). The goal of using worksets is to fit all the required fields into the processor cache so that an evaluation is not slowed down by paging memory. Suppose we have a cell-based discretization with 2020 cells to evaluate on a 4 node machine. We might distribute the load so that 505 cells are on each MPI processor. Now the user must figure out the workset size. This is the number of cells to per evaluation call so that the field memory will fit into cache. If we have 505 cells on a processor, suppose we find that only 50 cells at a time will fit into cache. Then we will create a FieldManager with a size of 50 cells. This number is specified in the construction of data layouts. During the call to postRegistrationSetup(), the FieldManager will allocate workspace storage for all fields relevant to the evaluation.</p>
<p class="interli">For our example, there will be 11 worksets. The first 10 worksets will have the 50 cell maximum and the final workset will have the 5 remaining cells. The evaluation routine is called for each workset, where workset information can be passed in through the evaluate call:</p>
<div class="fragment"><div class="line">std::vector&lt;WorksetData&gt; workset_data;</div>
<div class="line">    .</div>
<div class="line">    .</div>
<div class="line"><span class="comment">// Initialize workset data </span></div>
<div class="line">    .</div>
<div class="line">    .</div>
<div class="line">for (std::size_t i = 0; i &lt; workset_data.size(); ++i) {</div>
<div class="line">  field_manager.evaluateFields&lt;MyTraits::Residual&gt;(workset_data[i]);</div>
<div class="line">.</div>
<div class="line">    .  </div>
<div class="line">  <span class="comment">// use evaluated fields </span></div>
<div class="line">    .</div>
<div class="line">    .</div>
<div class="line">}</div>
</div><!-- fragment --><p class="interli">Note that the call to evaluateFields() takes a workset data object in this example. The field_manager is templated on a traits class that allows the user to define the actual object passed into the evaluatFields call. This does not have to be a workset_data object but can be any class or struct the user defines (even void).</p>
<p class="interli">Note that you do not have to use the workset idea. In this cell-based discretization example, one could just evaluate all local elements in one loop (equivalent to a single workset). Be aware that this can result in a possibly large performance hit.</p>
<p class="interli">Phalanx, in fact, does not restrict you to cell based iteration. You can iterate over any entity type such as edge or face structures.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Consistent Evaluation</b></p>
<p class="interli">Phalanx was imtended to perform consistent evaluations. By consistent, we mean that all dependencies of a field evaluation are current with respect to the current degree of freedom values. For example, suppose we need to evaluate the the energy flux. This has dependencies on the diffusivity, and the temperature gradient. Each of these quantities in turn depends on the temperature. So before the diffusivity and temperature gradient are evaluated, the temperature must be evaluated. Before the energy flux can be evaluated, the density, diffusivity, and temperature gradient must be evaluated. Phalanx forces an ordered evaluation that updates fields in order to maintain consistency of the dependency chain. Without this, one might end up with lagged values being used from a previous evaluate call.</p>
<p class="interli">This does not rule out the use of semi-implicit or operator split schemes. In fact these have been demonstrated in Phalanx. It just rquires that users store any lagged history and provide a field evaluator to pull that history in.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Scalar Type</b></p>
<p class="interli">A scalar type, typically the template argument ScalarT in Phalanx code, is the type of scalar used in an evaluation. It is typically a double or float, but can be special object types for extended precision, complex values, and special embedded methods data types such as sensitivity analysis. For example, for sensitivity analysis, a double scalar type is replaced with a foward automatic differentiation object (FAD) or a reverse automatic differentaion object (RAD) to produce sensitivity information. Whatever type is used, the standard mathematical operators are overloaded for the particular embedded technology. For an example of this, see the <a href="http://trilinos.sandia.gov/packages/sacado">Sacado Automatic Differentiation Library</a>. Some sample scalar types include:</p>
<ul>
<li>
float </li>
<li>
double </li>
<li>
Sacado::Fad::DFad&lt;double&gt; (for sensitivity analysis) </li>
</ul>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Data Type</b></p>
<p class="interli">The data type is a deprecated concept used in the original Phalanx implementation. It is now equivalent to the scalar type. You might see use older code specifying a DataT template parameter, but this is now equivalent the ScalarT template parameter.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Evaluation Type</b></p>
<p class="interli">The evaluation type, typically the template argument EvalT in Phalanx code, defines a unique type of evaluation to perform. The user is free to choose/create the evaluation types - they implement their own class or struct for their own evaluation types. An EvaluationContainer is allocated for each evaluation type specified in the users traits class. Examples that we usually use include:</p>
<ul>
<li>
Residual (simple function evaluation) </li>
<li>
Jacobian (function sensitivities with respect to state variables) </li>
<li>
Tangent (parameter sensitivity) </li>
</ul>
<p class="interli">The evaluation type must be associated with one default scalar type and can optionally support additional scalar types. The scalar type usually determines what is being evaluated. For example, to evaluate the equation residuals, the scalar type is usually a double, a float or an extended precision type. To evaluate a Jacobian, the scalar type could be a forward automatic differentiation object, Sacado::Fad::DFAD&lt;double&gt;. By introducing the evaluation type in Phalanx, the same scalar type can be used for different evaluation types and can be specialized accordingly. For example computing the Jacobian and computing parameter sensitivities both could use the Sacado::Fad::DFAD&lt;double&gt; scalar type.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Storage</b></p>
<p class="interli">A DataContainer object stores all fields of a particular data type. Each EvaluationContainer holds a vector of DataContainers, one DataContainer for each vaid data type that is associated with that particular evaluation type. One EvaluationContainer is constructed for each evaluation type.</p>
<p class="interli">NOTE: this concept was needed for memory allocation in the first generation Phalanx library when all fields for an evaluation type were stored contiguously in memory. Since the Kokkos transition, memory in now controlled by the <a class="el" href="classKokkos_1_1View.html">Kokkos::View</a>. We could remove this concept and corresponding code in the future. This object is not used by the user and is an underlying implementatino detail. It's removal will NOT result in changes to user code.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Data Layout</b></p>
<p class="interli">The DataLayout object is used to define layout of the multidimensional array used to store Phalanx Fields. It provides the size of each rank in the multidimensional array and provides a unique string name to distinguish fields with the same name that might exist on different layouts. For example, supposed we have written an evaluator the computes the "Density" field for a set of points in the cell. Now we want to evaluate the density at a different set of points in the cell. We might have a "Density" field in a cell associated with a set of integration points (quadrature/integration points in finite elements) and another field associated with the nodes (nodal basis degree of freedom points in finite elements). We use the same field name (so we can reuse the same Evaluator), "Density", but use two different DataLayouts, one for integration points and one for nodal point. Now a FieldTag comparison will differentiate the fields due to the different DataLayout.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Field Tag</b></p>
<p class="interli">The FieldTag is a description of a field. It is templated on the data type, DataT. It is used to identify a field stored in the field manager. It contains a unique identifier (an stl std::string) and a pointer to a data layout object. If two FieldTags are equal, the DataLayout, the data type, and the string name are exactly the same.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Field</b></p>
<p class="interli">A Field is a set of values for a particular quantity of interest that must be evaluated. It is templated on the data type, DataT. It consists of a FieldTag and a reference counted smart pointer (Teuchos::RCP&lt;DataT&gt;) to the data array where the values are stored. <br  />
</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Evaluator</b></p>
<p class="interli">An Evaluator is an object that evaluates a set of Fields. It contains two vectors of Fields, one set is the fields it will evaluate and one set is the fields it depends on for the evaluation. For example to evaluate a density field that is a function of temperature and pressure, the field the evaluator will evaluate (the first field set) is a density field, and the set of fields it requires to meet its dependencies are the temperature and pressure fields (the second field set). The evaluator is templated on the evaluation type and the traits class. <br  />
</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Evaluator Manager</b></p>
<p class="interli">The main object that stores all Fields and Evaluators. The evaluator manager (EM) sorts the evaluators and determines which evaluators to call and the order necessary to ensure consistency in the fields. The EM also allocates the memory for storage of all fields so that if we want to force all fields to be in a contiguous block, we have that option available. Users can write their own allocator for memory management.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Multidimensional Array</b></p>
<p class="interli">Instead of using the concept of an algebraic type that the user implements, it may be easier to use a multidimensional array. For example, suppose we have ten cells, and in each cell there are four points (specifically quadrature points) where we want to store a 3x3 matrix for the stress tensor. Using the concepts of algebraic types, we would use a user defined matrix in a Phalanx Field:</p>
<div class="fragment"><div class="line">PHX::MDA::Layout&lt;Cell,QP&gt; layout(10,4);</div>
<div class="line"><a class="code hl_class" href="classPHX_1_1Field.html">PHX::Field&lt; MyTensor&lt;double&gt;</a> &gt; stress(<span class="stringliteral">&quot;Stress&quot;</span>,layout);</div>
<div class="ttc" id="aclassPHX_1_1Field_html"><div class="ttname"><a href="classPHX_1_1Field.html">PHX::Field</a></div><div class="ttdef"><b>Definition</b> Phalanx_Field.hpp:59</div></div>
</div><!-- fragment --><p class="interli">However, Phalanx also implements the idea of a multidimensional array with optional compile time checking on rank accessors.</p>
<div class="fragment"><div class="line">PHX::MDA::Layout&lt;Cell,QP,Dim,Dim&gt; layout(10,4,3,3);</div>
<div class="line"><a class="code hl_class" href="classPHX_1_1MDField.html">PHX::MDField&lt;double,Cell,QP,Dim,Dim&gt;</a> stress(<span class="stringliteral">&quot;Stress&quot;</span>,layout);</div>
<div class="ttc" id="aclassPHX_1_1MDField_html"><div class="ttname"><a href="classPHX_1_1MDField.html">PHX::MDField</a></div><div class="ttdef"><b>Definition</b> Phalanx_MDField.hpp:250</div></div>
</div><!-- fragment --><p class="interli">Here, the "Cell", "QP", and "Dim" objects are small structs that allow users to describe the ordinates associated with the multidimensional array.</p>
<p class="interli">The benefits of using the multidimensional array are that (1) checking of the rank accessor at either compile time or runtime (runtime checking is only enabled for debug builds for efficiency) prevent coding errors and (2) the documentation of the ordinals is built into the code - no relying on comments that go out of date.</p>
<p class="interli">The EnergyFlux example is reimplemented using the multidimensional array instead of the algebric types in the directory Trilinos/packages/phalanx/example/MultiDimensionalArray/.</p>
<p class="interli">Our recomendation is to use the multidimensional array version as future codes plan to use this object. The <a class="el" href="classPHX_1_1MDField.html">PHX::MDField</a> is fully compatible with Intrepid whereas the <a class="el" href="classPHX_1_1Field.html">PHX::Field</a> is not. We keep the <a class="el" href="classPHX_1_1Field.html">PHX::Field</a> object around for performance measurements since it directly accesses the Teuchos::ArrayRCP object where the <a class="el" href="classPHX_1_1MDField.html">PHX::MDField</a> uses a shards::Array object. If the compiler optimizes correctly, there should be no difference in performance. By testing both the Field and MDField, we can test compiler optimization. <br  />
</p>
<p class="endli"></p>
</li>
</ul>
<h1><a class="anchor" id="performance"></a>
Performance</h1>
<p>Some recomendations for efficient code: </p><ul>
<li>
<p class="startli"><b>Use worksets</b> This may eliminate cache misses.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Enable compiler optimization:</b> The Field and MDField classes use inlined bracket operators for data access. That means if you build without optimization some compilers will produce very slow code. To see if your compiler is optimizing away the bracket operator overhead, run the test found in the directory "phalanx/test/Performance/BracketOperator". If the timings are the same between a raw pointer array and the Field and MDField classes, your compiler has removed the overhead. For example, on gnu g++ 4.2.4, compiling with -O0 shows approximately 2x overhead for bracket accessors, while -O2 shows about a 10% overhead, while -O3 completely removes the overhead.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Algebraic Types:</b> Implementing your own algebraic types, while convenient for users, can introduce overhead as opposed to using raw arrays or the multidimensional array. The tests found in "phalanx/test/Performance/AlgebraicTypes" demonstrate some of this overhead. Expression templates should remove this overhead, but in our experience, this seems to be very compiler and implementation dependent. If you build in tvmet support, you can compare expression templates, our "dumb" implementation for vectors and matrices, and our multidimensional array against raw array access. Our testing on gnu compilers shows an overhead of about 20-25% when using "dumb" objects and the expresion templates as opposed to raw arrays. We recommend using raw arrays with the multi-dimensional array (MDField) for fastest runtimes.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Use Contiguous Allocator:</b> Phalanx has two allocators, one that uses the "new" command for each separate field, and one that allocates a single contiguous array for ALL fields. If cache performance is the limiting factor, the contiguous allocator could have a big effect on performance. Additionally, alignment issues can play a part in the allocators depending on how you implement your algrbraic types. Our ContiguousAllocator allows users to choose the alignment based on a template parameter. Typically, this is double.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Limit the number of Fields and/or Evaluators:</b> The more evaluators used in your code, the more the loop sturcutre is broken up. You go from a single loop to a bunch of small loops. This can have an effect on the overall performance. Users should also be judicious on choosing Fields. Only select Fields as a place to introduce variability in your models or for reuse. For example, if you require density in a single place in the code and there is only one single model that won't change, do not make it a field. Just evaluate it once where needed. But if you need density in multiple providers or you want to swap models at runtime, then it should be a field. This prevents having to recompute the model or recompile your code to switch models. This is usually not an issue as long as the amount of work in each evaluator is larger than vtable lookup to make the evaluate call. In our experience, we have never observed this behaviour. We point it our here just in case.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Slow compilation times:</b> As the number of Evaluators in a code grows, the compilation times can become very long. Making even a minor change can result in the code recompiling all Evaluator code. Therefore, we recommend using explicit template instantiation. An example can be found in Trilinos/packages/phalanx/example/FEM_Nonlinear. All evaluators use explicit template instantiation if phalanx is built with explicit template instation enabled (in the cmake build system, use the flag -D Phalanx__EXPLICIT_TEMPLATE_INSTANTIATION=ON).</p>
<p class="endli"></p>
</li>
</ul>
<h1><a class="anchor" id="user_guide_mdarray_domain_model"></a>
Multi-Dimensional Array Domain Model</h1>
<p>The multidimensional array was designed for interoperability between a number of Trilinos packages including shards, phalanx and intrepid. These codes each have their own implementations but follow a basic set of requirements so that functions templated on the array type can use any of the multidimensional array implementations. The required functions are:</p>
<ul>
<li>
ScalarT&amp; operator[] - the bracket operator </li>
<li>
ScalarT&amp; operator(1,2,3,...,N) - accessor operators for each rank N array. </li>
<li>
size_type rank() - integer number of ordinates </li>
<li>
size_type dimension(size_type ordinate) - size of ordinate </li>
<li>
size_type size() - total size of array </li>
</ul>
<p>Phalanx implements the multidimensional array in the <a class="el" href="classPHX_1_1MDField.html">PHX::MDField</a> class and supports arrays with up to 8 ranks (one more than Fortran arrays support). More information can be found in the shards library.</p>
<h1><a class="anchor" id="user_guide_step1"></a>
Step 1: Configuring, Building, and installing Phalanx</h1>
<h2><a class="anchor" id="ug_step1_general"></a>
A. General Library Requirements</h2>
<p>Phalanx is distributed as a package in the <a href="http://trilinos.sandia.gov">Trilinos Framework</a>. It can be enabled as part of a trilinos build with the configure option "-D Trilinos_ENABLE_Phalanx=ON". Phalanx currently has direct dependencies on the following third party libraries:</p>
<ul>
<li><b>Requires</b> the <a href="http://trilinos.sandia.gov/packages/teuchos">Teuchos</a> utilities library, part of the <a href="http://trilinos.sandia.gov/">Trilinos Framework</a>. This will automatically be enabled when you enable the phalanx library.<ul>
<li><b>Requires</b> the <a href="http://trilinos.sandia.gov/packages/sacado">Sacado Automatic Differentiation Library</a>, part of the <a href="http://trilinos.sandia.gov/">Trilinos Framework</a>. This will automatically be enabled when you enable the phalanx library.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="ug_step1_performance"></a>
B. Performance Example Requirements</h2>
<ul>
<li><b>Optional:</b> Some performance tests run comparisons against <a href="http://tvmet.sourceforge.net/">TVMET: Tiny Vector Matrix library using Expression Templates</a>. This is to get a feel for how our "dumb" vector matrix objects perform compared to expression templates. You must enable the tvmet TPL add the path to the TVMET library during Trilinos configuration. An example configuration file can be found in Trilinos/packages/phalanx/build_scripts/build_phalanx_gcc.sh.</li>
</ul>
<p>TVMET is optional and hidden behind an ifdef. The performance tests will be built regardless of whether tvmet is enabled/disabled.</p>
<h2><a class="anchor" id="ug_step1_fem"></a>
C. Nonlinear Finite Element Example Requirements</h2>
<p>To build the example problem in "phalanx/example/FEM_Nonlinear", distributed vector, distributed sparse matrix, and corresponding linear solvers are required. The following <b>Trilinos</b> packages need to be enabled to build the FEM_Nonlinear example:</p>
<ul>
<li><b>Requires:</b> the <a href="http://trilinos.sandia.gov/packages/epetra">Epetra Library</a>, supplies the linear algebra data structures for spares matrices. Can be enabled during the Trilinos configure with the flag "-D Trilinos_ENABLE_Epetra=ON".</li>
<li><b>Requires:</b> the <a href="http://trilinos.sandia.gov/packages/ifpack">Ifpack Library</a>, supplies incomplete factorization preconditioners. Can be enabled during the Trilinos configure with the flag "-D Trilinos_ENABLE_Ifpack=ON".</li>
<li><b>Requires:</b> the <a href="http://trilinos.sandia.gov/packages/belos">Belos Library</a>, supplies block GMRES iterative linear solver. Can be enabled during the Trilinos configure with the flag "-D Trilinos_ENABLE_Belos=ON". <br  />
</li>
</ul>
<p>This example will be disabled if the above packages are not enabled.</p>
<h2><a class="anchor" id="db"></a>
D. Configure Trilinos/Phalanx</h2>
<p>The general instructions for building trilinos can be found at <a href="http://trilinos.sandia.gov/documentation.html">Trilinos Documentation Page</a>. Of particular importance are the Overview, User Guide, and Tutorial documents. At a minimum you must enable the Teuchos, Sacado, and Phalanx packages. An example configure script is:</p>
<pre class="fragment"></pre><p>Once configure is run, build and install the library with the command:</p>
<div class="fragment"><div class="line">make install</div>
</div><!-- fragment --><h1><a class="anchor" id="user_guide_step2"></a>
Step 2: Determine Types</h1>
<p>Users must next determine the evaluation types and data types they will require in their simulation. Please see the section <a class="el" href="user_guide.html#user_guide_domain_model">Phalanx Domain Model</a> for detailed explanation of types. Following the example in the phalanx/example/EnergyFlux directory, we will be requiring two evaluation types, one for the residual evaluation of the discretized PDE equation and one for the corresponding Jacobian. Additional evaluation types might be for the parameter sensitivites and uncertainty quantification. <br  />
</p>
<p>Once the evaluation types are chosen, users must decide on a default scalar type and on all data types that are valid for each evaluation type. The data types should all be templated on the default scalar type for the particular evaluation type, but this is not a requirement (expert users can violate this for performance reasons). Uses must implement their own data types or get them from a separate library. For sensitivities, the trilinos package <a href="http://trilinos.sandia.gov/packages/sacado">Sacado</a> should be used. For uncertainty quantification, the Trilinos package <a href="http://trilinos.sandia.gov/packages/stokhos">Stokhos</a> should be used.</p>
<p>In our example, the user has written an implementation of vector (MyVector) and matrix (MyTensor) classes found in the file AlgebraicTypes.hpp. They are templated on a scalar type and can be used for all evaluation types.</p>
<ul>
<li>
Residual - Default scalar type will be "double". The data types will be: <ul>
<li>
double </li>
<li>
MyVector&lt;double&gt; </li>
<li>
MyTensor&lt;double&gt; </li>
</ul>
</li>
<li>
Jacobian - Default scalar type will be "Sacado::Fad::DFad&lt;double&gt;". This scalar type will carry both the residual information as well as sensitivity information. The data types will be: <ul>
<li>
Sacado::Fad::DFad&lt;double&gt; </li>
<li>
MyVector&lt; Sacado::Fad::DFad&lt;double&gt; &gt; </li>
<li>
MyTensor&lt; Sacado::Fad::DFad&lt;double&gt; &gt; </li>
</ul>
</li>
</ul>
<p>Typical examples of algebraic types include vectors, matrices, or higher order tensor objects, but in reality can be any struct/class that the user desires. Remember to template the objects on the scalar type if possible. An example of a very inefficient Vector and Matrix implementation (operator overloading without expression templates) can be found in AlgebraicTypes.hpp.</p>
<h1><a class="anchor" id="user_guide_step3"></a>
Step 3: Write the Traits Object</h1>
<p>The Traits object is a struct that defines the evaluation types, the data types for each evaluation type, the allocator type, and the user defined types that will be passed through evaluator calls. We will go through each of these defninitions.</p>
<p>The basic class should derive from the <a class="el" href="structPHX_1_1TraitsBase.html">PHX::TraitsBase</a> object.</p>
<p><b> The Traits struct must define each of the following typedef members of the struct:</b></p>
<ul>
<li><b>EvalTypes</b> - an mpl::vector of user defined evaluation types. Each evaluation type must have a typedef member called ScalarT that provides the default scalar type. This is used to automate the building of evaluators for each evaluation type using the EvaluatorFactory.</li>
<li><b>EvalToDataMap</b> - an mpl::map. The key is an evaluation type and the value is an mpl::vector of valid data types for that particular evaluation type.</li>
<li><b>Allocator</b> type - type that defines the allocator class to use to allocate the memory for data storage.</li>
<li><b>SetupData</b> - A user defined type to be passed in to the postRegistrationSetup() call. Allows users to pass in arbitrary data to the evaluators during setup.</li>
<li><b>EvalData</b> - A user defined type to be passed in to the evaluateFields() call. Allows users to pass in arbitrary data.</li>
<li><b>PreEvalData</b> - A user defined type to be passed in to the preEvaluate() call. Allows users to pass in arbitrary data.</li>
<li><b>PostEvalData</b> - A user defined type to be passed in to the postEvaluate() call. Allows users to pass in arbitrary data.</li>
</ul>
<h2><a class="anchor" id="td1"></a>
A. Basic Class</h2>
<p>The basic outline of the traits struct is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyTraits : <span class="keyword">public</span> <a class="code hl_struct" href="structPHX_1_1TraitsBase.html">PHX::TraitsBase</a> {</div>
<div class="line">    .</div>
<div class="line">    .</div>
<div class="line">    .</div>
<div class="line">};</div>
<div class="ttc" id="astructPHX_1_1TraitsBase_html"><div class="ttname"><a href="structPHX_1_1TraitsBase.html">PHX::TraitsBase</a></div><div class="ttdef"><b>Definition</b> Phalanx_Traits.hpp:25</div></div>
</div><!-- fragment --><p>Inside this struct we need to implement all the typedefs listed above. The example we will follow is in the file Traits.hpp in "phalanx/example/EnergyFlux" directory.</p>
<h2><a class="anchor" id="td2"></a>
B. EvalTypes</h2>
<p>First we need to know the evaluation types. Each evaluation type must include at least a typedef'd default scalar type argument as a public member called ScalarT. Here is the example code:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyTraits : <span class="keyword">public</span> <a class="code hl_struct" href="structPHX_1_1TraitsBase.html">PHX::TraitsBase</a> {</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// ******************************************************************</span></div>
<div class="line">  <span class="comment">// *** Scalar Types</span></div>
<div class="line">  <span class="comment">// ******************************************************************</span></div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Scalar types we plan to use</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">double</span> RealType;</div>
<div class="line">  <span class="keyword">typedef</span> Sacado::Fad::DFad&lt;double&gt; FadType;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// ******************************************************************</span></div>
<div class="line">  <span class="comment">// *** Evaluation Types</span></div>
<div class="line">  <span class="comment">// ******************************************************************</span></div>
<div class="line">  <span class="keyword">struct </span>Residual { <span class="keyword">typedef</span> RealType ScalarT; };</div>
<div class="line">  <span class="keyword">struct </span>Jacobian { <span class="keyword">typedef</span> FadType ScalarT;  };</div>
<div class="line">  <span class="keyword">typedef</span> Sacado::mpl::vector&lt;Residual, Jacobian&gt; EvalTypes;</div>
<div class="line"> </div>
<div class="line">   .</div>
<div class="line">   .</div>
<div class="line">   .</div>
</div><!-- fragment --><p>The typedefs RealType and FadType are done only for convenience. They are not actually required but cut down on the typing. Only the EvalTypes typedef is required in the code above.</p>
<h2><a class="anchor" id="td3"></a>
C. EvaltoDataMap</h2>
<p>Next we need to link the data types to the evaluation type. Note that one could use the same data type in multiple evaluation types:</p>
<div class="fragment"><div class="line"> .</div>
<div class="line"> .</div>
<div class="line"> .</div>
<div class="line"><span class="comment">// Residual (default scalar type is RealType)</span></div>
<div class="line">typedef Sacado::mpl::vector&lt; RealType, </div>
<div class="line">             MyVector&lt;RealType&gt;,</div>
<div class="line">             MyTensor&lt;RealType&gt; </div>
<div class="line">&gt; ResidualDataTypes;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Jacobian (default scalar type is Fad&lt;double&gt;)</span></div>
<div class="line"><span class="keyword">typedef</span> Sacado::mpl::vector&lt; FadType,</div>
<div class="line">             MyVector&lt;FadType&gt;,</div>
<div class="line">             MyTensor&lt;FadType&gt; </div>
<div class="line">&gt; JacobianDataTypes;</div>
<div class="line"> .</div>
<div class="line"> .</div>
<div class="line"> .</div>
</div><!-- fragment --><h2><a class="anchor" id="td4"></a>
D. Allocator</h2>
<p>Define the Allocator type to use. Phalanx comes with two allocators, but the user can write their own allocator class if these aren't sufficient. The Phalanx allocator classes are:</p><ul>
<li>PHX::NewAllocator: uses the C++ "new" command to allocate each field on the heap separately.</li>
<li>PHX::ContiguousAllocator: allocates a single contiguous block of memory on the heap for all fields regardless of the type. This allows us to fit a subset of elements into cache to speed up the evaluation.</li>
</ul>
<p>Code using the NewAllocator is: </p><div class="fragment"><div class="line"> .</div>
<div class="line"> .</div>
<div class="line"> .</div>
<div class="line"><span class="comment">// ******************************************************************</span></div>
<div class="line"><span class="comment">// *** Allocator Type</span></div>
<div class="line"><span class="comment">// ******************************************************************</span></div>
<div class="line">typedef PHX::NewAllocator Allocator;</div>
<div class="line"> .</div>
<div class="line"> .</div>
<div class="line"> .</div>
</div><!-- fragment --><h2><a class="anchor" id="td5"></a>
E. EvalData,PreEvalData,PostEvalData</h2>
<p>Users can pass their own data to the postRegistrationSetup(), evaluateFields(), preEvaluate() and postEvaluate() methods of the PHX::FiledManager class. In this example, the user passes in a struct that they have written called MyEvalData. This contains information about the cell workset. The user is not required to write their own object. They could just pass in a null pointer if they don't need auxiliary information passed into the routine. This is demonstrated in the SetupSetup, PreEvalData, and PostEvalData. A void* is set for the data member. </p><div class="fragment"><div class="line">   .</div>
<div class="line">   .</div>
<div class="line">   .</div>
<div class="line">  <span class="comment">// ******************************************************************</span></div>
<div class="line">  <span class="comment">// *** User Defined Object Passed in for Evaluation Method</span></div>
<div class="line">  <span class="comment">// ******************************************************************</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">void</span>* SetupData;</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> MyEvalData&amp; EvalData;</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">void</span>* PreEvalData;</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">void</span>* PostEvalData;</div>
<div class="line"> </div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="user_guide_step4"></a>
Step 4: Specialize the PHX::TypeString Object</h1>
<p>For debugging information, Phalanx makes a forward declaration of the PHX::TypeString object. This must be specialized for each evaluation type and each data type so that if there is a run-time error, phalanx can report detailed information on the problem. We could have used the typeinfo from the stl, but the name() method is not demangled on every platform, so it can make debugging a challenge. The specialized classes can go into their own file or can be added to the traits file above depending on how you use the Traits class. During linking, if the compiler complains about multiple defninitions of your specialized traits classes, separate the traits implementation into their own .cpp file.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>PHX {</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ******************************************************************</span></div>
<div class="line">  <span class="comment">// ******************************************************************</span></div>
<div class="line">  <span class="comment">// Debug strings.  Specialize the Evaluation and Data types for the</span></div>
<div class="line">  <span class="comment">// TypeString object in the phalanx/src/Phalanx_TypeString.hpp file.</span></div>
<div class="line">  <span class="comment">// ******************************************************************</span></div>
<div class="line">  <span class="comment">// ******************************************************************</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Evaluation Types</span></div>
<div class="line">  <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>TypeString&lt;MyTraits::Residual&gt; </div>
<div class="line">  { <span class="keyword">static</span> <span class="keyword">const</span> std::string value; };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>TypeString&lt;MyTraits::Jacobian&gt; </div>
<div class="line">  { <span class="keyword">static</span> <span class="keyword">const</span> std::string value; };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::string TypeString&lt;MyTraits::Residual&gt;::value = </div>
<div class="line">    <span class="stringliteral">&quot;Residual&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::string TypeString&lt;MyTraits::Jacobian&gt;::value = </div>
<div class="line">    <span class="stringliteral">&quot;Jacobian&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Data Types</span></div>
<div class="line">  <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>TypeString&lt;double&gt; </div>
<div class="line">  { <span class="keyword">static</span> <span class="keyword">const</span> std::string value; };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>TypeString&lt; MyVector&lt;double&gt; &gt; </div>
<div class="line">  { <span class="keyword">static</span> <span class="keyword">const</span> std::string value; };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>TypeString&lt; MyTensor&lt;double&gt; &gt; </div>
<div class="line">  { <span class="keyword">static</span> <span class="keyword">const</span> std::string value; };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>TypeString&lt; Sacado::Fad::DFad&lt;double&gt; &gt; </div>
<div class="line">  { <span class="keyword">static</span> <span class="keyword">const</span> std::string value; };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>TypeString&lt; MyVector&lt;Sacado::Fad::DFad&lt;double&gt; &gt; &gt; </div>
<div class="line">  { <span class="keyword">static</span> <span class="keyword">const</span> std::string value; };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>TypeString&lt; MyTensor&lt;Sacado::Fad::DFad&lt;double&gt; &gt; &gt; </div>
<div class="line">  { <span class="keyword">static</span> <span class="keyword">const</span> std::string value; };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::string TypeString&lt;double&gt;::value = </div>
<div class="line">    <span class="stringliteral">&quot;double&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::string TypeString&lt; MyVector&lt;double&gt; &gt;::value = </div>
<div class="line">    <span class="stringliteral">&quot;MyVector&lt;double&gt;&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::string TypeString&lt; MyTensor&lt;double&gt; &gt;::value = </div>
<div class="line">    <span class="stringliteral">&quot;MyTensor&lt;double&gt;&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::string TypeString&lt; Sacado::Fad::DFad&lt;double&gt; &gt;::</div>
<div class="line">  value = <span class="stringliteral">&quot;Sacado::Fad::DFad&lt;double&gt;&quot;</span>;</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> std::string TypeString&lt; MyVector&lt;Sacado::Fad::DFad&lt;double&gt; &gt; &gt;::</div>
<div class="line">  value = <span class="stringliteral">&quot;Sacado::Fad::DFad&lt; MyVector&lt;double&gt; &gt;&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::string TypeString&lt; MyTensor&lt;Sacado::Fad::DFad&lt;double&gt; &gt; &gt;::</div>
<div class="line">  value = <span class="stringliteral">&quot;Sacado::Fad::DFad&lt; MyTensor&lt;double&gt; &gt;&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="user_guide_step5"></a>
Step 5: Write your Evaluators</h1>
<p>Before Writing your evaluators, you must decide on how you plan to build the evaluators. In most cases you will want to build one Evaluator for each evaluation type. Phalanx provides an automated factory called the <a class="el" href="classPHX_1_1EvaluatorFactory.html">PHX::EvaluatorFactory</a> that will build an evaluator for each evaluation type automatically, but this places a restriction on the constructor of all evaluators built this way. If you plan to use the automated builder, the constructor for the Evaluator must contain only one argument - a Teuchos::ParameterList. This paramter list must contain a key called "Type" with an integer value corresponding to the type of Evaluator object to build. The parameterlist can contain any other information the user requires for proper construction of the Evaluator. You are not restricted to using the automated factory for every Evaluator. You can selectively use the automated factory where convenient.</p>
<p>For each field, you will need an evaluator. Evaluators can evlauate multiple fields at the same time. You can derive from the base class <a class="el" href="classPHX_1_1Evaluator.html">PHX::Evaluator</a>, or you can derive from class <a class="el" href="classPHX_1_1EvaluatorWithBaseImpl.html" title="Class that implements helper functions for the pure virtual PHX::Evaluator class.">PHX::EvaluatorWithBaseImpl</a> that has most of the methods already implemented so that the same support code is not replicted in each evaluator. We STRONGLY recommend deriving from the class <a class="el" href="classPHX_1_1EvaluatorWithBaseImpl.html" title="Class that implements helper functions for the pure virtual PHX::Evaluator class.">PHX::EvaluatorWithBaseImpl</a>.</p>
<p>An example for evaluating the density field is:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef PHX_EXAMPLE_VP_DENSITY_HPP</span></div>
<div class="line"><span class="preprocessor">#define PHX_EXAMPLE_VP_DENSITY_HPP</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;Phalanx_config.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Phalanx_Evaluator_WithBaseImpl.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Phalanx_Evaluator_Derived.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Phalanx_Field.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> EvalT, <span class="keyword">typename</span> Traits&gt;</div>
<div class="line"><span class="keyword">class </span>Density : </div>
<div class="line">  <span class="keyword">public</span> <a class="code hl_class" href="classPHX_1_1EvaluatorWithBaseImpl.html">PHX::EvaluatorWithBaseImpl</a>&lt;Traits&gt;,</div>
<div class="line">  <span class="keyword">public</span> <a class="code hl_class" href="classPHX_1_1EvaluatorDerived.html">PHX::EvaluatorDerived</a>&lt;EvalT, Traits&gt; {</div>
<div class="line">  </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  </div>
<div class="line">  Density(<span class="keyword">const</span> Teuchos::ParameterList&amp; p);</div>
<div class="line">  </div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classPHX_1_1EvaluatorWithBaseImpl.html#abfaf6c34a36fbf67d89de23471fe8bb5">postRegistrationSetup</a>(<span class="keyword">typename</span> Traits::SetupData d,</div>
<div class="line">                 <a class="code hl_class" href="classPHX_1_1FieldManager.html">PHX::FieldManager&lt;Traits&gt;</a>&amp; vm);</div>
<div class="line">  </div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classPHX_1_1EvaluatorWithBaseImpl.html#a2b3bbd25911665100eb0de94879a7903">evaluateFields</a>(<span class="keyword">typename</span> Traits::EvalData ud);</div>
<div class="line">  </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> EvalT::ScalarT ScalarT;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> constant;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classPHX_1_1Field.html">PHX::Field&lt;ScalarT&gt;</a> density;</div>
<div class="line">  <a class="code hl_class" href="classPHX_1_1Field.html">PHX::Field&lt;ScalarT&gt;</a> temp;</div>
<div class="line"> </div>
<div class="line">  std::size_t data_layout_size;</div>
<div class="line"> </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;Evaluator_Density_Def.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="ttc" id="aclassPHX_1_1EvaluatorDerived_html"><div class="ttname"><a href="classPHX_1_1EvaluatorDerived.html">PHX::EvaluatorDerived</a></div><div class="ttdef"><b>Definition</b> Phalanx_Evaluator_Derived.hpp:22</div></div>
<div class="ttc" id="aclassPHX_1_1EvaluatorWithBaseImpl_html"><div class="ttname"><a href="classPHX_1_1EvaluatorWithBaseImpl.html">PHX::EvaluatorWithBaseImpl</a></div><div class="ttdoc">Class that implements helper functions for the pure virtual PHX::Evaluator class.</div><div class="ttdef"><b>Definition</b> Phalanx_Evaluator_WithBaseImpl.hpp:34</div></div>
<div class="ttc" id="aclassPHX_1_1EvaluatorWithBaseImpl_html_a2b3bbd25911665100eb0de94879a7903"><div class="ttname"><a href="classPHX_1_1EvaluatorWithBaseImpl.html#a2b3bbd25911665100eb0de94879a7903">PHX::EvaluatorWithBaseImpl::evaluateFields</a></div><div class="ttdeci">virtual void evaluateFields(typename Traits::EvalData d) override=0</div><div class="ttdoc">Evaluate all fields that the provider supplies.</div></div>
<div class="ttc" id="aclassPHX_1_1EvaluatorWithBaseImpl_html_abfaf6c34a36fbf67d89de23471fe8bb5"><div class="ttname"><a href="classPHX_1_1EvaluatorWithBaseImpl.html#abfaf6c34a36fbf67d89de23471fe8bb5">PHX::EvaluatorWithBaseImpl::postRegistrationSetup</a></div><div class="ttdeci">virtual void postRegistrationSetup(typename Traits::SetupData d, PHX::FieldManager&lt; Traits &gt; &amp;vm) override</div><div class="ttdoc">Allows providers to grab pointers to data arrays.</div><div class="ttdef"><b>Definition</b> Phalanx_Evaluator_WithBaseImpl_Def.hpp:393</div></div>
<div class="ttc" id="aclassPHX_1_1FieldManager_html"><div class="ttname"><a href="classPHX_1_1FieldManager.html">PHX::FieldManager</a></div><div class="ttdef"><b>Definition</b> Phalanx_FieldManager.hpp:43</div></div>
</div><!-- fragment --><p>Note that if you want to use the automated factory <a class="el" href="classPHX_1_1EvaluatorFactory.html">PHX::EvaluatorFactory</a> to build an object of each evaluation type, you must derive from the <a class="el" href="classPHX_1_1EvaluatorDerived.html">PHX::EvaluatorDerived</a> class as shown in the example above. This allows the variable manager to store a vector of base object pointers for each evaluation type in a single stl vector.</p>
<p>Also note that we pull the scalar type, ScalarT, out of the evaluation type.</p>
<p>The implementation is just as simple: </p><div class="fragment"><div class="line"><span class="comment">// **********************************************************************</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> EvalT, <span class="keyword">typename</span> Traits&gt; Density&lt;EvalT, Traits&gt;::</div>
<div class="line">Density(<span class="keyword">const</span> Teuchos::ParameterList&amp; p) :</div>
<div class="line">  density(<span class="stringliteral">&quot;Density&quot;</span>, p.get&lt; Teuchos::RCP&lt;PHX::DataLayout&gt; &gt;(<span class="stringliteral">&quot;Data Layout&quot;</span>) ),</div>
<div class="line">  temp(<span class="stringliteral">&quot;Temperature&quot;</span>, p.get&lt; Teuchos::RCP&lt;PHX::DataLayout&gt; &gt;(<span class="stringliteral">&quot;Data Layout&quot;</span>) )</div>
<div class="line">{ </div>
<div class="line">  this-&gt;addEvaluatedField(density);</div>
<div class="line">  this-&gt;addDependentField(temp);</div>
<div class="line">  this-&gt;setName(<span class="stringliteral">&quot;Density&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// **********************************************************************</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> EvalT, <span class="keyword">typename</span> Traits&gt;</div>
<div class="line"><span class="keywordtype">void</span> Density&lt;EvalT, Traits&gt;::</div>
<div class="line">postRegistrationSetup(<span class="keyword">typename</span> Traits::SetupData d,</div>
<div class="line">              <a class="code hl_class" href="classPHX_1_1FieldManager.html">PHX::FieldManager&lt;Traits&gt;</a>&amp; vm)</div>
<div class="line">{</div>
<div class="line">  this-&gt;utils.setFieldData(density,vm);</div>
<div class="line">  this-&gt;utils.setFieldData(temp,vm);</div>
<div class="line"> </div>
<div class="line">  data_layout_size = density.fieldTag().dataLayout().size();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// **********************************************************************</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> EvalT, <span class="keyword">typename</span> Traits&gt;</div>
<div class="line"><span class="keywordtype">void</span> Density&lt;EvalT, Traits&gt;::evaluateFields(<span class="keyword">typename</span> Traits::EvalData d)</div>
<div class="line">{ </div>
<div class="line">  std::size_t size = d.num_cells * data_layout_size;</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; size; ++i)</div>
<div class="line">    density[i] =  temp[i] * temp[i];</div>
<div class="line">}</div>
</div><!-- fragment --><p>The constructor pulls out data from the parameter list to set the correct data layout. Additionally, it tells the FieldManager what fields it will evaluate and what fields it requires/depends on to perform the evaluation.</p>
<p>The postRegistrationSetup method gets pointers from the FieldManager to the array for storing data for each particular field.</p>
<p>Writing evaluators can be tedious. We have invested much time in minimizing the amount of code a user writes for a new evaluator. Our experience is that you can literally have hundreds of evaluators. So we have added macros to hide the boilerplate code in each evaluator. Not only does this streamline/condense the code, but it also hides much of the templating. So if your user base is uncomfortable with C++ templates, the macro definitions could be very helpful. The definitions are found in the file Phalanx_Evaluator_Macros.hpp. The same evaluator shown above is now implemented using the macro definitions:</p>
<p>Class declaration: </p><div class="fragment"><div class="line"><span class="preprocessor">#ifndef PHX_EXAMPLE_VP_DENSITY_HPP</span></div>
<div class="line"><span class="preprocessor">#define PHX_EXAMPLE_VP_DENSITY_HPP</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;Phalanx_Evaluator_Macros.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Phalanx_Field.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line">PHX_EVALUATOR_CLASS(Density)</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> constant;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classPHX_1_1Field.html">PHX::Field&lt;ScalarT&gt;</a> density;</div>
<div class="line">  <a class="code hl_class" href="classPHX_1_1Field.html">PHX::Field&lt;ScalarT&gt;</a> temp;</div>
<div class="line"> </div>
<div class="line">  std::size_t data_layout_size;</div>
<div class="line"> </div>
<div class="line">PHX_EVALUATOR_CLASS_END</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;Evaluator_Density_Def.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p>Class definition: </p><div class="fragment"><div class="line"><span class="comment">//**********************************************************************</span></div>
<div class="line">PHX_EVALUATOR_CTOR(Density,p) :</div>
<div class="line">  density(<span class="stringliteral">&quot;Density&quot;</span>, p.get&lt; Teuchos::RCP&lt;PHX::DataLayout&gt; &gt;(<span class="stringliteral">&quot;Data Layout&quot;</span>) ),</div>
<div class="line">  temp(<span class="stringliteral">&quot;Temperature&quot;</span>, p.get&lt; Teuchos::RCP&lt;PHX::DataLayout&gt; &gt;(<span class="stringliteral">&quot;Data Layout&quot;</span>) )</div>
<div class="line">{ </div>
<div class="line">  this-&gt;addEvaluatedField(density);</div>
<div class="line">  this-&gt;addDependentField(temp);</div>
<div class="line">  this-&gt;setName(<span class="stringliteral">&quot;Density&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">//**********************************************************************</span></div>
<div class="line">PHX_POST_REGISTRATION_SETUP(Density,data,fm)</div>
<div class="line">{</div>
<div class="line">  this-&gt;utils.setFieldData(density,fm);</div>
<div class="line">  this-&gt;utils.setFieldData(temp,fm);</div>
<div class="line"> </div>
<div class="line">  data_layout_size = density.fieldTag().dataLayout().size();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">//**********************************************************************</span></div>
<div class="line">PHX_EVALUATE_FIELDS(Density,d)</div>
<div class="line">{ </div>
<div class="line">  std::size_t size = d.num_cells * data_layout_size;</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; size; ++i)</div>
<div class="line">    density[i] =  temp[i] * temp[i];</div>
<div class="line">}</div>
</div><!-- fragment --><p>The evaluators for the example problem in "phalanx/example/EnergyFlux" have been rewritten using the macro definitions and can be found in the directory "phalanx/test/Utilities/evaluators". <br  />
</p>
<p>Finally, since writing even the above code contains much boilerplate, we have written a python script that will generate the above skeleton files for you. All you need provide is the class name and the filename. The script is called phalanx_create_evaluator.py and can be found in the "scripts" directory. A "make install" will place the script in the "bin" directory. To generate a skeleton for the above function, you would execute the following command at the prompt:</p>
<div class="fragment"><div class="line">&gt; ./phalanx_create_evaluator.py -c -n Density Evaluator_Density</div>
</div><!-- fragment --><h1><a class="anchor" id="user_guide_step6"></a>
Step 6: Implement the FieldManager in your code</h1>
<p>Adding the FieldManager to your code is broken into steps. You must build each Evaluator for each field type, register the evaluators with the FieldManager, and then call the evaluate routines. Continuing from our example:</p>
<h2><a class="anchor" id="fmd1"></a>
A. Building your Evaluators</h2>
<p>Users can build their own Evaluators and register them with the FieldManager or they can use our automated factory, <a class="el" href="classPHX_1_1EvaluatorFactory.html">PHX::EvaluatorFactory</a> to handle this for them. Normally, users will want to build an evaluator for each evaluation type. The factory makes this very easy. Additionally, you are not restricted to using the automated factory for every Evaluator. You can selectively use the automated factory where convenient. The next two sections describe how to build the evaluators.</p>
<h3><a class="anchor" id="fmd1s1"></a>
A.1 Building and Registering Evaluators Manually.</h3>
<p>To build an Evaluator manually, all you need to do is allocate the Evaluator on the heap using a reference counted smart pointer (Teuchos::RCP) to point ot the object. This will ensure proper memory management of the object. Here is an example of code to build a Density evaluator for each evaluation type and register it with the corresponding manager.</p>
<div class="fragment"><div class="line"><span class="comment">// Create a FieldManager</span></div>
<div class="line">FieldManager&lt;MyTraits&gt; fm;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Constructor requirements</span></div>
<div class="line">RCP&lt;ParameterList&gt; p = rcp(<span class="keyword">new</span> ParameterList);</div>
<div class="line">p-&gt;set&lt; RCP&lt;DataLayout&gt; &gt;(<span class="stringliteral">&quot;Data Layout&quot;</span>, qp);</div>
<div class="line">     </div>
<div class="line"><span class="comment">// Residual</span></div>
<div class="line">Teuchos::RCP&lt; Density&lt;MyTraits::Residual,MyTraits&gt; &gt; residual_density = </div>
<div class="line">  Teuchos::rcp(<span class="keyword">new</span> Density&lt;MyTraits::Residual,MyTriats&gt;(p));</div>
<div class="line"> </div>
<div class="line">fm.registerEvaluator&lt;MyTraits::Residual&gt;(residual_density);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Jacobian</span></div>
<div class="line">Teuchos::RCP&lt; Density&lt;MyTraits::Jacobian,MyTraits&gt; &gt; jacobian_density = </div>
<div class="line">  Teuchos::rcp(<span class="keyword">new</span> Density&lt;MyTraits::Jacobian,MyTriats&gt;(p));</div>
<div class="line"> </div>
<div class="line">fm.registerEvaluator&lt;MyTraits::Residual&gt;(jacobian_density);</div>
</div><!-- fragment --><p>As one can see, this becomes very tedious if there are many evaluation types. It is much better to use the automated factory to build one for each evalaution type. Where this method is useful is if you are in a class already templated on the evaluation type, and would like to build and register an evaluator in that peice of code.</p>
<h3><a class="anchor" id="fmd1s2"></a>
A.2 Using the Automated Factory</h3>
<p>Phalanx provides an automated builder <a class="el" href="classPHX_1_1EvaluatorFactory.html">PHX::EvaluatorFactory</a> that will create an object of each evaluation type. The following requirements are placed on each and every Evaluator that a user writes if they plan to use the automated factory: </p><ol>
<li>
<p class="startli">The constructor of your Evaluator must take exactly one argument that is a Teuchos::ParamterList object. A Teuchos::ParameterList allows you to pass an arbitrary number of objects with arbitrary types.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">In the Teuchos::ParamterList, you must have one key called "Type" that is associated with an integer value that uniquely corresponds to an Evaluator object written by the user. This integer is defined in the users factory traits object described below.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The Evaluator must derive from the <a class="el" href="classPHX_1_1EvaluatorDerived.html">PHX::EvaluatorDerived</a> class as shown in the example above. This allows the variable manager to store a vector of base object pointers for each evaluation type in a single stl vector yet be able to return the derived class.</p>
<p class="endli"></p>
</li>
</ol>
<p>To build an <a class="el" href="classPHX_1_1EvaluatorFactory.html">PHX::EvaluatorFactory</a>, you must provide a factory traits class that gives the factory a list of its evaluator types. An example of the factory traits class is the FactoryTraits object in the file FactoryTraits.hpp:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef EXAMPLE_FACTORY_TRAITS_HPP</span></div>
<div class="line"><span class="preprocessor">#define EXAMPLE_FACTORY_TRAITS_HPP</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// mpl (Meta Programming Library) templates</span></div>
<div class="line"><span class="preprocessor">#include &quot;Sacado_mpl_vector.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// User Defined Evaluator Types</span></div>
<div class="line"><span class="preprocessor">#include &quot;Evaluator_Constant.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Evaluator_Density.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Evaluator_EnergyFlux_Fourier.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Evaluator_FEInterpolation.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Evaluator_NonlinearSource.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;Sacado_mpl_placeholders.hpp&quot;</span></div>
<div class="line"><span class="keyword">using namespace </span>Sacado::mpl::placeholders;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Traits&gt;</div>
<div class="line"><span class="keyword">struct </span>MyFactoryTraits {</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> id_constant = 0;</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> id_density = 1;</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> id_fourier = 2;</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> id_feinterpolation = 3;</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> id_nonlinearsource = 4;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">typedef</span> Sacado::mpl::vector&lt; Constant&lt;_,Traits&gt;,             <span class="comment">// 0</span></div>
<div class="line">                   Density&lt;_,Traits&gt;,              <span class="comment">// 1</span></div>
<div class="line">                   Fourier&lt;_,Traits&gt;,              <span class="comment">// 2</span></div>
<div class="line">                   FEInterpolation&lt;_,Traits&gt;,      <span class="comment">// 3</span></div>
<div class="line">                   NonlinearSource&lt;_,Traits&gt;       <span class="comment">// 4</span></div>
<div class="line">  &gt; EvaluatorTypes;</div>
<div class="line"> </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p>Since the factory is built at compile time, we need to link a run-time choice to the compile-time list of object types. Thus the user must provide the static const int identifiers that are unique for each type that can be constructed. Users can ignore the "_" argument in the mpl vector. This is a placeholder argument that allows us to iterate over and instert each evaluation type into the factory traits.</p>
<p>Now let's build the evaluators. The following code can be found in the Example.cpp file in the directory "phalanx/example/EnergyFlux". We create a ParameterList for each evaluator and call the factory constructor. Since we are using the factory, we need to specify the "Type" argument set to the integer of the corresponding Evaluator in the factory traits that we wish to build:</p>
<div class="fragment"><div class="line">  RCP&lt;DataLayout&gt; qp = rcp(<span class="keyword">new</span> FlatLayout(<span class="stringliteral">&quot;QP&quot;</span>, 4));</div>
<div class="line">  RCP&lt;DataLayout&gt; node = rcp(<span class="keyword">new</span> FlatLayout(<span class="stringliteral">&quot;NODE&quot;</span>, 4));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Parser will build parameter list that determines the field</span></div>
<div class="line">  <span class="comment">// evaluators to build</span></div>
<div class="line">  map&lt;string, RCP&lt;ParameterList&gt; &gt; evaluators_to_build;</div>
<div class="line">  </div>
<div class="line">  { <span class="comment">// Temperature</span></div>
<div class="line">RCP&lt;ParameterList&gt; p = rcp(<span class="keyword">new</span> ParameterList);</div>
<div class="line"><span class="keywordtype">int</span> type = MyFactoryTraits&lt;MyTraits&gt;::id_constant;</div>
<div class="line">p-&gt;set&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;Type&quot;</span>, type);</div>
<div class="line">p-&gt;set&lt;<span class="keywordtype">string</span>&gt;(<span class="stringliteral">&quot;Name&quot;</span>, <span class="stringliteral">&quot;Temperature&quot;</span>);</div>
<div class="line">p-&gt;set&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;Value&quot;</span>, 2.0);</div>
<div class="line">p-&gt;set&lt; RCP&lt;DataLayout&gt; &gt;(<span class="stringliteral">&quot;Data Layout&quot;</span>, node);</div>
<div class="line">evaluators_to_build[<span class="stringliteral">&quot;DOF_Temperature&quot;</span>] = p;</div>
<div class="line">  }</div>
<div class="line">  { <span class="comment">// Density</span></div>
<div class="line">RCP&lt;ParameterList&gt; p = rcp(<span class="keyword">new</span> ParameterList);</div>
<div class="line"><span class="keywordtype">int</span> type = MyFactoryTraits&lt;MyTraits&gt;::id_density;</div>
<div class="line">p-&gt;set&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;Type&quot;</span>, type);</div>
<div class="line">p-&gt;set&lt; RCP&lt;DataLayout&gt; &gt;(<span class="stringliteral">&quot;Data Layout&quot;</span>, qp);</div>
<div class="line">evaluators_to_build[<span class="stringliteral">&quot;Density&quot;</span>] = p;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  { <span class="comment">// Constant Thermal Conductivity</span></div>
<div class="line">RCP&lt;ParameterList&gt; p = rcp(<span class="keyword">new</span> ParameterList);</div>
<div class="line"><span class="keywordtype">int</span> type = MyFactoryTraits&lt;MyTraits&gt;::id_constant;</div>
<div class="line">p-&gt;set&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;Type&quot;</span>, type);</div>
<div class="line">p-&gt;set&lt;<span class="keywordtype">string</span>&gt;(<span class="stringliteral">&quot;Name&quot;</span>, <span class="stringliteral">&quot;Thermal Conductivity&quot;</span>);</div>
<div class="line">p-&gt;set&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;Value&quot;</span>, 2.0);</div>
<div class="line">p-&gt;set&lt; RCP&lt;DataLayout&gt; &gt;(<span class="stringliteral">&quot;Data Layout&quot;</span>, qp);</div>
<div class="line">evaluators_to_build[<span class="stringliteral">&quot;Thermal Conductivity&quot;</span>] = p;</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  { <span class="comment">// Nonlinear Source</span></div>
<div class="line">RCP&lt;ParameterList&gt; p = rcp(<span class="keyword">new</span> ParameterList);</div>
<div class="line"><span class="keywordtype">int</span> type = MyFactoryTraits&lt;MyTraits&gt;::id_nonlinearsource;</div>
<div class="line">p-&gt;set&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;Type&quot;</span>, type);</div>
<div class="line">p-&gt;set&lt; RCP&lt;DataLayout&gt; &gt;(<span class="stringliteral">&quot;Data Layout&quot;</span>, qp);</div>
<div class="line">evaluators_to_build[<span class="stringliteral">&quot;Nonlinear Source&quot;</span>] = p;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  { <span class="comment">// Fourier Energy Flux</span></div>
<div class="line">RCP&lt;ParameterList&gt; p = rcp(<span class="keyword">new</span> ParameterList);</div>
<div class="line"><span class="keywordtype">int</span> type = MyFactoryTraits&lt;MyTraits&gt;::id_fourier;</div>
<div class="line">p-&gt;set&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;Type&quot;</span>, type);</div>
<div class="line">p-&gt;set&lt; RCP&lt;DataLayout&gt; &gt;(<span class="stringliteral">&quot;Data Layout&quot;</span>, qp);</div>
<div class="line">evaluators_to_build[<span class="stringliteral">&quot;Energy Flux&quot;</span>] = p;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  { <span class="comment">// FE Interpolation</span></div>
<div class="line">RCP&lt;ParameterList&gt; p = rcp(<span class="keyword">new</span> ParameterList);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> type = MyFactoryTraits&lt;MyTraits&gt;::id_feinterpolation;</div>
<div class="line">p-&gt;set&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;Type&quot;</span>, type);</div>
<div class="line"> </div>
<div class="line">p-&gt;set&lt;<span class="keywordtype">string</span>&gt;(<span class="stringliteral">&quot;Node Variable Name&quot;</span>, <span class="stringliteral">&quot;Temperature&quot;</span>);</div>
<div class="line">p-&gt;set&lt;<span class="keywordtype">string</span>&gt;(<span class="stringliteral">&quot;QP Variable Name&quot;</span>, <span class="stringliteral">&quot;Temperature&quot;</span>);</div>
<div class="line">p-&gt;set&lt;<span class="keywordtype">string</span>&gt;(<span class="stringliteral">&quot;Gradient QP Variable Name&quot;</span>, <span class="stringliteral">&quot;Temperature Gradient&quot;</span>);</div>
<div class="line"> </div>
<div class="line">p-&gt;set&lt; RCP&lt;DataLayout&gt; &gt;(<span class="stringliteral">&quot;Node Data Layout&quot;</span>, node);</div>
<div class="line">p-&gt;set&lt; RCP&lt;DataLayout&gt; &gt;(<span class="stringliteral">&quot;QP Data Layout&quot;</span>, qp);</div>
<div class="line"> </div>
<div class="line">evaluators_to_build[<span class="stringliteral">&quot;FE Interpolation&quot;</span>] = p;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Build Field Evaluators for each evaluation type</span></div>
<div class="line">  EvaluatorFactory&lt;MyTraits,MyFactoryTraits&lt;MyTraits&gt; &gt; factory;</div>
<div class="line">  RCP&lt; vector&lt; RCP&lt;Evaluator_TemplateManager&lt;MyTraits&gt; &gt; &gt; &gt; </div>
<div class="line">evaluators;</div>
<div class="line">  evaluators = factory.buildEvaluators(evaluators_to_build);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a FieldManager</span></div>
<div class="line">  FieldManager&lt;MyTraits&gt; fm;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Register all Evaluators </span></div>
<div class="line">  registerEvaluators(evaluators, fm);</div>
</div><!-- fragment --><p>The map "evaluators_to_build" has a key of type "std::string". This key is irrelevant to the execution of the code. It is an identifer that can help users debug code or search for a specific provider in the list. What you put in the key is for your own use.</p>
<p>You are free to register evaluators until the time you call the method postRegistrationSetup() on the field manager. Once this is called, you can not register any more evaluators. You can make multiple registration calls to add more providers - there is no limit on the number of calls.</p>
<h2><a class="anchor" id="fmd2"></a>
B. Request which Fields to Evaluate</h2>
<p>You must tell the FieldManager which quantities it should evaluate. This step can occur before, after, or in-between the registration of Evaluators. You must request variables separately for each evaluation type. This is required since since data types can exist in multiple evaluation types.</p>
<div class="fragment"><div class="line">  <span class="comment">// Request quantities to assemble RESIDUAL PDE operators</span></div>
<div class="line">  {</div>
<div class="line"><span class="keyword">typedef</span> MyTraits::Residual::ScalarT ResScalarT;</div>
<div class="line"> </div>
<div class="line">Tag&lt; MyVector&lt;ResScalarT&gt; &gt; energy_flux(<span class="stringliteral">&quot;Energy_Flux&quot;</span>, qp);</div>
<div class="line">fm.requireField&lt;MyTraits::Residual&gt;(energy_flux);</div>
<div class="line"> </div>
<div class="line">Tag&lt;ResScalarT&gt; source(<span class="stringliteral">&quot;Nonlinear Source&quot;</span>, qp);</div>
<div class="line">fm.requireField&lt;MyTraits::Residual&gt;(source);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Request quantities to assemble JACOBIAN PDE operators</span></div>
<div class="line">  {</div>
<div class="line"><span class="keyword">typedef</span> MyTraits::Jacobian::ScalarT JacScalarT;</div>
<div class="line"> </div>
<div class="line">Tag&lt; MyVector&lt;JacScalarT&gt; &gt; energy_flux(<span class="stringliteral">&quot;Energy_Flux&quot;</span>, qp);</div>
<div class="line">fm.requireField&lt;MyTraits::Jacobian&gt;(energy_flux);</div>
<div class="line"> </div>
<div class="line">Tag&lt;JacScalarT&gt; source(<span class="stringliteral">&quot;Nonlinear Source&quot;</span>, qp);</div>
<div class="line">fm.requireField&lt;MyTraits::Jacobian&gt;(source);</div>
<div class="line">  }</div>
</div><!-- fragment --><p>You are free to request fields to evaluate until the time you call the method postRegistrationSetup() on the field manager. Once this is called, you can not request any more fields.</p>
<h2><a class="anchor" id="fmd3"></a>
C. Call FieldManager::postRegistrationSetup()</h2>
<p>Once the evaluators are registered with the FieldManager and it knows which field it needs to provide, call the postRegistrationSetup() method on the FieldManager. This method requires that the user specify the maximum number of cells for each evaluation - the workset size. This number should be selected so that all fields can fit in the cache of the processor if possible. <br  />
</p>
<div class="fragment"><div class="line"><span class="comment">// Assume we have 102 cells on processor and can fit 20 cells in cache</span></div>
<div class="line"><span class="keyword">const</span> std::size_t num_local_cells = 102;</div>
<div class="line"><span class="keyword">const</span> std::size_t workset_size = 20;</div>
<div class="line"> </div>
<div class="line">fm.postRegistrationSetup(workset_size);</div>
</div><!-- fragment --><p>The postRegistrationSetup() method causes the following actions to take place in the FieldManager:</p>
<ol>
<li>
Based on the requested fields in <a class="el" href="user_guide.html#fmd2">B. Request which Fields to Evaluate</a>, the FieldManager will trace through the evaluators to determine which evaluators to call and the order in which they need to be called to achieve a consistent evaluation. Not all evaluators that are registered will be used. They will only be called to satisfy dependencies of the required fields. </li>
<li>
Once the dependency chain is known, we can pull together a flat list of all fields that will be used. Now the FieldManager will allocate memory to store all fields. It will use the Allocator object from the users traits class to accomplish this. By unifying the allocation into a single object, we can force all fields to be allocated in a single contiguous block of memory if desired. </li>
<li>
Once the memory for field data is allocated, we must set the pointer to that memory block inside each Field or MDField object in each evaluator. The FieldManager does this by calling the postRegistrationSetup() method on each evaluator that is required for the computation. </li>
</ol>
<p>Note: you can no longer register evaluators or request fields to evaluate once postRegistrationSetup() method is called.</p>
<h2><a class="anchor" id="fmd6"></a>
D. Setup Worksets</h2>
<p>If the user plans to use worksets, these objects are typically passed in through the member of the evaluate call as defined in your traits class. In our example, we chose to pass a user defined class called a MyWorkset in to the evaluate call. Since we plan to use worksets, each object of MyWorkset contains information about the workset. Here is the MyWorkset implementation:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef PHX_EXAMPLE_MY_WORKSET_HPP</span></div>
<div class="line"><span class="preprocessor">#define PHX_EXAMPLE_MY_WORKSET_HPP</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;Phalanx_config.hpp&quot;</span> <span class="comment">// for std::vector</span></div>
<div class="line"><span class="preprocessor">#include &quot;Cell.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>MyWorkset {</div>
<div class="line">  </div>
<div class="line">  std::size_t local_offset;</div>
<div class="line"> </div>
<div class="line">  std::size_t num_cells;</div>
<div class="line">  </div>
<div class="line">  std::vector&lt;MyCell&gt;::iterator begin;</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;MyCell&gt;::iterator end;</div>
<div class="line"> </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p>The user has written a MyCell class that contains data for each specific local cell. MyWorkset contains iterators to the beginning and end of the chunk of cells for this particular workset. The local_offset is the starting index into the local cell array. The num_cells is the number of cells in the workset. The MyWorkset objects are created one for each workset via the following code:</p>
<div class="fragment"><div class="line">  <span class="comment">// Create Workset information: Cells and EvalData objects</span></div>
<div class="line">  std::vector&lt;MyCell&gt; cells(num_local_cells);</div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; cells.size(); ++i)</div>
<div class="line">cells[i].setLocalIndex(i);</div>
<div class="line">  std::vector&lt;MyWorkset&gt; worksets;</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;MyCell&gt;::iterator cell_it = cells.begin();</div>
<div class="line">  std::size_t count = 0;</div>
<div class="line">  MyWorkset w;</div>
<div class="line">  w.local_offset = cell_it-&gt;localIndex();</div>
<div class="line">  w.begin = cell_it;</div>
<div class="line">  <span class="keywordflow">for</span> (; cell_it != cells.end(); ++cell_it) {</div>
<div class="line">++count;</div>
<div class="line">std::vector&lt;MyCell&gt;::iterator next = cell_it;</div>
<div class="line">++next;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> ( count == workset_size || next == cells.end()) {</div>
<div class="line">  w.end = next;</div>
<div class="line">  w.num_cells = count;</div>
<div class="line">  worksets.push_back(w);</div>
<div class="line">  count = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (next != cells.end()) {</div>
<div class="line">    w.local_offset = next-&gt;localIndex();</div>
<div class="line">    w.begin = next;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Note that you do not have to use the workset idea. You could just pass in workset size equal to the number of local cells on the processor or you could use a workset size of one cell and wrap the evaluate call in a loop over the number of cells. Be aware that this can result in a possible performance hit.</p>
<h2><a class="anchor" id="fmd4"></a>
E. Call evaluate()</h2>
<p>Finally, users can call the evlauate routines and the pre/post evaluate routines if required.</p>
<div class="fragment"><div class="line">  fm.preEvaluate&lt;MyTraits::Residual&gt;(NULL);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Process all local cells on processor by looping over worksets</span></div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; worksets.size(); ++i) {</div>
<div class="line"> </div>
<div class="line">fm.evaluateFields&lt;MyTraits::Residual&gt;(worksets[i]);</div>
<div class="line">  </div>
<div class="line"><span class="comment">// Use workset values</span></div>
<div class="line">            .</div>
<div class="line">            .</div>
<div class="line">            .</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  fm.postEvaluate&lt;MyTraits::Residual&gt;(NULL);</div>
</div><!-- fragment --><h2><a class="anchor" id="fmd5"></a>
F. Accessing Data</h2>
<p>Accessing field data is achieved as follows:</p>
<div class="fragment"><div class="line">Field&lt; MyVector&lt;double&gt; &gt; ef(<span class="stringliteral">&quot;Energy_Flux&quot;</span>, qp);</div>
<div class="line"> </div>
<div class="line">fm.getFieldData&lt;MyVector&lt;double&gt;,MyTraits::Residual&gt;(ef);</div>
</div><!-- fragment --><p>You do not need to use the Field objects to access field data. You can get the reference counted smart pointer to the data array directly by using the field tag:</p>
<div class="fragment"><div class="line">RCP&lt;DataLayout&gt; qp = rcp(<span class="keyword">new</span> FlatLayout(<span class="stringliteral">&quot;QP&quot;</span>, 4));</div>
<div class="line"><a class="code hl_class" href="classPHX_1_1FieldTag.html">PHX::FieldTag&lt;double&gt;</a> s(<span class="stringliteral">&quot;Nonlinear Source&quot;</span>, qp);</div>
<div class="line">Teuchos::ArrayRCP&lt;double&gt; source_values;</div>
<div class="line">fm.getFieldData&lt;double,MyTraits::Residual&gt;(s,source_values);</div>
<div class="ttc" id="aclassPHX_1_1FieldTag_html"><div class="ttname"><a href="classPHX_1_1FieldTag.html">PHX::FieldTag</a></div><div class="ttdef"><b>Definition</b> Phalanx_FieldTag.hpp:24</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 9 2025 20:47:12 for Phalanx by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
