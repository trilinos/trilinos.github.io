<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stokhos: Belos::PseudoBlockGmresIter&lt; Sacado::MP::Vector&lt; Storage &gt;, MV, OP &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Stokhos<span id="projectnumber">&#160;Development</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Belos</b></li><li class="navelem"><a class="el" href="classBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4.html">PseudoBlockGmresIter&lt; Sacado::MP::Vector&lt; Storage &gt;, MV, OP &gt;</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="classBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Belos::PseudoBlockGmresIter&lt; Sacado::MP::Vector&lt; Storage &gt;, MV, OP &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for Belos::PseudoBlockGmresIter&lt; Sacado::MP::Vector&lt; Storage &gt;, MV, OP &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4__inherit__graph.gif" border="0" usemap="#aBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4_inherit__map" id="aBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4_inherit__map">
<area shape="rect" title=" " alt="" coords="5,108,232,163"/>
<area shape="rect" title=" " alt="" coords="41,5,197,60"/>
<area shape="poly" title=" " alt="" coords="121,74,121,108,116,108,116,74"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Belos::PseudoBlockGmresIter&lt; Sacado::MP::Vector&lt; Storage &gt;, MV, OP &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4__coll__graph.gif" border="0" usemap="#aBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4_coll__map" id="aBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4_coll__map">
<area shape="rect" title=" " alt="" coords="5,108,232,163"/>
<area shape="rect" title=" " alt="" coords="41,5,197,60"/>
<area shape="poly" title=" " alt="" coords="121,74,121,108,116,108,116,74"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3487be53d79995038ca89167e24027fc" id="r_a3487be53d79995038ca89167e24027fc"><td class="memItemLeft" align="right" valign="top"><a id="a3487be53d79995038ca89167e24027fc" name="a3487be53d79995038ca89167e24027fc"></a>
typedef <a class="el" href="classSacado_1_1MP_1_1Vector.html">Sacado::MP::Vector</a>&lt; Storage &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ScalarType</b></td></tr>
<tr class="separator:a3487be53d79995038ca89167e24027fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77da2b3166c51d71f2eece0e94291b32" id="r_a77da2b3166c51d71f2eece0e94291b32"><td class="memItemLeft" align="right" valign="top"><a id="a77da2b3166c51d71f2eece0e94291b32" name="a77da2b3166c51d71f2eece0e94291b32"></a>
typedef MultiVecTraits&lt; <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a>, MV &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MVT</b></td></tr>
<tr class="separator:a77da2b3166c51d71f2eece0e94291b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e9c8e82c20ffd3c6bf94044365b5ed" id="r_ad7e9c8e82c20ffd3c6bf94044365b5ed"><td class="memItemLeft" align="right" valign="top"><a id="ad7e9c8e82c20ffd3c6bf94044365b5ed" name="ad7e9c8e82c20ffd3c6bf94044365b5ed"></a>
typedef OperatorTraits&lt; <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a>, MV, OP &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>OPT</b></td></tr>
<tr class="separator:ad7e9c8e82c20ffd3c6bf94044365b5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd60234e3535641be3fcf4babaea716" id="r_abfd60234e3535641be3fcf4babaea716"><td class="memItemLeft" align="right" valign="top"><a id="abfd60234e3535641be3fcf4babaea716" name="abfd60234e3535641be3fcf4babaea716"></a>
typedef Teuchos::ScalarTraits&lt; <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SCT</b></td></tr>
<tr class="separator:abfd60234e3535641be3fcf4babaea716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0ba6a93e01dad97ab07d6e293a3cee" id="r_a4f0ba6a93e01dad97ab07d6e293a3cee"><td class="memItemLeft" align="right" valign="top"><a id="a4f0ba6a93e01dad97ab07d6e293a3cee" name="a4f0ba6a93e01dad97ab07d6e293a3cee"></a>
typedef SCT::magnitudeType&#160;</td><td class="memItemRight" valign="bottom"><b>MagnitudeType</b></td></tr>
<tr class="separator:a4f0ba6a93e01dad97ab07d6e293a3cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83811d7338b0ef53f56cc3172954352" id="r_af83811d7338b0ef53f56cc3172954352"><td class="memItemLeft" align="right" valign="top"><a id="af83811d7338b0ef53f56cc3172954352" name="af83811d7338b0ef53f56cc3172954352"></a>
typedef Teuchos::ScalarTraits&lt; typename Storage::value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SVT</b></td></tr>
<tr class="separator:af83811d7338b0ef53f56cc3172954352"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors/Destructor</div></td></tr>
<tr class="memitem:a2590f6b01af36487d7882c012e27870a" id="r_a2590f6b01af36487d7882c012e27870a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4.html#a2590f6b01af36487d7882c012e27870a">PseudoBlockGmresIter</a> (const Teuchos::RCP&lt; LinearProblem&lt; <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a>, MV, OP &gt; &gt; &amp;problem, const Teuchos::RCP&lt; OutputManager&lt; <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a> &gt; &gt; &amp;printer, const Teuchos::RCP&lt; StatusTest&lt; <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a>, MV, OP &gt; &gt; &amp;tester, const Teuchos::RCP&lt; MatOrthoManager&lt; <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a>, MV, OP &gt; &gt; &amp;ortho, Teuchos::ParameterList &amp;params)</td></tr>
<tr class="memdesc:a2590f6b01af36487d7882c012e27870a"><td class="mdescLeft">&#160;</td><td class="mdescRight">PseudoBlockGmresIter constructor with linear problem, solver utilities, and parameter list of solver options.  <br /></td></tr>
<tr class="separator:a2590f6b01af36487d7882c012e27870a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70899a64f99aaeaf651bf0c606aa5308" id="r_a70899a64f99aaeaf651bf0c606aa5308"><td class="memItemLeft" align="right" valign="top"><a id="a70899a64f99aaeaf651bf0c606aa5308" name="a70899a64f99aaeaf651bf0c606aa5308"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~PseudoBlockGmresIter</b> ()=default</td></tr>
<tr class="memdesc:a70899a64f99aaeaf651bf0c606aa5308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a70899a64f99aaeaf651bf0c606aa5308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Solver methods</div></td></tr>
<tr class="memitem:a3cfb3f8114c57233ee6cea4d651c8dfb" id="r_a3cfb3f8114c57233ee6cea4d651c8dfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4.html#a3cfb3f8114c57233ee6cea4d651c8dfb">iterate</a> ()</td></tr>
<tr class="memdesc:a3cfb3f8114c57233ee6cea4d651c8dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method performs block Gmres iterations until the status test indicates the need to stop or an error occurs (in which case, an std::exception is thrown).  <br /></td></tr>
<tr class="separator:a3cfb3f8114c57233ee6cea4d651c8dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa4fdfe591a36ea1365ae3796825d4e" id="r_abfa4fdfe591a36ea1365ae3796825d4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4.html#abfa4fdfe591a36ea1365ae3796825d4e">initialize</a> (const PseudoBlockGmresIterState&lt; <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a>, MV &gt; &amp;newstate)</td></tr>
<tr class="memdesc:abfa4fdfe591a36ea1365ae3796825d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the solver to an iterate, providing a complete state.  <br /></td></tr>
<tr class="separator:abfa4fdfe591a36ea1365ae3796825d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e72d6bbe5e6788a061f82456cf3b72" id="r_ae0e72d6bbe5e6788a061f82456cf3b72"><td class="memItemLeft" align="right" valign="top"><a id="ae0e72d6bbe5e6788a061f82456cf3b72" name="ae0e72d6bbe5e6788a061f82456cf3b72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initialize</b> ()</td></tr>
<tr class="memdesc:ae0e72d6bbe5e6788a061f82456cf3b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the solver with the initial vectors from the linear problem or random data. <br /></td></tr>
<tr class="separator:ae0e72d6bbe5e6788a061f82456cf3b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba2ba5e4aaec28f6246743224c308de" id="r_a6ba2ba5e4aaec28f6246743224c308de"><td class="memItemLeft" align="right" valign="top">PseudoBlockGmresIterState&lt; <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a>, MV &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4.html#a6ba2ba5e4aaec28f6246743224c308de">getState</a> () const</td></tr>
<tr class="memdesc:a6ba2ba5e4aaec28f6246743224c308de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current state of the linear solver.  <br /></td></tr>
<tr class="separator:a6ba2ba5e4aaec28f6246743224c308de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Status methods</div></td></tr>
<tr class="memitem:acac11d21cc05d61ae888d8a088c4bd96" id="r_acac11d21cc05d61ae888d8a088c4bd96"><td class="memItemLeft" align="right" valign="top"><a id="acac11d21cc05d61ae888d8a088c4bd96" name="acac11d21cc05d61ae888d8a088c4bd96"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumIters</b> () const</td></tr>
<tr class="memdesc:acac11d21cc05d61ae888d8a088c4bd96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current iteration count. <br /></td></tr>
<tr class="separator:acac11d21cc05d61ae888d8a088c4bd96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ae925c4e7fd6b52e494f019d95d79d" id="r_a25ae925c4e7fd6b52e494f019d95d79d"><td class="memItemLeft" align="right" valign="top"><a id="a25ae925c4e7fd6b52e494f019d95d79d" name="a25ae925c4e7fd6b52e494f019d95d79d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resetNumIters</b> (int iter=0)</td></tr>
<tr class="memdesc:a25ae925c4e7fd6b52e494f019d95d79d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the iteration count. <br /></td></tr>
<tr class="separator:a25ae925c4e7fd6b52e494f019d95d79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28194e457a15b691a28934166c2e98d4" id="r_a28194e457a15b691a28934166c2e98d4"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const MV &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4.html#a28194e457a15b691a28934166c2e98d4">getNativeResiduals</a> (std::vector&lt; MagnitudeType &gt; *norms) const</td></tr>
<tr class="memdesc:a28194e457a15b691a28934166c2e98d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the norms of the "native" residual vectors.  <br /></td></tr>
<tr class="separator:a28194e457a15b691a28934166c2e98d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc80c9cd0e0d6636861eb047385cb91f" id="r_afc80c9cd0e0d6636861eb047385cb91f"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; MV &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4.html#afc80c9cd0e0d6636861eb047385cb91f">getCurrentUpdate</a> () const</td></tr>
<tr class="memdesc:afc80c9cd0e0d6636861eb047385cb91f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current update to the linear system.  <br /></td></tr>
<tr class="separator:afc80c9cd0e0d6636861eb047385cb91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5358f8d818c8d6a983536befe1eca15" id="r_ac5358f8d818c8d6a983536befe1eca15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4.html#ac5358f8d818c8d6a983536befe1eca15">updateLSQR</a> (int dim=-1)</td></tr>
<tr class="memdesc:ac5358f8d818c8d6a983536befe1eca15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for updating QR factorization of upper Hessenberg matrix.  <br /></td></tr>
<tr class="separator:ac5358f8d818c8d6a983536befe1eca15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10408146f8b3282f107331b5673301ca" id="r_a10408146f8b3282f107331b5673301ca"><td class="memItemLeft" align="right" valign="top"><a id="a10408146f8b3282f107331b5673301ca" name="a10408146f8b3282f107331b5673301ca"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getCurSubspaceDim</b> () const</td></tr>
<tr class="memdesc:a10408146f8b3282f107331b5673301ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimension of the search subspace used to generate the current solution to the linear problem. <br /></td></tr>
<tr class="separator:a10408146f8b3282f107331b5673301ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d9d399cf9eaae6f895cc6884160dc3" id="r_ac8d9d399cf9eaae6f895cc6884160dc3"><td class="memItemLeft" align="right" valign="top"><a id="ac8d9d399cf9eaae6f895cc6884160dc3" name="ac8d9d399cf9eaae6f895cc6884160dc3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getMaxSubspaceDim</b> () const</td></tr>
<tr class="memdesc:ac8d9d399cf9eaae6f895cc6884160dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum dimension allocated for the search subspace. <br /></td></tr>
<tr class="separator:ac8d9d399cf9eaae6f895cc6884160dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Accessor methods</h2></td></tr>
<tr class="memitem:a0cb745967e07e8053b2e8c8560185459" id="r_a0cb745967e07e8053b2e8c8560185459"><td class="memItemLeft" align="right" valign="top"><a id="a0cb745967e07e8053b2e8c8560185459" name="a0cb745967e07e8053b2e8c8560185459"></a>
const LinearProblem&lt; <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a>, MV, OP &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getProblem</b> () const</td></tr>
<tr class="memdesc:a0cb745967e07e8053b2e8c8560185459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a constant reference to the linear problem. <br /></td></tr>
<tr class="separator:a0cb745967e07e8053b2e8c8560185459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b04cbae86f307a32972ca30c8c56f89" id="r_a3b04cbae86f307a32972ca30c8c56f89"><td class="memItemLeft" align="right" valign="top"><a id="a3b04cbae86f307a32972ca30c8c56f89" name="a3b04cbae86f307a32972ca30c8c56f89"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getBlockSize</b> () const</td></tr>
<tr class="memdesc:a3b04cbae86f307a32972ca30c8c56f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the blocksize to be used by the iterative solver in solving this linear problem. <br /></td></tr>
<tr class="separator:a3b04cbae86f307a32972ca30c8c56f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8691ae2cb0b4add24d744d82a5d5fd88" id="r_a8691ae2cb0b4add24d744d82a5d5fd88"><td class="memItemLeft" align="right" valign="top"><a id="a8691ae2cb0b4add24d744d82a5d5fd88" name="a8691ae2cb0b4add24d744d82a5d5fd88"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setBlockSize</b> (int blockSize)</td></tr>
<tr class="memdesc:a8691ae2cb0b4add24d744d82a5d5fd88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the blocksize. <br /></td></tr>
<tr class="separator:a8691ae2cb0b4add24d744d82a5d5fd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce3d383f9b6d859300761e4dea34b90" id="r_a1ce3d383f9b6d859300761e4dea34b90"><td class="memItemLeft" align="right" valign="top"><a id="a1ce3d383f9b6d859300761e4dea34b90" name="a1ce3d383f9b6d859300761e4dea34b90"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumBlocks</b> () const</td></tr>
<tr class="memdesc:a1ce3d383f9b6d859300761e4dea34b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of blocks used by the iterative solver in solving this linear problem. <br /></td></tr>
<tr class="separator:a1ce3d383f9b6d859300761e4dea34b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab393fc71e47ae60f839a2a6f199e6201" id="r_ab393fc71e47ae60f839a2a6f199e6201"><td class="memItemLeft" align="right" valign="top"><a id="ab393fc71e47ae60f839a2a6f199e6201" name="ab393fc71e47ae60f839a2a6f199e6201"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setNumBlocks</b> (int numBlocks)</td></tr>
<tr class="memdesc:ab393fc71e47ae60f839a2a6f199e6201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of blocks used by the iterative solver. <br /></td></tr>
<tr class="separator:ab393fc71e47ae60f839a2a6f199e6201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace069d39503d538affa5abdd72389e94" id="r_ace069d39503d538affa5abdd72389e94"><td class="memItemLeft" align="right" valign="top"><a id="ace069d39503d538affa5abdd72389e94" name="ace069d39503d538affa5abdd72389e94"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInitialized</b> ()</td></tr>
<tr class="memdesc:ace069d39503d538affa5abdd72389e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">States whether the solver has been initialized or not. <br /></td></tr>
<tr class="separator:ace069d39503d538affa5abdd72389e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2590f6b01af36487d7882c012e27870a" name="a2590f6b01af36487d7882c012e27870a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2590f6b01af36487d7882c012e27870a">&#9670;&#160;</a></span>PseudoBlockGmresIter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Storage , class MV , class OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBelos_1_1PseudoBlockGmresIter.html">Belos::PseudoBlockGmresIter</a>&lt; <a class="el" href="classSacado_1_1MP_1_1Vector.html">Sacado::MP::Vector</a>&lt; Storage &gt;, MV, OP &gt;<a class="el" href="classBelos_1_1PseudoBlockGmresIter.html">::PseudoBlockGmresIter</a> </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::RCP&lt; LinearProblem&lt; <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a>, MV, OP &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::RCP&lt; OutputManager&lt; <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::RCP&lt; StatusTest&lt; <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a>, MV, OP &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tester</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::RCP&lt; MatOrthoManager&lt; <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a>, MV, OP &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ortho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PseudoBlockGmresIter constructor with linear problem, solver utilities, and parameter list of solver options. </p>
<p>This constructor takes pointers required by the linear solver, in addition to a parameter list of options for the linear solver. These options include the following:</p><ul>
<li>"Block Size" - an <code>int</code> specifying the block size used by the algorithm. This can also be specified using the <a class="el" href="classBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4.html#a8691ae2cb0b4add24d744d82a5d5fd88" title="Set the blocksize.">setBlockSize()</a> method. Default: 1</li>
<li>"Num Blocks" - an <code>int</code> specifying the maximum number of blocks allocated for the solver basis. Default: 25</li>
<li>"Restart Timers" = a <code>bool</code> specifying whether the timers should be restarted each time <a class="el" href="classBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4.html#a3cfb3f8114c57233ee6cea4d651c8dfb" title="This method performs block Gmres iterations until the status test indicates the need to stop or an er...">iterate()</a> is called. Default: false </li>
</ul>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afc80c9cd0e0d6636861eb047385cb91f" name="afc80c9cd0e0d6636861eb047385cb91f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc80c9cd0e0d6636861eb047385cb91f">&#9670;&#160;</a></span>getCurrentUpdate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Storage , class MV , class OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; MV &gt; <a class="el" href="classBelos_1_1PseudoBlockGmresIter.html">Belos::PseudoBlockGmresIter</a>&lt; <a class="el" href="classSacado_1_1MP_1_1Vector.html">Sacado::MP::Vector</a>&lt; Storage &gt;, MV, OP &gt;::getCurrentUpdate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current update to the linear system. </p>
<dl class="section note"><dt>Note</dt><dd>Some solvers, like GMRES, do not compute updates to the solution every iteration. This method forces its computation. Other solvers, like CG, update the solution each iteration, so this method will return a zero vector indicating that the linear problem contains the current solution. </dd></dl>

</div>
</div>
<a id="a28194e457a15b691a28934166c2e98d4" name="a28194e457a15b691a28934166c2e98d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28194e457a15b691a28934166c2e98d4">&#9670;&#160;</a></span>getNativeResiduals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Storage , class MV , class OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const MV &gt; <a class="el" href="classBelos_1_1PseudoBlockGmresIter.html">Belos::PseudoBlockGmresIter</a>&lt; <a class="el" href="classSacado_1_1MP_1_1Vector.html">Sacado::MP::Vector</a>&lt; Storage &gt;, MV, OP &gt;::getNativeResiduals </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; MagnitudeType &gt; *&#160;</td>
          <td class="paramname"><em>norms</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the norms of the "native" residual vectors. </p>
<p>If norms != NULL, fill *norms with the native residual norms. There are numRHS_ of them. *norms will be resized if it has too few entries to hold the data.</p>
<p>For an explanation of "native" vs. "exact" (also known as "implicit" vs. "explicit") residuals, see the documentation of <code>PseudoBlockGmresSolMgr::isLOADetected()</code>. In brief: "Native" residuals are cheaper to compute than "exact" residuals, but the two may differ, especially when using a left preconditioner.</p>
<dl class="section return"><dt>Returns</dt><dd>Teuchos::null (always, regardless whether norms == NULL). We only return something in order to satisfy the Iteration interface. <code>PseudoBlockGmresSolMgr</code> knows that this method always returns null. </dd></dl>

</div>
</div>
<a id="a6ba2ba5e4aaec28f6246743224c308de" name="a6ba2ba5e4aaec28f6246743224c308de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba2ba5e4aaec28f6246743224c308de">&#9670;&#160;</a></span>getState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Storage , class MV , class OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PseudoBlockGmresIterState&lt; <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a>, MV &gt; <a class="el" href="classBelos_1_1PseudoBlockGmresIter.html">Belos::PseudoBlockGmresIter</a>&lt; <a class="el" href="classSacado_1_1MP_1_1Vector.html">Sacado::MP::Vector</a>&lt; Storage &gt;, MV, OP &gt;::getState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current state of the linear solver. </p>
<p>The data is only valid if <a class="el" href="classBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4.html#ace069d39503d538affa5abdd72389e94" title="States whether the solver has been initialized or not.">isInitialized()</a> == <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A PseudoBlockGmresIterState object containing const pointers to the current solver state. </dd></dl>

</div>
</div>
<a id="abfa4fdfe591a36ea1365ae3796825d4e" name="abfa4fdfe591a36ea1365ae3796825d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa4fdfe591a36ea1365ae3796825d4e">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Storage , class MV , class OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBelos_1_1PseudoBlockGmresIter.html">Belos::PseudoBlockGmresIter</a>&lt; <a class="el" href="classSacado_1_1MP_1_1Vector.html">Sacado::MP::Vector</a>&lt; Storage &gt;, MV, OP &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const PseudoBlockGmresIterState&lt; <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a>, MV &gt; &amp;&#160;</td>
          <td class="paramname"><em>newstate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the solver to an iterate, providing a complete state. </p>
<p>The PseudoBlockGmresIter contains a certain amount of state, consisting of the current Krylov basis and the associated Hessenberg matrix.</p>
<p><a class="el" href="classBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4.html#ae0e72d6bbe5e6788a061f82456cf3b72" title="Initialize the solver with the initial vectors from the linear problem or random data.">initialize()</a> gives the user the opportunity to manually set these, although this must be done with caution, abiding by the rules given below. All notions of orthogonality and orthonormality are derived from the inner product specified by the orthogonalization manager.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4.html#ace069d39503d538affa5abdd72389e94" title="States whether the solver has been initialized or not.">isInitialized()</a> == <code>true</code> (see post-conditions of isInitialize())</dd></dl>
<p>The user has the option of specifying any component of the state using <a class="el" href="classBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4.html#ae0e72d6bbe5e6788a061f82456cf3b72" title="Initialize the solver with the initial vectors from the linear problem or random data.">initialize()</a>. However, these arguments are assumed to match the post-conditions specified under <a class="el" href="classBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4.html#ace069d39503d538affa5abdd72389e94" title="States whether the solver has been initialized or not.">isInitialized()</a>. Any necessary component of the state not given to <a class="el" href="classBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4.html#ae0e72d6bbe5e6788a061f82456cf3b72" title="Initialize the solver with the initial vectors from the linear problem or random data.">initialize()</a> will be generated.</p>
<dl class="section note"><dt>Note</dt><dd>For any pointer in <code>newstate</code> which directly points to the multivectors in the solver, the data is not copied. </dd></dl>

</div>
</div>
<a id="a3cfb3f8114c57233ee6cea4d651c8dfb" name="a3cfb3f8114c57233ee6cea4d651c8dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfb3f8114c57233ee6cea4d651c8dfb">&#9670;&#160;</a></span>iterate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Storage , class MV , class OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBelos_1_1PseudoBlockGmresIter.html">Belos::PseudoBlockGmresIter</a>&lt; <a class="el" href="classSacado_1_1MP_1_1Vector.html">Sacado::MP::Vector</a>&lt; Storage &gt;, MV, OP &gt;::iterate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method performs block Gmres iterations until the status test indicates the need to stop or an error occurs (in which case, an std::exception is thrown). </p>
<p><a class="el" href="classBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4.html#a3cfb3f8114c57233ee6cea4d651c8dfb" title="This method performs block Gmres iterations until the status test indicates the need to stop or an er...">iterate()</a> will first determine whether the solver is inintialized; if not, it will call <a class="el" href="classBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4.html#ae0e72d6bbe5e6788a061f82456cf3b72" title="Initialize the solver with the initial vectors from the linear problem or random data.">initialize()</a> using default arguments. After initialization, the solver performs block Gmres iterations until the status test evaluates as ::Passed, at which point the method returns to the caller.</p>
<p>The block Gmres iteration proceeds as follows:</p><ol type="1">
<li>The operator problem-&gt;applyOp() is applied to the newest <code>blockSize</code> vectors in the Krylov basis.</li>
<li>The resulting vectors are orthogonalized against the previous basis vectors, and made orthonormal.</li>
<li>The Hessenberg matrix is updated.</li>
<li>The least squares system is updated.</li>
</ol>
<p>The status test is queried at the beginning of the iteration.</p>
<p>Possible exceptions thrown include the PseudoBlockGmresIterOrthoFailure. </p>

</div>
</div>
<a id="ac5358f8d818c8d6a983536befe1eca15" name="ac5358f8d818c8d6a983536befe1eca15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5358f8d818c8d6a983536befe1eca15">&#9670;&#160;</a></span>updateLSQR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Storage , class MV , class OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBelos_1_1PseudoBlockGmresIter.html">Belos::PseudoBlockGmresIter</a>&lt; <a class="el" href="classSacado_1_1MP_1_1Vector.html">Sacado::MP::Vector</a>&lt; Storage &gt;, MV, OP &gt;::updateLSQR </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method for updating QR factorization of upper Hessenberg matrix. </p>
<dl class="section note"><dt>Note</dt><dd>If <code>dim</code> &gt;= <code><a class="el" href="classBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4.html#a10408146f8b3282f107331b5673301ca" title="Get the dimension of the search subspace used to generate the current solution to the linear problem.">getCurSubspaceDim()</a></code> and <code>dim</code> &lt; <code><a class="el" href="classBelos_1_1PseudoBlockGmresIter_3_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_00_01MV_00_01OP_01_4.html#ac8d9d399cf9eaae6f895cc6884160dc3" title="Get the maximum dimension allocated for the search subspace.">getMaxSubspaceDim()</a></code>, then the <code>dim-th</code> equations of the least squares problem will be updated. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Belos__PseudoBlockGmresIter__MP__Vector_8hpp.html">Belos_PseudoBlockGmresIter_MP_Vector.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
