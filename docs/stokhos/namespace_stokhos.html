<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stokhos: Stokhos Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Stokhos<span id="projectnumber">&#160;Development</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Stokhos Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Top-level namespace for <a class="el" href="namespace_stokhos.html" title="Top-level namespace for Stokhos classes and functions.">Stokhos</a> classes and functions.  
<a href="namespace_stokhos.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_stokhos_1_1_k_l" id="r_namespace_stokhos_1_1_k_l"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_stokhos_1_1_k_l.html">KL</a></td></tr>
<tr class="memdesc:namespace_stokhos_1_1_k_l"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for analytic KL expansions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_abstract_preconditioner_factory.html">AbstractPreconditionerFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class to represent a generic preconditioner factory.  <a href="class_stokhos_1_1_abstract_preconditioner_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_adaptivity_manager.html">AdaptivityManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_algebraic_orthog_poly_expansion.html">AlgebraicOrthogPolyExpansion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orthogonal polynomial expansions limited to algebraic operations.  <a href="class_stokhos_1_1_algebraic_orthog_poly_expansion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1aligned__allocator.html">aligned_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An aligned STL allocator.  <a href="class_stokhos_1_1aligned__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1aligned__allocator_3_01const_01_t_01_4.html">aligned_allocator&lt; const T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An aligned STL allocator.  <a href="class_stokhos_1_1aligned__allocator_3_01const_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_aniso_sparse_grid_quadrature.html">AnisoSparseGridQuadrature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines quadrature for a tensor product basis by anisotropic Smolyak sparse grids.  <a href="class_stokhos_1_1_aniso_sparse_grid_quadrature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_anisotropic_total_order_index_set.html">AnisotropicTotalOrderIndexSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An anisotropic total order index set.  <a href="class_stokhos_1_1_anisotropic_total_order_index_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_approx_gauss_seidel_preconditioner.html">ApproxGaussSeidelPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stochastic preconditioner based on applying one iteration of approximate Gauss-Seidel.  <a href="class_stokhos_1_1_approx_gauss_seidel_preconditioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_approx_jacobi_preconditioner.html">ApproxJacobiPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stochastic preconditioner based on applying two iterations of approximate Jacobi.  <a href="class_stokhos_1_1_approx_jacobi_preconditioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_approx_schur_complement_preconditioner.html">ApproxSchurComplementPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stochastic preconditioner based on applying the approximate Schur complement preconditioner as defined by Sousedik, Ghanem, and Phipps, Numerical Linear Algebra and Applications, 2012.  <a href="class_stokhos_1_1_approx_schur_complement_preconditioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_basis_factory.html">BasisFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for building multivariate orthogonal polynomial bases.  <a href="class_stokhos_1_1_basis_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_basis_interaction_graph.html">BasisInteractionGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_block_crs_matrix.html">BlockCrsMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRS matrix of dense blocks.  <a href="class_stokhos_1_1_block_crs_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_block_diagonal_operator.html">BlockDiagonalOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Epetra operator representing the block stochastic Galerkin operator.  <a href="class_stokhos_1_1_block_diagonal_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_block_multiply.html">BlockMultiply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_block_multiply_3_01_coo_product_tensor_3_01_value_type_00_01_device_00_01_pack_01_4_01_4.html">BlockMultiply&lt; CooProductTensor&lt; ValueType, Device, Pack &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_block_multiply_3_01_crs_product_tensor_3_01_value_type_00_01_device_01_4_01_4.html">BlockMultiply&lt; CrsProductTensor&lt; ValueType, Device &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_block_multiply_3_01_flat_sparse3_tensor_3_01_value_type_00_01_device_01_4_01_4.html">BlockMultiply&lt; FlatSparse3Tensor&lt; ValueType, Device &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_block_multiply_3_01_flat_sparse3_tensor__kji_3_01_value_type_00_01_device_01_4_01_4.html">BlockMultiply&lt; FlatSparse3Tensor_kji&lt; ValueType, Device &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_block_multiply_3_01_lexicographic_block_sparse3_tensor_3_01_value_type_00_01_device_01_4_01_4.html">BlockMultiply&lt; LexicographicBlockSparse3Tensor&lt; ValueType, Device &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_block_multiply_3_01_linear_sparse3_tensor_3_01_value_type_00_01_device_00_01_block_size_01_4_01_4.html">BlockMultiply&lt; LinearSparse3Tensor&lt; ValueType, Device, BlockSize &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_block_multiply_3_01_simple_tiled_crs_product_tensor_3_01_value_type_00_01_device_01_4_01_4.html">BlockMultiply&lt; SimpleTiledCrsProductTensor&lt; ValueType, Device &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_block_multiply_3_01_stochastic_product_tensor_3_01_value_type_00_01_tensor_type_00_01_device_01_4_01_4.html">BlockMultiply&lt; StochasticProductTensor&lt; ValueType, TensorType, Device &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_block_multiply_3_01_symmetric_diagonal_spec_3_01_device_01_4_01_4.html">BlockMultiply&lt; SymmetricDiagonalSpec&lt; Device &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_block_multiply_3_01_symmetric_diagonal_spec_3_01_kokkos_1_1_cuda_01_4_01_4.html">BlockMultiply&lt; SymmetricDiagonalSpec&lt; Kokkos::Cuda &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_block_multiply_3_01_tiled_crs_product_tensor_3_01_value_type_00_01_device_01_4_01_4.html">BlockMultiply&lt; TiledCrsProductTensor&lt; ValueType, Device &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_block_preconditioner.html">BlockPreconditioner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_c_g_division_expansion_strategy.html">CGDivisionExpansionStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strategy interface for computing PCE of a/b using only b[0].  <a href="class_stokhos_1_1_c_g_division_expansion_strategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_cijk_data.html">CijkData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_clenshaw_curtis_exponential_growth_rule.html">ClenshawCurtisExponentialGrowthRule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exponential growth rule for Clenshaw-Curtis.  <a href="class_stokhos_1_1_clenshaw_curtis_exponential_growth_rule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_clenshaw_curtis_legendre_basis.html">ClenshawCurtisLegendreBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legendre polynomial basis using Clenshaw-Curtis quadrature points.  <a href="class_stokhos_1_1_clenshaw_curtis_legendre_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_complete_polynomial_basis.html">CompletePolynomialBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multivariate orthogonal polynomial basis generated from a total-order complete-polynomial tensor product of univariate polynomials.  <a href="class_stokhos_1_1_complete_polynomial_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_complete_polynomial_basis_utils.html">CompletePolynomialBasisUtils</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilities for indexing a multi-variate complete polynomial basis.  <a href="class_stokhos_1_1_complete_polynomial_basis_utils.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_constant_orthog_poly_expansion.html">ConstantOrthogPolyExpansion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orthogonal polynomial expansion class for constant (size 1) expansions.  <a href="class_stokhos_1_1_constant_orthog_poly_expansion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_coo_product_tensor.html">CooProductTensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse product tensor using 'COO'-like storage format.  <a href="class_stokhos_1_1_coo_product_tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_coo_product_tensor_3_01_value_type_00_01_execution_space_00_01false_01_4.html">CooProductTensor&lt; ValueType, ExecutionSpace, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="class_stokhos_1_1_coo_product_tensor.html" title="Sparse product tensor using &#39;COO&#39;-like storage format.">CooProductTensor</a> for unpacked (i,j,k)  <a href="class_stokhos_1_1_coo_product_tensor_3_01_value_type_00_01_execution_space_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_coo_product_tensor_3_01_value_type_00_01_execution_space_00_01true_01_4.html">CooProductTensor&lt; ValueType, ExecutionSpace, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="class_stokhos_1_1_coo_product_tensor.html" title="Sparse product tensor using &#39;COO&#39;-like storage format.">CooProductTensor</a> for packed (i,j,k)  <a href="class_stokhos_1_1_coo_product_tensor_3_01_value_type_00_01_execution_space_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_crs_matrix.html">CrsMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRS matrix. <br  />
  <a href="class_stokhos_1_1_crs_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_crs_product_tensor.html">CrsProductTensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse product tensor with replicated entries to provide subsets with a given coordinate.  <a href="class_stokhos_1_1_crs_product_tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_default_multiply.html">DefaultMultiply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_default_point_compare.html">DefaultPointCompare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct defining default point compare type.  <a href="struct_stokhos_1_1_default_point_compare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_dense3_tensor.html">Dense3Tensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure storing a dense 3-tensor C(i,j,k).  <a href="class_stokhos_1_1_dense3_tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_dense_direct_division_expansion_strategy.html">DenseDirectDivisionExpansionStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strategy interface for computing PCE of a/b using only b[0].  <a href="class_stokhos_1_1_dense_direct_division_expansion_strategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_dense_operator.html">DenseOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_deriv_basis.html">DerivBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for multivariate orthogonal polynomials that support computing double and triple products involving derivatives of the basis polynomials.  <a href="class_stokhos_1_1_deriv_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_deriv_orthog_poly_expansion.html">DerivOrthogPolyExpansion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Othogonal polynomial expansions based on derivative calculations.  <a href="class_stokhos_1_1_deriv_orthog_poly_expansion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_device_config.html">DeviceConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_device_for_node.html">DeviceForNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait class that determines (new) Kokkos execution space type from Kokkos(Classic) Node type.  <a href="struct_stokhos_1_1_device_for_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_device_for_node2.html">DeviceForNode2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_device_for_node2_3_01_tpetra_1_1_kokkos_compat_1_1_kokkos_device_wrapper_nodea06f8ad15bbd5be85326302395226e41.html">DeviceForNode2&lt; Tpetra::KokkosCompat::KokkosDeviceWrapperNode&lt; ExecSpace, MemSpace &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_device_prop.html">DeviceProp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_diag_epetra_op.html">DiagEpetraOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Epetra operator representing the block stochastic Galerkin operator.  <a href="class_stokhos_1_1_diag_epetra_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_diagonal_operator.html">DiagonalOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_diag_preconditioner.html">DiagPreconditioner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_discretized_stieltjes_basis.html">DiscretizedStieltjesBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates three-term recurrence using the Discretized Stieltjes procedure.  <a href="class_stokhos_1_1_discretized_stieltjes_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_division_expansion_strategy.html">DivisionExpansionStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strategy interface for computing PCE of a/b.  <a href="class_stokhos_1_1_division_expansion_strategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1ds__array.html">ds_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic array allocation class that works for any type.  <a href="struct_stokhos_1_1ds__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1ds__array_3_01_t_00_01true_01_4.html">ds_array&lt; T, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic array allocation class that is specialized for scalar i.e., fundamental or built-in types (float, double, etc...).  <a href="struct_stokhos_1_1ds__array_3_01_t_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_dynamic_storage.html">DynamicStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_dynamic_strided_storage.html">DynamicStridedStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_dynamic_threaded_storage.html">DynamicThreadedStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically allocated storage class with striding.  <a href="class_stokhos_1_1_dynamic_threaded_storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_dyn_array_traits.html">DynArrayTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic array allocation class that is specialized for scalar i.e., fundamental or built-in types (float, double, etc...).  <a href="struct_stokhos_1_1_dyn_array_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_dyn_array_traits_3_01_t_00_01device__t_00_01false_01_4.html">DynArrayTraits&lt; T, device_t, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic array allocation class that works for any type.  <a href="struct_stokhos_1_1_dyn_array_traits_3_01_t_00_01device__t_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_epetra_crs_matrix_cloner.html">EpetraCrsMatrixCloner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cloner for Epetra_CrsMatrix coefficients.  <a href="class_stokhos_1_1_epetra_crs_matrix_cloner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_epetra_multi_vector_cloner.html">EpetraMultiVectorCloner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cloner for Epetra_MultiVector coefficients.  <a href="class_stokhos_1_1_epetra_multi_vector_cloner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_epetra_multi_vector_operator.html">EpetraMultiVectorOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adaptor that supplies the operator interface to a multi-vector.  <a href="class_stokhos_1_1_epetra_multi_vector_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_epetra_multi_vector_operator_orthog_poly.html">EpetraMultiVectorOperatorOrthogPoly</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container class storing an orthogonal polynomial whose coefficients are vectors, operators, or in general any type that would have an expensive copy constructor. <br  />
  <a href="class_stokhos_1_1_epetra_multi_vector_operator_orthog_poly.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_epetra_multi_vector_orthog_poly.html">EpetraMultiVectorOrthogPoly</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container class storing an orthogonal polynomial whose coefficients are vectors, operators, or in general any type that would have an expensive copy constructor. <br  />
  <a href="class_stokhos_1_1_epetra_multi_vector_orthog_poly.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_epetra_operator_cloner.html">EpetraOperatorCloner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cloner for Epetra_Operator coefficients.  <a href="class_stokhos_1_1_epetra_operator_cloner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_epetra_operator_orthog_poly.html">EpetraOperatorOrthogPoly</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container class storing an orthogonal polynomial whose coefficients are vectors, operators, or in general any type that would have an expensive copy constructor. <br  />
  <a href="class_stokhos_1_1_epetra_operator_orthog_poly.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_epetra_sparse3_tensor.html">EpetraSparse3Tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_epetra_vector_cloner.html">EpetraVectorCloner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cloner for Epetra_Vector coefficients.  <a href="class_stokhos_1_1_epetra_vector_cloner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_epetra_vector_orthog_poly.html">EpetraVectorOrthogPoly</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container class storing an orthogonal polynomial whose coefficients are vectors, operators, or in general any type that would have an expensive copy constructor. <br  />
  <a href="class_stokhos_1_1_epetra_vector_orthog_poly.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1error__storage__type__is__not__allocateable.html">error_storage_type_is_not_allocateable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1error__storage__type__is__not__resizeable.html">error_storage_type_is_not_resizeable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_even_growth_rule.html">EvenGrowthRule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A growth rule that always makes the supplied order even.  <a href="class_stokhos_1_1_even_growth_rule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_expansion_factory.html">ExpansionFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for building multivariate expansion strategies.  <a href="class_stokhos_1_1_expansion_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_flat_l_t_b_sparse3_tensor.html">FlatLTBSparse3Tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_flat_l_t_b_sparse3_tensor_node.html">FlatLTBSparse3TensorNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_flat_sparse3_tensor.html">FlatSparse3Tensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse product tensor with replicated entries to provide subsets with a given coordinate.  <a href="class_stokhos_1_1_flat_sparse3_tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_flat_sparse3_tensor__kji.html">FlatSparse3Tensor_kji</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse product tensor with replicated entries to provide subsets with a given coordinate.  <a href="class_stokhos_1_1_flat_sparse3_tensor__kji.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_floating_point_less.html">FloatingPointLess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor for comparing floating-point numbers to some tolerance.  <a href="class_stokhos_1_1_floating_point_less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_for_u_q_t_k_orthog_poly_expansion.html">ForUQTKOrthogPolyExpansion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_fully_assembled_operator.html">FullyAssembledOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Epetra operator representing the block stochastic Galerkin operator generated by fully assembling the matrix.  <a href="class_stokhos_1_1_fully_assembled_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_fully_assembled_preconditioner.html">FullyAssembledPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stochastic preconditioner based on applying a preconditioner to the fully assembled operator.  <a href="class_stokhos_1_1_fully_assembled_preconditioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_gauss_patterson_exponential_growth_rule.html">GaussPattersonExponentialGrowthRule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exponential growth rule for Gauss-Patterson.  <a href="class_stokhos_1_1_gauss_patterson_exponential_growth_rule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_gauss_patterson_legendre_basis.html">GaussPattersonLegendreBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legendre polynomial basis using Gauss-Patterson quadrature points.  <a href="class_stokhos_1_1_gauss_patterson_legendre_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_get_mean_vals_func.html">GetMeanValsFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get mean values matrix for mean-based preconditioning.  <a href="class_stokhos_1_1_get_mean_vals_func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_get_mean_vals_func_3_01_kokkos_1_1_view_3_01_sacado_1_1_m_p_1_1_vector_3_01_stb5cded5453ab76799dbc54756cee1eb5.html">GetMeanValsFunc&lt; Kokkos::View&lt; Sacado::MP::Vector&lt; Storage &gt; *, P... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get mean values matrix for mean-based preconditioning.  <a href="class_stokhos_1_1_get_mean_vals_func_3_01_kokkos_1_1_view_3_01_sacado_1_1_m_p_1_1_vector_3_01_stb5cded5453ab76799dbc54756cee1eb5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_get_mean_vals_func_3_01_kokkos_1_1_view_3_01_sacado_1_1_u_q_1_1_p_c_e_3_01_sto445aa34bdd8364fa7e9cb17afca0060b.html">GetMeanValsFunc&lt; Kokkos::View&lt; Sacado::UQ::PCE&lt; Storage &gt; *, P... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get mean values matrix for mean-based preconditioning.  <a href="class_stokhos_1_1_get_mean_vals_func_3_01_kokkos_1_1_view_3_01_sacado_1_1_u_q_1_1_p_c_e_3_01_sto445aa34bdd8364fa7e9cb17afca0060b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_get_scalar_mean_vals_func.html">GetScalarMeanValsFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get mean values matrix for mean-based preconditioning.  <a href="class_stokhos_1_1_get_scalar_mean_vals_func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_get_scalar_mean_vals_func_3_01_kokkos_1_1_view_3_01_sacado_1_1_m_p_1_1_vector_38b18e521978c1be64fd94dcd9693fe8.html">GetScalarMeanValsFunc&lt; Kokkos::View&lt; Sacado::MP::Vector&lt; Storage &gt; *, P... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get mean values matrix for mean-based preconditioning.  <a href="class_stokhos_1_1_get_scalar_mean_vals_func_3_01_kokkos_1_1_view_3_01_sacado_1_1_m_p_1_1_vector_38b18e521978c1be64fd94dcd9693fe8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_get_scalar_mean_vals_func_3_01_kokkos_1_1_view_3_01_sacado_1_1_u_q_1_1_p_c_e_362337f0d5f6ecc2bcf8a7bae1bbac536.html">GetScalarMeanValsFunc&lt; Kokkos::View&lt; Sacado::UQ::PCE&lt; Storage &gt; *, P... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get mean values matrix for mean-based preconditioning.  <a href="class_stokhos_1_1_get_scalar_mean_vals_func_3_01_kokkos_1_1_view_3_01_sacado_1_1_u_q_1_1_p_c_e_362337f0d5f6ecc2bcf8a7bae1bbac536.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_g_m_r_e_s_division_expansion_strategy.html">GMRESDivisionExpansionStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strategy interface for computing PCE of a/b using only b[0].  <a href="class_stokhos_1_1_g_m_r_e_s_division_expansion_strategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_gram_schmidt_basis.html">GramSchmidtBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a non-orthogonal multivariate basis to an orthogonal one using the Gram-Schmit procedure.  <a href="class_stokhos_1_1_gram_schmidt_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_growth_rule.html">GrowthRule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for abstract growth rules.  <a href="class_stokhos_1_1_growth_rule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_g_s_preconditioner.html">GSPreconditioner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_g_s_reduced_p_c_e_basis_base.html">GSReducedPCEBasisBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a basis from a given set of PCE expansions that is orthogonal with respect to the product measure induced by these expansions.  <a href="class_stokhos_1_1_g_s_reduced_p_c_e_basis_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_hermite_basis.html">HermiteBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hermite polynomial basis.  <a href="class_stokhos_1_1_hermite_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_house_tri_diag_p_c_e_basis.html">HouseTriDiagPCEBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates three-term recurrence using the <a class="el" href="class_stokhos_1_1_lanczos.html" title="Applies Lanczos procedure to a given matrix.">Lanczos</a> procedure applied to a polynomial chaos expansion in another basis.  <a href="class_stokhos_1_1_house_tri_diag_p_c_e_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_identity_growth_rule.html">IdentityGrowthRule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A growth rule that is the identity.  <a href="class_stokhos_1_1_identity_growth_rule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_ifpack_preconditioner_factory.html">IfpackPreconditionerFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory for building Ifpack preconditioners.  <a href="class_stokhos_1_1_ifpack_preconditioner_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_integral_rank.html">IntegralRank</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_interlaced_operator.html">InterlacedOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Epetra operator representing the block stochastic Galerkin operator generated by fully assembling the matrix. The ordering of this operator is interlaced. That means that all stochastic degrees of freedom associated with a deterministic degree of freedom are interlaced. The result is a large sparse matrix that is composed of small (relatively) dense blocks.  <a href="class_stokhos_1_1_interlaced_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_inverse_preconditioner.html">InversePreconditioner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1is__mp__vector.html">is_mp_vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1is__mp__vector_3_01const_01_sacado_1_1_m_p_1_1_vector_3_01_stokhos_1_1_static_aca36a2a1846be5d9f618c07ddcbcdc1.html">is_mp_vector&lt; const Sacado::MP::Vector&lt; Stokhos::StaticFixedStorage&lt; I, T, N, Exec &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1is__mp__vector_3_01_sacado_1_1_m_p_1_1_vector_3_01_stokhos_1_1_static_fixed_stce79ad61b0d04d6ad1ef7987cdbc4b28.html">is_mp_vector&lt; Sacado::MP::Vector&lt; Stokhos::StaticFixedStorage&lt; I, T, N, Exec &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1is__power__of__two.html">is_power_of_two</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1is___view_storage.html">is_ViewStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1is___view_storage_3_01_view_storage_3_01ordinal__t_00_01value__t_00_01static__0c55c8b07f3aec0651e9f1810c46954d.html">is_ViewStorage&lt; ViewStorage&lt; ordinal_t, value_t, static_length, static_stride, device_t &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_is_scalar_type.html">IsScalarType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template specification for IsScalarType.  <a href="struct_stokhos_1_1_is_scalar_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_is_scalar_type2.html">IsScalarType2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template specification for IsScalarType.  <a href="struct_stokhos_1_1_is_scalar_type2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_is_scalar_type2_3_01double_01_4.html">IsScalarType2&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_is_scalar_type2_3_01float_01_4.html">IsScalarType2&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_is_scalar_type2_3_01int_01_4.html">IsScalarType2&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_is_scalar_type2_3_01long_01_4.html">IsScalarType2&lt; long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_is_scalar_type_3_01double_01_4.html">IsScalarType&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_is_scalar_type_3_01float_01_4.html">IsScalarType&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_is_scalar_type_3_01int_01_4.html">IsScalarType&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_is_scalar_type_3_01long_01_4.html">IsScalarType&lt; long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_jacobi_basis.html">JacobiBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobi polynomial basis.  <a href="class_stokhos_1_1_jacobi_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_jacobi_preconditioner.html">JacobiPreconditioner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_k_l_matrix_free_operator.html">KLMatrixFreeOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Epetra operator representing the block stochastic Galerkin operator.  <a href="class_stokhos_1_1_k_l_matrix_free_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_k_l_reduced_matrix_free_operator.html">KLReducedMatrixFreeOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Epetra operator representing the block stochastic Galerkin operator.  <a href="class_stokhos_1_1_k_l_reduced_matrix_free_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_kronecker_product_preconditioner.html">KroneckerProductPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Epetra operator representing applying the mean in a block stochastic Galerkin expansion.  <a href="class_stokhos_1_1_kronecker_product_preconditioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_lanczos.html">Lanczos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies <a class="el" href="class_stokhos_1_1_lanczos.html" title="Applies Lanczos procedure to a given matrix.">Lanczos</a> procedure to a given matrix.  <a href="class_stokhos_1_1_lanczos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_lanczos_p_c_e_basis.html">LanczosPCEBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates three-term recurrence using the <a class="el" href="class_stokhos_1_1_lanczos.html" title="Applies Lanczos procedure to a given matrix.">Lanczos</a> procedure applied to a polynomial chaos expansion in another basis.  <a href="class_stokhos_1_1_lanczos_p_c_e_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_lanczos_proj_p_c_e_basis.html">LanczosProjPCEBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates three-term recurrence using the <a class="el" href="class_stokhos_1_1_lanczos.html" title="Applies Lanczos procedure to a given matrix.">Lanczos</a> procedure applied to a polynomial chaos expansion in another basis.  <a href="class_stokhos_1_1_lanczos_proj_p_c_e_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_legendre_basis.html">LegendreBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legendre polynomial basis.  <a href="class_stokhos_1_1_legendre_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_lexicographic_block_sparse3_tensor.html">LexicographicBlockSparse3Tensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse product tensor with replicated entries to provide subsets with a given coordinate.  <a href="class_stokhos_1_1_lexicographic_block_sparse3_tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_lexicographic_tree_basis_node.html">LexicographicTreeBasisNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_lexographic_less.html">LexographicLess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A comparison functor implementing a strict weak ordering based lexographic ordering.  <a href="class_stokhos_1_1_lexographic_less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_linear_growth_rule.html">LinearGrowthRule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear growth rule.  <a href="class_stokhos_1_1_linear_growth_rule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_linear_sparse3_tensor.html">LinearSparse3Tensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse product tensor with replicated entries to provide subsets with a given coordinate.  <a href="class_stokhos_1_1_linear_sparse3_tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_l_t_b_sparse3_tensor.html">LTBSparse3Tensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure storing a sparse 3-tensor C(i,j,k) in a a tree-based format for lexicographically ordered product bases.  <a href="class_stokhos_1_1_l_t_b_sparse3_tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_matrix_free_operator.html">MatrixFreeOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Epetra operator representing the block stochastic Galerkin operator.  <a href="class_stokhos_1_1_matrix_free_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_matrix_market_writer.html">MatrixMarketWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_matrix_market_writer_3_01_crs_matrix_3_01_matrix_value_00_01_device_00_01_layout_01_4_01_4.html">MatrixMarketWriter&lt; CrsMatrix&lt; MatrixValue, Device, Layout &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_mean_based_division_expansion_strategy.html">MeanBasedDivisionExpansionStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strategy interface for computing PCE of a/b using only b[0].  <a href="class_stokhos_1_1_mean_based_division_expansion_strategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_mean_based_preconditioner.html">MeanBasedPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stochastic preconditioner based on applying the inverse of the mean.  <a href="class_stokhos_1_1_mean_based_preconditioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_mean_based_tpetra_operator.html">MeanBasedTpetraOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_mean_multiply.html">MeanMultiply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_mean_multiply_3_01_kokkos_sparse_1_1_crs_matrix_3_01const_01_sacado_1_1_u_q_1_de234cffd15c5c24358bd7bf5fca91c5.html">MeanMultiply&lt; KokkosSparse::CrsMatrix&lt; const Sacado::UQ::PCE&lt; MatrixStorage &gt;, MatrixOrdinal, MatrixDevice, MatrixMemory, MatrixSize &gt;, Kokkos::View&lt; const Sacado::UQ::PCE&lt; InputStorage &gt; **, InputP... &gt;, Kokkos::View&lt; Sacado::UQ::PCE&lt; OutputStorage &gt; **, OutputP... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_mean_multiply_3_01_kokkos_sparse_1_1_crs_matrix_3_01const_01_sacado_1_1_u_q_1_bb26db08bb9450be2fbb62984bae4750.html">MeanMultiply&lt; KokkosSparse::CrsMatrix&lt; const Sacado::UQ::PCE&lt; MatrixStorage &gt;, MatrixOrdinal, MatrixDevice, MatrixMemory, MatrixSize &gt;, Kokkos::View&lt; const Sacado::UQ::PCE&lt; InputStorage &gt; *, InputP... &gt;, Kokkos::View&lt; Sacado::UQ::PCE&lt; OutputStorage &gt; *, OutputP... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_mean_multiply_3_01_kokkos_sparse_1_1_crs_matrix_3_01_sacado_1_1_u_q_1_1_p_c_e_f4046b26cafc45fc9626b7847248a6ac.html">MeanMultiply&lt; KokkosSparse::CrsMatrix&lt; Sacado::UQ::PCE&lt; MatrixStorage &gt;, MatrixOrdinal, MatrixDevice, MatrixMemory, MatrixSize &gt;, Kokkos::View&lt; const Sacado::UQ::PCE&lt; InputStorage &gt; **, InputP... &gt;, Kokkos::View&lt; Sacado::UQ::PCE&lt; OutputStorage &gt; **, OutputP... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_mean_multiply_3_01_kokkos_sparse_1_1_crs_matrix_3_01_sacado_1_1_u_q_1_1_p_c_e_3a3a3621fe56834b67abfa26627ea61a.html">MeanMultiply&lt; KokkosSparse::CrsMatrix&lt; Sacado::UQ::PCE&lt; MatrixStorage &gt;, MatrixOrdinal, MatrixDevice, MatrixMemory, MatrixSize &gt;, Kokkos::View&lt; const Sacado::UQ::PCE&lt; InputStorage &gt; *, InputP... &gt;, Kokkos::View&lt; Sacado::UQ::PCE&lt; OutputStorage &gt; *, OutputP... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_memory_traits.html">MemoryTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class encapsulting memory alignment.  <a href="struct_stokhos_1_1_memory_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_memory_traits_3_01_kokkos_1_1_host_space_01_4.html">MemoryTraits&lt; Kokkos::HostSpace &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="struct_stokhos_1_1_memory_traits.html" title="Traits class encapsulting memory alignment.">MemoryTraits</a> for host memory spaces.  <a href="struct_stokhos_1_1_memory_traits_3_01_kokkos_1_1_host_space_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_m_l_preconditioner_factory.html">MLPreconditionerFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory for building ML preconditioners.  <a href="class_stokhos_1_1_m_l_preconditioner_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_monomial_gram_schmidt_p_c_e_basis.html">MonomialGramSchmidtPCEBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a basis from a given set of PCE expansions that is orthogonal with respect to the product measure induced by these expansions.  <a href="class_stokhos_1_1_monomial_gram_schmidt_p_c_e_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_monomial_proj_gram_schmidt_p_c_e_basis.html">MonomialProjGramSchmidtPCEBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a basis from a given set of PCE expansions that is orthogonal with respect to the product measure induced by these expansions.  <a href="class_stokhos_1_1_monomial_proj_gram_schmidt_p_c_e_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_monomial_proj_gram_schmidt_p_c_e_basis2.html">MonomialProjGramSchmidtPCEBasis2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a basis from a given set of PCE expansions that is orthogonal with respect to the product measure induced by these expansions.  <a href="class_stokhos_1_1_monomial_proj_gram_schmidt_p_c_e_basis2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_mono_proj_p_c_e_basis.html">MonoProjPCEBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates three-term recurrence using the <a class="el" href="class_stokhos_1_1_lanczos.html" title="Applies Lanczos procedure to a given matrix.">Lanczos</a> procedure applied to a polynomial chaos expansion in another basis.  <a href="class_stokhos_1_1_mono_proj_p_c_e_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_morton_z_less.html">MortonZLess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A comparison functor implementing a strict weak ordering based Morton Z-ordering.  <a href="class_stokhos_1_1_morton_z_less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_m_p_block_diagonal_preconditioner.html">MPBlockDiagonalPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-point preconditioner based on applying the inverse of the diagonal.  <a href="class_stokhos_1_1_m_p_block_diagonal_preconditioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_m_p_inverse_model_evaluator.html">MPInverseModelEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nonlinear, inverse multi-point ModelEvaluator.  <a href="class_stokhos_1_1_m_p_inverse_model_evaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_m_p_mean_based_preconditioner.html">MPMeanBasedPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-point preconditioner based on applying the inverse of the mean.  <a href="class_stokhos_1_1_m_p_mean_based_preconditioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_m_p_model_evaluator.html">MPModelEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-point model evaluator.  <a href="class_stokhos_1_1_m_p_model_evaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_m_p_model_evaluator_adapter.html">MPModelEvaluatorAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ModelEvaluator adapter that implements the multi-point evaluations through sampling.  <a href="class_stokhos_1_1_m_p_model_evaluator_adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_m_p_preconditioner.html">MPPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class to represent a generic stochastic Galerkin preconditioner as an Epetra_Operator.  <a href="class_stokhos_1_1_m_p_preconditioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_m_p_preconditioner_factory.html">MPPreconditionerFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for generating stochastic Galerkin preconditioners.  <a href="class_stokhos_1_1_m_p_preconditioner_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multi_index.html">MultiIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multidimensional index.  <a href="class_stokhos_1_1_multi_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply.html">Multiply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply_3_01_block_crs_matrix_3_01_block_spec_00_01_matrix_value_00_01_device25f84f50ef3db8f9770bf2b356fe523c.html">Multiply&lt; BlockCrsMatrix&lt; BlockSpec, MatrixValue, Device &gt;, Kokkos::View&lt; VectorValue **, Kokkos::LayoutLeft, Device &gt;, Kokkos::View&lt; VectorValue **, Kokkos::LayoutLeft, Device &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply_3_01_block_crs_matrix_3_01_block_spec_00_01_matrix_value_00_01_kokkos2c16bd3f32541a36d85dd2d7ab89d2d5.html">Multiply&lt; BlockCrsMatrix&lt; BlockSpec, MatrixValue, Kokkos::Cuda &gt;, Kokkos::View&lt; VectorValue **, Kokkos::LayoutLeft, Kokkos::Cuda &gt;, Kokkos::View&lt; VectorValue **, Kokkos::LayoutLeft, Kokkos::Cuda &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply_3_01_block_crs_matrix_3_01_coo_product_tensor_3_01_tensor_scalar_00_04a57dd159652c4cf68d97ba92f4bb088.html">Multiply&lt; BlockCrsMatrix&lt; CooProductTensor&lt; TensorScalar, Kokkos::Cuda, Pack &gt;, MatrixScalar, Kokkos::Cuda &gt;, Kokkos::View&lt; VectorScalar **, Kokkos::LayoutLeft, Kokkos::Cuda &gt;, Kokkos::View&lt; VectorScalar **, Kokkos::LayoutLeft, Kokkos::Cuda &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply_3_01_block_crs_matrix_3_01_crs_product_tensor_3_01_tensor_scalar_00_080bbf045035f3460a18c639f16e61e3a.html">Multiply&lt; BlockCrsMatrix&lt; CrsProductTensor&lt; TensorScalar, Kokkos::Cuda &gt;, MatrixScalar, Kokkos::Cuda &gt;, Kokkos::View&lt; VectorScalar **, Kokkos::LayoutLeft, Kokkos::Cuda &gt;, Kokkos::View&lt; VectorScalar **, Kokkos::LayoutLeft, Kokkos::Cuda &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply_3_01_block_crs_matrix_3_01_flat_sparse3_tensor_3_01_tensor_scalar_00_46064ea03ab3bf21e41dfa14080d9f5e.html">Multiply&lt; BlockCrsMatrix&lt; FlatSparse3Tensor&lt; TensorScalar, Kokkos::Cuda &gt;, MatrixScalar, Kokkos::Cuda &gt;, Kokkos::View&lt; VectorScalar **, Kokkos::LayoutLeft, Kokkos::Cuda &gt;, Kokkos::View&lt; VectorScalar **, Kokkos::LayoutLeft, Kokkos::Cuda &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply_3_01_block_crs_matrix_3_01_flat_sparse3_tensor__kji_3_01_tensor_scala4604568a1caa0213b6b5e838b7da5855.html">Multiply&lt; BlockCrsMatrix&lt; FlatSparse3Tensor_kji&lt; TensorScalar, Kokkos::Cuda &gt;, MatrixScalar, Kokkos::Cuda &gt;, Kokkos::View&lt; VectorScalar **, Kokkos::LayoutLeft, Kokkos::Cuda &gt;, Kokkos::View&lt; VectorScalar **, Kokkos::LayoutLeft, Kokkos::Cuda &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply_3_01_block_crs_matrix_3_01_lexicographic_block_sparse3_tensor_3_01_tea227cb5d3e2ed15a5128705b294616d0.html">Multiply&lt; BlockCrsMatrix&lt; LexicographicBlockSparse3Tensor&lt; TensorScalar, Kokkos::Cuda &gt;, MatrixScalar, Kokkos::Cuda &gt;, Kokkos::View&lt; VectorScalar **, Kokkos::LayoutLeft, Kokkos::Cuda &gt;, Kokkos::View&lt; VectorScalar **, Kokkos::LayoutLeft, Kokkos::Cuda &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply_3_01_block_crs_matrix_3_01_linear_sparse3_tensor_3_01_tensor_scalar_034c2f6301c52a5d4a41e9c315367f2cc.html">Multiply&lt; BlockCrsMatrix&lt; LinearSparse3Tensor&lt; TensorScalar, Kokkos::Cuda, BlockSize &gt;, MatrixScalar, Kokkos::Cuda &gt;, Kokkos::View&lt; VectorScalar **, Kokkos::LayoutLeft, Kokkos::Cuda &gt;, Kokkos::View&lt; VectorScalar **, Kokkos::LayoutLeft, Kokkos::Cuda &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply_3_01_block_crs_matrix_3_01_simple_tiled_crs_product_tensor_3_01_tenso8efd0b3eb53a1bd69011a394aa60c1bf.html">Multiply&lt; BlockCrsMatrix&lt; SimpleTiledCrsProductTensor&lt; TensorScalar, Kokkos::Cuda &gt;, MatrixScalar, Kokkos::Cuda &gt;, Kokkos::View&lt; VectorScalar **, Kokkos::LayoutLeft, Kokkos::Cuda &gt;, Kokkos::View&lt; VectorScalar **, Kokkos::LayoutLeft, Kokkos::Cuda &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply_3_01_block_crs_matrix_3_01_stochastic_product_tensor_3_01_tensor_scalfd9f6c383923e67fd05bcc90bc49d80b.html">Multiply&lt; BlockCrsMatrix&lt; StochasticProductTensor&lt; TensorScalar, TensorType, Kokkos::Cuda &gt;, MatrixScalar, Kokkos::Cuda &gt;, Kokkos::View&lt; VectorScalar **, Kokkos::LayoutLeft, Kokkos::Cuda &gt;, Kokkos::View&lt; VectorScalar **, Kokkos::LayoutLeft, Kokkos::Cuda &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply_3_01_block_crs_matrix_3_01_stochastic_product_tensor_3_01_value_type_e45c12b63557911451b456514050de4a.html">Multiply&lt; BlockCrsMatrix&lt; StochasticProductTensor&lt; ValueType, CrsProductTensor&lt; ValueType, Kokkos::OpenMP &gt;, Kokkos::OpenMP &gt;, MatrixValue, Kokkos::OpenMP &gt;, Kokkos::View&lt; VectorValue **, Kokkos::LayoutLeft, Kokkos::OpenMP &gt;, Kokkos::View&lt; VectorValue **, Kokkos::LayoutLeft, Kokkos::OpenMP &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply_3_01_block_crs_matrix_3_01_stochastic_product_tensor_3_01_value_type_03eff781fabeee20043e5e44ba3350e7.html">Multiply&lt; BlockCrsMatrix&lt; StochasticProductTensor&lt; ValueType, CrsProductTensor&lt; ValueType, Kokkos::Serial &gt;, Kokkos::Serial &gt;, MatrixValue, Kokkos::Serial &gt;, Kokkos::View&lt; VectorValue **, Kokkos::LayoutLeft, Kokkos::Serial &gt;, Kokkos::View&lt; VectorValue **, Kokkos::LayoutLeft, Kokkos::Serial &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply_3_01_block_crs_matrix_3_01_stochastic_product_tensor_3_01_value_type_cc71c48b30acfedd5528475b27bbcfe3.html">Multiply&lt; BlockCrsMatrix&lt; StochasticProductTensor&lt; ValueType, CrsProductTensor&lt; ValueType, Kokkos::Threads &gt;, Kokkos::Threads &gt;, MatrixValue, Kokkos::Threads &gt;, Kokkos::View&lt; VectorValue **, Kokkos::LayoutLeft, Kokkos::Threads &gt;, Kokkos::View&lt; VectorValue **, Kokkos::LayoutLeft, Kokkos::Threads &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply_3_01_block_crs_matrix_3_01_tiled_crs_product_tensor_3_01_tensor_scalafb44a6e783604073c0d357956f7b0d9c.html">Multiply&lt; BlockCrsMatrix&lt; TiledCrsProductTensor&lt; TensorScalar, Kokkos::Cuda &gt;, MatrixScalar, Kokkos::Cuda &gt;, Kokkos::View&lt; VectorScalar **, Kokkos::LayoutLeft, Kokkos::Cuda &gt;, Kokkos::View&lt; VectorScalar **, Kokkos::LayoutLeft, Kokkos::Cuda &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply_3_01_crs_matrix_3_01_matrix_value_00_01_device_00_01_layout_01_4_00_03c3687adfd9fe3ed95437a5446ea8efc.html">Multiply&lt; CrsMatrix&lt; MatrixValue, Device, Layout &gt;, InputMultiVectorType, OutputMultiVectorType, std::vector&lt; OrdinalType &gt;, IntegralRank&lt; 2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply_3_01_crs_matrix_3_01_matrix_value_00_01_device_00_01_layout_01_4_00_0f411ef439731f5c58a05f480baccaba0.html">Multiply&lt; CrsMatrix&lt; MatrixValue, Device, Layout &gt;, InputMultiVectorType, OutputMultiVectorType, void, IntegralRank&lt; 2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply_3_01_crs_matrix_3_01_matrix_value_00_01_device_00_01_layout_01_4_00_099e058e9796aa11c84ad04b301d82153.html">Multiply&lt; CrsMatrix&lt; MatrixValue, Device, Layout &gt;, InputVectorType, OutputVectorType, void, IntegralRank&lt; 1 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply_3_01_crs_matrix_3_01_matrix_value_00_01_device_00_01_layout_01_4_00_0073de2b7005d245836bf2939804e7961.html">Multiply&lt; CrsMatrix&lt; MatrixValue, Device, Layout &gt;, std::vector&lt; InputViewType &gt;, std::vector&lt; OutputViewType &gt;, void, IntegralRank&lt; 1 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply_3_01_kokkos_sparse_1_1_crs_matrix_3_01const_01_sacado_1_1_u_q_1_1_p_c39bfc6605fb1d36fe11dbe7647b727bb.html">Multiply&lt; KokkosSparse::CrsMatrix&lt; const Sacado::UQ::PCE&lt; MatrixStorage &gt;, MatrixOrdinal, MatrixDevice, MatrixMemory, MatrixSize &gt;, Kokkos::View&lt; const Sacado::UQ::PCE&lt; InputStorage &gt; **, InputP... &gt;, Kokkos::View&lt; Sacado::UQ::PCE&lt; OutputStorage &gt; **, OutputP... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply_3_01_kokkos_sparse_1_1_crs_matrix_3_01const_01_sacado_1_1_u_q_1_1_p_c400aa03876ca332df2f74bca571ce4ca.html">Multiply&lt; KokkosSparse::CrsMatrix&lt; const Sacado::UQ::PCE&lt; MatrixStorage &gt;, MatrixOrdinal, MatrixDevice, MatrixMemory, MatrixSize &gt;, Kokkos::View&lt; const Sacado::UQ::PCE&lt; InputStorage &gt; *, InputP... &gt;, Kokkos::View&lt; Sacado::UQ::PCE&lt; OutputStorage &gt; *, OutputP... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply_3_01_kokkos_sparse_1_1_crs_matrix_3_01_sacado_1_1_m_p_1_1_vector_3_0146d7f2c55f594575bc401a45e3e663fe.html">Multiply&lt; KokkosSparse::CrsMatrix&lt; Sacado::MP::Vector&lt; MatrixStorage &gt;, MatrixOrdinal, MatrixDevice, MatrixMemory, MatrixSize &gt;, Kokkos::View&lt; const Sacado::MP::Vector&lt; InputStorage &gt; **, InputP... &gt;, Kokkos::View&lt; Sacado::MP::Vector&lt; OutputStorage &gt; **, OutputP... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply_3_01_kokkos_sparse_1_1_crs_matrix_3_01_sacado_1_1_m_p_1_1_vector_3_0191caed1ca97cb9fb173bd535a71f214f.html">Multiply&lt; KokkosSparse::CrsMatrix&lt; Sacado::MP::Vector&lt; MatrixStorage &gt;, MatrixOrdinal, MatrixDevice, MatrixMemory, MatrixSize &gt;, Kokkos::View&lt; const Sacado::MP::Vector&lt; InputStorage &gt; *, InputP... &gt;, Kokkos::View&lt; Sacado::MP::Vector&lt; OutputStorage &gt; *, OutputP... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply_3_01_kokkos_sparse_1_1_crs_matrix_3_01_sacado_1_1_u_q_1_1_p_c_e_3_01_d115093da33c887e85d61cc62bc1bc23.html">Multiply&lt; KokkosSparse::CrsMatrix&lt; Sacado::UQ::PCE&lt; MatrixStorage &gt;, MatrixOrdinal, MatrixDevice, MatrixMemory, MatrixSize &gt;, Kokkos::View&lt; const Sacado::UQ::PCE&lt; InputStorage &gt; **, InputP... &gt;, Kokkos::View&lt; Sacado::UQ::PCE&lt; OutputStorage &gt; **, OutputP... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply_3_01_kokkos_sparse_1_1_crs_matrix_3_01_sacado_1_1_u_q_1_1_p_c_e_3_01_1a60c93e040e02c4daebc8bff2fec788.html">Multiply&lt; KokkosSparse::CrsMatrix&lt; Sacado::UQ::PCE&lt; MatrixStorage &gt;, MatrixOrdinal, MatrixDevice, MatrixMemory, MatrixSize &gt;, Kokkos::View&lt; const Sacado::UQ::PCE&lt; InputStorage &gt; *, InputP... &gt;, Kokkos::View&lt; Sacado::UQ::PCE&lt; OutputStorage &gt; *, OutputP... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_multiply_impl.html">MultiplyImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_one_d_orthog_poly_basis.html">OneDOrthogPolyBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for 1-D orthogonal polynomials.  <a href="class_stokhos_1_1_one_d_orthog_poly_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_operator.html">Operator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_orthogonalization_factory.html">OrthogonalizationFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulate various orthogonalization (ie QR) methods.  <a href="class_stokhos_1_1_orthogonalization_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_orthog_poly_approx.html">OrthogPolyApprox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to store coefficients of a projection onto an orthogonal polynomial basis.  <a href="class_stokhos_1_1_orthog_poly_approx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_orthog_poly_basis.html">OrthogPolyBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for multivariate orthogonal polynomials.  <a href="class_stokhos_1_1_orthog_poly_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_orthog_poly_expansion.html">OrthogPolyExpansion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for orthogonal polynomial-based expansions.  <a href="class_stokhos_1_1_orthog_poly_expansion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_orthog_poly_expansion_base.html">OrthogPolyExpansionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for consolidating common expansion implementations.  <a href="class_stokhos_1_1_orthog_poly_expansion_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_parallel_data.html">ParallelData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_p_c_e_covariance_op.html">PCECovarianceOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Epetra operator representing the covariance operator of a polynomial chaos expansion.  <a href="class_stokhos_1_1_p_c_e_covariance_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_pecos_one_d_orthog_poly_basis.html">PecosOneDOrthogPolyBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="class_stokhos_1_1_one_d_orthog_poly_basis.html" title="Abstract base class for 1-D orthogonal polynomials.">OneDOrthogPolyBasis</a> via Pecos.  <a href="class_stokhos_1_1_pecos_one_d_orthog_poly_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1power__of__two.html">power_of_two</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1power__of__two_3_011_00_01true_01_4.html">power_of_two&lt; 1, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1power__of__two_3_012_00_01true_01_4.html">power_of_two&lt; 2, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1power__of__two_3_01_n_00_01true_01_4.html">power_of_two&lt; N, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_preconditioner_factory.html">PreconditionerFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An class for building preconditioners.  <a href="class_stokhos_1_1_preconditioner_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_product_basis.html">ProductBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for multivariate orthogonal polynomials generated from tensor products of univariate polynomials.  <a href="class_stokhos_1_1_product_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_product_basis_utils.html">ProductBasisUtils</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilities for indexing a multi-variate complete polynomial basis.  <a href="class_stokhos_1_1_product_basis_utils.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_product_container.html">ProductContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A product (in the mathematical sense) container class whose coefficients are vectors, operators, or in general any type that would have an expensive copy constructor. <br  />
  <a href="class_stokhos_1_1_product_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_product_container_traits.html">ProductContainerTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base traits definition for <a class="el" href="class_stokhos_1_1_product_container.html" title="A product (in the mathematical sense) container class whose coefficients are vectors,...">ProductContainer</a>.  <a href="class_stokhos_1_1_product_container_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_product_container_traits_3_01_epetra___crs_matrix_01_4.html">ProductContainerTraits&lt; Epetra_CrsMatrix &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="class_stokhos_1_1_product_container_traits.html" title="Base traits definition for ProductContainer.">ProductContainerTraits</a> to Epetra_CrsMatrix coefficients.  <a href="class_stokhos_1_1_product_container_traits_3_01_epetra___crs_matrix_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_product_container_traits_3_01_epetra___multi_vector_01_4.html">ProductContainerTraits&lt; Epetra_MultiVector &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="class_stokhos_1_1_product_container_traits.html" title="Base traits definition for ProductContainer.">ProductContainerTraits</a> to Epetra_MultiVector coefficients.  <a href="class_stokhos_1_1_product_container_traits_3_01_epetra___multi_vector_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_product_container_traits_3_01_epetra___operator_01_4.html">ProductContainerTraits&lt; Epetra_Operator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="class_stokhos_1_1_product_container_traits.html" title="Base traits definition for ProductContainer.">ProductContainerTraits</a> to Epetra_Operator coefficients.  <a href="class_stokhos_1_1_product_container_traits_3_01_epetra___operator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_product_container_traits_3_01_epetra___vector_01_4.html">ProductContainerTraits&lt; Epetra_Vector &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="class_stokhos_1_1_product_container_traits.html" title="Base traits definition for ProductContainer.">ProductContainerTraits</a> to Epetra_Vector coefficients.  <a href="class_stokhos_1_1_product_container_traits_3_01_epetra___vector_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_product_epetra_multi_vector.html">ProductEpetraMultiVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container class storing products of Epetra_MultiVector's. <br  />
  <a href="class_stokhos_1_1_product_epetra_multi_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_product_epetra_multi_vector_operator.html">ProductEpetraMultiVectorOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container class for products of Epetra_Vector's. <br  />
  <a href="class_stokhos_1_1_product_epetra_multi_vector_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_product_epetra_operator.html">ProductEpetraOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container class for products of Epetra_Vector's. <br  />
  <a href="class_stokhos_1_1_product_epetra_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_product_epetra_vector.html">ProductEpetraVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container class for products of Epetra_Vector's. <br  />
  <a href="class_stokhos_1_1_product_epetra_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_product_lanczos_gram_schmidt_p_c_e_basis.html">ProductLanczosGramSchmidtPCEBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a basis from a given set of PCE expansions that is orthogonal with respect to the product measure induced by these expansions.  <a href="class_stokhos_1_1_product_lanczos_gram_schmidt_p_c_e_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_product_lanczos_p_c_e_basis.html">ProductLanczosPCEBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a basis from a given set of PCE expansions that is orthogonal with respect to the product measure induced by these expansions.  <a href="class_stokhos_1_1_product_lanczos_p_c_e_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_pseudo_spectral_operator.html">PseudoSpectralOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An operator interface for building pseudo-spectral approximations.  <a href="class_stokhos_1_1_pseudo_spectral_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_pseudo_spectral_operator_factory.html">PseudoSpectralOperatorFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for building multivariate quadrature strategies.  <a href="class_stokhos_1_1_pseudo_spectral_operator_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_pseudo_spectral_orthog_poly_expansion.html">PseudoSpectralOrthogPolyExpansion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orthogonal polynomial expansions based on numerical quadrature.  <a href="class_stokhos_1_1_pseudo_spectral_orthog_poly_expansion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_quad_orthog_poly_expansion.html">QuadOrthogPolyExpansion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orthogonal polynomial expansions based on numerical quadrature.  <a href="class_stokhos_1_1_quad_orthog_poly_expansion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_quadrature.html">Quadrature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for quadrature methods.  <a href="class_stokhos_1_1_quadrature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_quadrature_factory.html">QuadratureFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for building multivariate quadrature strategies.  <a href="class_stokhos_1_1_quadrature_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_quadrature_pseudo_spectral_operator.html">QuadraturePseudoSpectralOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An operator for building pseudo-spectral coefficients using an arbitrary quadrature rule.  <a href="class_stokhos_1_1_quadrature_pseudo_spectral_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_r_c_b.html">RCB</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_recurrence_basis.html">RecurrenceBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="class_stokhos_1_1_one_d_orthog_poly_basis.html" title="Abstract base class for 1-D orthogonal polynomials.">OneDOrthogPolyBasis</a> based on the general three-term recurrence relationship:  <a href="class_stokhos_1_1_recurrence_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_reduced_basis_factory.html">ReducedBasisFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a basis from a given set of PCE expansions that is orthogonal with respect to the product measure induced by these expansions.  <a href="class_stokhos_1_1_reduced_basis_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_reduced_p_c_e_basis.html">ReducedPCEBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for reduced basis strategies built from polynomial chaos expansions in some other basis.  <a href="class_stokhos_1_1_reduced_p_c_e_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_reduced_quadrature_factory.html">ReducedQuadratureFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a basis from a given set of PCE expansions that is orthogonal with respect to the product measure induced by these expansions.  <a href="class_stokhos_1_1_reduced_quadrature_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_response_statistic_model_evaluator.html">ResponseStatisticModelEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ModelEvaluator providing statistic response functions.  <a href="class_stokhos_1_1_response_statistic_model_evaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_rys_basis.html">RysBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rys polynomial basis.  <a href="class_stokhos_1_1_rys_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_schur_preconditioner.html">SchurPreconditioner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_s_g_inverse_model_evaluator.html">SGInverseModelEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nonlinear, inverse stochastic Galerkin ModelEvaluator.  <a href="class_stokhos_1_1_s_g_inverse_model_evaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_s_g_model_evaluator.html">SGModelEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nonlinear, stochastic Galerkin ModelEvaluator.  <a href="class_stokhos_1_1_s_g_model_evaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_s_g_model_evaluator___adaptive.html">SGModelEvaluator_Adaptive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nonlinear, stochastic Galerkin ModelEvaluator that constructs an adapted Jacobian.  <a href="class_stokhos_1_1_s_g_model_evaluator___adaptive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_s_g_model_evaluator___interlaced.html">SGModelEvaluator_Interlaced</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nonlinear, stochastic Galerkin ModelEvaluator that constructs a interlaced Jacobian.  <a href="class_stokhos_1_1_s_g_model_evaluator___interlaced.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_s_g_model_evaluator_base.html">SGModelEvaluatorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for stochastic Galerkin model evaluators.  <a href="class_stokhos_1_1_s_g_model_evaluator_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_s_g_operator.html">SGOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class to represent a generic stochastic Galerkin operator as an Epetra_Operator.  <a href="class_stokhos_1_1_s_g_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_s_g_operator_factory.html">SGOperatorFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for generating stochastic Galerkin preconditioners.  <a href="class_stokhos_1_1_s_g_operator_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_s_g_preconditioner.html">SGPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class to represent a generic stochastic Galerkin preconditioner as an Epetra_Operator.  <a href="class_stokhos_1_1_s_g_preconditioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_s_g_preconditioner_factory.html">SGPreconditionerFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for generating stochastic Galerkin preconditioners.  <a href="class_stokhos_1_1_s_g_preconditioner_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_s_g_quad_model_evaluator.html">SGQuadModelEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ModelEvaluator adaptor that implements the stochastic Galerkin residual and Jacobian computations using quadrature.  <a href="class_stokhos_1_1_s_g_quad_model_evaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_s_g_quad_m_p_model_evaluator.html">SGQuadMPModelEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ModelEvaluator adaptor that implements the stochastic Galerkin residual and Jacobian computations using quadrature.  <a href="class_stokhos_1_1_s_g_quad_m_p_model_evaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_simple_tiled_crs_product_tensor.html">SimpleTiledCrsProductTensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_single_column_multivector_multiply.html">SingleColumnMultivectorMultiply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_smolyak_basis.html">SmolyakBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multivariate orthogonal polynomial basis generated from a Smolyak sparse grid.  <a href="class_stokhos_1_1_smolyak_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_smolyak_pseudo_spectral_operator.html">SmolyakPseudoSpectralOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An operator for building pseudo-spectral coefficients using a sparse Smolyak construction.  <a href="class_stokhos_1_1_smolyak_pseudo_spectral_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_smolyak_sparse_grid_quadrature.html">SmolyakSparseGridQuadrature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines quadrature for a tensor product basis by Smolyak sparse grids.  <a href="class_stokhos_1_1_smolyak_sparse_grid_quadrature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_sparse3_tensor.html">Sparse3Tensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure storing a sparse 3-tensor C(i,j,k) in a a compressed format.  <a href="class_stokhos_1_1_sparse3_tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_sparse_array.html">SparseArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for a "sparse" array.  <a href="struct_stokhos_1_1_sparse_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_sparse_array_iterator.html">SparseArrayIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bi-directional iterator for traversing a sparse array.  <a href="struct_stokhos_1_1_sparse_array_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_sparse_array_reverse_iterator.html">SparseArrayReverseIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bi-directional reverse iterator for traversing a sparse array.  <a href="struct_stokhos_1_1_sparse_array_reverse_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_sparse_grid_quadrature.html">SparseGridQuadrature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines quadrature for a tensor product basis by Smolyak sparse grids.  <a href="class_stokhos_1_1_sparse_grid_quadrature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_s_p_d_dense_direct_division_expansion_strategy.html">SPDDenseDirectDivisionExpansionStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strategy interface for computing PCE of a/b using only b[0].  <a href="class_stokhos_1_1_s_p_d_dense_direct_division_expansion_strategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_standard_storage.html">StandardStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_static_array_traits.html">StaticArrayTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static array allocation class.  <a href="struct_stokhos_1_1_static_array_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_static_array_traits_3_01_t_00_01_d_00_01false_01_4.html">StaticArrayTraits&lt; T, D, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static array allocation class that works for any type.  <a href="struct_stokhos_1_1_static_array_traits_3_01_t_00_01_d_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_static_array_traits_3_01_t_00_01_d_00_01true_01_4.html">StaticArrayTraits&lt; T, D, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static array allocation class that is specialized for scalar i.e., fundamental or built-in types (float, double, etc...).  <a href="struct_stokhos_1_1_static_array_traits_3_01_t_00_01_d_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_static_fixed_standard_storage.html">StaticFixedStandardStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically allocated storage class.  <a href="class_stokhos_1_1_static_fixed_standard_storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_static_fixed_storage.html">StaticFixedStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically allocated storage class.  <a href="class_stokhos_1_1_static_fixed_storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_static_standard_storage.html">StaticStandardStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically allocated storage class.  <a href="class_stokhos_1_1_static_standard_storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_static_storage.html">StaticStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically allocated storage class.  <a href="class_stokhos_1_1_static_storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_stieltjes_basis.html">StieltjesBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates three-term recurrence using the Discretized Stieltjes procedure applied to a functional mapping another basis.  <a href="class_stokhos_1_1_stieltjes_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_stieltjes_gram_schmidt_builder.html">StieltjesGramSchmidtBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for building a reduced-dimension basis and quadrature from a given set of polynomial chaos expansions. First generates 1-D orthogonal bases using the discretized Stieltjes procedure, forms their tensor product, and then orthogonalizes using Gram-Schmidt.  <a href="class_stokhos_1_1_stieltjes_gram_schmidt_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_stieltjes_p_c_e_basis.html">StieltjesPCEBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates three-term recurrence using the Discretized Stieltjes procedure applied to a polynomial chaos expansion in another basis.  <a href="class_stokhos_1_1_stieltjes_p_c_e_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_stochastic_product_tensor.html">StochasticProductTensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bases defined by combinatorial product of polynomial bases.  <a href="class_stokhos_1_1_stochastic_product_tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_symmetric_diagonal_spec.html">SymmetricDiagonalSpec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetric diagonal storage for a dense matrix.  <a href="class_stokhos_1_1_symmetric_diagonal_spec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_tensor_product_basis.html">TensorProductBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multivariate orthogonal polynomial basis generated from a tensor product of univariate polynomials.  <a href="class_stokhos_1_1_tensor_product_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_tensor_product_element.html">TensorProductElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container storing a term in a generalized tensor product.  <a href="class_stokhos_1_1_tensor_product_element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_tensor_product_index_set.html">TensorProductIndexSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tensor product index set.  <a href="class_stokhos_1_1_tensor_product_index_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_tensor_product_predicate.html">TensorProductPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate functor for building sparse triple products.  <a href="struct_stokhos_1_1_tensor_product_predicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_tensor_product_pseudo_spectral_operator.html">TensorProductPseudoSpectralOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An operator for building pseudo-spectral coefficients using tensor-product quadrature.  <a href="class_stokhos_1_1_tensor_product_pseudo_spectral_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_tensor_product_quadrature.html">TensorProductQuadrature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines quadrature for a tensor product basis by tensor products of 1-D quadrature rules.  <a href="class_stokhos_1_1_tensor_product_quadrature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_tiled_crs_product_tensor.html">TiledCrsProductTensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_tiny_vec.html">TinyVec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_tiny_vec_3_01_value_type_00_01_n_00_01_use_intrinsics_00_01true_01_4.html">TinyVec&lt; ValueType, N, UseIntrinsics, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_total_order_basis.html">TotalOrderBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multivariate orthogonal polynomial basis generated from a total order tensor product of univariate polynomials.  <a href="class_stokhos_1_1_total_order_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_total_order_index_set.html">TotalOrderIndexSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An isotropic total order index set.  <a href="class_stokhos_1_1_total_order_index_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_total_order_less.html">TotalOrderLess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A comparison functor implementing a strict weak ordering based total-order ordering, recursive on the dimension.  <a href="class_stokhos_1_1_total_order_less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_total_order_predicate.html">TotalOrderPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate functor for building sparse triple products based on total order.  <a href="struct_stokhos_1_1_total_order_predicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_update.html">Update</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_user_defined_quadrature.html">UserDefinedQuadrature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_vector_orthog_poly.html">VectorOrthogPoly</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container class storing an orthogonal polynomial whose coefficients are vectors, operators, or in general any type that would have an expensive copy constructor. <br  />
  <a href="class_stokhos_1_1_vector_orthog_poly.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_view_rank.html">ViewRank</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_stokhos_1_1_view_rank_3_01std_1_1vector_3_01_t_01_4_01_4.html">ViewRank&lt; std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_view_storage.html">ViewStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic storage with view semantics and contiguous access.  <a href="class_stokhos_1_1_view_storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stokhos_1_1_weighted_vector_space.html">WeightedVectorSpace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a58eaf8b66f9231d76420853747a6c118" id="r_a58eaf8b66f9231d76420853747a6c118"><td class="memTemplParams" colspan="2"><a id="a58eaf8b66f9231d76420853747a6c118" name="a58eaf8b66f9231d76420853747a6c118"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a58eaf8b66f9231d76420853747a6c118"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>scalar_view_t</b> = decltype(reinterpret_as_unmanaged_scalar_view(std::declval&lt; T &gt;()))</td></tr>
<tr class="separator:a58eaf8b66f9231d76420853747a6c118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dae9a4344e7b76ab06cad9357009161" id="r_a2dae9a4344e7b76ab06cad9357009161"><td class="memTemplParams" colspan="2"><a id="a2dae9a4344e7b76ab06cad9357009161" name="a2dae9a4344e7b76ab06cad9357009161"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a2dae9a4344e7b76ab06cad9357009161"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>scalar_flat_view_t</b> = decltype(reinterpret_as_unmanaged_scalar_flat_view(std::declval&lt; T &gt;()))</td></tr>
<tr class="separator:a2dae9a4344e7b76ab06cad9357009161"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af571bcc9a6bf13e521247f9af735202d" id="r_af571bcc9a6bf13e521247f9af735202d"><td class="memItemLeft" align="right" valign="top"><a id="af571bcc9a6bf13e521247f9af735202d" name="af571bcc9a6bf13e521247f9af735202d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_stokhos.html#af571bcc9a6bf13e521247f9af735202d">GrowthPolicy</a> { <b>SLOW_GROWTH</b>
, <b>MODERATE_GROWTH</b>
 }</td></tr>
<tr class="memdesc:af571bcc9a6bf13e521247f9af735202d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type for determining Smolyak growth policies. <br /></td></tr>
<tr class="separator:af571bcc9a6bf13e521247f9af735202d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f0a2bd943ce2cde2275da27867c7c7" id="r_a82f0a2bd943ce2cde2275da27867c7c7"><td class="memItemLeft" align="right" valign="top"><a id="a82f0a2bd943ce2cde2275da27867c7c7" name="a82f0a2bd943ce2cde2275da27867c7c7"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>CijkSymmetryType</b> { <b>CIJK_NO_SYMMETRY</b>
, <b>CIJK_TWO_WAY_SYMMETRY</b>
, <b>CIJK_SIX_WAY_SYMMETRY</b>
 }</td></tr>
<tr class="separator:a82f0a2bd943ce2cde2275da27867c7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad77ffe70a1d3f696df326677e9fc65dc" id="r_ad77ffe70a1d3f696df326677e9fc65dc"><td class="memItemLeft" align="right" valign="top"><a id="ad77ffe70a1d3f696df326677e9fc65dc" name="ad77ffe70a1d3f696df326677e9fc65dc"></a>
Teuchos::RCP&lt; const EpetraExt::MultiComm &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>buildMultiComm</b> (const Epetra_Comm &amp;globalComm, int num_global_stochastic_blocks, int num_spatial_procs=-1)</td></tr>
<tr class="separator:ad77ffe70a1d3f696df326677e9fc65dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78793c0420c83e80a18c8f2cebd186f7" id="r_a78793c0420c83e80a18c8f2cebd186f7"><td class="memItemLeft" align="right" valign="top"><a id="a78793c0420c83e80a18c8f2cebd186f7" name="a78793c0420c83e80a18c8f2cebd186f7"></a>
Teuchos::RCP&lt; const Epetra_Comm &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getSpatialComm</b> (const Teuchos::RCP&lt; const EpetraExt::MultiComm &gt; &amp;globalMultiComm)</td></tr>
<tr class="separator:a78793c0420c83e80a18c8f2cebd186f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306810ec81177fd5f01ff252a6d10452" id="r_a306810ec81177fd5f01ff252a6d10452"><td class="memItemLeft" align="right" valign="top"><a id="a306810ec81177fd5f01ff252a6d10452" name="a306810ec81177fd5f01ff252a6d10452"></a>
Teuchos::RCP&lt; const Epetra_Comm &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getStochasticComm</b> (const Teuchos::RCP&lt; const EpetraExt::MultiComm &gt; &amp;globalMultiComm)</td></tr>
<tr class="separator:a306810ec81177fd5f01ff252a6d10452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a118fde0f4bdba73fdc8b97ac6e0e80" id="r_a7a118fde0f4bdba73fdc8b97ac6e0e80"><td class="memTemplParams" colspan="2"><a id="a7a118fde0f4bdba73fdc8b97ac6e0e80" name="a7a118fde0f4bdba73fdc8b97ac6e0e80"></a>
template&lt;typename coeff_type &gt; </td></tr>
<tr class="memitem:a7a118fde0f4bdba73fdc8b97ac6e0e80"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="class_stokhos_1_1_product_container.html">ProductContainer</a>&lt; coeff_type &gt; &amp;vec)</td></tr>
<tr class="separator:a7a118fde0f4bdba73fdc8b97ac6e0e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b50c65c53654bcb00e956b142219e41" id="r_a6b50c65c53654bcb00e956b142219e41"><td class="memTemplParams" colspan="2">template&lt;typename ordinal_type , typename value_type &gt; </td></tr>
<tr class="memitem:a6b50c65c53654bcb00e956b142219e41"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; Epetra_CrsGraph &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_stokhos.html#a6b50c65c53654bcb00e956b142219e41">sparse3Tensor2CrsGraph</a> (const <a class="el" href="class_stokhos_1_1_orthog_poly_basis.html">Stokhos::OrthogPolyBasis</a>&lt; ordinal_type, value_type &gt; &amp;basis, const <a class="el" href="class_stokhos_1_1_sparse3_tensor.html">Stokhos::Sparse3Tensor</a>&lt; ordinal_type, value_type &gt; &amp;Cijk, const Epetra_Comm &amp;comm)</td></tr>
<tr class="memdesc:a6b50c65c53654bcb00e956b142219e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an Epetra_CrsGraph from a sparse 3 tensor.  <br /></td></tr>
<tr class="separator:a6b50c65c53654bcb00e956b142219e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05bd24053308e7d7f4db8a89e4d514cf" id="r_a05bd24053308e7d7f4db8a89e4d514cf"><td class="memTemplParams" colspan="2">template&lt;typename ordinal_type , typename value_type &gt; </td></tr>
<tr class="memitem:a05bd24053308e7d7f4db8a89e4d514cf"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; Epetra_CrsGraph &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_stokhos.html#a05bd24053308e7d7f4db8a89e4d514cf">sparse3Tensor2CrsGraph</a> (const <a class="el" href="class_stokhos_1_1_sparse3_tensor.html">Stokhos::Sparse3Tensor</a>&lt; ordinal_type, value_type &gt; &amp;Cijk, const Epetra_BlockMap &amp;map)</td></tr>
<tr class="memdesc:a05bd24053308e7d7f4db8a89e4d514cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an Epetra_CrsGraph from a sparse 3 tensor.  <br /></td></tr>
<tr class="separator:a05bd24053308e7d7f4db8a89e4d514cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d830caef29ebac685e6381b5e7bf3d" id="r_ab4d830caef29ebac685e6381b5e7bf3d"><td class="memTemplParams" colspan="2"><a id="ab4d830caef29ebac685e6381b5e7bf3d" name="ab4d830caef29ebac685e6381b5e7bf3d"></a>
template&lt;typename ordinal_type , typename value_type &gt; </td></tr>
<tr class="memitem:ab4d830caef29ebac685e6381b5e7bf3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sparse3Tensor2MatrixMarket</b> (const <a class="el" href="class_stokhos_1_1_orthog_poly_basis.html">Stokhos::OrthogPolyBasis</a>&lt; ordinal_type, value_type &gt; &amp;basis, const <a class="el" href="class_stokhos_1_1_sparse3_tensor.html">Stokhos::Sparse3Tensor</a>&lt; ordinal_type, value_type &gt; &amp;Cijk, const Epetra_Comm &amp;comm, const std::string &amp;file)</td></tr>
<tr class="separator:ab4d830caef29ebac685e6381b5e7bf3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2412afad329ab6f5491587f20a209452" id="r_a2412afad329ab6f5491587f20a209452"><td class="memTemplParams" colspan="2"><a id="a2412afad329ab6f5491587f20a209452" name="a2412afad329ab6f5491587f20a209452"></a>
template&lt;typename ordinal_type , typename value_type &gt; </td></tr>
<tr class="memitem:a2412afad329ab6f5491587f20a209452"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sparse3Tensor2MatrixMarket</b> (const <a class="el" href="class_stokhos_1_1_sparse3_tensor.html">Stokhos::Sparse3Tensor</a>&lt; ordinal_type, value_type &gt; &amp;Cijk, const Epetra_BlockMap &amp;map, const std::string &amp;file)</td></tr>
<tr class="separator:a2412afad329ab6f5491587f20a209452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc238ef06e611e32b0e8dace38d3130" id="r_a2dc238ef06e611e32b0e8dace38d3130"><td class="memTemplParams" colspan="2"><a id="a2dc238ef06e611e32b0e8dace38d3130" name="a2dc238ef06e611e32b0e8dace38d3130"></a>
template&lt;typename coeff_type &gt; </td></tr>
<tr class="memitem:a2dc238ef06e611e32b0e8dace38d3130"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="class_stokhos_1_1_vector_orthog_poly.html">VectorOrthogPoly</a>&lt; coeff_type &gt; &amp;vec)</td></tr>
<tr class="separator:a2dc238ef06e611e32b0e8dace38d3130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d856ff5d8229efbacb8b0959190b47" id="r_ac6d856ff5d8229efbacb8b0959190b47"><td class="memTemplParams" colspan="2"><a id="ac6d856ff5d8229efbacb8b0959190b47" name="ac6d856ff5d8229efbacb8b0959190b47"></a>
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ac6d856ff5d8229efbacb8b0959190b47"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><b>shfl_down</b> (const Scalar &amp;val, const int &amp;delta, const int &amp;width)</td></tr>
<tr class="separator:ac6d856ff5d8229efbacb8b0959190b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1d67b7140df8951fd275e9d15bb4ce" id="r_aaf1d67b7140df8951fd275e9d15bb4ce"><td class="memTemplParams" colspan="2"><a id="aaf1d67b7140df8951fd275e9d15bb4ce" name="aaf1d67b7140df8951fd275e9d15bb4ce"></a>
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:aaf1d67b7140df8951fd275e9d15bb4ce"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><b>shfl_up</b> (const Scalar &amp;val, const int &amp;delta, const int &amp;width)</td></tr>
<tr class="separator:aaf1d67b7140df8951fd275e9d15bb4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04d55e7c62e8647878d84e9a619ca91" id="r_ad04d55e7c62e8647878d84e9a619ca91"><td class="memTemplParams" colspan="2"><a id="ad04d55e7c62e8647878d84e9a619ca91" name="ad04d55e7c62e8647878d84e9a619ca91"></a>
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ad04d55e7c62e8647878d84e9a619ca91"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><b>shfl_down</b> (const Scalar &amp;val, const int &amp;delta, const int &amp;width, const int &amp;mask)</td></tr>
<tr class="separator:ad04d55e7c62e8647878d84e9a619ca91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00caa9f8307b27b367701604d7352d3c" id="r_a00caa9f8307b27b367701604d7352d3c"><td class="memTemplParams" colspan="2"><a id="a00caa9f8307b27b367701604d7352d3c" name="a00caa9f8307b27b367701604d7352d3c"></a>
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a00caa9f8307b27b367701604d7352d3c"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><b>shfl_up</b> (const Scalar &amp;val, const int &amp;delta, const int &amp;width, const int &amp;mask)</td></tr>
<tr class="separator:a00caa9f8307b27b367701604d7352d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8ad9a7759f87851fb34af6d5116a15" id="r_a4a8ad9a7759f87851fb34af6d5116a15"><td class="memItemLeft" align="right" valign="top"><a id="a4a8ad9a7759f87851fb34af6d5116a15" name="a4a8ad9a7759f87851fb34af6d5116a15"></a>
KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memItemRight" valign="bottom"><b>sync_warp</b> (const int &amp;mask)</td></tr>
<tr class="separator:a4a8ad9a7759f87851fb34af6d5116a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c0897911ccecf4710dd783a0b92fb9" id="r_a39c0897911ccecf4710dd783a0b92fb9"><td class="memTemplParams" colspan="2"><a id="a39c0897911ccecf4710dd783a0b92fb9" name="a39c0897911ccecf4710dd783a0b92fb9"></a>
template&lt;class Device , bool Pack, typename OrdinalType , typename ValueType &gt; </td></tr>
<tr class="memitem:a39c0897911ccecf4710dd783a0b92fb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_stokhos_1_1_coo_product_tensor.html">CooProductTensor</a>&lt; ValueType, Device, Pack &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_coo_product_tensor</b> (const <a class="el" href="class_stokhos_1_1_product_basis.html">Stokhos::ProductBasis</a>&lt; OrdinalType, ValueType &gt; &amp;basis, const <a class="el" href="class_stokhos_1_1_sparse3_tensor.html">Stokhos::Sparse3Tensor</a>&lt; OrdinalType, ValueType &gt; &amp;Cijk, const Teuchos::ParameterList &amp;params=Teuchos::ParameterList())</td></tr>
<tr class="separator:a39c0897911ccecf4710dd783a0b92fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a1b199883eca8f03b80548bcf1219f" id="r_a74a1b199883eca8f03b80548bcf1219f"><td class="memTemplParams" colspan="2"><a id="a74a1b199883eca8f03b80548bcf1219f" name="a74a1b199883eca8f03b80548bcf1219f"></a>
template&lt;typename ValueType , typename Device , bool Pack&gt; </td></tr>
<tr class="memitem:a74a1b199883eca8f03b80548bcf1219f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="class_stokhos_1_1_coo_product_tensor.html">CooProductTensor</a>&lt; ValueType, Device, Pack &gt; &amp;tensor)</td></tr>
<tr class="separator:a74a1b199883eca8f03b80548bcf1219f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f54ee4c4630716b5a42a60d28b6113" id="r_af4f54ee4c4630716b5a42a60d28b6113"><td class="memTemplParams" colspan="2"><a id="af4f54ee4c4630716b5a42a60d28b6113" name="af4f54ee4c4630716b5a42a60d28b6113"></a>
template&lt;typename MatrixValue , typename Layout , typename Device , typename InputMultiVectorType , typename OutputMultiVectorType , typename OrdinalType &gt; </td></tr>
<tr class="memitem:af4f54ee4c4630716b5a42a60d28b6113"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multiply</b> (const <a class="el" href="class_stokhos_1_1_crs_matrix.html">CrsMatrix</a>&lt; MatrixValue, Device, Layout &gt; &amp;A, const InputMultiVectorType &amp;x, OutputMultiVectorType &amp;y, const std::vector&lt; OrdinalType &gt; &amp;col_indices, <a class="el" href="class_stokhos_1_1_single_column_multivector_multiply.html">SingleColumnMultivectorMultiply</a>)</td></tr>
<tr class="separator:af4f54ee4c4630716b5a42a60d28b6113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d51801398d4e3b89a9d924b12123900" id="r_a6d51801398d4e3b89a9d924b12123900"><td class="memTemplParams" colspan="2"><a id="a6d51801398d4e3b89a9d924b12123900" name="a6d51801398d4e3b89a9d924b12123900"></a>
template&lt;typename MatrixValue , typename Layout , typename Device , typename InputVectorType , typename OutputVectorType &gt; </td></tr>
<tr class="memitem:a6d51801398d4e3b89a9d924b12123900"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multiply</b> (const <a class="el" href="class_stokhos_1_1_crs_matrix.html">CrsMatrix</a>&lt; MatrixValue, Device, Layout &gt; &amp;A, const std::vector&lt; InputVectorType &gt; &amp;x, std::vector&lt; OutputVectorType &gt; &amp;y, <a class="el" href="class_stokhos_1_1_single_column_multivector_multiply.html">SingleColumnMultivectorMultiply</a>)</td></tr>
<tr class="separator:a6d51801398d4e3b89a9d924b12123900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3784ce7c4368b000a03761d97a64f964" id="r_a3784ce7c4368b000a03761d97a64f964"><td class="memTemplParams" colspan="2"><a id="a3784ce7c4368b000a03761d97a64f964" name="a3784ce7c4368b000a03761d97a64f964"></a>
template&lt;class Device , typename OrdinalType , typename ValueType &gt; </td></tr>
<tr class="memitem:a3784ce7c4368b000a03761d97a64f964"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_stokhos_1_1_crs_product_tensor.html">CrsProductTensor</a>&lt; ValueType, Device &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_product_tensor</b> (const <a class="el" href="class_stokhos_1_1_product_basis.html">Stokhos::ProductBasis</a>&lt; OrdinalType, ValueType &gt; &amp;basis, const <a class="el" href="class_stokhos_1_1_sparse3_tensor.html">Stokhos::Sparse3Tensor</a>&lt; OrdinalType, ValueType &gt; &amp;Cijk, const Teuchos::ParameterList &amp;params=Teuchos::ParameterList())</td></tr>
<tr class="separator:a3784ce7c4368b000a03761d97a64f964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae03e0bb51d09c78fc410e0ce8f6f20" id="r_a1ae03e0bb51d09c78fc410e0ce8f6f20"><td class="memTemplParams" colspan="2"><a id="a1ae03e0bb51d09c78fc410e0ce8f6f20" name="a1ae03e0bb51d09c78fc410e0ce8f6f20"></a>
template&lt;class Device , typename OrdinalType , typename ValueType , class Memory &gt; </td></tr>
<tr class="memitem:a1ae03e0bb51d09c78fc410e0ce8f6f20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_stokhos_1_1_crs_product_tensor.html">CrsProductTensor</a>&lt; ValueType, Device, Memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_product_tensor</b> (const <a class="el" href="class_stokhos_1_1_product_basis.html">Stokhos::ProductBasis</a>&lt; OrdinalType, ValueType &gt; &amp;basis, const <a class="el" href="class_stokhos_1_1_sparse3_tensor.html">Stokhos::Sparse3Tensor</a>&lt; OrdinalType, ValueType &gt; &amp;Cijk, const Teuchos::ParameterList &amp;params=Teuchos::ParameterList())</td></tr>
<tr class="separator:a1ae03e0bb51d09c78fc410e0ce8f6f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4005123e895b4129d40b02a886da48" id="r_acb4005123e895b4129d40b02a886da48"><td class="memTemplParams" colspan="2"><a id="acb4005123e895b4129d40b02a886da48" name="acb4005123e895b4129d40b02a886da48"></a>
template&lt;class Device , typename OrdinalType , typename ValueType &gt; </td></tr>
<tr class="memitem:acb4005123e895b4129d40b02a886da48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_stokhos_1_1_crs_product_tensor.html">CrsProductTensor</a>&lt; ValueType, Device &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_mean_based_product_tensor</b> ()</td></tr>
<tr class="separator:acb4005123e895b4129d40b02a886da48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90dae5082018f8835ef025e130dd7ec0" id="r_a90dae5082018f8835ef025e130dd7ec0"><td class="memTemplParams" colspan="2"><a id="a90dae5082018f8835ef025e130dd7ec0" name="a90dae5082018f8835ef025e130dd7ec0"></a>
template&lt;class Device , typename OrdinalType , typename ValueType , class Memory &gt; </td></tr>
<tr class="memitem:a90dae5082018f8835ef025e130dd7ec0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_stokhos_1_1_crs_product_tensor.html">CrsProductTensor</a>&lt; ValueType, Device, Memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_mean_based_product_tensor</b> ()</td></tr>
<tr class="separator:a90dae5082018f8835ef025e130dd7ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae540f4b95a69236ec0467b68aaff0b4e" id="r_ae540f4b95a69236ec0467b68aaff0b4e"><td class="memTemplParams" colspan="2"><a id="ae540f4b95a69236ec0467b68aaff0b4e" name="ae540f4b95a69236ec0467b68aaff0b4e"></a>
template&lt;class ValueType , class Device , class Memory &gt; </td></tr>
<tr class="memitem:ae540f4b95a69236ec0467b68aaff0b4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_stokhos_1_1_crs_product_tensor.html">CrsProductTensor</a>&lt; ValueType, Device, Memory &gt;::host_mirror_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_mirror_view</b> (const <a class="el" href="class_stokhos_1_1_crs_product_tensor.html">CrsProductTensor</a>&lt; ValueType, Device, Memory &gt; &amp;src)</td></tr>
<tr class="separator:ae540f4b95a69236ec0467b68aaff0b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fe6243b3315798ca7508cb13f29f11" id="r_aa3fe6243b3315798ca7508cb13f29f11"><td class="memTemplParams" colspan="2"><a id="aa3fe6243b3315798ca7508cb13f29f11" name="aa3fe6243b3315798ca7508cb13f29f11"></a>
template&lt;class ValueType , class DstDevice , class DstMemory , class SrcDevice , class SrcMemory &gt; </td></tr>
<tr class="memitem:aa3fe6243b3315798ca7508cb13f29f11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deep_copy</b> (const <a class="el" href="class_stokhos_1_1_crs_product_tensor.html">CrsProductTensor</a>&lt; ValueType, DstDevice, DstMemory &gt; &amp;dst, const <a class="el" href="class_stokhos_1_1_crs_product_tensor.html">CrsProductTensor</a>&lt; ValueType, SrcDevice, SrcMemory &gt; &amp;src)</td></tr>
<tr class="separator:aa3fe6243b3315798ca7508cb13f29f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e3cfd7a3e4e25d9b3e3c070ef4bbe7" id="r_ae6e3cfd7a3e4e25d9b3e3c070ef4bbe7"><td class="memTemplParams" colspan="2"><a id="ae6e3cfd7a3e4e25d9b3e3c070ef4bbe7" name="ae6e3cfd7a3e4e25d9b3e3c070ef4bbe7"></a>
template&lt;class Device , typename OrdinalType , typename ValueType &gt; </td></tr>
<tr class="memitem:ae6e3cfd7a3e4e25d9b3e3c070ef4bbe7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_stokhos_1_1_flat_sparse3_tensor.html">FlatSparse3Tensor</a>&lt; ValueType, Device &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_flat_sparse_3_tensor</b> (const <a class="el" href="class_stokhos_1_1_product_basis.html">Stokhos::ProductBasis</a>&lt; OrdinalType, ValueType &gt; &amp;basis, const <a class="el" href="class_stokhos_1_1_sparse3_tensor.html">Stokhos::Sparse3Tensor</a>&lt; OrdinalType, ValueType &gt; &amp;Cijk, const Teuchos::ParameterList &amp;params=Teuchos::ParameterList())</td></tr>
<tr class="separator:ae6e3cfd7a3e4e25d9b3e3c070ef4bbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ffea196bf6bdd88478bd2637ecf5667" id="r_a2ffea196bf6bdd88478bd2637ecf5667"><td class="memTemplParams" colspan="2"><a id="a2ffea196bf6bdd88478bd2637ecf5667" name="a2ffea196bf6bdd88478bd2637ecf5667"></a>
template&lt;class Device , typename OrdinalType , typename ValueType &gt; </td></tr>
<tr class="memitem:a2ffea196bf6bdd88478bd2637ecf5667"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_stokhos_1_1_flat_sparse3_tensor__kji.html">FlatSparse3Tensor_kji</a>&lt; ValueType, Device &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_flat_sparse_3_tensor_kji</b> (const <a class="el" href="class_stokhos_1_1_product_basis.html">Stokhos::ProductBasis</a>&lt; OrdinalType, ValueType &gt; &amp;basis, const <a class="el" href="class_stokhos_1_1_sparse3_tensor.html">Stokhos::Sparse3Tensor</a>&lt; OrdinalType, ValueType &gt; &amp;Cijk, const Teuchos::ParameterList &amp;params=Teuchos::ParameterList())</td></tr>
<tr class="separator:a2ffea196bf6bdd88478bd2637ecf5667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea787ad99d8a92e425b58790ccbc744" id="r_a0ea787ad99d8a92e425b58790ccbc744"><td class="memTemplParams" colspan="2"><a id="a0ea787ad99d8a92e425b58790ccbc744" name="a0ea787ad99d8a92e425b58790ccbc744"></a>
template&lt;class Device , typename OrdinalType , typename ValueType &gt; </td></tr>
<tr class="memitem:a0ea787ad99d8a92e425b58790ccbc744"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_stokhos_1_1_lexicographic_block_sparse3_tensor.html">LexicographicBlockSparse3Tensor</a>&lt; ValueType, Device &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_lexicographic_block_sparse_3_tensor</b> (const <a class="el" href="class_stokhos_1_1_product_basis.html">Stokhos::ProductBasis</a>&lt; OrdinalType, ValueType &gt; &amp;basis, const <a class="el" href="class_stokhos_1_1_l_t_b_sparse3_tensor.html">Stokhos::LTBSparse3Tensor</a>&lt; OrdinalType, ValueType &gt; &amp;Cijk, const Teuchos::ParameterList &amp;params=Teuchos::ParameterList())</td></tr>
<tr class="separator:a0ea787ad99d8a92e425b58790ccbc744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e82325bf3444b748bf20e30651179f" id="r_ab4e82325bf3444b748bf20e30651179f"><td class="memTemplParams" colspan="2"><a id="ab4e82325bf3444b748bf20e30651179f" name="ab4e82325bf3444b748bf20e30651179f"></a>
template&lt;class Device , typename OrdinalType , typename ValueType , int BlockSize&gt; </td></tr>
<tr class="memitem:ab4e82325bf3444b748bf20e30651179f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_stokhos_1_1_linear_sparse3_tensor.html">LinearSparse3Tensor</a>&lt; ValueType, Device, BlockSize &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_linear_sparse_3_tensor</b> (const <a class="el" href="class_stokhos_1_1_product_basis.html">Stokhos::ProductBasis</a>&lt; OrdinalType, ValueType &gt; &amp;basis, const <a class="el" href="class_stokhos_1_1_sparse3_tensor.html">Stokhos::Sparse3Tensor</a>&lt; OrdinalType, ValueType &gt; &amp;Cijk, const Teuchos::ParameterList &amp;params)</td></tr>
<tr class="separator:ab4e82325bf3444b748bf20e30651179f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaeca61883bb4f13415f370d8f058fd6" id="r_aaaeca61883bb4f13415f370d8f058fd6"><td class="memTemplParams" colspan="2"><a id="aaaeca61883bb4f13415f370d8f058fd6" name="aaaeca61883bb4f13415f370d8f058fd6"></a>
template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:aaaeca61883bb4f13415f370d8f058fd6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>write_matrix_market</b> (const MatrixType &amp;A, const std::string &amp;filename)</td></tr>
<tr class="separator:aaaeca61883bb4f13415f370d8f058fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8610bba379c1030de1aedc23661aa8" id="r_aff8610bba379c1030de1aedc23661aa8"><td class="memTemplParams" colspan="2"><a id="aff8610bba379c1030de1aedc23661aa8" name="aff8610bba379c1030de1aedc23661aa8"></a>
template&lt;typename MatrixType , typename InputVectorType , typename OutputVectorType &gt; </td></tr>
<tr class="memitem:aff8610bba379c1030de1aedc23661aa8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multiply</b> (const MatrixType &amp;A, const InputVectorType &amp;x, OutputVectorType &amp;y)</td></tr>
<tr class="separator:aff8610bba379c1030de1aedc23661aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ce5d2509dd213755255d140c6dc83e" id="r_a70ce5d2509dd213755255d140c6dc83e"><td class="memTemplParams" colspan="2"><a id="a70ce5d2509dd213755255d140c6dc83e" name="a70ce5d2509dd213755255d140c6dc83e"></a>
template&lt;typename MatrixType , typename InputVectorType , typename OutputVectorType &gt; </td></tr>
<tr class="memitem:a70ce5d2509dd213755255d140c6dc83e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multiply</b> (const MatrixType &amp;A, const InputVectorType &amp;x, OutputVectorType &amp;y, <a class="el" href="class_stokhos_1_1_default_multiply.html">DefaultMultiply</a> tag)</td></tr>
<tr class="separator:a70ce5d2509dd213755255d140c6dc83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d438a9843b7b4df1311779cdaf741ca" id="r_a8d438a9843b7b4df1311779cdaf741ca"><td class="memTemplParams" colspan="2"><a id="a8d438a9843b7b4df1311779cdaf741ca" name="a8d438a9843b7b4df1311779cdaf741ca"></a>
template&lt;typename MatrixType , typename InputVectorType , typename OutputVectorType , typename ColumnIndicesType &gt; </td></tr>
<tr class="memitem:a8d438a9843b7b4df1311779cdaf741ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multiply</b> (const MatrixType &amp;A, const InputVectorType &amp;x, OutputVectorType &amp;y, const ColumnIndicesType &amp;col)</td></tr>
<tr class="separator:a8d438a9843b7b4df1311779cdaf741ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02c0d524fb65c985569d2cb879bc53e" id="r_aa02c0d524fb65c985569d2cb879bc53e"><td class="memTemplParams" colspan="2"><a id="aa02c0d524fb65c985569d2cb879bc53e" name="aa02c0d524fb65c985569d2cb879bc53e"></a>
template&lt;typename MatrixType , typename InputVectorType , typename OutputVectorType , typename ColumnIndicesType &gt; </td></tr>
<tr class="memitem:aa02c0d524fb65c985569d2cb879bc53e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multiply</b> (const MatrixType &amp;A, const InputVectorType &amp;x, OutputVectorType &amp;y, const ColumnIndicesType &amp;col, <a class="el" href="class_stokhos_1_1_default_multiply.html">DefaultMultiply</a> tag)</td></tr>
<tr class="separator:aa02c0d524fb65c985569d2cb879bc53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc758b59d4099d123b33375137fe262" id="r_a4dc758b59d4099d123b33375137fe262"><td class="memTemplParams" colspan="2"><a id="a4dc758b59d4099d123b33375137fe262" name="a4dc758b59d4099d123b33375137fe262"></a>
template&lt;class Device , typename OrdinalType , typename ValueType &gt; </td></tr>
<tr class="memitem:a4dc758b59d4099d123b33375137fe262"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_stokhos_1_1_simple_tiled_crs_product_tensor.html">SimpleTiledCrsProductTensor</a>&lt; ValueType, Device &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_simple_tiled_product_tensor</b> (const <a class="el" href="class_stokhos_1_1_product_basis.html">Stokhos::ProductBasis</a>&lt; OrdinalType, ValueType &gt; &amp;basis, const <a class="el" href="class_stokhos_1_1_sparse3_tensor.html">Stokhos::Sparse3Tensor</a>&lt; OrdinalType, ValueType &gt; &amp;Cijk, const Teuchos::ParameterList &amp;params)</td></tr>
<tr class="separator:a4dc758b59d4099d123b33375137fe262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e789b4992ba727b6f2f6367e78968d" id="r_ac6e789b4992ba727b6f2f6367e78968d"><td class="memTemplParams" colspan="2"><a id="ac6e789b4992ba727b6f2f6367e78968d" name="ac6e789b4992ba727b6f2f6367e78968d"></a>
template&lt;typename TensorType , typename OrdinalType , typename ValueType , typename CijkType &gt; </td></tr>
<tr class="memitem:ac6e789b4992ba727b6f2f6367e78968d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_stokhos_1_1_stochastic_product_tensor.html">StochasticProductTensor</a>&lt; ValueType, TensorType, typename TensorType::execution_space &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_stochastic_product_tensor</b> (const <a class="el" href="class_stokhos_1_1_product_basis.html">Stokhos::ProductBasis</a>&lt; OrdinalType, ValueType &gt; &amp;basis, const CijkType &amp;Cijk, const Teuchos::ParameterList &amp;params=Teuchos::ParameterList())</td></tr>
<tr class="separator:ac6e789b4992ba727b6f2f6367e78968d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711e6fccbad819caf01ae30ffc599745" id="r_a711e6fccbad819caf01ae30ffc599745"><td class="memTemplParams" colspan="2"><a id="a711e6fccbad819caf01ae30ffc599745" name="a711e6fccbad819caf01ae30ffc599745"></a>
template&lt;class Device , typename OrdinalType , typename ValueType &gt; </td></tr>
<tr class="memitem:a711e6fccbad819caf01ae30ffc599745"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_stokhos_1_1_tiled_crs_product_tensor.html">TiledCrsProductTensor</a>&lt; ValueType, Device &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_tiled_product_tensor</b> (const <a class="el" href="class_stokhos_1_1_product_basis.html">Stokhos::ProductBasis</a>&lt; OrdinalType, ValueType &gt; &amp;basis, const <a class="el" href="class_stokhos_1_1_sparse3_tensor.html">Stokhos::Sparse3Tensor</a>&lt; OrdinalType, ValueType &gt; &amp;Cijk, const Teuchos::ParameterList &amp;params)</td></tr>
<tr class="separator:a711e6fccbad819caf01ae30ffc599745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde7ffb0d53a25311a648fd6a94941ae" id="r_abde7ffb0d53a25311a648fd6a94941ae"><td class="memTemplParams" colspan="2"><a id="abde7ffb0d53a25311a648fd6a94941ae" name="abde7ffb0d53a25311a648fd6a94941ae"></a>
template&lt;typename ValueType , typename VectorType &gt; </td></tr>
<tr class="memitem:abde7ffb0d53a25311a648fd6a94941ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>update</b> (const ValueType &amp;alpha, VectorType &amp;x, const ValueType &amp;beta, const VectorType &amp;y)</td></tr>
<tr class="separator:abde7ffb0d53a25311a648fd6a94941ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311835aeebc29d57453c272a1d95b594" id="r_a311835aeebc29d57453c272a1d95b594"><td class="memTemplParams" colspan="2"><a id="a311835aeebc29d57453c272a1d95b594" name="a311835aeebc29d57453c272a1d95b594"></a>
template&lt;typename LocalOrdinal , typename GlobalOrdinal , typename Node , typename CijkType &gt; </td></tr>
<tr class="memitem:a311835aeebc29d57453c272a1d95b594"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; Tpetra::CrsGraph&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_cijk_crs_graph</b> (const CijkType &amp;cijk_dev, const Teuchos::RCP&lt; const Teuchos::Comm&lt; int &gt; &gt; &amp;comm, const size_t matrix_pce_size)</td></tr>
<tr class="separator:a311835aeebc29d57453c272a1d95b594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8fa85f16df75f20bb07579e56e0d8a" id="r_a1e8fa85f16df75f20bb07579e56e0d8a"><td class="memTemplParams" colspan="2"><a id="a1e8fa85f16df75f20bb07579e56e0d8a" name="a1e8fa85f16df75f20bb07579e56e0d8a"></a>
template&lt;typename LocalOrdinal , typename GlobalOrdinal , typename Node , typename CijkType &gt; </td></tr>
<tr class="memitem:a1e8fa85f16df75f20bb07579e56e0d8a"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; Tpetra::CrsGraph&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_flat_pce_graph</b> (const Tpetra::CrsGraph&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &amp;graph, const CijkType &amp;cijk, Teuchos::RCP&lt; const Tpetra::Map&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt; &amp;flat_domain_map, Teuchos::RCP&lt; const Tpetra::Map&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt; &amp;flat_range_map, Teuchos::RCP&lt; const Tpetra::CrsGraph&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt; &amp;cijk_graph, const size_t matrix_pce_size)</td></tr>
<tr class="separator:a1e8fa85f16df75f20bb07579e56e0d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7588f01d3397a90910630a7537d26c6d" id="r_a7588f01d3397a90910630a7537d26c6d"><td class="memTemplParams" colspan="2"><a id="a7588f01d3397a90910630a7537d26c6d" name="a7588f01d3397a90910630a7537d26c6d"></a>
template&lt;typename Storage , typename LocalOrdinal , typename GlobalOrdinal , typename Node &gt; </td></tr>
<tr class="memitem:a7588f01d3397a90910630a7537d26c6d"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; const Tpetra::MultiVector&lt; typename Storage::value_type, LocalOrdinal, GlobalOrdinal, Node &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_flat_vector_view</b> (const Tpetra::MultiVector&lt; <a class="el" href="class_sacado_1_1_u_q_1_1_p_c_e.html">Sacado::UQ::PCE</a>&lt; Storage &gt;, LocalOrdinal, GlobalOrdinal, Node &gt; &amp;vec, const Teuchos::RCP&lt; const Tpetra::Map&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt; &amp;flat_map)</td></tr>
<tr class="separator:a7588f01d3397a90910630a7537d26c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5d042918ff99088bb57c728ab962e4" id="r_acf5d042918ff99088bb57c728ab962e4"><td class="memTemplParams" colspan="2"><a id="acf5d042918ff99088bb57c728ab962e4" name="acf5d042918ff99088bb57c728ab962e4"></a>
template&lt;typename Storage , typename LocalOrdinal , typename GlobalOrdinal , typename Node &gt; </td></tr>
<tr class="memitem:acf5d042918ff99088bb57c728ab962e4"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; Tpetra::MultiVector&lt; typename Storage::value_type, LocalOrdinal, GlobalOrdinal, Node &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_flat_vector_view</b> (Tpetra::MultiVector&lt; <a class="el" href="class_sacado_1_1_u_q_1_1_p_c_e.html">Sacado::UQ::PCE</a>&lt; Storage &gt;, LocalOrdinal, GlobalOrdinal, Node &gt; &amp;vec, const Teuchos::RCP&lt; const Tpetra::Map&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt; &amp;flat_map)</td></tr>
<tr class="separator:acf5d042918ff99088bb57c728ab962e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a51ef21d9744389b23ad31d4f05efb" id="r_a43a51ef21d9744389b23ad31d4f05efb"><td class="memTemplParams" colspan="2"><a id="a43a51ef21d9744389b23ad31d4f05efb" name="a43a51ef21d9744389b23ad31d4f05efb"></a>
template&lt;typename Storage , typename LocalOrdinal , typename GlobalOrdinal , typename Node &gt; </td></tr>
<tr class="memitem:a43a51ef21d9744389b23ad31d4f05efb"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; const Tpetra::MultiVector&lt; typename Storage::value_type, LocalOrdinal, GlobalOrdinal, Node &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_flat_vector_view</b> (const Tpetra::MultiVector&lt; <a class="el" href="class_sacado_1_1_u_q_1_1_p_c_e.html">Sacado::UQ::PCE</a>&lt; Storage &gt;, LocalOrdinal, GlobalOrdinal, Node &gt; &amp;vec, Teuchos::RCP&lt; const Tpetra::Map&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt; &amp;flat_map)</td></tr>
<tr class="separator:a43a51ef21d9744389b23ad31d4f05efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf9cc1579659ce8b7db79e19b294572" id="r_aedf9cc1579659ce8b7db79e19b294572"><td class="memTemplParams" colspan="2"><a id="aedf9cc1579659ce8b7db79e19b294572" name="aedf9cc1579659ce8b7db79e19b294572"></a>
template&lt;typename Storage , typename LocalOrdinal , typename GlobalOrdinal , typename Node &gt; </td></tr>
<tr class="memitem:aedf9cc1579659ce8b7db79e19b294572"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; Tpetra::MultiVector&lt; typename Storage::value_type, LocalOrdinal, GlobalOrdinal, Node &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_flat_vector_view</b> (Tpetra::MultiVector&lt; <a class="el" href="class_sacado_1_1_u_q_1_1_p_c_e.html">Sacado::UQ::PCE</a>&lt; Storage &gt;, LocalOrdinal, GlobalOrdinal, Node &gt; &amp;vec, Teuchos::RCP&lt; const Tpetra::Map&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt; &amp;flat_map)</td></tr>
<tr class="separator:aedf9cc1579659ce8b7db79e19b294572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78469658677a8ec62fc9267fa1a7773c" id="r_a78469658677a8ec62fc9267fa1a7773c"><td class="memTemplParams" colspan="2"><a id="a78469658677a8ec62fc9267fa1a7773c" name="a78469658677a8ec62fc9267fa1a7773c"></a>
template&lt;typename Storage , typename LocalOrdinal , typename GlobalOrdinal , typename Node &gt; </td></tr>
<tr class="memitem:a78469658677a8ec62fc9267fa1a7773c"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; const Tpetra::Vector&lt; typename Storage::value_type, LocalOrdinal, GlobalOrdinal, Node &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_flat_vector_view</b> (const Tpetra::Vector&lt; <a class="el" href="class_sacado_1_1_u_q_1_1_p_c_e.html">Sacado::UQ::PCE</a>&lt; Storage &gt;, LocalOrdinal, GlobalOrdinal, Node &gt; &amp;vec_const, const Teuchos::RCP&lt; const Tpetra::Map&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt; &amp;flat_map)</td></tr>
<tr class="separator:a78469658677a8ec62fc9267fa1a7773c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7ea29bfc7787c79cd617cec33cdcc5" id="r_a6b7ea29bfc7787c79cd617cec33cdcc5"><td class="memTemplParams" colspan="2"><a id="a6b7ea29bfc7787c79cd617cec33cdcc5" name="a6b7ea29bfc7787c79cd617cec33cdcc5"></a>
template&lt;typename Storage , typename LocalOrdinal , typename GlobalOrdinal , typename Node &gt; </td></tr>
<tr class="memitem:a6b7ea29bfc7787c79cd617cec33cdcc5"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; const Tpetra::Vector&lt; typename Storage::value_type, LocalOrdinal, GlobalOrdinal, Node &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_flat_vector_view</b> (const Tpetra::Vector&lt; <a class="el" href="class_sacado_1_1_u_q_1_1_p_c_e.html">Sacado::UQ::PCE</a>&lt; Storage &gt;, LocalOrdinal, GlobalOrdinal, Node &gt; &amp;vec, Teuchos::RCP&lt; const Tpetra::Map&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt; &amp;flat_map)</td></tr>
<tr class="separator:a6b7ea29bfc7787c79cd617cec33cdcc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fc1f7a6df5874d73b68aab3f35a2c1" id="r_a29fc1f7a6df5874d73b68aab3f35a2c1"><td class="memTemplParams" colspan="2"><a id="a29fc1f7a6df5874d73b68aab3f35a2c1" name="a29fc1f7a6df5874d73b68aab3f35a2c1"></a>
template&lt;typename Storage , typename LocalOrdinal , typename GlobalOrdinal , typename Node &gt; </td></tr>
<tr class="memitem:a29fc1f7a6df5874d73b68aab3f35a2c1"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; Tpetra::Vector&lt; typename Storage::value_type, LocalOrdinal, GlobalOrdinal, Node &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_flat_vector_view</b> (Tpetra::Vector&lt; <a class="el" href="class_sacado_1_1_u_q_1_1_p_c_e.html">Sacado::UQ::PCE</a>&lt; Storage &gt;, LocalOrdinal, GlobalOrdinal, Node &gt; &amp;vec, const Teuchos::RCP&lt; const Tpetra::Map&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt; &amp;flat_map)</td></tr>
<tr class="separator:a29fc1f7a6df5874d73b68aab3f35a2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac149214b7134e817491cad320f45dd12" id="r_ac149214b7134e817491cad320f45dd12"><td class="memTemplParams" colspan="2"><a id="ac149214b7134e817491cad320f45dd12" name="ac149214b7134e817491cad320f45dd12"></a>
template&lt;typename Storage , typename LocalOrdinal , typename GlobalOrdinal , typename Node &gt; </td></tr>
<tr class="memitem:ac149214b7134e817491cad320f45dd12"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; Tpetra::Vector&lt; typename Storage::value_type, LocalOrdinal, GlobalOrdinal, Node &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_flat_vector_view</b> (Tpetra::Vector&lt; <a class="el" href="class_sacado_1_1_u_q_1_1_p_c_e.html">Sacado::UQ::PCE</a>&lt; Storage &gt;, LocalOrdinal, GlobalOrdinal, Node &gt; &amp;vec, Teuchos::RCP&lt; const Tpetra::Map&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt; &amp;flat_map)</td></tr>
<tr class="separator:ac149214b7134e817491cad320f45dd12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144fbc1bbf3230a7921e764791020196" id="r_a144fbc1bbf3230a7921e764791020196"><td class="memTemplParams" colspan="2"><a id="a144fbc1bbf3230a7921e764791020196" name="a144fbc1bbf3230a7921e764791020196"></a>
template&lt;typename Storage , typename LocalOrdinal , typename GlobalOrdinal , typename Node , typename CijkType &gt; </td></tr>
<tr class="memitem:a144fbc1bbf3230a7921e764791020196"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; Tpetra::CrsMatrix&lt; typename Storage::value_type, LocalOrdinal, GlobalOrdinal, Node &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_flat_matrix</b> (const Tpetra::CrsMatrix&lt; <a class="el" href="class_sacado_1_1_u_q_1_1_p_c_e.html">Sacado::UQ::PCE</a>&lt; Storage &gt;, LocalOrdinal, GlobalOrdinal, Node &gt; &amp;mat, const Teuchos::RCP&lt; const Tpetra::CrsGraph&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt; &amp;flat_graph, const Teuchos::RCP&lt; const Tpetra::CrsGraph&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt; &amp;cijk_graph, const CijkType &amp;cijk_dev)</td></tr>
<tr class="separator:a144fbc1bbf3230a7921e764791020196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab010097c521b8c18dacbfa73a9afdfee" id="r_ab010097c521b8c18dacbfa73a9afdfee"><td class="memTemplParams" colspan="2"><a id="ab010097c521b8c18dacbfa73a9afdfee" name="ab010097c521b8c18dacbfa73a9afdfee"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ab010097c521b8c18dacbfa73a9afdfee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="class_stokhos_1_1aligned__allocator.html">aligned_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="class_stokhos_1_1aligned__allocator.html">aligned_allocator</a>&lt; U &gt; &amp;)</td></tr>
<tr class="separator:ab010097c521b8c18dacbfa73a9afdfee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033c2aefc06380afeb068fc1d0884961" id="r_a033c2aefc06380afeb068fc1d0884961"><td class="memTemplParams" colspan="2"><a id="a033c2aefc06380afeb068fc1d0884961" name="a033c2aefc06380afeb068fc1d0884961"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a033c2aefc06380afeb068fc1d0884961"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_stokhos_1_1aligned__allocator.html">aligned_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="class_stokhos_1_1aligned__allocator.html">aligned_allocator</a>&lt; U &gt; &amp;)</td></tr>
<tr class="separator:a033c2aefc06380afeb068fc1d0884961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff572e8936e5d6aebb3c7b7b3112f93" id="r_a5ff572e8936e5d6aebb3c7b7b3112f93"><td class="memTemplParams" colspan="2"><a id="a5ff572e8936e5d6aebb3c7b7b3112f93" name="a5ff572e8936e5d6aebb3c7b7b3112f93"></a>
template&lt;typename Scalar , typename LO , typename GO , typename N &gt; </td></tr>
<tr class="memitem:a5ff572e8936e5d6aebb3c7b7b3112f93"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; Tpetra::CrsMatrix&lt; Scalar, LO, GO, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>build_mean_matrix</b> (const Tpetra::CrsMatrix&lt; Scalar, LO, GO, N &gt; &amp;A)</td></tr>
<tr class="separator:a5ff572e8936e5d6aebb3c7b7b3112f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21741f6ae5440f6eae55b7880bd35ae0" id="r_a21741f6ae5440f6eae55b7880bd35ae0"><td class="memTemplParams" colspan="2"><a id="a21741f6ae5440f6eae55b7880bd35ae0" name="a21741f6ae5440f6eae55b7880bd35ae0"></a>
template&lt;typename Scalar , typename LO , typename GO , typename N &gt; </td></tr>
<tr class="memitem:a21741f6ae5440f6eae55b7880bd35ae0"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; Tpetra::CrsMatrix&lt; typename Scalar::value_type, LO, GO, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>build_mean_scalar_matrix</b> (const Tpetra::CrsMatrix&lt; Scalar, LO, GO, N &gt; &amp;A)</td></tr>
<tr class="separator:a21741f6ae5440f6eae55b7880bd35ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0b8b53689701f8593d11e09e5a2648" id="r_abb0b8b53689701f8593d11e09e5a2648"><td class="memTemplParams" colspan="2"><a id="abb0b8b53689701f8593d11e09e5a2648" name="abb0b8b53689701f8593d11e09e5a2648"></a>
template&lt;typename DstView , typename SrcView &gt; </td></tr>
<tr class="memitem:abb0b8b53689701f8593d11e09e5a2648"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_pce_to_scalar</b> (const DstView &amp;dst, const SrcView &amp;src)</td></tr>
<tr class="separator:abb0b8b53689701f8593d11e09e5a2648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7cf93334c27a893c2beab1bcbb61e8d" id="r_aa7cf93334c27a893c2beab1bcbb61e8d"><td class="memTemplParams" colspan="2"><a id="aa7cf93334c27a893c2beab1bcbb61e8d" name="aa7cf93334c27a893c2beab1bcbb61e8d"></a>
template&lt;typename DstView , typename SrcView &gt; </td></tr>
<tr class="memitem:aa7cf93334c27a893c2beab1bcbb61e8d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_scalar_to_pce</b> (const DstView &amp;dst, const SrcView &amp;src)</td></tr>
<tr class="separator:aa7cf93334c27a893c2beab1bcbb61e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15578c6f57febd6147b7dfd473c1a4b6" id="r_a15578c6f57febd6147b7dfd473c1a4b6"><td class="memTemplParams" colspan="2"><a id="a15578c6f57febd6147b7dfd473c1a4b6" name="a15578c6f57febd6147b7dfd473c1a4b6"></a>
template&lt;class DataType , class ... Args&gt; <br />
requires (!is_mp_vector_v&lt;typename Kokkos::View&lt;DataType, Args...&gt;::value_type&gt;)</td></tr>
<tr class="memitem:a15578c6f57febd6147b7dfd473c1a4b6"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FUNCTION auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reinterpret_as_unmanaged_scalar_view</b> (const Kokkos::View&lt; DataType, Args... &gt; &amp;view)</td></tr>
<tr class="separator:a15578c6f57febd6147b7dfd473c1a4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef940947daa600cddadcdc1467e8f2d" id="r_aeef940947daa600cddadcdc1467e8f2d"><td class="memTemplParams" colspan="2"><a id="aeef940947daa600cddadcdc1467e8f2d" name="aeef940947daa600cddadcdc1467e8f2d"></a>
template&lt;class DataType , class ... Args&gt; <br />
requires (is_mp_vector_v&lt;typename Kokkos::View&lt;DataType, Args...&gt;::value_type&gt;)</td></tr>
<tr class="memitem:aeef940947daa600cddadcdc1467e8f2d"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FUNCTION auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reinterpret_as_unmanaged_scalar_view</b> (const Kokkos::View&lt; DataType, Args... &gt; &amp;view)</td></tr>
<tr class="separator:aeef940947daa600cddadcdc1467e8f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687a4da9e30f5f4436e279867a867f65" id="r_a687a4da9e30f5f4436e279867a867f65"><td class="memTemplParams" colspan="2"><a id="a687a4da9e30f5f4436e279867a867f65" name="a687a4da9e30f5f4436e279867a867f65"></a>
template&lt;class DataType , class ... Args&gt; <br />
requires (!is_mp_vector_v&lt;typename Kokkos::View&lt;DataType, Args...&gt;::value_type&gt;)</td></tr>
<tr class="memitem:a687a4da9e30f5f4436e279867a867f65"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FUNCTION auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reinterpret_as_unmanaged_scalar_flat_view</b> (const Kokkos::View&lt; DataType, Args... &gt; &amp;view)</td></tr>
<tr class="separator:a687a4da9e30f5f4436e279867a867f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40b1be34442e194cd9b3fa85e987d3c" id="r_ad40b1be34442e194cd9b3fa85e987d3c"><td class="memTemplParams" colspan="2"><a id="ad40b1be34442e194cd9b3fa85e987d3c" name="ad40b1be34442e194cd9b3fa85e987d3c"></a>
template&lt;class DataType , class ... Args&gt; <br />
requires (is_mp_vector_v&lt;typename Kokkos::View&lt;DataType, Args...&gt;::value_type&gt;)</td></tr>
<tr class="memitem:ad40b1be34442e194cd9b3fa85e987d3c"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FUNCTION auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reinterpret_as_unmanaged_scalar_flat_view</b> (const Kokkos::View&lt; DataType, Args... &gt; &amp;view)</td></tr>
<tr class="separator:ad40b1be34442e194cd9b3fa85e987d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a02e78a20563394f573278c8978559" id="r_ae7a02e78a20563394f573278c8978559"><td class="memTemplParams" colspan="2"><a id="ae7a02e78a20563394f573278c8978559" name="ae7a02e78a20563394f573278c8978559"></a>
template&lt;class DataType , class ... Args&gt; <br />
requires (!is_mp_vector_v&lt;typename Kokkos::DualView&lt;DataType, Args...&gt;::value_type&gt;)</td></tr>
<tr class="memitem:ae7a02e78a20563394f573278c8978559"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FUNCTION auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reinterpret_as_unmanaged_scalar_dual_view_of_same_rank</b> (const Kokkos::DualView&lt; DataType, Args... &gt; &amp;view)</td></tr>
<tr class="separator:ae7a02e78a20563394f573278c8978559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e81d8e64d92d25dd735a6d49001ede" id="r_a09e81d8e64d92d25dd735a6d49001ede"><td class="memTemplParams" colspan="2"><a id="a09e81d8e64d92d25dd735a6d49001ede" name="a09e81d8e64d92d25dd735a6d49001ede"></a>
template&lt;class DataType , class ... Args&gt; <br />
requires (is_mp_vector_v&lt;typename Kokkos::View&lt;DataType, Args...&gt;::value_type&gt;)</td></tr>
<tr class="memitem:a09e81d8e64d92d25dd735a6d49001ede"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FUNCTION auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reinterpret_as_unmanaged_scalar_dual_view_of_same_rank</b> (const Kokkos::DualView&lt; DataType, Args... &gt; &amp;view)</td></tr>
<tr class="separator:a09e81d8e64d92d25dd735a6d49001ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449dd328100d535c17dfcc2e7622d3bf" id="r_a449dd328100d535c17dfcc2e7622d3bf"><td class="memTemplParams" colspan="2"><a id="a449dd328100d535c17dfcc2e7622d3bf" name="a449dd328100d535c17dfcc2e7622d3bf"></a>
template&lt;typename Matrix , typename Vector , typename Ordinal &gt; </td></tr>
<tr class="memitem:a449dd328100d535c17dfcc2e7622d3bf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CG_Solve</b> (const Matrix &amp;A, Vector &amp;x, const Vector &amp;b, typename Vector::mag_type tol, Ordinal max_its, std::ostream *out=0)</td></tr>
<tr class="separator:a449dd328100d535c17dfcc2e7622d3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c31a4b7c9ddaf2b9cebe93aeb32971" id="r_a54c31a4b7c9ddaf2b9cebe93aeb32971"><td class="memTemplParams" colspan="2"><a id="a54c31a4b7c9ddaf2b9cebe93aeb32971" name="a54c31a4b7c9ddaf2b9cebe93aeb32971"></a>
template&lt;typename Matrix , typename Vector , typename Prec , typename Ordinal &gt; </td></tr>
<tr class="memitem:a54c31a4b7c9ddaf2b9cebe93aeb32971"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PCG_Solve</b> (const Matrix &amp;A, Vector &amp;x, const Vector &amp;b, const Prec &amp;M, typename Vector::mag_type tol, Ordinal max_its, std::ostream *out=0)</td></tr>
<tr class="separator:a54c31a4b7c9ddaf2b9cebe93aeb32971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e9436452de2869b4e43cc75bf17ff9" id="r_ae0e9436452de2869b4e43cc75bf17ff9"><td class="memTemplParams" colspan="2"><a id="ae0e9436452de2869b4e43cc75bf17ff9" name="ae0e9436452de2869b4e43cc75bf17ff9"></a>
template&lt;typename LocalOrdinal , typename GlobalOrdinal , typename Node &gt; </td></tr>
<tr class="memitem:ae0e9436452de2869b4e43cc75bf17ff9"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; Tpetra::Map&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_flat_map</b> (const Tpetra::Map&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &amp;map, const LocalOrdinal block_size)</td></tr>
<tr class="separator:ae0e9436452de2869b4e43cc75bf17ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40b05419def4a75e83a5a3939987c3a" id="r_ab40b05419def4a75e83a5a3939987c3a"><td class="memTemplParams" colspan="2"><a id="ab40b05419def4a75e83a5a3939987c3a" name="ab40b05419def4a75e83a5a3939987c3a"></a>
template&lt;typename LocalOrdinal , typename GlobalOrdinal , typename Node &gt; </td></tr>
<tr class="memitem:ab40b05419def4a75e83a5a3939987c3a"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; Tpetra::CrsGraph&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_flat_mp_graph</b> (const Tpetra::CrsGraph&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &amp;graph, Teuchos::RCP&lt; const Tpetra::Map&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt; &amp;flat_domain_map, Teuchos::RCP&lt; const Tpetra::Map&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt; &amp;flat_range_map, const LocalOrdinal block_size)</td></tr>
<tr class="separator:ab40b05419def4a75e83a5a3939987c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa101de4ba54c8630cc3fcbbe5adba7b4" id="r_aa101de4ba54c8630cc3fcbbe5adba7b4"><td class="memTemplParams" colspan="2"><a id="aa101de4ba54c8630cc3fcbbe5adba7b4" name="aa101de4ba54c8630cc3fcbbe5adba7b4"></a>
template&lt;typename Storage , typename LocalOrdinal , typename GlobalOrdinal , typename Node &gt; </td></tr>
<tr class="memitem:aa101de4ba54c8630cc3fcbbe5adba7b4"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; Tpetra::MultiVector&lt; typename Storage::value_type, LocalOrdinal, GlobalOrdinal, Node &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_flat_vector_view</b> (const Tpetra::MultiVector&lt; <a class="el" href="class_sacado_1_1_m_p_1_1_vector.html">Sacado::MP::Vector</a>&lt; Storage &gt;, LocalOrdinal, GlobalOrdinal, Node &gt; &amp;vec, const Teuchos::RCP&lt; const Tpetra::Map&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt; &amp;flat_map)</td></tr>
<tr class="separator:aa101de4ba54c8630cc3fcbbe5adba7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d367cd1a3efe441f7eed43eea35645" id="r_ad2d367cd1a3efe441f7eed43eea35645"><td class="memTemplParams" colspan="2"><a id="ad2d367cd1a3efe441f7eed43eea35645" name="ad2d367cd1a3efe441f7eed43eea35645"></a>
template&lt;typename Storage , typename LocalOrdinal , typename GlobalOrdinal , typename Node &gt; </td></tr>
<tr class="memitem:ad2d367cd1a3efe441f7eed43eea35645"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; Tpetra::MultiVector&lt; typename Storage::value_type, LocalOrdinal, GlobalOrdinal, Node &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_flat_vector_view</b> (const Tpetra::MultiVector&lt; <a class="el" href="class_sacado_1_1_m_p_1_1_vector.html">Sacado::MP::Vector</a>&lt; Storage &gt;, LocalOrdinal, GlobalOrdinal, Node &gt; &amp;vec, Teuchos::RCP&lt; const Tpetra::Map&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt; &amp;flat_map)</td></tr>
<tr class="separator:ad2d367cd1a3efe441f7eed43eea35645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63913bac7d798f4c6cfb784bf7f3421d" id="r_a63913bac7d798f4c6cfb784bf7f3421d"><td class="memTemplParams" colspan="2"><a id="a63913bac7d798f4c6cfb784bf7f3421d" name="a63913bac7d798f4c6cfb784bf7f3421d"></a>
template&lt;typename Storage , typename LocalOrdinal , typename GlobalOrdinal , typename Node &gt; </td></tr>
<tr class="memitem:a63913bac7d798f4c6cfb784bf7f3421d"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; Tpetra::Vector&lt; typename Storage::value_type, LocalOrdinal, GlobalOrdinal, Node &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_flat_vector_view</b> (const Tpetra::Vector&lt; <a class="el" href="class_sacado_1_1_m_p_1_1_vector.html">Sacado::MP::Vector</a>&lt; Storage &gt;, LocalOrdinal, GlobalOrdinal, Node &gt; &amp;vec, const Teuchos::RCP&lt; const Tpetra::Map&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt; &amp;flat_map)</td></tr>
<tr class="separator:a63913bac7d798f4c6cfb784bf7f3421d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa2454ef245687d831a12f2d89a9dee" id="r_a9fa2454ef245687d831a12f2d89a9dee"><td class="memTemplParams" colspan="2"><a id="a9fa2454ef245687d831a12f2d89a9dee" name="a9fa2454ef245687d831a12f2d89a9dee"></a>
template&lt;typename Storage , typename LocalOrdinal , typename GlobalOrdinal , typename Node &gt; </td></tr>
<tr class="memitem:a9fa2454ef245687d831a12f2d89a9dee"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; Tpetra::Vector&lt; typename Storage::value_type, LocalOrdinal, GlobalOrdinal, Node &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_flat_vector_view</b> (const Tpetra::Vector&lt; <a class="el" href="class_sacado_1_1_m_p_1_1_vector.html">Sacado::MP::Vector</a>&lt; Storage &gt;, LocalOrdinal, GlobalOrdinal, Node &gt; &amp;vec, Teuchos::RCP&lt; const Tpetra::Map&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt; &amp;flat_map)</td></tr>
<tr class="separator:a9fa2454ef245687d831a12f2d89a9dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9b746ac1a05c9b9916917a2a50dc05" id="r_abf9b746ac1a05c9b9916917a2a50dc05"><td class="memTemplParams" colspan="2"><a id="abf9b746ac1a05c9b9916917a2a50dc05" name="abf9b746ac1a05c9b9916917a2a50dc05"></a>
template&lt;typename Storage , typename LocalOrdinal , typename GlobalOrdinal , typename Node &gt; </td></tr>
<tr class="memitem:abf9b746ac1a05c9b9916917a2a50dc05"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; Tpetra::CrsMatrix&lt; typename Storage::value_type, LocalOrdinal, GlobalOrdinal, Node &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_flat_matrix</b> (const Tpetra::CrsMatrix&lt; <a class="el" href="class_sacado_1_1_m_p_1_1_vector.html">Sacado::MP::Vector</a>&lt; Storage &gt;, LocalOrdinal, GlobalOrdinal, Node &gt; &amp;mat, const Teuchos::RCP&lt; const Tpetra::CrsGraph&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt; &amp;flat_graph, const LocalOrdinal block_size)</td></tr>
<tr class="separator:abf9b746ac1a05c9b9916917a2a50dc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb6cc6490441e15d1351ffd1e8ce83e" id="r_a9cb6cc6490441e15d1351ffd1e8ce83e"><td class="memTemplParams" colspan="2"><a id="a9cb6cc6490441e15d1351ffd1e8ce83e" name="a9cb6cc6490441e15d1351ffd1e8ce83e"></a>
template&lt;typename ordinal_type , typename value_type &gt; </td></tr>
<tr class="memitem:a9cb6cc6490441e15d1351ffd1e8ce83e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="class_stokhos_1_1_dense3_tensor.html">Dense3Tensor</a>&lt; ordinal_type, value_type &gt; &amp;Cijk)</td></tr>
<tr class="separator:a9cb6cc6490441e15d1351ffd1e8ce83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b11c1ed8ef2eed39f5256055c1741e" id="r_a87b11c1ed8ef2eed39f5256055c1741e"><td class="memTemplParams" colspan="2"><a id="a87b11c1ed8ef2eed39f5256055c1741e" name="a87b11c1ed8ef2eed39f5256055c1741e"></a>
template&lt;typename ordinal_type &gt; </td></tr>
<tr class="memitem:a87b11c1ed8ef2eed39f5256055c1741e"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="struct_stokhos_1_1_lexicographic_tree_basis_node.html">LexicographicTreeBasisNode</a>&lt; ordinal_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>build_lexicographic_basis_tree</b> (const Teuchos::ArrayView&lt; const ordinal_type &gt; &amp;basis_orders, const ordinal_type total_order, const ordinal_type index_begin=ordinal_type(0), const ordinal_type order_sum=ordinal_type(0), const <a class="el" href="class_stokhos_1_1_multi_index.html">Stokhos::MultiIndex</a>&lt; ordinal_type &gt; &amp;term_prefix=<a class="el" href="class_stokhos_1_1_multi_index.html">Stokhos::MultiIndex</a>&lt; ordinal_type &gt;())</td></tr>
<tr class="separator:a87b11c1ed8ef2eed39f5256055c1741e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808364a5cac2191b2d37c3db1fb750a9" id="r_a808364a5cac2191b2d37c3db1fb750a9"><td class="memTemplParams" colspan="2"><a id="a808364a5cac2191b2d37c3db1fb750a9" name="a808364a5cac2191b2d37c3db1fb750a9"></a>
template&lt;typename ordinal_type , typename value_type &gt; </td></tr>
<tr class="memitem:a808364a5cac2191b2d37c3db1fb750a9"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="class_stokhos_1_1_l_t_b_sparse3_tensor.html">LTBSparse3Tensor</a>&lt; ordinal_type, value_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computeTripleProductTensorLTB</b> (const <a class="el" href="class_stokhos_1_1_total_order_basis.html">TotalOrderBasis</a>&lt; ordinal_type, value_type, <a class="el" href="class_stokhos_1_1_lexographic_less.html">LexographicLess</a>&lt; <a class="el" href="class_stokhos_1_1_multi_index.html">MultiIndex</a>&lt; ordinal_type &gt; &gt; &gt; &amp;product_basis, bool symmetric=false)</td></tr>
<tr class="separator:a808364a5cac2191b2d37c3db1fb750a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7484e5e809edbb65a297cee614df1a5" id="r_af7484e5e809edbb65a297cee614df1a5"><td class="memTemplParams" colspan="2"><a id="af7484e5e809edbb65a297cee614df1a5" name="af7484e5e809edbb65a297cee614df1a5"></a>
template&lt;typename ordinal_type , typename value_type &gt; </td></tr>
<tr class="memitem:af7484e5e809edbb65a297cee614df1a5"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; typename <a class="el" href="class_stokhos_1_1_l_t_b_sparse3_tensor.html">LTBSparse3Tensor</a>&lt; ordinal_type, value_type &gt;::CijkNode &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computeCijkLTBNode</b> (const Teuchos::ArrayView&lt; const ordinal_type &gt; &amp;basis_orders, const Teuchos::ArrayView&lt; const Teuchos::RCP&lt; <a class="el" href="class_stokhos_1_1_sparse3_tensor.html">Sparse3Tensor</a>&lt; ordinal_type, value_type &gt; &gt; &gt; &amp;Cijk_1d, const Teuchos::RCP&lt; <a class="el" href="struct_stokhos_1_1_lexicographic_tree_basis_node.html">LexicographicTreeBasisNode</a>&lt; ordinal_type &gt; &gt; &amp;i_ltb, const Teuchos::RCP&lt; <a class="el" href="struct_stokhos_1_1_lexicographic_tree_basis_node.html">LexicographicTreeBasisNode</a>&lt; ordinal_type &gt; &gt; &amp;j_ltb, const Teuchos::RCP&lt; <a class="el" href="struct_stokhos_1_1_lexicographic_tree_basis_node.html">LexicographicTreeBasisNode</a>&lt; ordinal_type &gt; &gt; &amp;k_ltb, const ordinal_type total_order, const bool symmetric, const ordinal_type sum_i=ordinal_type(0), const ordinal_type sum_j=ordinal_type(0), const ordinal_type sum_k=ordinal_type(0), const value_type cijk_base=value_type(1))</td></tr>
<tr class="separator:af7484e5e809edbb65a297cee614df1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a999b6436d43ebf5ff414a11698e49" id="r_a46a999b6436d43ebf5ff414a11698e49"><td class="memTemplParams" colspan="2"><a id="a46a999b6436d43ebf5ff414a11698e49" name="a46a999b6436d43ebf5ff414a11698e49"></a>
template&lt;typename ordinal_type , typename value_type &gt; </td></tr>
<tr class="memitem:a46a999b6436d43ebf5ff414a11698e49"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="class_stokhos_1_1_l_t_b_sparse3_tensor.html">LTBSparse3Tensor</a>&lt; ordinal_type, value_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computeTripleProductTensorLTBBlockLeaf</b> (const <a class="el" href="class_stokhos_1_1_total_order_basis.html">TotalOrderBasis</a>&lt; ordinal_type, value_type, <a class="el" href="class_stokhos_1_1_lexographic_less.html">LexographicLess</a>&lt; <a class="el" href="class_stokhos_1_1_multi_index.html">MultiIndex</a>&lt; ordinal_type &gt; &gt; &gt; &amp;product_basis, bool symmetric=false)</td></tr>
<tr class="separator:a46a999b6436d43ebf5ff414a11698e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe8b8dd7fcaf338abcecb01f8bcd397" id="r_acbe8b8dd7fcaf338abcecb01f8bcd397"><td class="memTemplParams" colspan="2"><a id="acbe8b8dd7fcaf338abcecb01f8bcd397" name="acbe8b8dd7fcaf338abcecb01f8bcd397"></a>
template&lt;typename ordinal_type , typename value_type &gt; </td></tr>
<tr class="memitem:acbe8b8dd7fcaf338abcecb01f8bcd397"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; typename <a class="el" href="class_stokhos_1_1_l_t_b_sparse3_tensor.html">LTBSparse3Tensor</a>&lt; ordinal_type, value_type &gt;::CijkNode &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computeCijkLTBNodeBlockLeaf</b> (const Teuchos::ArrayView&lt; const ordinal_type &gt; &amp;basis_orders, const Teuchos::ArrayView&lt; const Teuchos::RCP&lt; <a class="el" href="class_stokhos_1_1_dense3_tensor.html">Dense3Tensor</a>&lt; ordinal_type, value_type &gt; &gt; &gt; &amp;Cijk_1d, const Teuchos::RCP&lt; <a class="el" href="struct_stokhos_1_1_lexicographic_tree_basis_node.html">LexicographicTreeBasisNode</a>&lt; ordinal_type &gt; &gt; &amp;i_ltb, const Teuchos::RCP&lt; <a class="el" href="struct_stokhos_1_1_lexicographic_tree_basis_node.html">LexicographicTreeBasisNode</a>&lt; ordinal_type &gt; &gt; &amp;j_ltb, const Teuchos::RCP&lt; <a class="el" href="struct_stokhos_1_1_lexicographic_tree_basis_node.html">LexicographicTreeBasisNode</a>&lt; ordinal_type &gt; &gt; &amp;k_ltb, const ordinal_type total_order, const bool symmetric, const ordinal_type sum_i=ordinal_type(0), const ordinal_type sum_j=ordinal_type(0), const ordinal_type sum_k=ordinal_type(0), const value_type cijk_base=value_type(1), const bool parent_j_equals_k=true)</td></tr>
<tr class="separator:acbe8b8dd7fcaf338abcecb01f8bcd397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25eaf569cbab444947407176eebf9a89" id="r_a25eaf569cbab444947407176eebf9a89"><td class="memTemplParams" colspan="2"><a id="a25eaf569cbab444947407176eebf9a89" name="a25eaf569cbab444947407176eebf9a89"></a>
template&lt;typename ordinal_type , typename value_type &gt; </td></tr>
<tr class="memitem:a25eaf569cbab444947407176eebf9a89"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="struct_stokhos_1_1_flat_l_t_b_sparse3_tensor.html">FlatLTBSparse3Tensor</a>&lt; ordinal_type, value_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computeFlatTripleProductTensorLTB</b> (const <a class="el" href="class_stokhos_1_1_total_order_basis.html">TotalOrderBasis</a>&lt; ordinal_type, value_type, <a class="el" href="class_stokhos_1_1_lexographic_less.html">LexographicLess</a>&lt; <a class="el" href="class_stokhos_1_1_multi_index.html">MultiIndex</a>&lt; ordinal_type &gt; &gt; &gt; &amp;product_basis, bool symmetric=false)</td></tr>
<tr class="separator:a25eaf569cbab444947407176eebf9a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d162c2501c4b08763d813b914f5c33" id="r_a66d162c2501c4b08763d813b914f5c33"><td class="memTemplParams" colspan="2"><a id="a66d162c2501c4b08763d813b914f5c33" name="a66d162c2501c4b08763d813b914f5c33"></a>
template&lt;int max_size, typename ordinal_type , typename value_type &gt; </td></tr>
<tr class="memitem:a66d162c2501c4b08763d813b914f5c33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>flatLTB3TensorMultiply</b> (<a class="el" href="class_stokhos_1_1_orthog_poly_approx.html">OrthogPolyApprox</a>&lt; ordinal_type, value_type &gt; &amp;c, const <a class="el" href="class_stokhos_1_1_orthog_poly_approx.html">OrthogPolyApprox</a>&lt; ordinal_type, value_type &gt; &amp;a, const <a class="el" href="class_stokhos_1_1_orthog_poly_approx.html">OrthogPolyApprox</a>&lt; ordinal_type, value_type &gt; &amp;b, const <a class="el" href="struct_stokhos_1_1_flat_l_t_b_sparse3_tensor.html">FlatLTBSparse3Tensor</a>&lt; ordinal_type, value_type &gt; &amp;cijk)</td></tr>
<tr class="separator:a66d162c2501c4b08763d813b914f5c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bf9dd8dc26b4eab773ea7f48ca4cce" id="r_a17bf9dd8dc26b4eab773ea7f48ca4cce"><td class="memTemplParams" colspan="2"><a id="a17bf9dd8dc26b4eab773ea7f48ca4cce" name="a17bf9dd8dc26b4eab773ea7f48ca4cce"></a>
template&lt;typename ordinal_type , typename value_type &gt; </td></tr>
<tr class="memitem:a17bf9dd8dc26b4eab773ea7f48ca4cce"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="class_stokhos_1_1_one_d_orthog_poly_basis.html">OneDOrthogPolyBasis</a>&lt; ordinal_type, value_type &gt; &amp;b)</td></tr>
<tr class="memdesc:a17bf9dd8dc26b4eab773ea7f48ca4cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print basis to stream <code>os</code>. <br /></td></tr>
<tr class="separator:a17bf9dd8dc26b4eab773ea7f48ca4cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9adb94b473d429a39291724611a983" id="r_a5a9adb94b473d429a39291724611a983"><td class="memTemplParams" colspan="2"><a id="a5a9adb94b473d429a39291724611a983" name="a5a9adb94b473d429a39291724611a983"></a>
template&lt;typename ordinal_type , typename value_type , typename node_type &gt; </td></tr>
<tr class="memitem:a5a9adb94b473d429a39291724611a983"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="class_stokhos_1_1_orthog_poly_approx.html">OrthogPolyApprox</a>&lt; ordinal_type, value_type, node_type &gt; &amp;a)</td></tr>
<tr class="memdesc:a5a9adb94b473d429a39291724611a983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the array of coefficients (more compact than print()) <br /></td></tr>
<tr class="separator:a5a9adb94b473d429a39291724611a983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b196c6ff2d12338a289885304f22bdf" id="r_a2b196c6ff2d12338a289885304f22bdf"><td class="memTemplParams" colspan="2"><a id="a2b196c6ff2d12338a289885304f22bdf" name="a2b196c6ff2d12338a289885304f22bdf"></a>
template&lt;typename ordinal_type , typename value_type &gt; </td></tr>
<tr class="memitem:a2b196c6ff2d12338a289885304f22bdf"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="class_stokhos_1_1_orthog_poly_basis.html">OrthogPolyBasis</a>&lt; ordinal_type, value_type &gt; &amp;b)</td></tr>
<tr class="memdesc:a2b196c6ff2d12338a289885304f22bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print basis to stream <code>os</code>. <br /></td></tr>
<tr class="separator:a2b196c6ff2d12338a289885304f22bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70f89ea85637a5dc9f7d31a27648764" id="r_ad70f89ea85637a5dc9f7d31a27648764"><td class="memTemplParams" colspan="2"><a id="ad70f89ea85637a5dc9f7d31a27648764" name="ad70f89ea85637a5dc9f7d31a27648764"></a>
template&lt;typename ordinal_type &gt; </td></tr>
<tr class="memitem:ad70f89ea85637a5dc9f7d31a27648764"><td class="memTemplItemLeft" align="right" valign="top">ordinal_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>n_choose_k</b> (const ordinal_type &amp;n, const ordinal_type &amp;k)</td></tr>
<tr class="memdesc:ad70f89ea85637a5dc9f7d31a27648764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute bionomial coefficient (n ; k) = n!/( k! (n-k)! ) <br /></td></tr>
<tr class="separator:ad70f89ea85637a5dc9f7d31a27648764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49f709ca439b75961f4ea43b5ebb3fd" id="r_ab49f709ca439b75961f4ea43b5ebb3fd"><td class="memTemplParams" colspan="2"><a id="ab49f709ca439b75961f4ea43b5ebb3fd" name="ab49f709ca439b75961f4ea43b5ebb3fd"></a>
template&lt;typename ordinal_type &gt; </td></tr>
<tr class="memitem:ab49f709ca439b75961f4ea43b5ebb3fd"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="class_stokhos_1_1_multi_index.html">MultiIndex</a>&lt; ordinal_type &gt; &amp;m)</td></tr>
<tr class="separator:ab49f709ca439b75961f4ea43b5ebb3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f177e699553683ea5be4dcec8b2466" id="r_a11f177e699553683ea5be4dcec8b2466"><td class="memTemplParams" colspan="2"><a id="a11f177e699553683ea5be4dcec8b2466" name="a11f177e699553683ea5be4dcec8b2466"></a>
template&lt;typename ordinal_type , typename element_type &gt; </td></tr>
<tr class="memitem:a11f177e699553683ea5be4dcec8b2466"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="class_stokhos_1_1_tensor_product_element.html">TensorProductElement</a>&lt; ordinal_type, element_type &gt; &amp;m)</td></tr>
<tr class="separator:a11f177e699553683ea5be4dcec8b2466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e0c532d946a84f2c4eb12f3a1741ff" id="r_a02e0c532d946a84f2c4eb12f3a1741ff"><td class="memTemplParams" colspan="2"><a id="a02e0c532d946a84f2c4eb12f3a1741ff" name="a02e0c532d946a84f2c4eb12f3a1741ff"></a>
template&lt;typename ordinal_type &gt; </td></tr>
<tr class="memitem:a02e0c532d946a84f2c4eb12f3a1741ff"><td class="memTemplItemLeft" align="right" valign="top">ordinal_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>totalOrderMapping</b> (const <a class="el" href="class_stokhos_1_1_multi_index.html">Stokhos::MultiIndex</a>&lt; ordinal_type &gt; &amp;index)</td></tr>
<tr class="separator:a02e0c532d946a84f2c4eb12f3a1741ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a64809be152d5463623e10eacfd6a7" id="r_a57a64809be152d5463623e10eacfd6a7"><td class="memTemplParams" colspan="2"><a id="a57a64809be152d5463623e10eacfd6a7" name="a57a64809be152d5463623e10eacfd6a7"></a>
template&lt;typename ordinal_type &gt; </td></tr>
<tr class="memitem:a57a64809be152d5463623e10eacfd6a7"><td class="memTemplItemLeft" align="right" valign="top">ordinal_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lexicographicMapping</b> (const <a class="el" href="class_stokhos_1_1_multi_index.html">Stokhos::MultiIndex</a>&lt; ordinal_type &gt; &amp;index, ordinal_type max_order)</td></tr>
<tr class="separator:a57a64809be152d5463623e10eacfd6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981fc65bb329bc151e8b4c80f46edde9" id="r_a981fc65bb329bc151e8b4c80f46edde9"><td class="memTemplParams" colspan="2"><a id="a981fc65bb329bc151e8b4c80f46edde9" name="a981fc65bb329bc151e8b4c80f46edde9"></a>
template&lt;typename ordinal_type , typename value_type &gt; </td></tr>
<tr class="memitem:a981fc65bb329bc151e8b4c80f46edde9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="class_stokhos_1_1_quadrature.html">Quadrature</a>&lt; ordinal_type, value_type &gt; &amp;quad)</td></tr>
<tr class="memdesc:a981fc65bb329bc151e8b4c80f46edde9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print quadrature object to stream. <br /></td></tr>
<tr class="separator:a981fc65bb329bc151e8b4c80f46edde9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a565c3f720035db69ee6459fc127540" id="r_a8a565c3f720035db69ee6459fc127540"><td class="memTemplParams" colspan="2"><a id="a8a565c3f720035db69ee6459fc127540" name="a8a565c3f720035db69ee6459fc127540"></a>
template&lt;typename ordinal_type , typename scalar_type &gt; </td></tr>
<tr class="memitem:a8a565c3f720035db69ee6459fc127540"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>print_matlab</b> (std::ostream &amp;os, const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;A)</td></tr>
<tr class="separator:a8a565c3f720035db69ee6459fc127540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e642c05f87c4b67f6c6af20c19aadd" id="r_a47e642c05f87c4b67f6c6af20c19aadd"><td class="memTemplParams" colspan="2"><a id="a47e642c05f87c4b67f6c6af20c19aadd" name="a47e642c05f87c4b67f6c6af20c19aadd"></a>
template&lt;typename ordinal_type , typename scalar_type &gt; </td></tr>
<tr class="memitem:a47e642c05f87c4b67f6c6af20c19aadd"><td class="memTemplItemLeft" align="right" valign="top">scalar_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vec_norm_inf</b> (const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;A)</td></tr>
<tr class="memdesc:a47e642c05f87c4b67f6c6af20c19aadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector-infinity norm of a matrix. <br /></td></tr>
<tr class="separator:a47e642c05f87c4b67f6c6af20c19aadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd78fc3c9830cd53e4483db17605d4ca" id="r_abd78fc3c9830cd53e4483db17605d4ca"><td class="memTemplParams" colspan="2">template&lt;typename ordinal_type , typename scalar_type &gt; </td></tr>
<tr class="memitem:abd78fc3c9830cd53e4483db17605d4ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_stokhos.html#abd78fc3c9830cd53e4483db17605d4ca">QR_CGS</a> (ordinal_type k, const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;A, const Teuchos::Array&lt; scalar_type &gt; &amp;w, Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;Q, Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;R)</td></tr>
<tr class="memdesc:abd78fc3c9830cd53e4483db17605d4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute thin QR using classical Gram-Schmidt.  <br /></td></tr>
<tr class="separator:abd78fc3c9830cd53e4483db17605d4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976da99a712c72b48f115a33a2b3cfe8" id="r_a976da99a712c72b48f115a33a2b3cfe8"><td class="memTemplParams" colspan="2">template&lt;typename ordinal_type , typename scalar_type &gt; </td></tr>
<tr class="memitem:a976da99a712c72b48f115a33a2b3cfe8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_stokhos.html#a976da99a712c72b48f115a33a2b3cfe8">QR_MGS</a> (ordinal_type k, const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;A, const Teuchos::Array&lt; scalar_type &gt; &amp;w, Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;Q, Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;R)</td></tr>
<tr class="memdesc:a976da99a712c72b48f115a33a2b3cfe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute thin QR using modified Gram-Schmidt.  <br /></td></tr>
<tr class="separator:a976da99a712c72b48f115a33a2b3cfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27cfde568a781c27567661f4469c708" id="r_aa27cfde568a781c27567661f4469c708"><td class="memTemplParams" colspan="2">template&lt;typename ordinal_type , typename scalar_type &gt; </td></tr>
<tr class="memitem:aa27cfde568a781c27567661f4469c708"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_stokhos.html#aa27cfde568a781c27567661f4469c708">QR_MGS2</a> (ordinal_type k, const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;A, const Teuchos::Array&lt; scalar_type &gt; &amp;w, Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;Q, Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;R)</td></tr>
<tr class="memdesc:aa27cfde568a781c27567661f4469c708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute thin QR using modified Gram-Schmidt with reorthogonalization.  <br /></td></tr>
<tr class="separator:aa27cfde568a781c27567661f4469c708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4266f5096a5376b56f41294035ac5dc" id="r_ac4266f5096a5376b56f41294035ac5dc"><td class="memTemplParams" colspan="2">template&lt;typename ordinal_type , typename scalar_type &gt; </td></tr>
<tr class="memitem:ac4266f5096a5376b56f41294035ac5dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_stokhos.html#ac4266f5096a5376b56f41294035ac5dc">QR_Householder</a> (ordinal_type k, const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;A, const Teuchos::Array&lt; scalar_type &gt; &amp;w, Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;Q, Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;R)</td></tr>
<tr class="memdesc:ac4266f5096a5376b56f41294035ac5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute thin QR using Householder reflections.  <br /></td></tr>
<tr class="separator:ac4266f5096a5376b56f41294035ac5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7835553d789acd06de6a3509561424b1" id="r_a7835553d789acd06de6a3509561424b1"><td class="memTemplParams" colspan="2">template&lt;typename ordinal_type , typename scalar_type &gt; </td></tr>
<tr class="memitem:a7835553d789acd06de6a3509561424b1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_stokhos.html#a7835553d789acd06de6a3509561424b1">CPQR_Householder3</a> (const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;A, Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;Q, Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;R, Teuchos::Array&lt; ordinal_type &gt; &amp;piv)</td></tr>
<tr class="memdesc:a7835553d789acd06de6a3509561424b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute column-pivoted QR using Householder reflections.  <br /></td></tr>
<tr class="separator:a7835553d789acd06de6a3509561424b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0aa77a0340112f76ca996a4e64d53e" id="r_a3b0aa77a0340112f76ca996a4e64d53e"><td class="memTemplParams" colspan="2">template&lt;typename ordinal_type , typename scalar_type &gt; </td></tr>
<tr class="memitem:a3b0aa77a0340112f76ca996a4e64d53e"><td class="memTemplItemLeft" align="right" valign="top">ordinal_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_stokhos.html#a3b0aa77a0340112f76ca996a4e64d53e">CPQR_Householder_threshold</a> (const scalar_type &amp;rank_threshold, const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;A, const Teuchos::Array&lt; scalar_type &gt; &amp;w, Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;Q, Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;R, Teuchos::Array&lt; ordinal_type &gt; &amp;piv)</td></tr>
<tr class="memdesc:a3b0aa77a0340112f76ca996a4e64d53e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute column-pivoted QR using Householder reflections.  <br /></td></tr>
<tr class="separator:a3b0aa77a0340112f76ca996a4e64d53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2ef8273fcb4ad7015db71bf40b455b" id="r_a1d2ef8273fcb4ad7015db71bf40b455b"><td class="memTemplParams" colspan="2">template&lt;typename ordinal_type , typename scalar_type &gt; </td></tr>
<tr class="memitem:a1d2ef8273fcb4ad7015db71bf40b455b"><td class="memTemplItemLeft" align="right" valign="top">ordinal_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_stokhos.html#a1d2ef8273fcb4ad7015db71bf40b455b">CPQR_MGS_threshold</a> (const scalar_type &amp;rank_threshold, const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;A, const Teuchos::Array&lt; scalar_type &gt; &amp;w, Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;Q, Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;R, Teuchos::Array&lt; ordinal_type &gt; &amp;piv)</td></tr>
<tr class="memdesc:a1d2ef8273fcb4ad7015db71bf40b455b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute column-pivoted QR using modified Gram-Schmidt.  <br /></td></tr>
<tr class="separator:a1d2ef8273fcb4ad7015db71bf40b455b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33aa8a89b7351fc5a86e2432192ce387" id="r_a33aa8a89b7351fc5a86e2432192ce387"><td class="memTemplParams" colspan="2">template&lt;typename ordinal_type , typename scalar_type &gt; </td></tr>
<tr class="memitem:a33aa8a89b7351fc5a86e2432192ce387"><td class="memTemplItemLeft" align="right" valign="top">ordinal_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_stokhos.html#a33aa8a89b7351fc5a86e2432192ce387">CPQR_MGS_reorthog_threshold</a> (const scalar_type &amp;rank_threshold, const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;A, const Teuchos::Array&lt; scalar_type &gt; &amp;w, Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;Q, Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;R, Teuchos::Array&lt; ordinal_type &gt; &amp;piv)</td></tr>
<tr class="memdesc:a33aa8a89b7351fc5a86e2432192ce387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute column-pivoted QR using modified Gram-Schmidt and reorthogonalization.  <br /></td></tr>
<tr class="separator:a33aa8a89b7351fc5a86e2432192ce387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab833cab36711cc6f143a9c254f96524c" id="r_ab833cab36711cc6f143a9c254f96524c"><td class="memTemplParams" colspan="2"><a id="ab833cab36711cc6f143a9c254f96524c" name="ab833cab36711cc6f143a9c254f96524c"></a>
template&lt;typename ordinal_type , typename scalar_type &gt; </td></tr>
<tr class="memitem:ab833cab36711cc6f143a9c254f96524c"><td class="memTemplItemLeft" align="right" valign="top">scalar_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cond_R</b> (const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;R)</td></tr>
<tr class="memdesc:ab833cab36711cc6f143a9c254f96524c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute condition number of upper-triangular R. <br /></td></tr>
<tr class="separator:ab833cab36711cc6f143a9c254f96524c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedf09b409bead5914922fe0408a1af5" id="r_aeedf09b409bead5914922fe0408a1af5"><td class="memTemplParams" colspan="2">template&lt;typename ordinal_type , typename scalar_type &gt; </td></tr>
<tr class="memitem:aeedf09b409bead5914922fe0408a1af5"><td class="memTemplItemLeft" align="right" valign="top">scalar_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_stokhos.html#aeedf09b409bead5914922fe0408a1af5">weightedQROrthogonalizationError</a> (const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;Q, const Teuchos::Array&lt; scalar_type &gt; &amp;w)</td></tr>
<tr class="memdesc:aeedf09b409bead5914922fe0408a1af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute weighted QR orthogonalization error.  <br /></td></tr>
<tr class="separator:aeedf09b409bead5914922fe0408a1af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a79baff2e138fbfb804a374fa612ee" id="r_ae4a79baff2e138fbfb804a374fa612ee"><td class="memTemplParams" colspan="2">template&lt;typename ordinal_type , typename scalar_type &gt; </td></tr>
<tr class="memitem:ae4a79baff2e138fbfb804a374fa612ee"><td class="memTemplItemLeft" align="right" valign="top">scalar_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_stokhos.html#ae4a79baff2e138fbfb804a374fa612ee">QROrthogonalizationError</a> (const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;Q)</td></tr>
<tr class="memdesc:ae4a79baff2e138fbfb804a374fa612ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute QR orthogonalization error.  <br /></td></tr>
<tr class="separator:ae4a79baff2e138fbfb804a374fa612ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f75e92ef4f2b241c8158929db724f2" id="r_a79f75e92ef4f2b241c8158929db724f2"><td class="memTemplParams" colspan="2">template&lt;typename ordinal_type , typename scalar_type &gt; </td></tr>
<tr class="memitem:a79f75e92ef4f2b241c8158929db724f2"><td class="memTemplItemLeft" align="right" valign="top">scalar_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_stokhos.html#a79f75e92ef4f2b241c8158929db724f2">residualQRError</a> (const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;A, const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;Q, const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;R)</td></tr>
<tr class="memdesc:a79f75e92ef4f2b241c8158929db724f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute QR residual error.  <br /></td></tr>
<tr class="separator:a79f75e92ef4f2b241c8158929db724f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7b8599407eb1f166d13345e43ec7fe" id="r_a5a7b8599407eb1f166d13345e43ec7fe"><td class="memTemplParams" colspan="2">template&lt;typename ordinal_type , typename scalar_type &gt; </td></tr>
<tr class="memitem:a5a7b8599407eb1f166d13345e43ec7fe"><td class="memTemplItemLeft" align="right" valign="top">scalar_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_stokhos.html#a5a7b8599407eb1f166d13345e43ec7fe">residualCPQRError</a> (const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;A, const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;Q, const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;R, const Teuchos::Array&lt; ordinal_type &gt; &amp;piv)</td></tr>
<tr class="memdesc:a5a7b8599407eb1f166d13345e43ec7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute column-pivoted QR residual error.  <br /></td></tr>
<tr class="separator:a5a7b8599407eb1f166d13345e43ec7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafdfb05537516e2a14564ed26651838" id="r_abafdfb05537516e2a14564ed26651838"><td class="memTemplParams" colspan="2">template&lt;typename ordinal_type , typename scalar_type &gt; </td></tr>
<tr class="memitem:abafdfb05537516e2a14564ed26651838"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_stokhos.html#abafdfb05537516e2a14564ed26651838">svd</a> (const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;A, Teuchos::Array&lt; scalar_type &gt; &amp;s, Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;U, Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;Vt)</td></tr>
<tr class="memdesc:abafdfb05537516e2a14564ed26651838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute SVD of matrix.  <br /></td></tr>
<tr class="separator:abafdfb05537516e2a14564ed26651838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a767cf4df12ef38588fac8aa1e59ab4" id="r_a4a767cf4df12ef38588fac8aa1e59ab4"><td class="memTemplParams" colspan="2"><a id="a4a767cf4df12ef38588fac8aa1e59ab4" name="a4a767cf4df12ef38588fac8aa1e59ab4"></a>
template&lt;typename ordinal_type , typename scalar_type &gt; </td></tr>
<tr class="memitem:a4a767cf4df12ef38588fac8aa1e59ab4"><td class="memTemplItemLeft" align="right" valign="top">ordinal_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>svd_threshold</b> (const scalar_type &amp;rank_threshold, const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;A, Teuchos::Array&lt; scalar_type &gt; &amp;s, Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;U, Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;Vt)</td></tr>
<tr class="separator:a4a767cf4df12ef38588fac8aa1e59ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf0c8784d1570e71255541acbf44d96" id="r_a9bf0c8784d1570e71255541acbf44d96"><td class="memTemplParams" colspan="2"><a id="a9bf0c8784d1570e71255541acbf44d96" name="a9bf0c8784d1570e71255541acbf44d96"></a>
template&lt;typename ordinal_type , typename scalar_type &gt; </td></tr>
<tr class="memitem:a9bf0c8784d1570e71255541acbf44d96"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::ArrayRCP&lt; <a class="el" href="struct_stokhos_1_1_cijk_data.html">CijkData</a>&lt; ordinal_type, scalar_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>build_cijk_coordinate_list</b> (const <a class="el" href="class_stokhos_1_1_sparse3_tensor.html">Sparse3Tensor</a>&lt; ordinal_type, scalar_type &gt; &amp;Cijk, CijkSymmetryType symmetry_type)</td></tr>
<tr class="separator:a9bf0c8784d1570e71255541acbf44d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906c2820d6058b6469b33afedd9b7d6d" id="r_a906c2820d6058b6469b33afedd9b7d6d"><td class="memTemplParams" colspan="2"><a id="a906c2820d6058b6469b33afedd9b7d6d" name="a906c2820d6058b6469b33afedd9b7d6d"></a>
template&lt;typename ordinal_type , typename value_type &gt; </td></tr>
<tr class="memitem:a906c2820d6058b6469b33afedd9b7d6d"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="class_stokhos_1_1_sparse3_tensor.html">Sparse3Tensor</a>&lt; ordinal_type, value_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computeTripleProductTensorLTO</b> (const <a class="el" href="class_stokhos_1_1_total_order_basis.html">TotalOrderBasis</a>&lt; ordinal_type, value_type, <a class="el" href="class_stokhos_1_1_lexographic_less.html">LexographicLess</a>&lt; <a class="el" href="class_stokhos_1_1_multi_index.html">MultiIndex</a>&lt; ordinal_type &gt; &gt; &gt; &amp;product_basis, bool symmetric=false)</td></tr>
<tr class="separator:a906c2820d6058b6469b33afedd9b7d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eddff5953ffb189e007eef9770d93ae" id="r_a4eddff5953ffb189e007eef9770d93ae"><td class="memTemplParams" colspan="2">template&lt;typename TpetraLocalOrdinal , typename TpetraGlobalOrdinal , typename TpetraNode , typename StokhosOrdinal , typename StokhosValue &gt; </td></tr>
<tr class="memitem:a4eddff5953ffb189e007eef9770d93ae"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; Tpetra::CrsGraph&lt; TpetraLocalOrdinal, TpetraGlobalOrdinal, TpetraNode &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_stokhos.html#a4eddff5953ffb189e007eef9770d93ae">sparse3Tensor2TpetraCrsGraph</a> (const <a class="el" href="class_stokhos_1_1_orthog_poly_basis.html">Stokhos::OrthogPolyBasis</a>&lt; StokhosOrdinal, StokhosValue &gt; &amp;basis, const <a class="el" href="class_stokhos_1_1_sparse3_tensor.html">Stokhos::Sparse3Tensor</a>&lt; StokhosOrdinal, StokhosValue &gt; &amp;Cijk, const Teuchos::RCP&lt; const Teuchos::Comm&lt; int &gt; &gt; &amp;comm)</td></tr>
<tr class="memdesc:a4eddff5953ffb189e007eef9770d93ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an Tpetra::CrsGraph from a sparse 3 tensor.  <br /></td></tr>
<tr class="separator:a4eddff5953ffb189e007eef9770d93ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0ca33abc558a909cc171149021ecc6" id="r_a5f0ca33abc558a909cc171149021ecc6"><td class="memTemplParams" colspan="2"><a id="a5f0ca33abc558a909cc171149021ecc6" name="a5f0ca33abc558a909cc171149021ecc6"></a>
template&lt;typename TpetraLocalOrdinal , typename TpetraGlobalOrdinal , typename TpetraNode , typename StokhosOrdinal , typename StokhosValue &gt; </td></tr>
<tr class="memitem:a5f0ca33abc558a909cc171149021ecc6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sparse3Tensor2TpetraMatrixMarket</b> (const <a class="el" href="class_stokhos_1_1_orthog_poly_basis.html">Stokhos::OrthogPolyBasis</a>&lt; StokhosOrdinal, StokhosValue &gt; &amp;basis, const <a class="el" href="class_stokhos_1_1_sparse3_tensor.html">Stokhos::Sparse3Tensor</a>&lt; StokhosOrdinal, StokhosValue &gt; &amp;Cijk, const Teuchos::RCP&lt; const Teuchos::Comm&lt; int &gt; &gt; &amp;comm, const std::string &amp;file)</td></tr>
<tr class="separator:a5f0ca33abc558a909cc171149021ecc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a79b61e5ef3e75b9502f77d0704f0cbe6" id="r_a79b61e5ef3e75b9502f77d0704f0cbe6"><td class="memTemplParams" colspan="2"><a id="a79b61e5ef3e75b9502f77d0704f0cbe6" name="a79b61e5ef3e75b9502f77d0704f0cbe6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a79b61e5ef3e75b9502f77d0704f0cbe6"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_mp_vector_v</b> = <a class="el" href="struct_stokhos_1_1is__mp__vector.html">is_mp_vector</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a79b61e5ef3e75b9502f77d0704f0cbe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Top-level namespace for <a class="el" href="namespace_stokhos.html" title="Top-level namespace for Stokhos classes and functions.">Stokhos</a> classes and functions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a7835553d789acd06de6a3509561424b1" name="a7835553d789acd06de6a3509561424b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7835553d789acd06de6a3509561424b1">&#9670;&#160;</a></span>CPQR_Householder3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ordinal_type , typename scalar_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Stokhos::CPQR_Householder3 </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::Array&lt; ordinal_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>piv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute column-pivoted QR using Householder reflections. </p>
<p>For A an m-by-n matrix with m &gt;= n, computes A*P = Q*R with R n-by-n upper triangular and Q m-by-n with orthogonal columns (often called the economy size QR) and P an m-by-n permutation matrix. For n &gt;= m, computes A*P = Q*R with R m-by-n upper trapezoidal and Q m-by-m upper trapezoidal (R = [R_1 R_2] with R_1 upper triangular and R_2 rectangular). For k = min(m,n), both cases are handled with Q m-by-k and R k-by-n.</p>
<p>The QR factorization is computed by the corresponding LAPACK function. This version uses the BLAS3-rich xGEQP3. </p>

<p class="reference">Referenced by <a class="el" href="namespace_stokhos.html#a3b0aa77a0340112f76ca996a4e64d53e">CPQR_Householder_threshold()</a>.</p>

</div>
</div>
<a id="a3b0aa77a0340112f76ca996a4e64d53e" name="a3b0aa77a0340112f76ca996a4e64d53e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0aa77a0340112f76ca996a4e64d53e">&#9670;&#160;</a></span>CPQR_Householder_threshold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ordinal_type , typename scalar_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ordinal_type Stokhos::CPQR_Householder_threshold </td>
          <td>(</td>
          <td class="paramtype">const scalar_type &amp;&#160;</td>
          <td class="paramname"><em>rank_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::Array&lt; scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::Array&lt; ordinal_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>piv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute column-pivoted QR using Householder reflections. </p>
<p>For A an m-by-n matrix, computes A*P = Q*R with R k-by-k upper triangular, Q m-by-k with orthonormal columns, and P an n-by-k permutation matrix. Here k &lt;= min(m,n) is determined by a rank threshold tau provided by the user. The resulting R will have cond(R) &lt;= 1/tau. P is returned in the pivot array <code>piv</code> and the rank k returned by the function. Only the first k entries of <code>piv</code> will be set. As with LAPACK, the user can require columns of A to be included in P by setting the corresponding entries of piv to be nonzero on input.</p>
<p>If <code>make_R_square</code> is <code>false</code> then R is k-by-n.</p>
<p>This ultimately uses the LAPACK column-pivoted QR function which does a full QR factorization. This then extracts the parts of Q, R, and P determined by the threshold as described above. As such, this function requires the weight vector to be 1 (Note the weight vector will be ignored if it is size 0). </p>

<p class="reference">References <a class="el" href="namespace_stokhos.html#a7835553d789acd06de6a3509561424b1">CPQR_Householder3()</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_stokhos_1_1_orthogonalization_factory.html#ab9026918df7927c98b14bb25e110c3a7">Stokhos::OrthogonalizationFactory&lt; ordinal_type, value_type &gt;::createOrthogonalBasis()</a>.</p>

</div>
</div>
<a id="a33aa8a89b7351fc5a86e2432192ce387" name="a33aa8a89b7351fc5a86e2432192ce387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33aa8a89b7351fc5a86e2432192ce387">&#9670;&#160;</a></span>CPQR_MGS_reorthog_threshold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ordinal_type , typename scalar_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ordinal_type Stokhos::CPQR_MGS_reorthog_threshold </td>
          <td>(</td>
          <td class="paramtype">const scalar_type &amp;&#160;</td>
          <td class="paramname"><em>rank_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::Array&lt; scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::Array&lt; ordinal_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>piv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute column-pivoted QR using modified Gram-Schmidt and reorthogonalization. </p>
<p>For A an m-by-n matrix, computes A*P = Q*R with R k-by-k upper triangular, Q m-by-k with orthonormal columns, and P an n-by-k permutation matrix. Here k &lt;= min(m,n) is determined by a rank threshold tau provided by the user. The resulting R will have cond(R) &lt;= 1/tau. P is returned in the pivot array <code>piv</code> and the rank k returned by the function. Only the first k entries of <code>piv</code> will be set. As with LAPACK, the user can require columns of A to be included in P by setting the corresponding entries of piv to be nonzero on input. The orthogonality of Q is determined by the weight vector w, defining a weighted inner-product. </p>

<p class="reference">References <a class="el" href="namespace_stokhos.html#a1d2ef8273fcb4ad7015db71bf40b455b">CPQR_MGS_threshold()</a>, and <a class="el" href="namespace_stokhos.html#a976da99a712c72b48f115a33a2b3cfe8">QR_MGS()</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_stokhos_1_1_orthogonalization_factory.html#ab9026918df7927c98b14bb25e110c3a7">Stokhos::OrthogonalizationFactory&lt; ordinal_type, value_type &gt;::createOrthogonalBasis()</a>.</p>

</div>
</div>
<a id="a1d2ef8273fcb4ad7015db71bf40b455b" name="a1d2ef8273fcb4ad7015db71bf40b455b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2ef8273fcb4ad7015db71bf40b455b">&#9670;&#160;</a></span>CPQR_MGS_threshold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ordinal_type , typename scalar_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ordinal_type Stokhos::CPQR_MGS_threshold </td>
          <td>(</td>
          <td class="paramtype">const scalar_type &amp;&#160;</td>
          <td class="paramname"><em>rank_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::Array&lt; scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::Array&lt; ordinal_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>piv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute column-pivoted QR using modified Gram-Schmidt. </p>
<p>For A an m-by-n matrix, computes A*P = Q*R with R k-by-k upper triangular, Q m-by-k with orthonormal columns, and P an n-by-k permutation matrix. Here k &lt;= min(m,n) is determined by a rank threshold tau provided by the user. The resulting R will have cond(R) &lt;= 1/tau. P is returned in the pivot array <code>piv</code> and the rank k returned by the function. Only the first k entries of <code>piv</code> will be set. As with LAPACK, the user can require columns of A to be included in P by setting the corresponding entries of piv to be nonzero on input. The orthogonality of Q is determined by the weight vector w, defining a weighted inner-product. </p>

<p class="reference">Referenced by <a class="el" href="namespace_stokhos.html#a33aa8a89b7351fc5a86e2432192ce387">CPQR_MGS_reorthog_threshold()</a>, and <a class="el" href="class_stokhos_1_1_orthogonalization_factory.html#ab9026918df7927c98b14bb25e110c3a7">Stokhos::OrthogonalizationFactory&lt; ordinal_type, value_type &gt;::createOrthogonalBasis()</a>.</p>

</div>
</div>
<a id="abd78fc3c9830cd53e4483db17605d4ca" name="abd78fc3c9830cd53e4483db17605d4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd78fc3c9830cd53e4483db17605d4ca">&#9670;&#160;</a></span>QR_CGS()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ordinal_type , typename scalar_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Stokhos::QR_CGS </td>
          <td>(</td>
          <td class="paramtype">ordinal_type&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::Array&lt; scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute thin QR using classical Gram-Schmidt. </p>
<p>For A an m-by-n matrix computes A = Q*R with R k-by-k upper triangular, Q m-by-k with orthogonal columns, k &lt;= min(m,n). </p>

</div>
</div>
<a id="ac4266f5096a5376b56f41294035ac5dc" name="ac4266f5096a5376b56f41294035ac5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4266f5096a5376b56f41294035ac5dc">&#9670;&#160;</a></span>QR_Householder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ordinal_type , typename scalar_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Stokhos::QR_Householder </td>
          <td>(</td>
          <td class="paramtype">ordinal_type&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::Array&lt; scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute thin QR using Householder reflections. </p>
<p>For A an m-by-n matrix computes A = Q*R with R k-by-k upper triangular, Q m-by-k with orthogonal columns, k &lt;= min(m,n).</p>
<p>The QR factorization is computed by the corresponding LAPACK function. </p>

<p class="reference">Referenced by <a class="el" href="class_stokhos_1_1_orthogonalization_factory.html#ab9026918df7927c98b14bb25e110c3a7">Stokhos::OrthogonalizationFactory&lt; ordinal_type, value_type &gt;::createOrthogonalBasis()</a>.</p>

</div>
</div>
<a id="a976da99a712c72b48f115a33a2b3cfe8" name="a976da99a712c72b48f115a33a2b3cfe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976da99a712c72b48f115a33a2b3cfe8">&#9670;&#160;</a></span>QR_MGS()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ordinal_type , typename scalar_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Stokhos::QR_MGS </td>
          <td>(</td>
          <td class="paramtype">ordinal_type&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::Array&lt; scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute thin QR using modified Gram-Schmidt. </p>
<p>For A an m-by-n matrix computes A = Q*R with R k-by-k upper triangular, Q m-by-k with orthogonal columns, k &lt;= min(m,n). </p>

<p class="reference">Referenced by <a class="el" href="namespace_stokhos.html#a33aa8a89b7351fc5a86e2432192ce387">CPQR_MGS_reorthog_threshold()</a>, and <a class="el" href="class_stokhos_1_1_orthogonalization_factory.html#ab9026918df7927c98b14bb25e110c3a7">Stokhos::OrthogonalizationFactory&lt; ordinal_type, value_type &gt;::createOrthogonalBasis()</a>.</p>

</div>
</div>
<a id="aa27cfde568a781c27567661f4469c708" name="aa27cfde568a781c27567661f4469c708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa27cfde568a781c27567661f4469c708">&#9670;&#160;</a></span>QR_MGS2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ordinal_type , typename scalar_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Stokhos::QR_MGS2 </td>
          <td>(</td>
          <td class="paramtype">ordinal_type&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::Array&lt; scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute thin QR using modified Gram-Schmidt with reorthogonalization. </p>
<p>For A an m-by-n matrix computes A = Q*R with R k-by-k upper triangular, Q m-by-k with orthogonal columns, k &lt;= min(m,n). </p>

<p class="reference">Referenced by <a class="el" href="class_stokhos_1_1_orthogonalization_factory.html#ab9026918df7927c98b14bb25e110c3a7">Stokhos::OrthogonalizationFactory&lt; ordinal_type, value_type &gt;::createOrthogonalBasis()</a>.</p>

</div>
</div>
<a id="ae4a79baff2e138fbfb804a374fa612ee" name="ae4a79baff2e138fbfb804a374fa612ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a79baff2e138fbfb804a374fa612ee">&#9670;&#160;</a></span>QROrthogonalizationError()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ordinal_type , typename scalar_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">scalar_type Stokhos::QROrthogonalizationError </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute QR orthogonalization error. </p>
<p>Computes ||Q^T*Q-I||_infinity for Q coming from a QR factorization. </p>

</div>
</div>
<a id="a5a7b8599407eb1f166d13345e43ec7fe" name="a5a7b8599407eb1f166d13345e43ec7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7b8599407eb1f166d13345e43ec7fe">&#9670;&#160;</a></span>residualCPQRError()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ordinal_type , typename scalar_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">scalar_type Stokhos::residualCPQRError </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::Array&lt; ordinal_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>piv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute column-pivoted QR residual error. </p>
<p>Computes ||Q*R-A*P||_infinity for Q,R coming from a column-pivoted QR factorization.</p>
<p>Works with thin or full QR, weighted or not. </p>

<p class="reference">Referenced by <a class="el" href="class_stokhos_1_1_orthogonalization_factory.html#ab9026918df7927c98b14bb25e110c3a7">Stokhos::OrthogonalizationFactory&lt; ordinal_type, value_type &gt;::createOrthogonalBasis()</a>.</p>

</div>
</div>
<a id="a79f75e92ef4f2b241c8158929db724f2" name="a79f75e92ef4f2b241c8158929db724f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f75e92ef4f2b241c8158929db724f2">&#9670;&#160;</a></span>residualQRError()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ordinal_type , typename scalar_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">scalar_type Stokhos::residualQRError </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute QR residual error. </p>
<p>Computes ||Q*R-A||_infinity for Q,R coming from QR factorization.</p>
<p>Works with thin or full QR, weighted or not. </p>

</div>
</div>
<a id="a6b50c65c53654bcb00e956b142219e41" name="a6b50c65c53654bcb00e956b142219e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b50c65c53654bcb00e956b142219e41">&#9670;&#160;</a></span>sparse3Tensor2CrsGraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ordinal_type , typename value_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; Epetra_CrsGraph &gt; Stokhos::sparse3Tensor2CrsGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_stokhos_1_1_orthog_poly_basis.html">Stokhos::OrthogPolyBasis</a>&lt; ordinal_type, value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_stokhos_1_1_sparse3_tensor.html">Stokhos::Sparse3Tensor</a>&lt; ordinal_type, value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>Cijk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_Comm &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build an Epetra_CrsGraph from a sparse 3 tensor. </p>
<p>Builds a sparse graph from a sparse 3 tensor by summing over the third index. This graph then represents the sparsity pattern of the stochastic part of the block stochastic Galerkin operator. Redistributing the graph should then provide a suitable parallel distribution for block stochastic Galerkin linear solves. </p>

<p class="reference">References <a class="el" href="class_stokhos_1_1_sparse3_tensor.html#a8a4a436b22292a5a17d891012f070c0d">Stokhos::Sparse3Tensor&lt; ordinal_type, value_type &gt;::i_begin()</a>, <a class="el" href="class_stokhos_1_1_sparse3_tensor.html#ab5584df2af46457926c1c7f85430a1f6">Stokhos::Sparse3Tensor&lt; ordinal_type, value_type &gt;::i_end()</a>, <a class="el" href="class_stokhos_1_1_sparse3_tensor.html#aa066e1cc3710af12770a54e2820ed277">Stokhos::Sparse3Tensor&lt; ordinal_type, value_type &gt;::j_begin()</a>, <a class="el" href="class_stokhos_1_1_sparse3_tensor.html#a39a9bdb9599a8f082a4d46bf28449c28">Stokhos::Sparse3Tensor&lt; ordinal_type, value_type &gt;::j_end()</a>, <a class="el" href="class_stokhos_1_1_sparse3_tensor.html#a5d80c524f0af83b69ab67de289a11afc">Stokhos::Sparse3Tensor&lt; ordinal_type, value_type &gt;::k_begin()</a>, <a class="el" href="class_stokhos_1_1_sparse3_tensor.html#ae4add7501855cd74708fa255f26149bf">Stokhos::Sparse3Tensor&lt; ordinal_type, value_type &gt;::k_end()</a>, and <a class="el" href="class_stokhos_1_1_orthog_poly_basis.html#a9ec183b10345ceb6f99c1526929a8986">Stokhos::OrthogPolyBasis&lt; ordinal_type, value_type &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_stokhos_1_1_epetra_sparse3_tensor.html#afba58effb2293feddd3b0d974acbe011">Stokhos::EpetraSparse3Tensor::EpetraSparse3Tensor()</a>, <a class="el" href="class_stokhos_1_1_epetra_sparse3_tensor.html#abd0cadc3a31b01d08382fd877b3204ad">Stokhos::EpetraSparse3Tensor::EpetraSparse3Tensor()</a>, and <a class="el" href="class_stokhos_1_1_epetra_sparse3_tensor.html#a0b7289f5613e2a03029be212b35097f7">Stokhos::EpetraSparse3Tensor::EpetraSparse3Tensor()</a>.</p>

</div>
</div>
<a id="a05bd24053308e7d7f4db8a89e4d514cf" name="a05bd24053308e7d7f4db8a89e4d514cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05bd24053308e7d7f4db8a89e4d514cf">&#9670;&#160;</a></span>sparse3Tensor2CrsGraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ordinal_type , typename value_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; Epetra_CrsGraph &gt; Stokhos::sparse3Tensor2CrsGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_stokhos_1_1_sparse3_tensor.html">Stokhos::Sparse3Tensor</a>&lt; ordinal_type, value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>Cijk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_BlockMap &amp;&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build an Epetra_CrsGraph from a sparse 3 tensor. </p>
<p>Builds a sparse graph from a sparse 3 tensor by summing over the third index. This graph then represents the sparsity pattern of the stochastic part of the block stochastic Galerkin operator. Redistributing the graph should then provide a suitable parallel distribution for block stochastic Galerkin linear solves. </p>

<p class="reference">References <a class="el" href="class_stokhos_1_1_sparse3_tensor.html#a8a4a436b22292a5a17d891012f070c0d">Stokhos::Sparse3Tensor&lt; ordinal_type, value_type &gt;::i_begin()</a>, <a class="el" href="class_stokhos_1_1_sparse3_tensor.html#ab5584df2af46457926c1c7f85430a1f6">Stokhos::Sparse3Tensor&lt; ordinal_type, value_type &gt;::i_end()</a>, <a class="el" href="class_stokhos_1_1_sparse3_tensor.html#aa066e1cc3710af12770a54e2820ed277">Stokhos::Sparse3Tensor&lt; ordinal_type, value_type &gt;::j_begin()</a>, <a class="el" href="class_stokhos_1_1_sparse3_tensor.html#a39a9bdb9599a8f082a4d46bf28449c28">Stokhos::Sparse3Tensor&lt; ordinal_type, value_type &gt;::j_end()</a>, <a class="el" href="class_stokhos_1_1_sparse3_tensor.html#a5d80c524f0af83b69ab67de289a11afc">Stokhos::Sparse3Tensor&lt; ordinal_type, value_type &gt;::k_begin()</a>, and <a class="el" href="class_stokhos_1_1_sparse3_tensor.html#ae4add7501855cd74708fa255f26149bf">Stokhos::Sparse3Tensor&lt; ordinal_type, value_type &gt;::k_end()</a>.</p>

</div>
</div>
<a id="a4eddff5953ffb189e007eef9770d93ae" name="a4eddff5953ffb189e007eef9770d93ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eddff5953ffb189e007eef9770d93ae">&#9670;&#160;</a></span>sparse3Tensor2TpetraCrsGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TpetraLocalOrdinal , typename TpetraGlobalOrdinal , typename TpetraNode , typename StokhosOrdinal , typename StokhosValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; Tpetra::CrsGraph&lt; TpetraLocalOrdinal, TpetraGlobalOrdinal, TpetraNode &gt; &gt; Stokhos::sparse3Tensor2TpetraCrsGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_stokhos_1_1_orthog_poly_basis.html">Stokhos::OrthogPolyBasis</a>&lt; StokhosOrdinal, StokhosValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_stokhos_1_1_sparse3_tensor.html">Stokhos::Sparse3Tensor</a>&lt; StokhosOrdinal, StokhosValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>Cijk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::RCP&lt; const Teuchos::Comm&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build an Tpetra::CrsGraph from a sparse 3 tensor. </p>
<p>Builds a sparse graph from a sparse 3 tensor by summing over the third index. This graph then represents the sparsity pattern of the stochastic part of the block stochastic Galerkin operator. Redistributing the graph should then provide a suitable parallel distribution for block stochastic Galerkin linear solves. </p>

<p class="reference">References <a class="el" href="class_stokhos_1_1_sparse3_tensor.html#a8a4a436b22292a5a17d891012f070c0d">Stokhos::Sparse3Tensor&lt; ordinal_type, value_type &gt;::i_begin()</a>, <a class="el" href="class_stokhos_1_1_sparse3_tensor.html#ab5584df2af46457926c1c7f85430a1f6">Stokhos::Sparse3Tensor&lt; ordinal_type, value_type &gt;::i_end()</a>, <a class="el" href="class_stokhos_1_1_sparse3_tensor.html#aa066e1cc3710af12770a54e2820ed277">Stokhos::Sparse3Tensor&lt; ordinal_type, value_type &gt;::j_begin()</a>, <a class="el" href="class_stokhos_1_1_sparse3_tensor.html#a39a9bdb9599a8f082a4d46bf28449c28">Stokhos::Sparse3Tensor&lt; ordinal_type, value_type &gt;::j_end()</a>, <a class="el" href="class_stokhos_1_1_sparse3_tensor.html#a5d80c524f0af83b69ab67de289a11afc">Stokhos::Sparse3Tensor&lt; ordinal_type, value_type &gt;::k_begin()</a>, <a class="el" href="class_stokhos_1_1_sparse3_tensor.html#ae4add7501855cd74708fa255f26149bf">Stokhos::Sparse3Tensor&lt; ordinal_type, value_type &gt;::k_end()</a>, and <a class="el" href="class_stokhos_1_1_orthog_poly_basis.html#a9ec183b10345ceb6f99c1526929a8986">Stokhos::OrthogPolyBasis&lt; ordinal_type, value_type &gt;::size()</a>.</p>

</div>
</div>
<a id="abafdfb05537516e2a14564ed26651838" name="abafdfb05537516e2a14564ed26651838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abafdfb05537516e2a14564ed26651838">&#9670;&#160;</a></span>svd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ordinal_type , typename scalar_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Stokhos::svd </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::Array&lt; scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute SVD of matrix. </p>
<p>The SVD is computed by the corresponding LAPACK function. </p>

</div>
</div>
<a id="aeedf09b409bead5914922fe0408a1af5" name="aeedf09b409bead5914922fe0408a1af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeedf09b409bead5914922fe0408a1af5">&#9670;&#160;</a></span>weightedQROrthogonalizationError()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ordinal_type , typename scalar_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">scalar_type Stokhos::weightedQROrthogonalizationError </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::SerialDenseMatrix&lt; ordinal_type, scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::Array&lt; scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute weighted QR orthogonalization error. </p>
<p>Computes ||Q^T*W*Q-I||_infinity for Q coming from a weighted QR factorization. </p>

<p class="reference">Referenced by <a class="el" href="class_stokhos_1_1_orthogonalization_factory.html#ab9026918df7927c98b14bb25e110c3a7">Stokhos::OrthogonalizationFactory&lt; ordinal_type, value_type &gt;::createOrthogonalBasis()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
