<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stokhos: Teuchos::SerialQRDenseSolver&lt; OrdinalType, Sacado::MP::Vector&lt; Storage &gt; &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Stokhos<span id="projectnumber">&#160;Development</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Teuchos</b></li><li class="navelem"><a class="el" href="classTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4.html">SerialQRDenseSolver&lt; OrdinalType, Sacado::MP::Vector&lt; Storage &gt; &gt;</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="classTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Teuchos::SerialQRDenseSolver&lt; OrdinalType, Sacado::MP::Vector&lt; Storage &gt; &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for Teuchos::SerialQRDenseSolver&lt; OrdinalType, Sacado::MP::Vector&lt; Storage &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4__inherit__graph.gif" border="0" usemap="#aTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4_inherit__map" id="aTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4_inherit__map">
<area shape="rect" title=" " alt="" coords="5,79,225,133"/>
<area shape="rect" title=" " alt="" coords="11,5,113,31"/>
<area shape="poly" title=" " alt="" coords="79,41,101,77,97,80,74,44"/>
<area shape="rect" title=" " alt="" coords="138,5,202,31"/>
<area shape="poly" title=" " alt="" coords="158,44,134,80,130,77,153,41"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Teuchos::SerialQRDenseSolver&lt; OrdinalType, Sacado::MP::Vector&lt; Storage &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4__coll__graph.gif" border="0" usemap="#aTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4_coll__map" id="aTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4_coll__map">
<area shape="rect" title=" " alt="" coords="5,79,225,133"/>
<area shape="rect" title=" " alt="" coords="11,5,113,31"/>
<area shape="poly" title=" " alt="" coords="79,41,101,77,97,80,74,44"/>
<area shape="rect" title=" " alt="" coords="138,5,202,31"/>
<area shape="poly" title=" " alt="" coords="158,44,134,80,130,77,153,41"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a79eb7b85aa95dae8a909d994fee5a530" id="r_a79eb7b85aa95dae8a909d994fee5a530"><td class="memItemLeft" align="right" valign="top"><a id="a79eb7b85aa95dae8a909d994fee5a530" name="a79eb7b85aa95dae8a909d994fee5a530"></a>
typedef <a class="el" href="classSacado_1_1MP_1_1Vector.html">Sacado::MP::Vector</a>&lt; Storage &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ScalarType</b></td></tr>
<tr class="separator:a79eb7b85aa95dae8a909d994fee5a530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d94a4e11c6d077826c8ed42d6b8b49" id="r_a50d94a4e11c6d077826c8ed42d6b8b49"><td class="memItemLeft" align="right" valign="top"><a id="a50d94a4e11c6d077826c8ed42d6b8b49" name="a50d94a4e11c6d077826c8ed42d6b8b49"></a>
typedef ScalarTraits&lt; <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a> &gt;::magnitudeType&#160;</td><td class="memItemRight" valign="bottom"><b>MagnitudeType</b></td></tr>
<tr class="separator:a50d94a4e11c6d077826c8ed42d6b8b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructor/Destructor Methods</div></td></tr>
<tr class="memitem:a975ce49c56318951b528420dc281c201" id="r_a975ce49c56318951b528420dc281c201"><td class="memItemLeft" align="right" valign="top"><a id="a975ce49c56318951b528420dc281c201" name="a975ce49c56318951b528420dc281c201"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SerialQRDenseSolver</b> ()</td></tr>
<tr class="memdesc:a975ce49c56318951b528420dc281c201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor; matrix should be set using <a class="el" href="classTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4.html#a7c078cb94a1b04e72b64f264499e4290" title="Sets the pointers for coefficient matrix.">setMatrix()</a>, LHS and RHS set with <a class="el" href="classTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4.html#aee9c191f47596746948ddfd0ff013349" title="Sets the pointers for left and right hand side vector(s).">setVectors()</a>. <br /></td></tr>
<tr class="separator:a975ce49c56318951b528420dc281c201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4750aafa0bdca340fb4397dd93a6a710" id="r_a4750aafa0bdca340fb4397dd93a6a710"><td class="memItemLeft" align="right" valign="top"><a id="a4750aafa0bdca340fb4397dd93a6a710" name="a4750aafa0bdca340fb4397dd93a6a710"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~SerialQRDenseSolver</b> ()</td></tr>
<tr class="memdesc:a4750aafa0bdca340fb4397dd93a6a710"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classTeuchos_1_1SerialQRDenseSolver.html" title="Specialization for Sacado::UQ::PCE&lt; Storage&lt;...&gt; &gt;">SerialQRDenseSolver</a> destructor. <br /></td></tr>
<tr class="separator:a4750aafa0bdca340fb4397dd93a6a710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Set Methods</div></td></tr>
<tr class="memitem:a7c078cb94a1b04e72b64f264499e4290" id="r_a7c078cb94a1b04e72b64f264499e4290"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4.html#a7c078cb94a1b04e72b64f264499e4290">setMatrix</a> (const RCP&lt; SerialDenseMatrix&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a> &gt; &gt; &amp;A)</td></tr>
<tr class="memdesc:a7c078cb94a1b04e72b64f264499e4290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pointers for coefficient matrix.  <br /></td></tr>
<tr class="separator:a7c078cb94a1b04e72b64f264499e4290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9c191f47596746948ddfd0ff013349" id="r_aee9c191f47596746948ddfd0ff013349"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4.html#aee9c191f47596746948ddfd0ff013349">setVectors</a> (const RCP&lt; SerialDenseMatrix&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a> &gt; &gt; &amp;X, const RCP&lt; SerialDenseMatrix&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a> &gt; &gt; &amp;B)</td></tr>
<tr class="memdesc:aee9c191f47596746948ddfd0ff013349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pointers for left and right hand side vector(s).  <br /></td></tr>
<tr class="separator:aee9c191f47596746948ddfd0ff013349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Strategy Modifying Methods</div></td></tr>
<tr class="memitem:af30ee206cec92a5b4609f644338adda1" id="r_af30ee206cec92a5b4609f644338adda1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4.html#af30ee206cec92a5b4609f644338adda1">factorWithEquilibration</a> (bool flag)</td></tr>
<tr class="memdesc:af30ee206cec92a5b4609f644338adda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes equilibration to be called just before the matrix factorization as part of the call to <code>factor</code>.  <br /></td></tr>
<tr class="separator:af30ee206cec92a5b4609f644338adda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd27b6943fbd4e16862065bd3ea21e7" id="r_a1dd27b6943fbd4e16862065bd3ea21e7"><td class="memItemLeft" align="right" valign="top"><a id="a1dd27b6943fbd4e16862065bd3ea21e7" name="a1dd27b6943fbd4e16862065bd3ea21e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>solveWithTranspose</b> (bool flag)</td></tr>
<tr class="memdesc:a1dd27b6943fbd4e16862065bd3ea21e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>flag</code> is true, causes all subsequent function calls to work with the adjoint of <em>this</em> matrix, otherwise not. <br /></td></tr>
<tr class="separator:a1dd27b6943fbd4e16862065bd3ea21e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b1eb6795404627ee765ee2633fffda" id="r_ad2b1eb6795404627ee765ee2633fffda"><td class="memItemLeft" align="right" valign="top"><a id="ad2b1eb6795404627ee765ee2633fffda" name="ad2b1eb6795404627ee765ee2633fffda"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>solveWithTransposeFlag</b> (Teuchos::ETransp trans)</td></tr>
<tr class="memdesc:ad2b1eb6795404627ee765ee2633fffda"><td class="mdescLeft">&#160;</td><td class="mdescRight">All subsequent function calls will work with the transpose-type set by this method (<code>Teuchos::NO_TRANS</code> or Teuchos::CONJ_TRANS). <br /></td></tr>
<tr class="separator:ad2b1eb6795404627ee765ee2633fffda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Factor/Solve/Invert Methods</div></td></tr>
<tr class="memitem:a8a7f50b257ba6c65368ae9d8e38a6785" id="r_a8a7f50b257ba6c65368ae9d8e38a6785"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4.html#a8a7f50b257ba6c65368ae9d8e38a6785">factor</a> ()</td></tr>
<tr class="memdesc:a8a7f50b257ba6c65368ae9d8e38a6785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the in-place QR factorization of the matrix using the <a class="el" href="classTeuchos_1_1LAPACK.html" title="Specialization for Sacado::UQ::PCE&lt; Storage&lt;...&gt; &gt;">LAPACK</a> routine <em>_GETRF</em> or the Eigen class <em>HouseholderQR</em>.  <br /></td></tr>
<tr class="separator:a8a7f50b257ba6c65368ae9d8e38a6785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fd29b15f7a6aba7215c80f39da378b" id="r_a89fd29b15f7a6aba7215c80f39da378b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4.html#a89fd29b15f7a6aba7215c80f39da378b">solve</a> ()</td></tr>
<tr class="memdesc:a89fd29b15f7a6aba7215c80f39da378b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the solution X to AX = B for the <em>this</em> matrix and the B provided to SetVectors()..  <br /></td></tr>
<tr class="separator:a89fd29b15f7a6aba7215c80f39da378b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979398d152c739104e3434707572ad50" id="r_a979398d152c739104e3434707572ad50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4.html#a979398d152c739104e3434707572ad50">computeEquilibrateScaling</a> ()</td></tr>
<tr class="memdesc:a979398d152c739104e3434707572ad50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <em>this</em> matrix should be scaled.  <br /></td></tr>
<tr class="separator:a979398d152c739104e3434707572ad50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7dcb70da7e5057700a67867d81d7e7" id="r_abd7dcb70da7e5057700a67867d81d7e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4.html#abd7dcb70da7e5057700a67867d81d7e7">equilibrateMatrix</a> ()</td></tr>
<tr class="memdesc:abd7dcb70da7e5057700a67867d81d7e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equilibrates the <em>this</em> matrix.  <br /></td></tr>
<tr class="separator:abd7dcb70da7e5057700a67867d81d7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500b4d499b92d4e068ecd9d9e615ebf5" id="r_a500b4d499b92d4e068ecd9d9e615ebf5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4.html#a500b4d499b92d4e068ecd9d9e615ebf5">equilibrateRHS</a> ()</td></tr>
<tr class="memdesc:a500b4d499b92d4e068ecd9d9e615ebf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equilibrates the current RHS.  <br /></td></tr>
<tr class="separator:a500b4d499b92d4e068ecd9d9e615ebf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f51812293fad9e0cfa91f7126afe635" id="r_a2f51812293fad9e0cfa91f7126afe635"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4.html#a2f51812293fad9e0cfa91f7126afe635">unequilibrateLHS</a> ()</td></tr>
<tr class="memdesc:a2f51812293fad9e0cfa91f7126afe635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unscales the solution vectors if equilibration was used to solve the system.  <br /></td></tr>
<tr class="separator:a2f51812293fad9e0cfa91f7126afe635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ebb782f569729d95d6cd8aa341a63b" id="r_a78ebb782f569729d95d6cd8aa341a63b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4.html#a78ebb782f569729d95d6cd8aa341a63b">formQ</a> ()</td></tr>
<tr class="memdesc:a78ebb782f569729d95d6cd8aa341a63b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly forms the unitary matrix Q.  <br /></td></tr>
<tr class="separator:a78ebb782f569729d95d6cd8aa341a63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18fc845825a547edc5dca939cae36b7b" id="r_a18fc845825a547edc5dca939cae36b7b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4.html#a18fc845825a547edc5dca939cae36b7b">formR</a> ()</td></tr>
<tr class="memdesc:a18fc845825a547edc5dca939cae36b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly forms the upper triangular matrix R.  <br /></td></tr>
<tr class="separator:a18fc845825a547edc5dca939cae36b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade97f1f142f1b10a451a6effa694af50" id="r_ade97f1f142f1b10a451a6effa694af50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4.html#ade97f1f142f1b10a451a6effa694af50">multiplyQ</a> (ETransp transq, SerialDenseMatrix&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a> &gt; &amp;C)</td></tr>
<tr class="memdesc:ade97f1f142f1b10a451a6effa694af50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left multiply the input matrix by the unitary matrix Q or its adjoint.  <br /></td></tr>
<tr class="separator:ade97f1f142f1b10a451a6effa694af50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5dfcbd3aea4e00b974e409f8fffe59" id="r_afc5dfcbd3aea4e00b974e409f8fffe59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4.html#afc5dfcbd3aea4e00b974e409f8fffe59">solveR</a> (ETransp transr, SerialDenseMatrix&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a> &gt; &amp;C)</td></tr>
<tr class="memdesc:afc5dfcbd3aea4e00b974e409f8fffe59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve input matrix on the left with the upper triangular matrix R or its adjoint.  <br /></td></tr>
<tr class="separator:afc5dfcbd3aea4e00b974e409f8fffe59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Query methods</div></td></tr>
<tr class="memitem:aa16952e3390af68460c15a303fda485e" id="r_aa16952e3390af68460c15a303fda485e"><td class="memItemLeft" align="right" valign="top"><a id="aa16952e3390af68460c15a303fda485e" name="aa16952e3390af68460c15a303fda485e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>transpose</b> ()</td></tr>
<tr class="memdesc:aa16952e3390af68460c15a303fda485e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if adjoint of <em>this</em> matrix has and will be used. <br /></td></tr>
<tr class="separator:aa16952e3390af68460c15a303fda485e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687a43b60c46e7d5ccf302d61c56dd20" id="r_a687a43b60c46e7d5ccf302d61c56dd20"><td class="memItemLeft" align="right" valign="top"><a id="a687a43b60c46e7d5ccf302d61c56dd20" name="a687a43b60c46e7d5ccf302d61c56dd20"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>factored</b> ()</td></tr>
<tr class="memdesc:a687a43b60c46e7d5ccf302d61c56dd20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if matrix is factored (factor available via <a class="el" href="classTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4.html#abafe762224b42a194973ac70a36eec59" title="Returns pointer to factored matrix (assuming factorization has been performed).">getFactoredMatrix()</a>). <br /></td></tr>
<tr class="separator:a687a43b60c46e7d5ccf302d61c56dd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a5d4b268dec18bafa7ddbd5466f699" id="r_ab6a5d4b268dec18bafa7ddbd5466f699"><td class="memItemLeft" align="right" valign="top"><a id="ab6a5d4b268dec18bafa7ddbd5466f699" name="ab6a5d4b268dec18bafa7ddbd5466f699"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equilibratedA</b> ()</td></tr>
<tr class="memdesc:ab6a5d4b268dec18bafa7ddbd5466f699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if factor is equilibrated (factor available via <a class="el" href="classTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4.html#abafe762224b42a194973ac70a36eec59" title="Returns pointer to factored matrix (assuming factorization has been performed).">getFactoredMatrix()</a>). <br /></td></tr>
<tr class="separator:ab6a5d4b268dec18bafa7ddbd5466f699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c28b03a5c6accce055c7e2779f2921" id="r_aa0c28b03a5c6accce055c7e2779f2921"><td class="memItemLeft" align="right" valign="top"><a id="aa0c28b03a5c6accce055c7e2779f2921" name="aa0c28b03a5c6accce055c7e2779f2921"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equilibratedB</b> ()</td></tr>
<tr class="memdesc:aa0c28b03a5c6accce055c7e2779f2921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if RHS is equilibrated (RHS available via <a class="el" href="classTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4.html#adae13c9f8909893464bb61f6611b4535" title="Returns pointer to current RHS.">getRHS()</a>). <br /></td></tr>
<tr class="separator:aa0c28b03a5c6accce055c7e2779f2921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e30573eb8700b9a11fdce09caf9ad07" id="r_a4e30573eb8700b9a11fdce09caf9ad07"><td class="memItemLeft" align="right" valign="top"><a id="a4e30573eb8700b9a11fdce09caf9ad07" name="a4e30573eb8700b9a11fdce09caf9ad07"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>shouldEquilibrate</b> ()</td></tr>
<tr class="memdesc:a4e30573eb8700b9a11fdce09caf9ad07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classTeuchos_1_1LAPACK.html" title="Specialization for Sacado::UQ::PCE&lt; Storage&lt;...&gt; &gt;">LAPACK</a> general rules for equilibration suggest you should equilibrate the system. <br /></td></tr>
<tr class="separator:a4e30573eb8700b9a11fdce09caf9ad07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a84a204bf0feca70d65d2c97595f0c7" id="r_a7a84a204bf0feca70d65d2c97595f0c7"><td class="memItemLeft" align="right" valign="top"><a id="a7a84a204bf0feca70d65d2c97595f0c7" name="a7a84a204bf0feca70d65d2c97595f0c7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>solved</b> ()</td></tr>
<tr class="memdesc:a7a84a204bf0feca70d65d2c97595f0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the current set of vectors has been solved. <br /></td></tr>
<tr class="separator:a7a84a204bf0feca70d65d2c97595f0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa7e514ddb8fe3d727a2ed01873a325" id="r_afaa7e514ddb8fe3d727a2ed01873a325"><td class="memItemLeft" align="right" valign="top"><a id="afaa7e514ddb8fe3d727a2ed01873a325" name="afaa7e514ddb8fe3d727a2ed01873a325"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>formedQ</b> ()</td></tr>
<tr class="memdesc:afaa7e514ddb8fe3d727a2ed01873a325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if Q has been formed explicitly. <br /></td></tr>
<tr class="separator:afaa7e514ddb8fe3d727a2ed01873a325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dcdaa480f748e4293f981651ef8e49f" id="r_a5dcdaa480f748e4293f981651ef8e49f"><td class="memItemLeft" align="right" valign="top"><a id="a5dcdaa480f748e4293f981651ef8e49f" name="a5dcdaa480f748e4293f981651ef8e49f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>formedR</b> ()</td></tr>
<tr class="memdesc:a5dcdaa480f748e4293f981651ef8e49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if R has been formed explicitly. <br /></td></tr>
<tr class="separator:a5dcdaa480f748e4293f981651ef8e49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data Accessor methods</div></td></tr>
<tr class="memitem:a9bb77769194901a381565e71df5d59d3" id="r_a9bb77769194901a381565e71df5d59d3"><td class="memItemLeft" align="right" valign="top"><a id="a9bb77769194901a381565e71df5d59d3" name="a9bb77769194901a381565e71df5d59d3"></a>
RCP&lt; SerialDenseMatrix&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getMatrix</b> () const</td></tr>
<tr class="memdesc:a9bb77769194901a381565e71df5d59d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to current matrix. <br /></td></tr>
<tr class="separator:a9bb77769194901a381565e71df5d59d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafe762224b42a194973ac70a36eec59" id="r_abafe762224b42a194973ac70a36eec59"><td class="memItemLeft" align="right" valign="top"><a id="abafe762224b42a194973ac70a36eec59" name="abafe762224b42a194973ac70a36eec59"></a>
RCP&lt; SerialDenseMatrix&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getFactoredMatrix</b> () const</td></tr>
<tr class="memdesc:abafe762224b42a194973ac70a36eec59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to factored matrix (assuming factorization has been performed). <br /></td></tr>
<tr class="separator:abafe762224b42a194973ac70a36eec59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7a2941e7f48bda3cf5b6235ef79bd1" id="r_a2e7a2941e7f48bda3cf5b6235ef79bd1"><td class="memItemLeft" align="right" valign="top"><a id="a2e7a2941e7f48bda3cf5b6235ef79bd1" name="a2e7a2941e7f48bda3cf5b6235ef79bd1"></a>
RCP&lt; SerialDenseMatrix&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getQ</b> () const</td></tr>
<tr class="memdesc:a2e7a2941e7f48bda3cf5b6235ef79bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to Q (assuming factorization has been performed). <br /></td></tr>
<tr class="separator:a2e7a2941e7f48bda3cf5b6235ef79bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ad7413cab86755ffb06fa0ebf477bf" id="r_ae0ad7413cab86755ffb06fa0ebf477bf"><td class="memItemLeft" align="right" valign="top"><a id="ae0ad7413cab86755ffb06fa0ebf477bf" name="ae0ad7413cab86755ffb06fa0ebf477bf"></a>
RCP&lt; SerialDenseMatrix&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getR</b> () const</td></tr>
<tr class="memdesc:ae0ad7413cab86755ffb06fa0ebf477bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to R (assuming factorization has been performed). <br /></td></tr>
<tr class="separator:ae0ad7413cab86755ffb06fa0ebf477bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b62488dbd95e548d902a80fe1c44d0" id="r_a52b62488dbd95e548d902a80fe1c44d0"><td class="memItemLeft" align="right" valign="top"><a id="a52b62488dbd95e548d902a80fe1c44d0" name="a52b62488dbd95e548d902a80fe1c44d0"></a>
RCP&lt; SerialDenseMatrix&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getLHS</b> () const</td></tr>
<tr class="memdesc:a52b62488dbd95e548d902a80fe1c44d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to current LHS. <br /></td></tr>
<tr class="separator:a52b62488dbd95e548d902a80fe1c44d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae13c9f8909893464bb61f6611b4535" id="r_adae13c9f8909893464bb61f6611b4535"><td class="memItemLeft" align="right" valign="top"><a id="adae13c9f8909893464bb61f6611b4535" name="adae13c9f8909893464bb61f6611b4535"></a>
RCP&lt; SerialDenseMatrix&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getRHS</b> () const</td></tr>
<tr class="memdesc:adae13c9f8909893464bb61f6611b4535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to current RHS. <br /></td></tr>
<tr class="separator:adae13c9f8909893464bb61f6611b4535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f967bc1723f8af486dcef442f1e3282" id="r_a1f967bc1723f8af486dcef442f1e3282"><td class="memItemLeft" align="right" valign="top"><a id="a1f967bc1723f8af486dcef442f1e3282" name="a1f967bc1723f8af486dcef442f1e3282"></a>
OrdinalType&#160;</td><td class="memItemRight" valign="bottom"><b>numRows</b> () const</td></tr>
<tr class="memdesc:a1f967bc1723f8af486dcef442f1e3282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns row dimension of system. <br /></td></tr>
<tr class="separator:a1f967bc1723f8af486dcef442f1e3282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605ad28db3135e98b3b8c38bc621494f" id="r_a605ad28db3135e98b3b8c38bc621494f"><td class="memItemLeft" align="right" valign="top"><a id="a605ad28db3135e98b3b8c38bc621494f" name="a605ad28db3135e98b3b8c38bc621494f"></a>
OrdinalType&#160;</td><td class="memItemRight" valign="bottom"><b>numCols</b> () const</td></tr>
<tr class="memdesc:a605ad28db3135e98b3b8c38bc621494f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns column dimension of system. <br /></td></tr>
<tr class="separator:a605ad28db3135e98b3b8c38bc621494f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb00428510991928d849b14b81c796ec" id="r_afb00428510991928d849b14b81c796ec"><td class="memItemLeft" align="right" valign="top"><a id="afb00428510991928d849b14b81c796ec" name="afb00428510991928d849b14b81c796ec"></a>
std::vector&lt; <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tau</b> () const</td></tr>
<tr class="memdesc:afb00428510991928d849b14b81c796ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to pivot vector (if factorization has been computed), zero otherwise. <br /></td></tr>
<tr class="separator:afb00428510991928d849b14b81c796ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864093b2f627812a3fd5c7f0f93f072e" id="r_a864093b2f627812a3fd5c7f0f93f072e"><td class="memItemLeft" align="right" valign="top"><a id="a864093b2f627812a3fd5c7f0f93f072e" name="a864093b2f627812a3fd5c7f0f93f072e"></a>
MagnitudeType&#160;</td><td class="memItemRight" valign="bottom"><b>ANORM</b> () const</td></tr>
<tr class="memdesc:a864093b2f627812a3fd5c7f0f93f072e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of the largest element of <em>this</em> matrix (returns -1 if not yet computed). <br /></td></tr>
<tr class="separator:a864093b2f627812a3fd5c7f0f93f072e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">I/O methods</h2></td></tr>
<tr class="memitem:a2ed9c691cd4c66c66bbd23e4c326f4e9" id="r_a2ed9c691cd4c66c66bbd23e4c326f4e9"><td class="memItemLeft" align="right" valign="top"><a id="a2ed9c691cd4c66c66bbd23e4c326f4e9" name="a2ed9c691cd4c66c66bbd23e4c326f4e9"></a>
typedef ScalarType::value_type&#160;</td><td class="memItemRight" valign="bottom"><b>BaseScalarType</b></td></tr>
<tr class="separator:a2ed9c691cd4c66c66bbd23e4c326f4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89bb665f900ccaefcccc088c6d0ecbe" id="r_ae89bb665f900ccaefcccc088c6d0ecbe"><td class="memItemLeft" align="right" valign="top"><a id="ae89bb665f900ccaefcccc088c6d0ecbe" name="ae89bb665f900ccaefcccc088c6d0ecbe"></a>
typedef <a class="el" href="classTeuchos_1_1SerialQRDenseSolver.html">SerialQRDenseSolver</a>&lt; OrdinalType, BaseScalarType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BaseQRType</b></td></tr>
<tr class="separator:ae89bb665f900ccaefcccc088c6d0ecbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8c29f92b7e29858d348e147d20a095" id="r_a0d8c29f92b7e29858d348e147d20a095"><td class="memItemLeft" align="right" valign="top"><a id="a0d8c29f92b7e29858d348e147d20a095" name="a0d8c29f92b7e29858d348e147d20a095"></a>
typedef SerialDenseMatrix&lt; OrdinalType, BaseScalarType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BaseMatrixType</b></td></tr>
<tr class="separator:a0d8c29f92b7e29858d348e147d20a095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbcaaf9426ebd2b6f7d3b3b78229b07" id="r_a1bbcaaf9426ebd2b6f7d3b3b78229b07"><td class="memItemLeft" align="right" valign="top"><a id="a1bbcaaf9426ebd2b6f7d3b3b78229b07" name="a1bbcaaf9426ebd2b6f7d3b3b78229b07"></a>
typedef SerialDenseMatrix&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixType</b></td></tr>
<tr class="separator:a1bbcaaf9426ebd2b6f7d3b3b78229b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e4b11112ac1d28624801676677e698" id="r_ae2e4b11112ac1d28624801676677e698"><td class="memItemLeft" align="right" valign="top"><a id="ae2e4b11112ac1d28624801676677e698" name="ae2e4b11112ac1d28624801676677e698"></a>
<a class="el" href="classTeuchos_1_1SerialQRDenseSolver.html">BaseQRType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>base_QR_</b></td></tr>
<tr class="separator:ae2e4b11112ac1d28624801676677e698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec46bdfdd8bb753fec3e898bdb86f3e" id="r_aaec46bdfdd8bb753fec3e898bdb86f3e"><td class="memItemLeft" align="right" valign="top"><a id="aaec46bdfdd8bb753fec3e898bdb86f3e" name="aaec46bdfdd8bb753fec3e898bdb86f3e"></a>
OrdinalType&#160;</td><td class="memItemRight" valign="bottom"><b>M_</b></td></tr>
<tr class="separator:aaec46bdfdd8bb753fec3e898bdb86f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7986df0452c3256c4abd1948bc5c25" id="r_a7f7986df0452c3256c4abd1948bc5c25"><td class="memItemLeft" align="right" valign="top"><a id="a7f7986df0452c3256c4abd1948bc5c25" name="a7f7986df0452c3256c4abd1948bc5c25"></a>
OrdinalType&#160;</td><td class="memItemRight" valign="bottom"><b>N_</b></td></tr>
<tr class="separator:a7f7986df0452c3256c4abd1948bc5c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba824ded8970ddf57901ccc1aa217057" id="r_aba824ded8970ddf57901ccc1aa217057"><td class="memItemLeft" align="right" valign="top"><a id="aba824ded8970ddf57901ccc1aa217057" name="aba824ded8970ddf57901ccc1aa217057"></a>
OrdinalType&#160;</td><td class="memItemRight" valign="bottom"><b>SacadoSize_</b></td></tr>
<tr class="separator:aba824ded8970ddf57901ccc1aa217057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c97aa7b7a44e5bcffe708c050f51a5" id="r_a21c97aa7b7a44e5bcffe708c050f51a5"><td class="memItemLeft" align="right" valign="top"><a id="a21c97aa7b7a44e5bcffe708c050f51a5" name="a21c97aa7b7a44e5bcffe708c050f51a5"></a>
RCP&lt; MatrixType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Matrix_</b></td></tr>
<tr class="separator:a21c97aa7b7a44e5bcffe708c050f51a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09264dbe6119a71939b5f2a364ebbcb0" id="r_a09264dbe6119a71939b5f2a364ebbcb0"><td class="memItemLeft" align="right" valign="top"><a id="a09264dbe6119a71939b5f2a364ebbcb0" name="a09264dbe6119a71939b5f2a364ebbcb0"></a>
RCP&lt; MatrixType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>LHS_</b></td></tr>
<tr class="separator:a09264dbe6119a71939b5f2a364ebbcb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d285b7a1f5011f6787c643b37e0b70" id="r_ab9d285b7a1f5011f6787c643b37e0b70"><td class="memItemLeft" align="right" valign="top"><a id="ab9d285b7a1f5011f6787c643b37e0b70" name="ab9d285b7a1f5011f6787c643b37e0b70"></a>
RCP&lt; MatrixType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RHS_</b></td></tr>
<tr class="separator:ab9d285b7a1f5011f6787c643b37e0b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdff33bf5bda43438acc4450950e767" id="r_a4cdff33bf5bda43438acc4450950e767"><td class="memItemLeft" align="right" valign="top"><a id="a4cdff33bf5bda43438acc4450950e767" name="a4cdff33bf5bda43438acc4450950e767"></a>
RCP&lt; MatrixType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Factor_</b></td></tr>
<tr class="separator:a4cdff33bf5bda43438acc4450950e767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa24a70c99fe60941512a04faabe9fd" id="r_aaaa24a70c99fe60941512a04faabe9fd"><td class="memItemLeft" align="right" valign="top"><a id="aaaa24a70c99fe60941512a04faabe9fd" name="aaaa24a70c99fe60941512a04faabe9fd"></a>
RCP&lt; MatrixType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>FactorQ_</b></td></tr>
<tr class="separator:aaaa24a70c99fe60941512a04faabe9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464af9333cc958bc7c726394a8e47525" id="r_a464af9333cc958bc7c726394a8e47525"><td class="memItemLeft" align="right" valign="top"><a id="a464af9333cc958bc7c726394a8e47525" name="a464af9333cc958bc7c726394a8e47525"></a>
RCP&lt; MatrixType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>FactorR_</b></td></tr>
<tr class="separator:a464af9333cc958bc7c726394a8e47525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52c9e8ee7bdf0b1274c609d5c808998" id="r_aa52c9e8ee7bdf0b1274c609d5c808998"><td class="memItemLeft" align="right" valign="top"><a id="aa52c9e8ee7bdf0b1274c609d5c808998" name="aa52c9e8ee7bdf0b1274c609d5c808998"></a>
RCP&lt; BaseMatrixType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Base_Matrix_</b></td></tr>
<tr class="separator:aa52c9e8ee7bdf0b1274c609d5c808998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dbb72e4c96bb1790cb4d37adfc00c33" id="r_a7dbb72e4c96bb1790cb4d37adfc00c33"><td class="memItemLeft" align="right" valign="top"><a id="a7dbb72e4c96bb1790cb4d37adfc00c33" name="a7dbb72e4c96bb1790cb4d37adfc00c33"></a>
RCP&lt; BaseMatrixType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Base_LHS_</b></td></tr>
<tr class="separator:a7dbb72e4c96bb1790cb4d37adfc00c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a977eb124bb9c1db35de511c5265c60" id="r_a2a977eb124bb9c1db35de511c5265c60"><td class="memItemLeft" align="right" valign="top"><a id="a2a977eb124bb9c1db35de511c5265c60" name="a2a977eb124bb9c1db35de511c5265c60"></a>
RCP&lt; BaseMatrixType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Base_RHS_</b></td></tr>
<tr class="separator:a2a977eb124bb9c1db35de511c5265c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58258e2ba4e9bb736b9349d9fc472622" id="r_a58258e2ba4e9bb736b9349d9fc472622"><td class="memItemLeft" align="right" valign="top"><a id="a58258e2ba4e9bb736b9349d9fc472622" name="a58258e2ba4e9bb736b9349d9fc472622"></a>
RCP&lt; BaseMatrixType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Base_Factor_</b></td></tr>
<tr class="separator:a58258e2ba4e9bb736b9349d9fc472622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b2ee069810029561b93e00ac8ef30a" id="r_a82b2ee069810029561b93e00ac8ef30a"><td class="memItemLeft" align="right" valign="top"><a id="a82b2ee069810029561b93e00ac8ef30a" name="a82b2ee069810029561b93e00ac8ef30a"></a>
RCP&lt; BaseMatrixType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Base_FactorQ_</b></td></tr>
<tr class="separator:a82b2ee069810029561b93e00ac8ef30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2c7b649f65e6ab2113d60528bef200" id="r_a8a2c7b649f65e6ab2113d60528bef200"><td class="memItemLeft" align="right" valign="top"><a id="a8a2c7b649f65e6ab2113d60528bef200" name="a8a2c7b649f65e6ab2113d60528bef200"></a>
RCP&lt; BaseMatrixType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Base_FactorR_</b></td></tr>
<tr class="separator:a8a2c7b649f65e6ab2113d60528bef200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8aa2eb70a1c0a57989e7656f43cdbf" id="r_a5c8aa2eb70a1c0a57989e7656f43cdbf"><td class="memItemLeft" align="right" valign="top"><a id="a5c8aa2eb70a1c0a57989e7656f43cdbf" name="a5c8aa2eb70a1c0a57989e7656f43cdbf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Print</b> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:a5c8aa2eb70a1c0a57989e7656f43cdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print service methods; defines behavior of ostream &lt;&lt; operator. <br /></td></tr>
<tr class="separator:a5c8aa2eb70a1c0a57989e7656f43cdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00012570f12aa7ac008db210a7561f68" id="r_a00012570f12aa7ac008db210a7561f68"><td class="memItemLeft" align="right" valign="top"><a id="a00012570f12aa7ac008db210a7561f68" name="a00012570f12aa7ac008db210a7561f68"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resetMatrix</b> ()</td></tr>
<tr class="separator:a00012570f12aa7ac008db210a7561f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a0f6b956139f17f03977d15bc65b33" id="r_a58a0f6b956139f17f03977d15bc65b33"><td class="memItemLeft" align="right" valign="top"><a id="a58a0f6b956139f17f03977d15bc65b33" name="a58a0f6b956139f17f03977d15bc65b33"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resetVectors</b> ()</td></tr>
<tr class="separator:a58a0f6b956139f17f03977d15bc65b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de3f62c7f02e2b8a1f42e6e3904d80c" id="r_a9de3f62c7f02e2b8a1f42e6e3904d80c"><td class="memItemLeft" align="right" valign="top"><a id="a9de3f62c7f02e2b8a1f42e6e3904d80c" name="a9de3f62c7f02e2b8a1f42e6e3904d80c"></a>
RCP&lt; BaseMatrixType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>createBaseMatrix</b> (const RCP&lt; MatrixType &gt; &amp;mat) const</td></tr>
<tr class="separator:a9de3f62c7f02e2b8a1f42e6e3904d80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c114139c7977cf524a8e3866cb3cf7a" id="r_a9c114139c7977cf524a8e3866cb3cf7a"><td class="memItemLeft" align="right" valign="top"><a id="a9c114139c7977cf524a8e3866cb3cf7a" name="a9c114139c7977cf524a8e3866cb3cf7a"></a>
RCP&lt; MatrixType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>createMatrix</b> (const RCP&lt; BaseMatrixType &gt; &amp;base_mat) const</td></tr>
<tr class="separator:a9c114139c7977cf524a8e3866cb3cf7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a979398d152c739104e3434707572ad50" name="a979398d152c739104e3434707572ad50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979398d152c739104e3434707572ad50">&#9670;&#160;</a></span>computeEquilibrateScaling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OrdinalType , typename Storage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classTeuchos_1_1SerialQRDenseSolver.html">Teuchos::SerialQRDenseSolver</a>&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">Sacado::MP::Vector</a>&lt; Storage &gt; &gt;::computeEquilibrateScaling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if <em>this</em> matrix should be scaled. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="abd7dcb70da7e5057700a67867d81d7e7" name="abd7dcb70da7e5057700a67867d81d7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd7dcb70da7e5057700a67867d81d7e7">&#9670;&#160;</a></span>equilibrateMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OrdinalType , typename Storage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classTeuchos_1_1SerialQRDenseSolver.html">Teuchos::SerialQRDenseSolver</a>&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">Sacado::MP::Vector</a>&lt; Storage &gt; &gt;::equilibrateMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equilibrates the <em>this</em> matrix. </p>
<dl class="section note"><dt>Note</dt><dd>This method will be called automatically in <a class="el" href="classTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4.html#a89fd29b15f7a6aba7215c80f39da378b" title="Computes the solution X to AX = B for the this matrix and the B provided to SetVectors()....">solve()</a> method if factorWithEquilibration( true ) is called. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="a500b4d499b92d4e068ecd9d9e615ebf5" name="a500b4d499b92d4e068ecd9d9e615ebf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500b4d499b92d4e068ecd9d9e615ebf5">&#9670;&#160;</a></span>equilibrateRHS()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OrdinalType , typename Storage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classTeuchos_1_1SerialQRDenseSolver.html">Teuchos::SerialQRDenseSolver</a>&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">Sacado::MP::Vector</a>&lt; Storage &gt; &gt;::equilibrateRHS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equilibrates the current RHS. </p>
<dl class="section note"><dt>Note</dt><dd>This method will be called automatically in <a class="el" href="classTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4.html#a89fd29b15f7a6aba7215c80f39da378b" title="Computes the solution X to AX = B for the this matrix and the B provided to SetVectors()....">solve()</a> method if factorWithEquilibration( true ) is called. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="a8a7f50b257ba6c65368ae9d8e38a6785" name="a8a7f50b257ba6c65368ae9d8e38a6785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7f50b257ba6c65368ae9d8e38a6785">&#9670;&#160;</a></span>factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OrdinalType , typename Storage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classTeuchos_1_1SerialQRDenseSolver.html">Teuchos::SerialQRDenseSolver</a>&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">Sacado::MP::Vector</a>&lt; Storage &gt; &gt;::factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the in-place QR factorization of the matrix using the <a class="el" href="classTeuchos_1_1LAPACK.html" title="Specialization for Sacado::UQ::PCE&lt; Storage&lt;...&gt; &gt;">LAPACK</a> routine <em>_GETRF</em> or the Eigen class <em>HouseholderQR</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="af30ee206cec92a5b4609f644338adda1" name="af30ee206cec92a5b4609f644338adda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30ee206cec92a5b4609f644338adda1">&#9670;&#160;</a></span>factorWithEquilibration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OrdinalType , typename Storage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTeuchos_1_1SerialQRDenseSolver.html">Teuchos::SerialQRDenseSolver</a>&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">Sacado::MP::Vector</a>&lt; Storage &gt; &gt;::factorWithEquilibration </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Causes equilibration to be called just before the matrix factorization as part of the call to <code>factor</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This method must be called before the factorization is performed, otherwise it will have no effect. </dd></dl>

</div>
</div>
<a id="a78ebb782f569729d95d6cd8aa341a63b" name="a78ebb782f569729d95d6cd8aa341a63b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ebb782f569729d95d6cd8aa341a63b">&#9670;&#160;</a></span>formQ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OrdinalType , typename Storage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classTeuchos_1_1SerialQRDenseSolver.html">Teuchos::SerialQRDenseSolver</a>&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">Sacado::MP::Vector</a>&lt; Storage &gt; &gt;::formQ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly forms the unitary matrix Q. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="a18fc845825a547edc5dca939cae36b7b" name="a18fc845825a547edc5dca939cae36b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18fc845825a547edc5dca939cae36b7b">&#9670;&#160;</a></span>formR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OrdinalType , typename Storage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classTeuchos_1_1SerialQRDenseSolver.html">Teuchos::SerialQRDenseSolver</a>&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">Sacado::MP::Vector</a>&lt; Storage &gt; &gt;::formR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly forms the upper triangular matrix R. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="ade97f1f142f1b10a451a6effa694af50" name="ade97f1f142f1b10a451a6effa694af50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade97f1f142f1b10a451a6effa694af50">&#9670;&#160;</a></span>multiplyQ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OrdinalType , typename Storage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classTeuchos_1_1SerialQRDenseSolver.html">Teuchos::SerialQRDenseSolver</a>&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">Sacado::MP::Vector</a>&lt; Storage &gt; &gt;::multiplyQ </td>
          <td>(</td>
          <td class="paramtype">ETransp&#160;</td>
          <td class="paramname"><em>transq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SerialDenseMatrix&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left multiply the input matrix by the unitary matrix Q or its adjoint. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="a7c078cb94a1b04e72b64f264499e4290" name="a7c078cb94a1b04e72b64f264499e4290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c078cb94a1b04e72b64f264499e4290">&#9670;&#160;</a></span>setMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OrdinalType , typename Storage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classTeuchos_1_1SerialQRDenseSolver.html">Teuchos::SerialQRDenseSolver</a>&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">Sacado::MP::Vector</a>&lt; Storage &gt; &gt;::setMatrix </td>
          <td>(</td>
          <td class="paramtype">const RCP&lt; SerialDenseMatrix&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the pointers for coefficient matrix. </p>
<p>Row dimension of A must be greater than or equal to the column dimension of A. </p>

</div>
</div>
<a id="aee9c191f47596746948ddfd0ff013349" name="aee9c191f47596746948ddfd0ff013349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9c191f47596746948ddfd0ff013349">&#9670;&#160;</a></span>setVectors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OrdinalType , typename Storage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classTeuchos_1_1SerialQRDenseSolver.html">Teuchos::SerialQRDenseSolver</a>&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">Sacado::MP::Vector</a>&lt; Storage &gt; &gt;::setVectors </td>
          <td>(</td>
          <td class="paramtype">const RCP&lt; SerialDenseMatrix&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RCP&lt; SerialDenseMatrix&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the pointers for left and right hand side vector(s). </p>
<p>Row dimension of X must match column dimension of matrix A, row dimension of B must match row dimension of A. </p>

</div>
</div>
<a id="a89fd29b15f7a6aba7215c80f39da378b" name="a89fd29b15f7a6aba7215c80f39da378b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89fd29b15f7a6aba7215c80f39da378b">&#9670;&#160;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OrdinalType , typename Storage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classTeuchos_1_1SerialQRDenseSolver.html">Teuchos::SerialQRDenseSolver</a>&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">Sacado::MP::Vector</a>&lt; Storage &gt; &gt;::solve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the solution X to AX = B for the <em>this</em> matrix and the B provided to SetVectors().. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="afc5dfcbd3aea4e00b974e409f8fffe59" name="afc5dfcbd3aea4e00b974e409f8fffe59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5dfcbd3aea4e00b974e409f8fffe59">&#9670;&#160;</a></span>solveR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OrdinalType , typename Storage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classTeuchos_1_1SerialQRDenseSolver.html">Teuchos::SerialQRDenseSolver</a>&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">Sacado::MP::Vector</a>&lt; Storage &gt; &gt;::solveR </td>
          <td>(</td>
          <td class="paramtype">ETransp&#160;</td>
          <td class="paramname"><em>transr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SerialDenseMatrix&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">ScalarType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve input matrix on the left with the upper triangular matrix R or its adjoint. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="a2f51812293fad9e0cfa91f7126afe635" name="a2f51812293fad9e0cfa91f7126afe635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f51812293fad9e0cfa91f7126afe635">&#9670;&#160;</a></span>unequilibrateLHS()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OrdinalType , typename Storage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classTeuchos_1_1SerialQRDenseSolver.html">Teuchos::SerialQRDenseSolver</a>&lt; OrdinalType, <a class="el" href="classSacado_1_1MP_1_1Vector.html">Sacado::MP::Vector</a>&lt; Storage &gt; &gt;::unequilibrateLHS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unscales the solution vectors if equilibration was used to solve the system. </p>
<dl class="section note"><dt>Note</dt><dd>This method will be called automatically in <a class="el" href="classTeuchos_1_1SerialQRDenseSolver_3_01OrdinalType_00_01Sacado_1_1MP_1_1Vector_3_01Storage_01_4_01_4.html#a89fd29b15f7a6aba7215c80f39da378b" title="Computes the solution X to AX = B for the this matrix and the B provided to SetVectors()....">solve()</a> method if factorWithEquilibration( true ) is called. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><b>Teuchos_SerialQRDenseSolver_MP_Vector.hpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
