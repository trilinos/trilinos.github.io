<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Isorropia: Partitioning, Load Balancing and more: ispatest Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Isorropia: Partitioning, Load Balancing and more
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ispatest Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>ispatest is the namespace that contains isorropia's test-utilities.  
<a href="namespaceispatest.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a754979a240d862d9824b030c9330c99d" id="r_a754979a240d862d9824b030c9330c99d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceispatest.html#a754979a240d862d9824b030c9330c99d">fill_matrix</a> (Epetra_CrsMatrix &amp;matrix, int numNonzerosPerRow, bool verbose)</td></tr>
<tr class="memdesc:a754979a240d862d9824b030c9330c99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a matrix with the specified number of nonzeros per row, using matrix.InsertGlobalValues.  <br /></td></tr>
<tr class="separator:a754979a240d862d9824b030c9330c99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd2d9369f3e884c2b09a07f9d9d3c08" id="r_a2cd2d9369f3e884c2b09a07f9d9d3c08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceispatest.html#a2cd2d9369f3e884c2b09a07f9d9d3c08">fill_graph</a> (Epetra_CrsGraph &amp;graph, int numNonzerosPerRow, bool verbose)</td></tr>
<tr class="memdesc:a2cd2d9369f3e884c2b09a07f9d9d3c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a graph with the specified number of nonzeros per row.  <br /></td></tr>
<tr class="separator:a2cd2d9369f3e884c2b09a07f9d9d3c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087eca749fbd9564c24c2db39727c57c" id="r_a087eca749fbd9564c24c2db39727c57c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceispatest.html#a087eca749fbd9564c24c2db39727c57c">test_matrix_vector_multiply</a> (Epetra_CrsMatrix &amp;A)</td></tr>
<tr class="memdesc:a087eca749fbd9564c24c2db39727c57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that a matrix is a valid Epetra_CrsMatrix by attempting to multiply with it.  <br /></td></tr>
<tr class="separator:a087eca749fbd9564c24c2db39727c57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b73994fa17ab23fa24e4f1fd31438f" id="r_aa1b73994fa17ab23fa24e4f1fd31438f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceispatest.html#aa1b73994fa17ab23fa24e4f1fd31438f">test_row_matrix_vector_multiply</a> (Epetra_RowMatrix &amp;R)</td></tr>
<tr class="memdesc:aa1b73994fa17ab23fa24e4f1fd31438f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that a matrix is a valid Epetra_RowMatrix by attempting to multiply with it.  <br /></td></tr>
<tr class="separator:aa1b73994fa17ab23fa24e4f1fd31438f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62c0a12f4e20b19aac1d96c8d3eea37" id="r_ae62c0a12f4e20b19aac1d96c8d3eea37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceispatest.html#ae62c0a12f4e20b19aac1d96c8d3eea37">test_matrix_vector_multiply</a> (Epetra_CrsGraph &amp;G)</td></tr>
<tr class="memdesc:ae62c0a12f4e20b19aac1d96c8d3eea37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that a matrix is a valid Epetra_CrsGraph by attempting to multiply with it.  <br /></td></tr>
<tr class="separator:ae62c0a12f4e20b19aac1d96c8d3eea37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1fe71b4f51a0f9231333d74b8557f7" id="r_a3d1fe71b4f51a0f9231333d74b8557f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceispatest.html#a3d1fe71b4f51a0f9231333d74b8557f7">test_matrix_vector_multiply</a> (Epetra_LinearProblem &amp;LP)</td></tr>
<tr class="memdesc:a3d1fe71b4f51a0f9231333d74b8557f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that the Epetra_RowMatrix in a Epetra_LinearProblem is valid by attempting to multiply with it.  <br /></td></tr>
<tr class="separator:a3d1fe71b4f51a0f9231333d74b8557f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e054d200fd5246cdbc570c878e86e30" id="r_a7e054d200fd5246cdbc570c878e86e30"><td class="memItemLeft" align="right" valign="top">Epetra_Map *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceispatest.html#a7e054d200fd5246cdbc570c878e86e30">map_from_blockmap</a> (const Epetra_BlockMap &amp;b)</td></tr>
<tr class="memdesc:a7e054d200fd5246cdbc570c878e86e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to create an Epetra_Map from an Epetra_BlockMap, when using methods that require an Epetra_Map but you only have an Epetra_BlockMap.  <br /></td></tr>
<tr class="separator:a7e054d200fd5246cdbc570c878e86e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63668f3d07b34adb43d381c11cca9afc" id="r_a63668f3d07b34adb43d381c11cca9afc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceispatest.html#a63668f3d07b34adb43d381c11cca9afc">readCoordFile</a> (const std::string &amp;fname, std::vector&lt; double &gt; &amp;x, std::vector&lt; double &gt; &amp;y, std::vector&lt; double &gt; &amp;z)</td></tr>
<tr class="memdesc:a63668f3d07b34adb43d381c11cca9afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in the file "fname".  <br /></td></tr>
<tr class="separator:a63668f3d07b34adb43d381c11cca9afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6de8cc3ba9e8b5a2f80952021d71e2c" id="r_ae6de8cc3ba9e8b5a2f80952021d71e2c"><td class="memItemLeft" align="right" valign="top">Epetra_MultiVector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceispatest.html#ae6de8cc3ba9e8b5a2f80952021d71e2c">makeWeights</a> (const Epetra_BlockMap &amp;map, double(*wFunc)(const int, const int, const int, const int))</td></tr>
<tr class="memdesc:ae6de8cc3ba9e8b5a2f80952021d71e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a multivector of 1 dimensional weights with the same distribution as the supplied map.  <br /></td></tr>
<tr class="separator:ae6de8cc3ba9e8b5a2f80952021d71e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61942a00e5dcbb797c4da4c8850ef2a1" id="r_a61942a00e5dcbb797c4da4c8850ef2a1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceispatest.html#a61942a00e5dcbb797c4da4c8850ef2a1">unitWeights</a> (const int id, const int me, const int nids, const int nprocs)</td></tr>
<tr class="memdesc:a61942a00e5dcbb797c4da4c8850ef2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function for makeWeights, returns 1.0 for the object's weight.  <br /></td></tr>
<tr class="separator:a61942a00e5dcbb797c4da4c8850ef2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbc10e84244ea0d2e0e44b426b43cdc" id="r_a7bbc10e84244ea0d2e0e44b426b43cdc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceispatest.html#a7bbc10e84244ea0d2e0e44b426b43cdc">veeWeights</a> (const int id, const int me, const int nids, const int nprocs)</td></tr>
<tr class="memdesc:a7bbc10e84244ea0d2e0e44b426b43cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function for makeWeights, weight is based on global ID, lower in the middle and higher at both ends.  <br /></td></tr>
<tr class="separator:a7bbc10e84244ea0d2e0e44b426b43cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1b2ecbb8b76c493b77822b661d0b58" id="r_a8b1b2ecbb8b76c493b77822b661d0b58"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceispatest.html#a8b1b2ecbb8b76c493b77822b661d0b58">alternateWeights</a> (const int id, const int me, const int nids, const int nprocs)</td></tr>
<tr class="memdesc:a8b1b2ecbb8b76c493b77822b661d0b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function for makeWeights, weights alternate 1.0, 2.0, 1.0, etc.  <br /></td></tr>
<tr class="separator:a8b1b2ecbb8b76c493b77822b661d0b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a98b82240ef253e1156a4fe6012d6b" id="r_a16a98b82240ef253e1156a4fe6012d6b"><td class="memItemLeft" align="right" valign="top">Epetra_MultiVector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceispatest.html#a16a98b82240ef253e1156a4fe6012d6b">file2multivector</a> (const Epetra_Comm &amp;comm, const std::string &amp;fname)</td></tr>
<tr class="memdesc:a16a98b82240ef253e1156a4fe6012d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a file of 1, 2 or 3 dimensional coordinates and create a multivector with a standard linear distribution.  <br /></td></tr>
<tr class="separator:a16a98b82240ef253e1156a4fe6012d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d03c56ec987c92034cc3a54fa76f9c" id="r_a38d03c56ec987c92034cc3a54fa76f9c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceispatest.html#a38d03c56ec987c92034cc3a54fa76f9c">printMultiVector</a> (const Epetra_MultiVector &amp;mv, std::ostream &amp;os, const char *s, int max=1000)</td></tr>
<tr class="memdesc:a38d03c56ec987c92034cc3a54fa76f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the contents of the multivector by process, with optional title.  <br /></td></tr>
<tr class="separator:a38d03c56ec987c92034cc3a54fa76f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230b9ed57d3a518b3022a730969e60ad" id="r_a230b9ed57d3a518b3022a730969e60ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceispatest.html#a230b9ed57d3a518b3022a730969e60ad">printRowMatrix</a> (const Epetra_RowMatrix &amp;m, std::ostream &amp;os, const char *s, bool withGraphCuts, int max=1000)</td></tr>
<tr class="memdesc:a230b9ed57d3a518b3022a730969e60ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the contents of a small Epetra_RowMatrix, with optional title.  <br /></td></tr>
<tr class="separator:a230b9ed57d3a518b3022a730969e60ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf4ea860675d758cf2f122abb9562bd" id="r_adbf4ea860675d758cf2f122abb9562bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceispatest.html#adbf4ea860675d758cf2f122abb9562bd">compute_balance</a> (const Epetra_Vector &amp;wgts, double myGoalWeight, double &amp;min, double &amp;max, double &amp;avg)</td></tr>
<tr class="memdesc:adbf4ea860675d758cf2f122abb9562bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an Epetra_Vector of weights, compute the weight imbalance on each process.  <br /></td></tr>
<tr class="separator:adbf4ea860675d758cf2f122abb9562bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6697692f98d1a250b4452170a7cdab01" id="r_a6697692f98d1a250b4452170a7cdab01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceispatest.html#a6697692f98d1a250b4452170a7cdab01">compute_hypergraph_metrics</a> (const Epetra_CrsGraph &amp;graph, <a class="el" href="classIsorropia_1_1Epetra_1_1CostDescriber.html">Isorropia::Epetra::CostDescriber</a> &amp;costs, double &amp;myGoalWeight, double &amp;balance, double &amp;cutn, double &amp;cutl)</td></tr>
<tr class="memdesc:a6697692f98d1a250b4452170a7cdab01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Zoltan-style hypergraph metrics given a partitioned CrsGraph and a CostDescriber (weight) object.  <br /></td></tr>
<tr class="separator:a6697692f98d1a250b4452170a7cdab01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d9faba59cebc513f69668e2c15c6a7" id="r_a00d9faba59cebc513f69668e2c15c6a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceispatest.html#a00d9faba59cebc513f69668e2c15c6a7">compute_hypergraph_metrics</a> (const Epetra_RowMatrix &amp;matrix, <a class="el" href="classIsorropia_1_1Epetra_1_1CostDescriber.html">Isorropia::Epetra::CostDescriber</a> &amp;costs, double &amp;myGoalWeight, double &amp;balance, double &amp;cutn, double &amp;cutl)</td></tr>
<tr class="memdesc:a00d9faba59cebc513f69668e2c15c6a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Zoltan-style hypergraph metrics given a partitioned RowMatrix and a CostDescriber (weight) object.  <br /></td></tr>
<tr class="separator:a00d9faba59cebc513f69668e2c15c6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678bc9037c712e4cc7a09c1ca81ea4f3" id="r_a678bc9037c712e4cc7a09c1ca81ea4f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceispatest.html#a678bc9037c712e4cc7a09c1ca81ea4f3">compute_graph_metrics</a> (const Epetra_RowMatrix &amp;matrix, <a class="el" href="classIsorropia_1_1Epetra_1_1CostDescriber.html">Isorropia::Epetra::CostDescriber</a> &amp;costs, double &amp;myGoalWeight, double &amp;balance, int &amp;numCuts, double &amp;cutWgt, double &amp;cutn, double &amp;cutl)</td></tr>
<tr class="memdesc:a678bc9037c712e4cc7a09c1ca81ea4f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute graph metrics given an Epetra_RowMatrix.  <br /></td></tr>
<tr class="separator:a678bc9037c712e4cc7a09c1ca81ea4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbd987179a9308a8c30d367ac0fd1ea" id="r_a1fbd987179a9308a8c30d367ac0fd1ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceispatest.html#a1fbd987179a9308a8c30d367ac0fd1ea">compute_graph_metrics</a> (const Epetra_CrsGraph &amp;graph, <a class="el" href="classIsorropia_1_1Epetra_1_1CostDescriber.html">Isorropia::Epetra::CostDescriber</a> &amp;costs, double &amp;myGoalWeight, double &amp;balance, int &amp;numCuts, double &amp;cutWgt, double &amp;cutn, double &amp;cutl)</td></tr>
<tr class="memdesc:a1fbd987179a9308a8c30d367ac0fd1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute graph metrics given an Epetra_CrsGraph.  <br /></td></tr>
<tr class="separator:a1fbd987179a9308a8c30d367ac0fd1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac072eb715a2b825d727dcea68255f830" id="r_ac072eb715a2b825d727dcea68255f830"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceispatest.html#ac072eb715a2b825d727dcea68255f830">show_matrix</a> (const char *txt, const Epetra_RowMatrix &amp;matrix, const Epetra_Comm &amp;comm)</td></tr>
<tr class="memdesc:ac072eb715a2b825d727dcea68255f830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out a distributed RowMatrix.  <br /></td></tr>
<tr class="separator:ac072eb715a2b825d727dcea68255f830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec48f5223202ef397dd98f77726630e" id="r_a1ec48f5223202ef397dd98f77726630e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceispatest.html#a1ec48f5223202ef397dd98f77726630e">show_matrix</a> (const char *txt, const Epetra_CrsGraph &amp;graph, const Epetra_Comm &amp;comm)</td></tr>
<tr class="memdesc:a1ec48f5223202ef397dd98f77726630e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out a distributed CrsGraph.  <br /></td></tr>
<tr class="separator:a1ec48f5223202ef397dd98f77726630e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea808485e539ce97383ddc7780d85417" id="r_aea808485e539ce97383ddc7780d85417"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceispatest.html#aea808485e539ce97383ddc7780d85417">show_matrix</a> (const char *txt, const Epetra_LinearProblem &amp;problem, const Epetra_Comm &amp;comm)</td></tr>
<tr class="memdesc:aea808485e539ce97383ddc7780d85417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out a distributed LinearProblem.  <br /></td></tr>
<tr class="separator:aea808485e539ce97383ddc7780d85417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13975a259b05522e10e0bbb034b884c3" id="r_a13975a259b05522e10e0bbb034b884c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceispatest.html#a13975a259b05522e10e0bbb034b884c3">read_distribution</a> (const char *filename, std::vector&lt; int &gt; &amp;rows, std::vector&lt; int &gt; &amp;cols, std::vector&lt; int &gt; &amp;partitions)</td></tr>
<tr class="memdesc:a13975a259b05522e10e0bbb034b884c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a matrix distribution from a file.  <br /></td></tr>
<tr class="separator:a13975a259b05522e10e0bbb034b884c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119aa4a18532dbf67dd8348cb148a49f" id="r_a119aa4a18532dbf67dd8348cb148a49f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceispatest.html#a119aa4a18532dbf67dd8348cb148a49f">set_verbose</a> (int localProc, int argc, char **argv)</td></tr>
<tr class="memdesc:a119aa4a18532dbf67dd8348cb148a49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a bool that's true if &ndash;v appears in the command-line arguments.  <br /></td></tr>
<tr class="separator:a119aa4a18532dbf67dd8348cb148a49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ispatest is the namespace that contains isorropia's test-utilities. </p>
<p>These test-utilities are for internal testing, and are not generally expected to be seen or used by external users. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a754979a240d862d9824b030c9330c99d" name="a754979a240d862d9824b030c9330c99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754979a240d862d9824b030c9330c99d">&#9670;&#160;</a></span>fill_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ispatest::fill_matrix </td>
          <td>(</td>
          <td class="paramtype">Epetra_CrsMatrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numNonzerosPerRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a matrix with the specified number of nonzeros per row, using matrix.InsertGlobalValues. </p>
<p>Call FillComplete on the matrix before returning. If any negative error code is returned by an Epetra method, that will be the return value of this function. </p>

</div>
</div>
<a id="a2cd2d9369f3e884c2b09a07f9d9d3c08" name="a2cd2d9369f3e884c2b09a07f9d9d3c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd2d9369f3e884c2b09a07f9d9d3c08">&#9670;&#160;</a></span>fill_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ispatest::fill_graph </td>
          <td>(</td>
          <td class="paramtype">Epetra_CrsGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numNonzerosPerRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a graph with the specified number of nonzeros per row. </p>
<p>Call FillComplete on the graph before returning. If any non-zero error code is returned by an Epetra method, that will be the return value of this function. </p>

</div>
</div>
<a id="a087eca749fbd9564c24c2db39727c57c" name="a087eca749fbd9564c24c2db39727c57c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087eca749fbd9564c24c2db39727c57c">&#9670;&#160;</a></span>test_matrix_vector_multiply() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ispatest::test_matrix_vector_multiply </td>
          <td>(</td>
          <td class="paramtype">Epetra_CrsMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that a matrix is a valid Epetra_CrsMatrix by attempting to multiply with it. </p>
<p>Return true if successful, false otherwise.</p>
<p>A is the input matrix, and "x" and "y" will be created and then y = Ax will be computed.</p>
<p>"x" will be created with the domain map of the "A", "y" will be created with the range map.</p>
<p>Return true if successful, false otherwise. </p>

</div>
</div>
<a id="aa1b73994fa17ab23fa24e4f1fd31438f" name="aa1b73994fa17ab23fa24e4f1fd31438f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b73994fa17ab23fa24e4f1fd31438f">&#9670;&#160;</a></span>test_row_matrix_vector_multiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ispatest::test_row_matrix_vector_multiply </td>
          <td>(</td>
          <td class="paramtype">Epetra_RowMatrix &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that a matrix is a valid Epetra_RowMatrix by attempting to multiply with it. </p>
<p>Return true if successful, false otherwise.</p>
<p>y = Rx will be calculated, where "y" will be created with the OperatorRangeMap() of "R" and "x" will be created with the OperatorDomainMap() of "R".</p>
<p>Return true if successful, false otherwise. </p>

</div>
</div>
<a id="ae62c0a12f4e20b19aac1d96c8d3eea37" name="ae62c0a12f4e20b19aac1d96c8d3eea37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62c0a12f4e20b19aac1d96c8d3eea37">&#9670;&#160;</a></span>test_matrix_vector_multiply() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ispatest::test_matrix_vector_multiply </td>
          <td>(</td>
          <td class="paramtype">Epetra_CrsGraph &amp;&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that a matrix is a valid Epetra_CrsGraph by attempting to multiply with it. </p>
<p>Return true if successful, false otherwise.</p>
<p>An Epetra_CrsMatrix (A) will be created from the input graph G, and then y = Ax will be computed.</p>
<p>"x" will be created with the domain map of "G", and "y" will be created with the range map of "G".</p>
<p>Return true if successful, false otherwise. </p>

</div>
</div>
<a id="a3d1fe71b4f51a0f9231333d74b8557f7" name="a3d1fe71b4f51a0f9231333d74b8557f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1fe71b4f51a0f9231333d74b8557f7">&#9670;&#160;</a></span>test_matrix_vector_multiply() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ispatest::test_matrix_vector_multiply </td>
          <td>(</td>
          <td class="paramtype">Epetra_LinearProblem &amp;&#160;</td>
          <td class="paramname"><em>LP</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that the Epetra_RowMatrix in a Epetra_LinearProblem is valid by attempting to multiply with it. </p>
<p>An Epetra_RowMatrix (R) will be extracted from the linear problem, and then y = Rx will be computed.</p>
<p>"y" will be created with the OperatorRangeMap() of "R" and "x" will be created with the OperatorDomainMap() of "R".</p>
<p>This test does not use the vectors in the linear problem, it uses a made up vector. (Maybe it should use rhs and lhs?)</p>
<p>Return true if successful, false otherwise. </p>

</div>
</div>
<a id="a7e054d200fd5246cdbc570c878e86e30" name="a7e054d200fd5246cdbc570c878e86e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e054d200fd5246cdbc570c878e86e30">&#9670;&#160;</a></span>map_from_blockmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_Map * ispatest::map_from_blockmap </td>
          <td>(</td>
          <td class="paramtype">const Epetra_BlockMap &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to create an Epetra_Map from an Epetra_BlockMap, when using methods that require an Epetra_Map but you only have an Epetra_BlockMap. </p>
<p>Caller should delete the returned map when done with it. </p>

</div>
</div>
<a id="a63668f3d07b34adb43d381c11cca9afc" name="a63668f3d07b34adb43d381c11cca9afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63668f3d07b34adb43d381c11cca9afc">&#9670;&#160;</a></span>readCoordFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ispatest::readCoordFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read in the file "fname". </p>
<p>It should be a text file with a list of 1, 2 or 3-dimensional floating point coordinates. Each is on one line of the file, and coordinates are separated by white space. Blank lines are allowed.</p>
<p>Fill the vectors x, y, and z with the x, y and z coordinates. (z will have size 0 for 1 and 2 dimensional coordinates, y will have size 0 for 1 dimensional coordinates.)</p>
<p>Return the dimension of the coordinates, or 0 if none could be read. </p>

</div>
</div>
<a id="ae6de8cc3ba9e8b5a2f80952021d71e2c" name="ae6de8cc3ba9e8b5a2f80952021d71e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6de8cc3ba9e8b5a2f80952021d71e2c">&#9670;&#160;</a></span>makeWeights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_MultiVector * ispatest::makeWeights </td>
          <td>(</td>
          <td class="paramtype">const Epetra_BlockMap &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(const int, const int, const int, const int)&#160;</td>
          <td class="paramname"><em>wFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a multivector of 1 dimensional weights with the same distribution as the supplied map. </p>
<p>The weight for each object will be computed with the supplied function. The arguments for the supplied function are the global ID of the object, the rank of the calling process, the global number of objects, and the number of processes. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="geometric_2example_rcb_8cpp-example.html#a2">geometric/example_rcb.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a61942a00e5dcbb797c4da4c8850ef2a1" name="a61942a00e5dcbb797c4da4c8850ef2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61942a00e5dcbb797c4da4c8850ef2a1">&#9670;&#160;</a></span>unitWeights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ispatest::unitWeights </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nprocs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function for makeWeights, returns 1.0 for the object's weight. </p>

</div>
</div>
<a id="a7bbc10e84244ea0d2e0e44b426b43cdc" name="a7bbc10e84244ea0d2e0e44b426b43cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bbc10e84244ea0d2e0e44b426b43cdc">&#9670;&#160;</a></span>veeWeights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ispatest::veeWeights </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nprocs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function for makeWeights, weight is based on global ID, lower in the middle and higher at both ends. </p>
<p>Graph of weights for IDs would be "v" shaped. </p>

</div>
</div>
<a id="a8b1b2ecbb8b76c493b77822b661d0b58" name="a8b1b2ecbb8b76c493b77822b661d0b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1b2ecbb8b76c493b77822b661d0b58">&#9670;&#160;</a></span>alternateWeights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ispatest::alternateWeights </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nprocs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function for makeWeights, weights alternate 1.0, 2.0, 1.0, etc. </p>
<p>by process ID. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="geometric_2example_rcb_8cpp-example.html#a3">geometric/example_rcb.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a16a98b82240ef253e1156a4fe6012d6b" name="a16a98b82240ef253e1156a4fe6012d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a98b82240ef253e1156a4fe6012d6b">&#9670;&#160;</a></span>file2multivector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_MultiVector * ispatest::file2multivector </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Comm &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read in a file of 1, 2 or 3 dimensional coordinates and create a multivector with a standard linear distribution. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="geometric_2example_rcb_8cpp-example.html#a0">geometric/example_rcb.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a38d03c56ec987c92034cc3a54fa76f9c" name="a38d03c56ec987c92034cc3a54fa76f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d03c56ec987c92034cc3a54fa76f9c">&#9670;&#160;</a></span>printMultiVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ispatest::printMultiVector </td>
          <td>(</td>
          <td class="paramtype">const Epetra_MultiVector &amp;&#160;</td>
          <td class="paramname"><em>mv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out the contents of the multivector by process, with optional title. </p>
<p>This is more compact the Epetra_MultiVector::Print(). </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="geometric_2example_rcb_8cpp-example.html#a1">geometric/example_rcb.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a230b9ed57d3a518b3022a730969e60ad" name="a230b9ed57d3a518b3022a730969e60ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230b9ed57d3a518b3022a730969e60ad">&#9670;&#160;</a></span>printRowMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ispatest::printRowMatrix </td>
          <td>(</td>
          <td class="paramtype">const Epetra_RowMatrix &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>withGraphCuts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out the contents of a small Epetra_RowMatrix, with optional title. </p>
<p>There is no Epetra_RowMatrix::Print. If m is symmetric, we can view it as a graph and show graph cuts if "withGraphCuts" is true. </p>

</div>
</div>
<a id="adbf4ea860675d758cf2f122abb9562bd" name="adbf4ea860675d758cf2f122abb9562bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf4ea860675d758cf2f122abb9562bd">&#9670;&#160;</a></span>compute_balance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ispatest::compute_balance </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Vector &amp;&#160;</td>
          <td class="paramname"><em>wgts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>myGoalWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>avg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an Epetra_Vector of weights, compute the weight imbalance on each process. </p>
<p>Set the minimum imbalance across all processes, the maximum, and the average. <br  />
 myShare is between 0 and 1, and usually would be 1.0/numProc. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="geometric_2example_rcb_8cpp-example.html#a7">geometric/example_rcb.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6697692f98d1a250b4452170a7cdab01" name="a6697692f98d1a250b4452170a7cdab01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6697692f98d1a250b4452170a7cdab01">&#9670;&#160;</a></span>compute_hypergraph_metrics() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ispatest::compute_hypergraph_metrics </td>
          <td>(</td>
          <td class="paramtype">const Epetra_CrsGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIsorropia_1_1Epetra_1_1CostDescriber.html">Isorropia::Epetra::CostDescriber</a> &amp;&#160;</td>
          <td class="paramname"><em>costs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>myGoalWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>balance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cutn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cutl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Zoltan-style hypergraph metrics given a partitioned CrsGraph and a CostDescriber (weight) object. </p>
<p>If the CostDescriber has no weights in it, reasonable defaults will be used. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="hgedge_weights_8cpp-example.html#a3">hgedge_weights.cpp</a>, <a class="el" href="matrix_1_8cpp-example.html#a2">matrix_1.cpp</a>, and <a class="el" href="part_redist_8cpp-example.html#a3">part_redist.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a00d9faba59cebc513f69668e2c15c6a7" name="a00d9faba59cebc513f69668e2c15c6a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d9faba59cebc513f69668e2c15c6a7">&#9670;&#160;</a></span>compute_hypergraph_metrics() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ispatest::compute_hypergraph_metrics </td>
          <td>(</td>
          <td class="paramtype">const Epetra_RowMatrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIsorropia_1_1Epetra_1_1CostDescriber.html">Isorropia::Epetra::CostDescriber</a> &amp;&#160;</td>
          <td class="paramname"><em>costs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>myGoalWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>balance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cutn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cutl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Zoltan-style hypergraph metrics given a partitioned RowMatrix and a CostDescriber (weight) object. </p>
<p>If the CostDescriber has no weights in it, reasonable defaults will be used. </p>

</div>
</div>
<a id="a678bc9037c712e4cc7a09c1ca81ea4f3" name="a678bc9037c712e4cc7a09c1ca81ea4f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678bc9037c712e4cc7a09c1ca81ea4f3">&#9670;&#160;</a></span>compute_graph_metrics() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ispatest::compute_graph_metrics </td>
          <td>(</td>
          <td class="paramtype">const Epetra_RowMatrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIsorropia_1_1Epetra_1_1CostDescriber.html">Isorropia::Epetra::CostDescriber</a> &amp;&#160;</td>
          <td class="paramname"><em>costs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>myGoalWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>balance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>numCuts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cutWgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cutn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cutl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute graph metrics given an Epetra_RowMatrix. </p>
<p>A CostDescriber object may provide vertex (row) and/or edge (non-zeroes) weights, or it may be an initialized object with no weights. If no vertex weights are provided, each vertex is assumed to be weight 1. If no edge weights are provided, each edge is assumed to be weight 1.</p>
<p>The goal weight for a process is the proportion of the total vertex (row) weights that were to be assigned to this process under repartitioning. If all processes are to get an equal proportion of the weight, set this value to (1.0 / # processes). This value is needed in order to compute how close the repartitioning is to being perfectly balanced.</p>
<p>If the CostDescriber has no weights in it, reasonable defaults will be used. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="graphedge_weights_8cpp-example.html#a4">graphedge_weights.cpp</a>, <a class="el" href="matrix_1_8cpp-example.html#a3">matrix_1.cpp</a>, and <a class="el" href="vert_weights_8cpp-example.html#a3">vert_weights.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1fbd987179a9308a8c30d367ac0fd1ea" name="a1fbd987179a9308a8c30d367ac0fd1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fbd987179a9308a8c30d367ac0fd1ea">&#9670;&#160;</a></span>compute_graph_metrics() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ispatest::compute_graph_metrics </td>
          <td>(</td>
          <td class="paramtype">const Epetra_CrsGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIsorropia_1_1Epetra_1_1CostDescriber.html">Isorropia::Epetra::CostDescriber</a> &amp;&#160;</td>
          <td class="paramname"><em>costs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>myGoalWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>balance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>numCuts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cutWgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cutn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cutl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute graph metrics given an Epetra_CrsGraph. </p>
<p>A CostDescriber object may provide vertex (row) and/or edge (non-zeroes) weights, or it may be an initialized object with no weights. If no vertex weights are provided, each vertex is assumed to be weight 1. If no edge weights are provided, each edge is assumed to be weight 1.</p>
<p>The goal weight for a process is the proportion of the total vertex (row) weights that were to be assigned to this process under repartitioning. If all processes are to get an equal proportion of the weight, set this value to (1.0 / # processes). This value is needed in order to compute how close the repartitioning is to being perfectly balanced.</p>
<p>If the CostDescriber has no weights in it, reasonable defaults will be used. </p>

</div>
</div>
<a id="ac072eb715a2b825d727dcea68255f830" name="ac072eb715a2b825d727dcea68255f830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac072eb715a2b825d727dcea68255f830">&#9670;&#160;</a></span>show_matrix() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ispatest::show_matrix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>txt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_RowMatrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_Comm &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out a distributed RowMatrix. </p>
<p>This only works for small test matrices of 1s and 0s, and 10 or fewer processes. </p>

</div>
</div>
<a id="a1ec48f5223202ef397dd98f77726630e" name="a1ec48f5223202ef397dd98f77726630e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec48f5223202ef397dd98f77726630e">&#9670;&#160;</a></span>show_matrix() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ispatest::show_matrix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>txt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_CrsGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_Comm &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out a distributed CrsGraph. </p>
<p>This only works for small test matrices of 1s and 0s and 10 or fewer processes. </p>

</div>
</div>
<a id="aea808485e539ce97383ddc7780d85417" name="aea808485e539ce97383ddc7780d85417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea808485e539ce97383ddc7780d85417">&#9670;&#160;</a></span>show_matrix() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ispatest::show_matrix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>txt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_LinearProblem &amp;&#160;</td>
          <td class="paramname"><em>problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_Comm &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out a distributed LinearProblem. </p>
<p>This only works for small test matrices of 1s and 0s and 10 or fewer processes. </p>

</div>
</div>
<a id="a13975a259b05522e10e0bbb034b884c3" name="a13975a259b05522e10e0bbb034b884c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13975a259b05522e10e0bbb034b884c3">&#9670;&#160;</a></span>read_distribution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ispatest::read_distribution </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>partitions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a matrix distribution from a file. </p>
<p>The file is expected to follow a very simple format where each line corresponds to a single nonzero of the matrix, and each line contains 3 numbers which specify a row number, a column-number, and a partition number. When this function returns, each of the three vectors should have the same length, which is the number of nonzeros. </p>

</div>
</div>
<a id="a119aa4a18532dbf67dd8348cb148a49f" name="a119aa4a18532dbf67dd8348cb148a49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a119aa4a18532dbf67dd8348cb148a49f">&#9670;&#160;</a></span>set_verbose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ispatest::set_verbose </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a bool that's true if &ndash;v appears in the command-line arguments. </p>

</div>
</div>
</div><!-- contents -->
</BODY>
</HTML>
