<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Isorropia: Partitioning, Load Balancing and more: Isorropia Probing Methods  &lt;br&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Isorropia: Partitioning, Load Balancing and more
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Isorropia Probing Methods &lt;br&gt;</div></div>
</div><!--header-->
<div class="contents">

<p>Here we describe the probing interface provided by <a class="el" href="namespaceIsorropia.html" title="Isorropia is the namespace that contains general definitions that apply to all partitioners and that ...">Isorropia</a>.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIsorropia_1_1Epetra_1_1Prober.html">Isorropia::Epetra::Prober</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of the <a class="el" href="classIsorropia_1_1Epetra_1_1Prober.html" title="An implementation of the Prober interface that operates on Epetra matrices and linear systems.">Prober</a> interface that operates on <a class="el" href="namespaceIsorropia_1_1Epetra.html">Epetra</a> matrices and linear systems.  <a href="classIsorropia_1_1Epetra_1_1Prober.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8697683eca8f1f7a56939850bfe287b5" id="r_ga8697683eca8f1f7a56939850bfe287b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__probing__grp.html#ga8697683eca8f1f7a56939850bfe287b5">Isorropia::Epetra::Prober::Prober</a> (Teuchos::RCP&lt; const Epetra_CrsGraph &gt; input_graph, const Teuchos::ParameterList &amp;paramlist, bool compute_now=true)</td></tr>
<tr class="memdesc:ga8697683eca8f1f7a56939850bfe287b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:ga8697683eca8f1f7a56939850bfe287b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f952a3d95f8c818e7c76faba0c6f92e" id="r_ga5f952a3d95f8c818e7c76faba0c6f92e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__probing__grp.html#ga5f952a3d95f8c818e7c76faba0c6f92e">Isorropia::Epetra::Prober::Prober</a> (const Epetra_CrsGraph *input_graph, const Teuchos::ParameterList &amp;paramlist, bool compute_now=true)</td></tr>
<tr class="memdesc:ga5f952a3d95f8c818e7c76faba0c6f92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:ga5f952a3d95f8c818e7c76faba0c6f92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1dc8b5974e4d5d759428ec050e68493" id="r_gaa1dc8b5974e4d5d759428ec050e68493"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__probing__grp.html#gaa1dc8b5974e4d5d759428ec050e68493">Isorropia::Epetra::Prober::Prober</a> (Teuchos::RCP&lt; const Epetra_CrsMatrix &gt; input_matrix, const Teuchos::ParameterList &amp;paramlist, bool compute_now=true)</td></tr>
<tr class="memdesc:gaa1dc8b5974e4d5d759428ec050e68493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:gaa1dc8b5974e4d5d759428ec050e68493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccea3ee18edb751418826337ead36e4f" id="r_gaccea3ee18edb751418826337ead36e4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__probing__grp.html#gaccea3ee18edb751418826337ead36e4f">Isorropia::Epetra::Prober::Prober</a> (const Epetra_CrsMatrix *input_matrix, const Teuchos::ParameterList &amp;paramlist, bool compute_now=true)</td></tr>
<tr class="memdesc:gaccea3ee18edb751418826337ead36e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:gaccea3ee18edb751418826337ead36e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga041e681fc6b67632dd86a47ce1d6a18c" id="r_ga041e681fc6b67632dd86a47ce1d6a18c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__probing__grp.html#ga041e681fc6b67632dd86a47ce1d6a18c">Isorropia::Epetra::Prober::color</a> ()</td></tr>
<tr class="memdesc:ga041e681fc6b67632dd86a47ce1d6a18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the coloring.  <br /></td></tr>
<tr class="separator:ga041e681fc6b67632dd86a47ce1d6a18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74adb4d6838fc8b6c26d7d26eb4f2630" id="r_ga74adb4d6838fc8b6c26d7d26eb4f2630"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__probing__grp.html#ga74adb4d6838fc8b6c26d7d26eb4f2630">Isorropia::Epetra::Prober::getNumOrthogonalVectors</a> ()</td></tr>
<tr class="memdesc:ga74adb4d6838fc8b6c26d7d26eb4f2630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of orthogonal vectors (or the number of colors from coloring)  <br /></td></tr>
<tr class="separator:ga74adb4d6838fc8b6c26d7d26eb4f2630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68a56c305f87708789d7860e5b90bcad" id="r_ga68a56c305f87708789d7860e5b90bcad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__probing__grp.html#ga68a56c305f87708789d7860e5b90bcad">Isorropia::Epetra::Prober::probe</a> (const Epetra_Operator &amp;op, Epetra_CrsMatrix &amp;out_matrix)</td></tr>
<tr class="memdesc:ga68a56c305f87708789d7860e5b90bcad"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt;&gt; Perform the actual probing.  <br /></td></tr>
<tr class="separator:ga68a56c305f87708789d7860e5b90bcad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bce2a28c438f920c6772bf967ffa4f3" id="r_ga0bce2a28c438f920c6772bf967ffa4f3"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; Epetra_CrsMatrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__probing__grp.html#ga0bce2a28c438f920c6772bf967ffa4f3">Isorropia::Epetra::Prober::probe</a> (const Epetra_Operator &amp;op)</td></tr>
<tr class="memdesc:ga0bce2a28c438f920c6772bf967ffa4f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the actual probing.  <br /></td></tr>
<tr class="separator:ga0bce2a28c438f920c6772bf967ffa4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Here we describe the probing interface provided by <a class="el" href="namespaceIsorropia.html" title="Isorropia is the namespace that contains general definitions that apply to all partitioners and that ...">Isorropia</a>. </p>
<h1><a class="anchor" id="probingIntro"></a>
Probing</h1>
<p><a class="el" href="namespaceIsorropia.html" title="Isorropia is the namespace that contains general definitions that apply to all partitioners and that ...">Isorropia</a>'s distance-2 graph vertex capability enables matrix probing, the re-construction (or approximation) of a matrix from matrix-vector products with specially chosen vectors. <br  />
 These vectors are combinations of columns of the identity which are carefully chosen such that the columns probed by such a vector are structurally orthogonal. The most common use case of probing is when the matrix is not explicitly stored, but the matrix entries are necessary for some other procedure (e.g. preconditioning). In certain applications, an exact reconstruction of the matrix is needed. In others, an approximation based on <em>a priori</em> knowledge of the "significant" matrix entries suffices. <a class="el" href="namespaceIsorropia.html" title="Isorropia is the namespace that contains general definitions that apply to all partitioners and that ...">Isorropia</a>'s probing functionality works in both cases.</p>
<p>Currently, <a class="el" href="namespaceIsorropia.html" title="Isorropia is the namespace that contains general definitions that apply to all partitioners and that ...">Isorropia</a>'s probing functionality is limited to structurally symmetric matrices but we expect to support nonsymmetric matrices (e.g. Jacobians) in the future. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga8697683eca8f1f7a56939850bfe287b5" name="ga8697683eca8f1f7a56939850bfe287b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8697683eca8f1f7a56939850bfe287b5">&#9670;&#160;</a></span>Prober() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Isorropia::Epetra::Prober::Prober </td>
          <td>(</td>
          <td class="paramtype">Teuchos::RCP&lt; const Epetra_CrsGraph &gt;&#160;</td>
          <td class="paramname"><em>input_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>paramlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compute_now</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_graph</td><td>the graph whose sparsity pattern is to guide the probing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramlist</td><td>this parameter list may be used to pass parameters to the colorer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compute_now</td><td>if <code>true</code>, the coloring is computed in the constructor, otherwise call <a class="el" href="group__probing__grp.html#ga041e681fc6b67632dd86a47ce1d6a18c" title="Compute the coloring.">Isorropia::Epetra::Prober::color</a> when you want to compute the coloring, defaults to <code>false</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5f952a3d95f8c818e7c76faba0c6f92e" name="ga5f952a3d95f8c818e7c76faba0c6f92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f952a3d95f8c818e7c76faba0c6f92e">&#9670;&#160;</a></span>Prober() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Isorropia::Epetra::Prober::Prober </td>
          <td>(</td>
          <td class="paramtype">const Epetra_CrsGraph *&#160;</td>
          <td class="paramname"><em>input_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>paramlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compute_now</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_graph</td><td>the graph whose sparsity pattern is to guide the probing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramlist</td><td>this parameter list may be used to pass parameters to the colorer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compute_now</td><td>if <code>true</code>, the coloring is computed in the constructor, otherwise call <a class="el" href="group__probing__grp.html#ga041e681fc6b67632dd86a47ce1d6a18c" title="Compute the coloring.">Isorropia::Epetra::Prober::color</a> when you want to compute the coloring, defaults to <code>false</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa1dc8b5974e4d5d759428ec050e68493" name="gaa1dc8b5974e4d5d759428ec050e68493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1dc8b5974e4d5d759428ec050e68493">&#9670;&#160;</a></span>Prober() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Isorropia::Epetra::Prober::Prober </td>
          <td>(</td>
          <td class="paramtype">Teuchos::RCP&lt; const Epetra_CrsMatrix &gt;&#160;</td>
          <td class="paramname"><em>input_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>paramlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compute_now</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_matrix</td><td>the matrix whose sparsity pattern is to guide the probing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramlist</td><td>this parameter list may be used to pass parameters to the colorer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compute_now</td><td>if <code>true</code>, the coloring is computed in the constructor, otherwise call <a class="el" href="group__probing__grp.html#ga041e681fc6b67632dd86a47ce1d6a18c" title="Compute the coloring.">Isorropia::Epetra::Prober::color</a> when you want to compute the coloring, defaults to <code>true</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaccea3ee18edb751418826337ead36e4f" name="gaccea3ee18edb751418826337ead36e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccea3ee18edb751418826337ead36e4f">&#9670;&#160;</a></span>Prober() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Isorropia::Epetra::Prober::Prober </td>
          <td>(</td>
          <td class="paramtype">const Epetra_CrsMatrix *&#160;</td>
          <td class="paramname"><em>input_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>paramlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compute_now</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_matrix</td><td>the matrix whose sparsity pattern is to guide the probing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramlist</td><td>this parameter list may be used to pass parameters to the colorer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compute_now</td><td>if <code>true</code>, the coloring is computed in the constructor, otherwise call <a class="el" href="group__probing__grp.html#ga041e681fc6b67632dd86a47ce1d6a18c" title="Compute the coloring.">Isorropia::Epetra::Prober::color</a> when you want to compute the coloring, defaults to <code>true</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga041e681fc6b67632dd86a47ce1d6a18c" name="ga041e681fc6b67632dd86a47ce1d6a18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga041e681fc6b67632dd86a47ce1d6a18c">&#9670;&#160;</a></span>color()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Isorropia::Epetra::Prober::color </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the coloring. </p>

</div>
</div>
<a id="ga74adb4d6838fc8b6c26d7d26eb4f2630" name="ga74adb4d6838fc8b6c26d7d26eb4f2630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74adb4d6838fc8b6c26d7d26eb4f2630">&#9670;&#160;</a></span>getNumOrthogonalVectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Isorropia::Epetra::Prober::getNumOrthogonalVectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of orthogonal vectors (or the number of colors from coloring) </p>
<dl class="section return"><dt>Returns</dt><dd>number of orthogonal vectors </dd></dl>

</div>
</div>
<a id="ga68a56c305f87708789d7860e5b90bcad" name="ga68a56c305f87708789d7860e5b90bcad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68a56c305f87708789d7860e5b90bcad">&#9670;&#160;</a></span>probe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Isorropia::Epetra::Prober::probe </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Operator &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Epetra_CrsMatrix &amp;&#160;</td>
          <td class="paramname"><em>out_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>&lt;&gt; Perform the actual probing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>is the operator we are probing </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out_matrix</td><td>is the matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0bce2a28c438f920c6772bf967ffa4f3" name="ga0bce2a28c438f920c6772bf967ffa4f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bce2a28c438f920c6772bf967ffa4f3">&#9670;&#160;</a></span>probe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; Epetra_CrsMatrix &gt; Isorropia::Epetra::Prober::probe </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Operator &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the actual probing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>is the operator we are probing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RCP to the matrix </dd></dl>

</div>
</div>
</div><!-- contents -->
</BODY>
</HTML>
