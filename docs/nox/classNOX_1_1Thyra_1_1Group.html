<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NOX: NOX::Thyra::Group Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">NOX<span id="projectnumber">&#160;Development</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceNOX.html">NOX</a></li><li class="navelem"><a class="el" href="namespaceNOX_1_1Thyra.html">Thyra</a></li><li class="navelem"><a class="el" href="classNOX_1_1Thyra_1_1Group.html">Group</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classNOX_1_1Thyra_1_1Group-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">NOX::Thyra::Group Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A concrete implementation of the <a class="el" href="classNOX_1_1Abstract_1_1Group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F-vector,...">NOX::Abstract::Group</a> using <a class="el" href="namespaceNOX_1_1Thyra.html" title="NOX Thyra support.">Thyra</a>.  
 <a href="classNOX_1_1Thyra_1_1Group.html#details">More...</a></p>

<p><code>#include &lt;NOX_Thyra_Group.H&gt;</code></p>
<div class="dynheader">
Inheritance diagram for NOX::Thyra::Group:</div>
<div class="dyncontent">
<div class="center"><img src="classNOX_1_1Thyra_1_1Group__inherit__graph.gif" border="0" usemap="#aNOX_1_1Thyra_1_1Group_inherit__map" alt="Inheritance graph"/></div>
<map name="aNOX_1_1Thyra_1_1Group_inherit__map" id="aNOX_1_1Thyra_1_1Group_inherit__map">
<area shape="rect" title="A concrete implementation of the NOX::Abstract::Group using Thyra." alt="" coords="36,79,179,104"/>
<area shape="rect" href="classLOCA_1_1Thyra_1_1Group.html" title="Extension of the NOX::Thyra::Group to LOCA." alt="" coords="33,152,182,177"/>
<area shape="poly" title=" " alt="" coords="110,118,110,152,105,152,105,118"/>
<area shape="rect" href="classNOX_1_1Abstract_1_1Group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F&#45;vector,..." alt="" coords="27,5,187,31"/>
<area shape="poly" title=" " alt="" coords="110,44,110,79,105,79,105,44"/>
<area shape="rect" href="classLOCA_1_1Thyra_1_1GroupWrapper.html" title="Extension of the LOCA::Thyra::Group to provide access to solution data." alt="" coords="5,225,209,251"/>
<area shape="poly" title=" " alt="" coords="110,191,110,225,105,225,105,191"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for NOX::Thyra::Group:</div>
<div class="dyncontent">
<div class="center"><img src="classNOX_1_1Thyra_1_1Group__coll__graph.gif" border="0" usemap="#aNOX_1_1Thyra_1_1Group_coll__map" alt="Collaboration graph"/></div>
<map name="aNOX_1_1Thyra_1_1Group_coll__map" id="aNOX_1_1Thyra_1_1Group_coll__map">
<area shape="rect" title="A concrete implementation of the NOX::Abstract::Group using Thyra." alt="" coords="14,79,157,104"/>
<area shape="rect" href="classNOX_1_1Abstract_1_1Group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F&#45;vector,..." alt="" coords="5,5,165,31"/>
<area shape="poly" title=" " alt="" coords="88,44,88,79,83,79,83,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaaa6e80d0835dbf20391d0109277f528" id="r_aaaa6e80d0835dbf20391d0109277f528"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#aaaa6e80d0835dbf20391d0109277f528">Group</a> (const <a class="el" href="classNOX_1_1Thyra_1_1Vector.html">NOX::Thyra::Vector</a> &amp;initialGuess, const Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1ModelEvaluator.html">::Thyra::ModelEvaluator</a>&lt; double &gt; &gt; &amp;model, const Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1VectorBase.html">::Thyra::VectorBase</a>&lt; double &gt; &gt; &amp;weightVector=Teuchos::null, const Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1VectorBase.html">::Thyra::VectorBase</a>&lt; double &gt; &gt; &amp;rightWeightVector=Teuchos::null, const Teuchos::RCP&lt;<a class="el" href="classThyra_1_1VectorBase.html">::Thyra::VectorBase</a>&lt; double &gt; &gt; &amp;inv_rightWeightVector=Teuchos::null, const bool rightScalingFirst=false)</td></tr>
<tr class="memdesc:aaaa6e80d0835dbf20391d0109277f528"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor that uses the linear solver from the ModelEvaluator.  <br /></td></tr>
<tr class="separator:aaaa6e80d0835dbf20391d0109277f528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4619a2a8be71bd87ebce47e3517a14b1" id="r_a4619a2a8be71bd87ebce47e3517a14b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#a4619a2a8be71bd87ebce47e3517a14b1">Group</a> (const <a class="el" href="classNOX_1_1Thyra_1_1Vector.html">NOX::Thyra::Vector</a> &amp;initialGuess, const Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1ModelEvaluator.html">::Thyra::ModelEvaluator</a>&lt; double &gt; &gt; &amp;model, const Teuchos::RCP&lt; <a class="el" href="classThyra_1_1LinearOpBase.html">::Thyra::LinearOpBase</a>&lt; double &gt; &gt; &amp;linearOp, const Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1LinearOpWithSolveFactoryBase.html">::Thyra::LinearOpWithSolveFactoryBase</a>&lt; double &gt; &gt; &amp;lowsFactory, const Teuchos::RCP&lt; <a class="el" href="classThyra_1_1PreconditionerBase.html">::Thyra::PreconditionerBase</a>&lt; double &gt; &gt; &amp;precOp, const Teuchos::RCP&lt; <a class="el" href="classThyra_1_1PreconditionerFactoryBase.html">::Thyra::PreconditionerFactoryBase</a>&lt; double &gt; &gt; &amp;precFactory, const Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1VectorBase.html">::Thyra::VectorBase</a>&lt; double &gt; &gt; &amp;weightVector=Teuchos::null, const Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1VectorBase.html">::Thyra::VectorBase</a>&lt; double &gt; &gt; &amp;rightWeightVector=Teuchos::null, const Teuchos::RCP&lt;<a class="el" href="classThyra_1_1VectorBase.html">::Thyra::VectorBase</a>&lt; double &gt; &gt; &amp;inv_rightWeightVector=Teuchos::null, const bool rightScalingFirst=false, const bool updatePreconditioner=true, const bool jacobianIsEvaluated=false)</td></tr>
<tr class="memdesc:a4619a2a8be71bd87ebce47e3517a14b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power user constructor that takes explicit linear solver objects to handle different combinations.  <br /></td></tr>
<tr class="separator:a4619a2a8be71bd87ebce47e3517a14b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e3afc46d56980b1c4cb45c7a7599fe" id="r_a15e3afc46d56980b1c4cb45c7a7599fe"><td class="memItemLeft" align="right" valign="top"><a id="a15e3afc46d56980b1c4cb45c7a7599fe" name="a15e3afc46d56980b1c4cb45c7a7599fe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Group</b> (const <a class="el" href="classNOX_1_1Thyra_1_1Group.html">NOX::Thyra::Group</a> &amp;source, <a class="el" href="namespaceNOX.html#a053a1ab5b2b3bd9546883b949142c592">NOX::CopyType</a> type=<a class="el" href="namespaceNOX.html#a053a1ab5b2b3bd9546883b949142c592af22ab6417594618436dfab3f95f98261">DeepCopy</a>)</td></tr>
<tr class="memdesc:a15e3afc46d56980b1c4cb45c7a7599fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:a15e3afc46d56980b1c4cb45c7a7599fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe12d16061856e041389248a1fb901a7" id="r_afe12d16061856e041389248a1fb901a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#afe12d16061856e041389248a1fb901a7">~Group</a> ()</td></tr>
<tr class="memdesc:afe12d16061856e041389248a1fb901a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:afe12d16061856e041389248a1fb901a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc115d416746eb7ddda266006a915e8" id="r_aedc115d416746eb7ddda266006a915e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNOX_1_1Abstract_1_1Group.html">NOX::Abstract::Group</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#aedc115d416746eb7ddda266006a915e8">operator=</a> (const <a class="el" href="classNOX_1_1Abstract_1_1Group.html">NOX::Abstract::Group</a> &amp;source)</td></tr>
<tr class="memdesc:aedc115d416746eb7ddda266006a915e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source group into this group.  <br /></td></tr>
<tr class="separator:aedc115d416746eb7ddda266006a915e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e7785bc3cbc66c1c6a260970afcbc9" id="r_a30e7785bc3cbc66c1c6a260970afcbc9"><td class="memItemLeft" align="right" valign="top"><a id="a30e7785bc3cbc66c1c6a260970afcbc9" name="a30e7785bc3cbc66c1c6a260970afcbc9"></a>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html">NOX::Abstract::Group</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classNOX_1_1Thyra_1_1Group.html">NOX::Thyra::Group</a> &amp;source)</td></tr>
<tr class="separator:a30e7785bc3cbc66c1c6a260970afcbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bb0f02a71af39c77c9cfa09266139b" id="r_af0bb0f02a71af39c77c9cfa09266139b"><td class="memItemLeft" align="right" valign="top"><a id="af0bb0f02a71af39c77c9cfa09266139b" name="af0bb0f02a71af39c77c9cfa09266139b"></a>
Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1VectorBase.html">::Thyra::VectorBase</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_current_x</b> () const</td></tr>
<tr class="separator:af0bb0f02a71af39c77c9cfa09266139b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940e65a6fde30bafefe4625c10f041e1" id="r_a940e65a6fde30bafefe4625c10f041e1"><td class="memItemLeft" align="right" valign="top"><a id="a940e65a6fde30bafefe4625c10f041e1" name="a940e65a6fde30bafefe4625c10f041e1"></a>
Teuchos::RCP&lt; <a class="el" href="classThyra_1_1LinearOpBase.html">::Thyra::LinearOpBase</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getNonconstJacobianOperator</b> ()</td></tr>
<tr class="separator:a940e65a6fde30bafefe4625c10f041e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204d6222779f910535eec6075f8e9a44" id="r_a204d6222779f910535eec6075f8e9a44"><td class="memItemLeft" align="right" valign="top"><a id="a204d6222779f910535eec6075f8e9a44" name="a204d6222779f910535eec6075f8e9a44"></a>
Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1LinearOpBase.html">::Thyra::LinearOpBase</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getJacobianOperator</b> () const</td></tr>
<tr class="separator:a204d6222779f910535eec6075f8e9a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76e3e9d65a2dc01d9d873562b553963" id="r_af76e3e9d65a2dc01d9d873562b553963"><td class="memItemLeft" align="right" valign="top"><a id="af76e3e9d65a2dc01d9d873562b553963" name="af76e3e9d65a2dc01d9d873562b553963"></a>
Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1LinearOpBase.html">::Thyra::LinearOpBase</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getScaledJacobianOperator</b> () const</td></tr>
<tr class="separator:af76e3e9d65a2dc01d9d873562b553963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3806b0d5eb8259c0a240530419e95b" id="r_a7e3806b0d5eb8259c0a240530419e95b"><td class="memItemLeft" align="right" valign="top"><a id="a7e3806b0d5eb8259c0a240530419e95b" name="a7e3806b0d5eb8259c0a240530419e95b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unscaleJacobianOperator</b> () const</td></tr>
<tr class="separator:a7e3806b0d5eb8259c0a240530419e95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d0a2e5cf825a0b6874f3d9cc04064f" id="r_af2d0a2e5cf825a0b6874f3d9cc04064f"><td class="memItemLeft" align="right" valign="top"><a id="af2d0a2e5cf825a0b6874f3d9cc04064f" name="af2d0a2e5cf825a0b6874f3d9cc04064f"></a>
Teuchos::RCP&lt; <a class="el" href="classThyra_1_1LinearOpWithSolveBase.html">::Thyra::LinearOpWithSolveBase</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getNonconstJacobian</b> ()</td></tr>
<tr class="separator:af2d0a2e5cf825a0b6874f3d9cc04064f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba91ba68819fff00edaafbf5090bb0f" id="r_a4ba91ba68819fff00edaafbf5090bb0f"><td class="memItemLeft" align="right" valign="top"><a id="a4ba91ba68819fff00edaafbf5090bb0f" name="a4ba91ba68819fff00edaafbf5090bb0f"></a>
Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1LinearOpWithSolveBase.html">::Thyra::LinearOpWithSolveBase</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getJacobian</b> () const</td></tr>
<tr class="separator:a4ba91ba68819fff00edaafbf5090bb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46aaaf19cc51d02e00abb0d885643401" id="r_a46aaaf19cc51d02e00abb0d885643401"><td class="memItemLeft" align="right" valign="top"><a id="a46aaaf19cc51d02e00abb0d885643401" name="a46aaaf19cc51d02e00abb0d885643401"></a>
Teuchos::RCP&lt; <a class="el" href="classThyra_1_1PreconditionerBase.html">::Thyra::PreconditionerBase</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getNonconstPreconditioner</b> ()</td></tr>
<tr class="separator:a46aaaf19cc51d02e00abb0d885643401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9a6fabe2474ebd54e789bfda4f6e43" id="r_a2a9a6fabe2474ebd54e789bfda4f6e43"><td class="memItemLeft" align="right" valign="top"><a id="a2a9a6fabe2474ebd54e789bfda4f6e43" name="a2a9a6fabe2474ebd54e789bfda4f6e43"></a>
Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1PreconditionerBase.html">::Thyra::PreconditionerBase</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getPreconditioner</b> () const</td></tr>
<tr class="separator:a2a9a6fabe2474ebd54e789bfda4f6e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa9a6c55babf27add50be95929f3160" id="r_a0fa9a6c55babf27add50be95929f3160"><td class="memItemLeft" align="right" valign="top"><a id="a0fa9a6c55babf27add50be95929f3160" name="a0fa9a6c55babf27add50be95929f3160"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setJacobianOperator</b> (const Teuchos::RCP&lt;<a class="el" href="classThyra_1_1LinearOpBase.html">::Thyra::LinearOpBase</a>&lt; double &gt; &gt; &amp;op)</td></tr>
<tr class="memdesc:a0fa9a6c55babf27add50be95929f3160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dangerous power user function for LOCA Householder bordered algorithm. <br /></td></tr>
<tr class="separator:a0fa9a6c55babf27add50be95929f3160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07207ccce58afa04d10058a3ddaadf9c" id="r_a07207ccce58afa04d10058a3ddaadf9c"><td class="memItemLeft" align="right" valign="top"><a id="a07207ccce58afa04d10058a3ddaadf9c" name="a07207ccce58afa04d10058a3ddaadf9c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setPreconditionerMatrix</b> (const Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1DefaultLinearOpSource.html">::Thyra::DefaultLinearOpSource</a>&lt; double &gt; &gt; &amp;op)</td></tr>
<tr class="memdesc:a07207ccce58afa04d10058a3ddaadf9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dangerous power user function for LOCA Householder bordered algorithm. This is the Matrix M that is used to initialize a stratimikos preconditioner. NOTE: this sets the losb_ object used to update prec_! <br /></td></tr>
<tr class="separator:a07207ccce58afa04d10058a3ddaadf9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">"Compute" functions.</div></td></tr>
<tr class="memitem:abce50aac0aaafc4c74527ef86a43a194" id="r_abce50aac0aaafc4c74527ef86a43a194"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#abce50aac0aaafc4c74527ef86a43a194">setX</a> (const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp;y)</td></tr>
<tr class="memdesc:abce50aac0aaafc4c74527ef86a43a194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the solution vector x to y.  <br /></td></tr>
<tr class="separator:abce50aac0aaafc4c74527ef86a43a194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c796635c94a22bdbed973387163199f" id="r_a2c796635c94a22bdbed973387163199f"><td class="memItemLeft" align="right" valign="top"><a id="a2c796635c94a22bdbed973387163199f" name="a2c796635c94a22bdbed973387163199f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setX</b> (const <a class="el" href="classNOX_1_1Thyra_1_1Vector.html">NOX::Thyra::Vector</a> &amp;y)</td></tr>
<tr class="memdesc:a2c796635c94a22bdbed973387163199f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See above. <br /></td></tr>
<tr class="separator:a2c796635c94a22bdbed973387163199f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15ae6058f024d77c053f0745c3ef94e" id="r_ad15ae6058f024d77c053f0745c3ef94e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#ad15ae6058f024d77c053f0745c3ef94e">computeX</a> (const <a class="el" href="classNOX_1_1Abstract_1_1Group.html">NOX::Abstract::Group</a> &amp;grp, const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp;d, double step)</td></tr>
<tr class="memdesc:ad15ae6058f024d77c053f0745c3ef94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute x = grp.x + step * d.  <br /></td></tr>
<tr class="separator:ad15ae6058f024d77c053f0745c3ef94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc379f3434b3b7036c18a655131fe388" id="r_adc379f3434b3b7036c18a655131fe388"><td class="memItemLeft" align="right" valign="top"><a id="adc379f3434b3b7036c18a655131fe388" name="adc379f3434b3b7036c18a655131fe388"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>computeX</b> (const <a class="el" href="classNOX_1_1Thyra_1_1Group.html">NOX::Thyra::Group</a> &amp;grp, const <a class="el" href="classNOX_1_1Thyra_1_1Vector.html">NOX::Thyra::Vector</a> &amp;d, double step)</td></tr>
<tr class="memdesc:adc379f3434b3b7036c18a655131fe388"><td class="mdescLeft">&#160;</td><td class="mdescRight">See above. <br /></td></tr>
<tr class="separator:adc379f3434b3b7036c18a655131fe388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77844a29d5f6a02d95ab294f48a259bd" id="r_a77844a29d5f6a02d95ab294f48a259bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#a77844a29d5f6a02d95ab294f48a259bd">computeF</a> ()</td></tr>
<tr class="memdesc:a77844a29d5f6a02d95ab294f48a259bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and store F(x).  <br /></td></tr>
<tr class="separator:a77844a29d5f6a02d95ab294f48a259bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedffa57479128c777f78565902215a1" id="r_aeedffa57479128c777f78565902215a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#aeedffa57479128c777f78565902215a1">computeJacobian</a> ()</td></tr>
<tr class="memdesc:aeedffa57479128c777f78565902215a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and store Jacobian.  <br /></td></tr>
<tr class="separator:aeedffa57479128c777f78565902215a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf0ee549de9fd7b013be91200f87290" id="r_aebf0ee549de9fd7b013be91200f87290"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#aebf0ee549de9fd7b013be91200f87290">computeGradient</a> ()</td></tr>
<tr class="memdesc:aebf0ee549de9fd7b013be91200f87290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and store gradient.  <br /></td></tr>
<tr class="separator:aebf0ee549de9fd7b013be91200f87290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88722de7a732f0d8eb58c8e2d3461d62" id="r_a88722de7a732f0d8eb58c8e2d3461d62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#a88722de7a732f0d8eb58c8e2d3461d62">computeNewton</a> (Teuchos::ParameterList &amp;params)</td></tr>
<tr class="memdesc:a88722de7a732f0d8eb58c8e2d3461d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Newton direction, using parameters for the linear solve.  <br /></td></tr>
<tr class="separator:a88722de7a732f0d8eb58c8e2d3461d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Jacobian operations.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Operations using the Jacobian matrix. These may not be defined in matrix-free scenarios. </p>
</div></td></tr>
<tr class="memitem:a4e72dd7baf41a2c83fb65fd5d30e86bb" id="r_a4e72dd7baf41a2c83fb65fd5d30e86bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#a4e72dd7baf41a2c83fb65fd5d30e86bb">applyJacobian</a> (const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp;input, <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp;result) const</td></tr>
<tr class="memdesc:a4e72dd7baf41a2c83fb65fd5d30e86bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies Jacobian to the given input vector and puts the answer in the result.  <br /></td></tr>
<tr class="separator:a4e72dd7baf41a2c83fb65fd5d30e86bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d42f2ec21dccce55300a91ee57682aa" id="r_a3d42f2ec21dccce55300a91ee57682aa"><td class="memItemLeft" align="right" valign="top"><a id="a3d42f2ec21dccce55300a91ee57682aa" name="a3d42f2ec21dccce55300a91ee57682aa"></a>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>applyJacobian</b> (const <a class="el" href="classNOX_1_1Thyra_1_1Vector.html">NOX::Thyra::Vector</a> &amp;input, <a class="el" href="classNOX_1_1Thyra_1_1Vector.html">NOX::Thyra::Vector</a> &amp;result) const</td></tr>
<tr class="separator:a3d42f2ec21dccce55300a91ee57682aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac176d23981d8fee9258a840dd5d9e3d2" id="r_ac176d23981d8fee9258a840dd5d9e3d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#ac176d23981d8fee9258a840dd5d9e3d2">applyJacobianMultiVector</a> (const <a class="el" href="classNOX_1_1Abstract_1_1MultiVector.html">NOX::Abstract::MultiVector</a> &amp;input, <a class="el" href="classNOX_1_1Abstract_1_1MultiVector.html">NOX::Abstract::MultiVector</a> &amp;result) const</td></tr>
<tr class="memdesc:ac176d23981d8fee9258a840dd5d9e3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">applyJacobian for multiple right-hand sides  <br /></td></tr>
<tr class="separator:ac176d23981d8fee9258a840dd5d9e3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945d4022986d44d8fc9b62e9d6521a60" id="r_a945d4022986d44d8fc9b62e9d6521a60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#a945d4022986d44d8fc9b62e9d6521a60">applyJacobianTranspose</a> (const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp;input, <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp;result) const</td></tr>
<tr class="memdesc:a945d4022986d44d8fc9b62e9d6521a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies Jacobian-Transpose to the given input vector and puts the answer in the result.  <br /></td></tr>
<tr class="separator:a945d4022986d44d8fc9b62e9d6521a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5312aa99d1271b11e5eb6ac64b1a35" id="r_adf5312aa99d1271b11e5eb6ac64b1a35"><td class="memItemLeft" align="right" valign="top"><a id="adf5312aa99d1271b11e5eb6ac64b1a35" name="adf5312aa99d1271b11e5eb6ac64b1a35"></a>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>applyJacobianTranspose</b> (const <a class="el" href="classNOX_1_1Thyra_1_1Vector.html">NOX::Thyra::Vector</a> &amp;input, <a class="el" href="classNOX_1_1Thyra_1_1Vector.html">NOX::Thyra::Vector</a> &amp;result) const</td></tr>
<tr class="separator:adf5312aa99d1271b11e5eb6ac64b1a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98de0a9bce446cee6a15b7cbc124fb93" id="r_a98de0a9bce446cee6a15b7cbc124fb93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#a98de0a9bce446cee6a15b7cbc124fb93">applyJacobianTransposeMultiVector</a> (const <a class="el" href="classNOX_1_1Abstract_1_1MultiVector.html">NOX::Abstract::MultiVector</a> &amp;input, <a class="el" href="classNOX_1_1Abstract_1_1MultiVector.html">NOX::Abstract::MultiVector</a> &amp;result) const</td></tr>
<tr class="memdesc:a98de0a9bce446cee6a15b7cbc124fb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">applyJacobianTranspose for multiple right-hand sides  <br /></td></tr>
<tr class="separator:a98de0a9bce446cee6a15b7cbc124fb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591ca60a7e9414e06df5492bd37074e2" id="r_a591ca60a7e9414e06df5492bd37074e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#a591ca60a7e9414e06df5492bd37074e2">applyJacobianInverse</a> (Teuchos::ParameterList &amp;params, const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp;input, <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp;result) const</td></tr>
<tr class="memdesc:a591ca60a7e9414e06df5492bd37074e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the inverse of the Jacobian matrix to the given input vector and puts the answer in result.  <br /></td></tr>
<tr class="separator:a591ca60a7e9414e06df5492bd37074e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe82386c401a6f642b0dd1d51751f806" id="r_abe82386c401a6f642b0dd1d51751f806"><td class="memItemLeft" align="right" valign="top"><a id="abe82386c401a6f642b0dd1d51751f806" name="abe82386c401a6f642b0dd1d51751f806"></a>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>applyJacobianInverse</b> (Teuchos::ParameterList &amp;params, const <a class="el" href="classNOX_1_1Thyra_1_1Vector.html">NOX::Thyra::Vector</a> &amp;input, <a class="el" href="classNOX_1_1Thyra_1_1Vector.html">NOX::Thyra::Vector</a> &amp;result) const</td></tr>
<tr class="separator:abe82386c401a6f642b0dd1d51751f806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df36b427b54d34b527cd9e53c4dfffe" id="r_a8df36b427b54d34b527cd9e53c4dfffe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#a8df36b427b54d34b527cd9e53c4dfffe">applyJacobianInverseMultiVector</a> (Teuchos::ParameterList &amp;params, const <a class="el" href="classNOX_1_1Abstract_1_1MultiVector.html">NOX::Abstract::MultiVector</a> &amp;input, <a class="el" href="classNOX_1_1Abstract_1_1MultiVector.html">NOX::Abstract::MultiVector</a> &amp;result) const</td></tr>
<tr class="memdesc:a8df36b427b54d34b527cd9e53c4dfffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">applyJacobianInverse for multiple right-hand sides  <br /></td></tr>
<tr class="separator:a8df36b427b54d34b527cd9e53c4dfffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b10e40c5d7703952a75f41d8d7631e" id="r_af9b10e40c5d7703952a75f41d8d7631e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#af9b10e40c5d7703952a75f41d8d7631e">applyRightPreconditioning</a> (bool useTranspose, Teuchos::ParameterList &amp;params, const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp;input, <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp;result) const</td></tr>
<tr class="memdesc:af9b10e40c5d7703952a75f41d8d7631e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply right preconditiong to the given input vector.  <br /></td></tr>
<tr class="separator:af9b10e40c5d7703952a75f41d8d7631e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">"Is" functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Checks to see if various objects have been computed. Returns true if the corresponding "compute" function has been called since the last update to the solution vector (via instantiation or computeX). </p>
</div></td></tr>
<tr class="memitem:adea192c39bba4d224179cc3c85b4d07d" id="r_adea192c39bba4d224179cc3c85b4d07d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#adea192c39bba4d224179cc3c85b4d07d">isF</a> () const</td></tr>
<tr class="memdesc:adea192c39bba4d224179cc3c85b4d07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if F is valid.  <br /></td></tr>
<tr class="separator:adea192c39bba4d224179cc3c85b4d07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597d0c628e70d5f0777a416786d58837" id="r_a597d0c628e70d5f0777a416786d58837"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#a597d0c628e70d5f0777a416786d58837">isJacobian</a> () const</td></tr>
<tr class="memdesc:a597d0c628e70d5f0777a416786d58837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the Jacobian is valid.  <br /></td></tr>
<tr class="separator:a597d0c628e70d5f0777a416786d58837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1016ca595b660b41f8a63e4b36841dd" id="r_aa1016ca595b660b41f8a63e4b36841dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#aa1016ca595b660b41f8a63e4b36841dd">isGradient</a> () const</td></tr>
<tr class="memdesc:aa1016ca595b660b41f8a63e4b36841dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the gradient is valid.  <br /></td></tr>
<tr class="separator:aa1016ca595b660b41f8a63e4b36841dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3939cb79b59f7424911529814b98db" id="r_a4d3939cb79b59f7424911529814b98db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#a4d3939cb79b59f7424911529814b98db">isNewton</a> () const</td></tr>
<tr class="memdesc:a4d3939cb79b59f7424911529814b98db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the Newton direction is valid.  <br /></td></tr>
<tr class="separator:a4d3939cb79b59f7424911529814b98db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classNOX_1_1Abstract_1_1Group"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classNOX_1_1Abstract_1_1Group')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classNOX_1_1Abstract_1_1Group.html">NOX::Abstract::Group</a></td></tr>
<tr class="memitem:af49179db064ac14246c4386d1b5bff0b inherit pub_methods_classNOX_1_1Abstract_1_1Group" id="r_af49179db064ac14246c4386d1b5bff0b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#af49179db064ac14246c4386d1b5bff0b">Group</a> ()</td></tr>
<tr class="memdesc:af49179db064ac14246c4386d1b5bff0b inherit pub_methods_classNOX_1_1Abstract_1_1Group"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:af49179db064ac14246c4386d1b5bff0b inherit pub_methods_classNOX_1_1Abstract_1_1Group"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ebd348f91e6e06a08d1f71e3031462 inherit pub_methods_classNOX_1_1Abstract_1_1Group" id="r_a44ebd348f91e6e06a08d1f71e3031462"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#a44ebd348f91e6e06a08d1f71e3031462">applyRightPreconditioningMultiVector</a> (bool useTranspose, Teuchos::ParameterList &amp;params, const <a class="el" href="classNOX_1_1Abstract_1_1MultiVector.html">NOX::Abstract::MultiVector</a> &amp;input, <a class="el" href="classNOX_1_1Abstract_1_1MultiVector.html">NOX::Abstract::MultiVector</a> &amp;result) const</td></tr>
<tr class="memdesc:a44ebd348f91e6e06a08d1f71e3031462 inherit pub_methods_classNOX_1_1Abstract_1_1Group"><td class="mdescLeft">&#160;</td><td class="mdescRight">applyRightPreconditioning for multiple right-hand sides  <br /></td></tr>
<tr class="separator:a44ebd348f91e6e06a08d1f71e3031462 inherit pub_methods_classNOX_1_1Abstract_1_1Group"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d38546018154b4e7cf9ddd74557279 inherit pub_methods_classNOX_1_1Abstract_1_1Group" id="r_ad1d38546018154b4e7cf9ddd74557279"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#ad1d38546018154b4e7cf9ddd74557279">getNormLastLinearSolveResidual</a> (double &amp;residual) const</td></tr>
<tr class="memdesc:ad1d38546018154b4e7cf9ddd74557279 inherit pub_methods_classNOX_1_1Abstract_1_1Group"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the norm of the last linear solve residual as the result of either a call to <a class="el" href="classNOX_1_1Abstract_1_1Group.html#a0ea79dfbca4bb39b408bc472bcd8853e" title="Compute the Newton direction, using parameters for the linear solve.">computeNewton()</a> or <a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa85242fccabcfe99c6cb66b07a7e57eb" title="Applies the inverse of the Jacobian matrix to the given input vector and puts the answer in result.">applyJacobianInverse()</a>.  <br /></td></tr>
<tr class="separator:ad1d38546018154b4e7cf9ddd74557279 inherit pub_methods_classNOX_1_1Abstract_1_1Group"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14cca8c4e8df87fe08e97b1946a11f6b inherit pub_methods_classNOX_1_1Abstract_1_1Group" id="r_a14cca8c4e8df87fe08e97b1946a11f6b"><td class="memItemLeft" align="right" valign="top">virtual Teuchos::RCP&lt; <a class="el" href="classNOX_1_1Abstract_1_1Group.html">NOX::Abstract::Group</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#a14cca8c4e8df87fe08e97b1946a11f6b">getNestedGroup</a> ()</td></tr>
<tr class="memdesc:a14cca8c4e8df87fe08e97b1946a11f6b inherit pub_methods_classNOX_1_1Abstract_1_1Group"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an internally stored group from this group.  <br /></td></tr>
<tr class="separator:a14cca8c4e8df87fe08e97b1946a11f6b inherit pub_methods_classNOX_1_1Abstract_1_1Group"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6579e907d15c56b80bc3156e31fb55a inherit pub_methods_classNOX_1_1Abstract_1_1Group" id="r_ab6579e907d15c56b80bc3156e31fb55a"><td class="memItemLeft" align="right" valign="top">virtual Teuchos::RCP&lt; const <a class="el" href="classNOX_1_1Abstract_1_1Group.html">NOX::Abstract::Group</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#ab6579e907d15c56b80bc3156e31fb55a">getNestedGroup</a> () const</td></tr>
<tr class="memdesc:ab6579e907d15c56b80bc3156e31fb55a inherit pub_methods_classNOX_1_1Abstract_1_1Group"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an internally stored group from this group.  <br /></td></tr>
<tr class="separator:ab6579e907d15c56b80bc3156e31fb55a inherit pub_methods_classNOX_1_1Abstract_1_1Group"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">IsValid flags</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>True if the current solution is up-to-date with respect to the currect solution vector. </p>
</div></td></tr>
<tr class="memitem:a3117b1a0667140080ea1417e6a49362a" id="r_a3117b1a0667140080ea1417e6a49362a"><td class="memItemLeft" align="right" valign="top"><a id="a3117b1a0667140080ea1417e6a49362a" name="a3117b1a0667140080ea1417e6a49362a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_valid_f_</b></td></tr>
<tr class="separator:a3117b1a0667140080ea1417e6a49362a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a1fa4cf23b736d9e4ae21d43f6fda0" id="r_a60a1fa4cf23b736d9e4ae21d43f6fda0"><td class="memItemLeft" align="right" valign="top"><a id="a60a1fa4cf23b736d9e4ae21d43f6fda0" name="a60a1fa4cf23b736d9e4ae21d43f6fda0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_valid_jacobian_</b></td></tr>
<tr class="separator:a60a1fa4cf23b736d9e4ae21d43f6fda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d90ce7596a0e0ccb504159f55b1115" id="r_af7d90ce7596a0e0ccb504159f55b1115"><td class="memItemLeft" align="right" valign="top"><a id="af7d90ce7596a0e0ccb504159f55b1115" name="af7d90ce7596a0e0ccb504159f55b1115"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_valid_newton_dir_</b></td></tr>
<tr class="separator:af7d90ce7596a0e0ccb504159f55b1115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb78d741016099cc8ee8cc233368381b" id="r_abb78d741016099cc8ee8cc233368381b"><td class="memItemLeft" align="right" valign="top"><a id="abb78d741016099cc8ee8cc233368381b" name="abb78d741016099cc8ee8cc233368381b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_valid_gradient_dir_</b></td></tr>
<tr class="separator:abb78d741016099cc8ee8cc233368381b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9198313575b4438ad7b6ec4bf462a899" id="r_a9198313575b4438ad7b6ec4bf462a899"><td class="memItemLeft" align="right" valign="top"><a id="a9198313575b4438ad7b6ec4bf462a899" name="a9198313575b4438ad7b6ec4bf462a899"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_valid_lows_</b></td></tr>
<tr class="separator:a9198313575b4438ad7b6ec4bf462a899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9845a8449218b0e04dc62197ab15c0c2" id="r_a9845a8449218b0e04dc62197ab15c0c2"><td class="memItemLeft" align="right" valign="top"><a id="a9845a8449218b0e04dc62197ab15c0c2" name="a9845a8449218b0e04dc62197ab15c0c2"></a>
Teuchos::RCP&lt; <a class="el" href="classNOX_1_1Thyra_1_1Vector.html">NOX::Thyra::Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>x_vec_</b></td></tr>
<tr class="memdesc:a9845a8449218b0e04dc62197ab15c0c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solution vector. <br /></td></tr>
<tr class="separator:a9845a8449218b0e04dc62197ab15c0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb658fede2093f47cfeb967e7aef398" id="r_addb658fede2093f47cfeb967e7aef398"><td class="memItemLeft" align="right" valign="top"><a id="addb658fede2093f47cfeb967e7aef398" name="addb658fede2093f47cfeb967e7aef398"></a>
Teuchos::RCP&lt; <a class="el" href="classNOX_1_1Thyra_1_1Vector.html">NOX::Thyra::Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>f_vec_</b></td></tr>
<tr class="memdesc:addb658fede2093f47cfeb967e7aef398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Residual vector. <br /></td></tr>
<tr class="separator:addb658fede2093f47cfeb967e7aef398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ce389db8ebf1cdac07839a617cb64b" id="r_af8ce389db8ebf1cdac07839a617cb64b"><td class="memItemLeft" align="right" valign="top"><a id="af8ce389db8ebf1cdac07839a617cb64b" name="af8ce389db8ebf1cdac07839a617cb64b"></a>
Teuchos::RCP&lt; <a class="el" href="classNOX_1_1Thyra_1_1Vector.html">NOX::Thyra::Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>newton_vec_</b></td></tr>
<tr class="memdesc:af8ce389db8ebf1cdac07839a617cb64b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Newton direction vector. <br /></td></tr>
<tr class="separator:af8ce389db8ebf1cdac07839a617cb64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed9f729edc671909bda0bbc04c2ea68" id="r_a4ed9f729edc671909bda0bbc04c2ea68"><td class="memItemLeft" align="right" valign="top"><a id="a4ed9f729edc671909bda0bbc04c2ea68" name="a4ed9f729edc671909bda0bbc04c2ea68"></a>
Teuchos::RCP&lt; <a class="el" href="classNOX_1_1Thyra_1_1Vector.html">NOX::Thyra::Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>gradient_vec_</b></td></tr>
<tr class="memdesc:a4ed9f729edc671909bda0bbc04c2ea68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gradient direction vector. <br /></td></tr>
<tr class="separator:a4ed9f729edc671909bda0bbc04c2ea68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3771b31b751f9d8e68d033fcbbdd0d" id="r_abb3771b31b751f9d8e68d033fcbbdd0d"><td class="memItemLeft" align="right" valign="top"><a id="abb3771b31b751f9d8e68d033fcbbdd0d" name="abb3771b31b751f9d8e68d033fcbbdd0d"></a>
Teuchos::RCP&lt; <a class="el" href="classNOX_1_1SharedObject.html">NOX::SharedObject</a>&lt; <a class="el" href="classThyra_1_1LinearOpWithSolveBase.html">::Thyra::LinearOpWithSolveBase</a>&lt; double &gt;, <a class="el" href="classNOX_1_1Thyra_1_1Group.html">NOX::Thyra::Group</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>shared_jacobian_</b></td></tr>
<tr class="memdesc:abb3771b31b751f9d8e68d033fcbbdd0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared Jacobian operator with solve. <br /></td></tr>
<tr class="separator:abb3771b31b751f9d8e68d033fcbbdd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c9efd44a2cb6932cf2d8702da0ecff" id="r_a43c9efd44a2cb6932cf2d8702da0ecff"><td class="memItemLeft" align="right" valign="top"><a id="a43c9efd44a2cb6932cf2d8702da0ecff" name="a43c9efd44a2cb6932cf2d8702da0ecff"></a>
Teuchos::RCP&lt; <a class="el" href="classThyra_1_1LinearOpBase.html">::Thyra::LinearOpBase</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>lop_</b></td></tr>
<tr class="memdesc:a43c9efd44a2cb6932cf2d8702da0ecff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobian operator. <br /></td></tr>
<tr class="separator:a43c9efd44a2cb6932cf2d8702da0ecff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145eee12fd36e3bfc66d2eaa16b0b87a" id="r_a145eee12fd36e3bfc66d2eaa16b0b87a"><td class="memItemLeft" align="right" valign="top"><a id="a145eee12fd36e3bfc66d2eaa16b0b87a" name="a145eee12fd36e3bfc66d2eaa16b0b87a"></a>
Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1LinearOpWithSolveFactoryBase.html">::Thyra::LinearOpWithSolveFactoryBase</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>lows_factory_</b></td></tr>
<tr class="memdesc:a145eee12fd36e3bfc66d2eaa16b0b87a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceNOX_1_1Thyra.html" title="NOX Thyra support.">Thyra</a> LOWS factory for building Jacobians. <br /></td></tr>
<tr class="separator:a145eee12fd36e3bfc66d2eaa16b0b87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3f9ae401cbeea2bf5be964afd72e46" id="r_aed3f9ae401cbeea2bf5be964afd72e46"><td class="memItemLeft" align="right" valign="top"><a id="aed3f9ae401cbeea2bf5be964afd72e46" name="aed3f9ae401cbeea2bf5be964afd72e46"></a>
Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1DefaultLinearOpSource.html">::Thyra::DefaultLinearOpSource</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>losb_</b></td></tr>
<tr class="memdesc:aed3f9ae401cbeea2bf5be964afd72e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Source base needed to create preconditioner. <br /></td></tr>
<tr class="separator:aed3f9ae401cbeea2bf5be964afd72e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d13fc6bde1c4bbe6cdcd740ff335c5f" id="r_a8d13fc6bde1c4bbe6cdcd740ff335c5f"><td class="memItemLeft" align="right" valign="top"><a id="a8d13fc6bde1c4bbe6cdcd740ff335c5f" name="a8d13fc6bde1c4bbe6cdcd740ff335c5f"></a>
Teuchos::RCP&lt; <a class="el" href="classThyra_1_1PreconditionerBase.html">::Thyra::PreconditionerBase</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>prec_</b></td></tr>
<tr class="memdesc:a8d13fc6bde1c4bbe6cdcd740ff335c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preconditioner for Jacobian. <br /></td></tr>
<tr class="separator:a8d13fc6bde1c4bbe6cdcd740ff335c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521421339690059473e9a418ff2e3f9e" id="r_a521421339690059473e9a418ff2e3f9e"><td class="memItemLeft" align="right" valign="top"><a id="a521421339690059473e9a418ff2e3f9e" name="a521421339690059473e9a418ff2e3f9e"></a>
Teuchos::RCP&lt; <a class="el" href="classThyra_1_1PreconditionerFactoryBase.html">::Thyra::PreconditionerFactoryBase</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>prec_factory_</b></td></tr>
<tr class="memdesc:a521421339690059473e9a418ff2e3f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preconditioner factory. <br /></td></tr>
<tr class="separator:a521421339690059473e9a418ff2e3f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0cf912ca40f1623d2ced6873917f52f" id="r_aa0cf912ca40f1623d2ced6873917f52f"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1VectorBase.html">::Thyra::VectorBase</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#aa0cf912ca40f1623d2ced6873917f52f">weight_vec_</a></td></tr>
<tr class="memdesc:aa0cf912ca40f1623d2ced6873917f52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional wieghting vector for function scaling. <a class="el" href="namespaceNOX.html" title="Nonlinear solvers package namespace.">NOX</a> assumes that this vector can be updated in between nonlinear iterations.  <br /></td></tr>
<tr class="separator:aa0cf912ca40f1623d2ced6873917f52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9937bc0c654ecc33160f714904dbbe9d" id="r_a9937bc0c654ecc33160f714904dbbe9d"><td class="memItemLeft" align="right" valign="top"><a id="a9937bc0c654ecc33160f714904dbbe9d" name="a9937bc0c654ecc33160f714904dbbe9d"></a>
Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1VectorBase.html">::Thyra::VectorBase</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>right_weight_vec_</b></td></tr>
<tr class="memdesc:a9937bc0c654ecc33160f714904dbbe9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional wieghting vector for solution (right) scaling. <br /></td></tr>
<tr class="separator:a9937bc0c654ecc33160f714904dbbe9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8513371f13bfa46d73e425fb40b54fde" id="r_a8513371f13bfa46d73e425fb40b54fde"><td class="memItemLeft" align="right" valign="top"><a id="a8513371f13bfa46d73e425fb40b54fde" name="a8513371f13bfa46d73e425fb40b54fde"></a>
Teuchos::RCP&lt; <a class="el" href="classThyra_1_1VectorBase.html">::Thyra::VectorBase</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>inv_weight_vec_</b></td></tr>
<tr class="memdesc:a8513371f13bfa46d73e425fb40b54fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of weight vector used to unscale function (left) scaling. <a class="el" href="namespaceNOX.html" title="Nonlinear solvers package namespace.">NOX</a> assumes that this vector can be updated in between nonlinear iterations. <br /></td></tr>
<tr class="separator:a8513371f13bfa46d73e425fb40b54fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddf605880d6c0eb735ea2bd2e2bdbee" id="r_a2ddf605880d6c0eb735ea2bd2e2bdbee"><td class="memItemLeft" align="right" valign="top"><a id="a2ddf605880d6c0eb735ea2bd2e2bdbee" name="a2ddf605880d6c0eb735ea2bd2e2bdbee"></a>
Teuchos::RCP&lt; <a class="el" href="classThyra_1_1VectorBase.html">::Thyra::VectorBase</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>inv_right_weight_vec_</b></td></tr>
<tr class="memdesc:a2ddf605880d6c0eb735ea2bd2e2bdbee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of weight vector used to unscale solution (right) scaling. <br /></td></tr>
<tr class="separator:a2ddf605880d6c0eb735ea2bd2e2bdbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f279ab32e8524880d0c159aaabed9a" id="r_a66f279ab32e8524880d0c159aaabed9a"><td class="memItemLeft" align="right" valign="top"><a id="a66f279ab32e8524880d0c159aaabed9a" name="a66f279ab32e8524880d0c159aaabed9a"></a>
Teuchos::RCP&lt; <a class="el" href="classNOX_1_1Thyra_1_1Vector.html">NOX::Thyra::Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>scaled_x_vec_</b></td></tr>
<tr class="memdesc:a66f279ab32e8524880d0c159aaabed9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaled solution vector scaled by the. <br /></td></tr>
<tr class="separator:a66f279ab32e8524880d0c159aaabed9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d2f6a5bfa0cf096f80d4d74d0f387c" id="r_aa0d2f6a5bfa0cf096f80d4d74d0f387c"><td class="memItemLeft" align="right" valign="top"><a id="aa0d2f6a5bfa0cf096f80d4d74d0f387c" name="aa0d2f6a5bfa0cf096f80d4d74d0f387c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>rightScalingFirst_</b></td></tr>
<tr class="memdesc:aa0d2f6a5bfa0cf096f80d4d74d0f387c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do right scaling before left scaling? <br /></td></tr>
<tr class="separator:aa0d2f6a5bfa0cf096f80d4d74d0f387c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6116e3575a797f08924fbdfa7fda81eb" id="r_a6116e3575a797f08924fbdfa7fda81eb"><td class="memItemLeft" align="right" valign="top"><a id="a6116e3575a797f08924fbdfa7fda81eb" name="a6116e3575a797f08924fbdfa7fda81eb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>updatePreconditioner_</b></td></tr>
<tr class="memdesc:a6116e3575a797f08924fbdfa7fda81eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set to true, the preconditioner matrix values will be automatically updated via precFactory or ModelEvalautor. If set to false, the user must manually handle updating the preconditioner. <br /></td></tr>
<tr class="separator:a6116e3575a797f08924fbdfa7fda81eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ad05c4bc4fd6aeb608866968cb7baa" id="r_aa2ad05c4bc4fd6aeb608866968cb7baa"><td class="memItemLeft" align="right" valign="top"><a id="aa2ad05c4bc4fd6aeb608866968cb7baa" name="aa2ad05c4bc4fd6aeb608866968cb7baa"></a>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>last_linear_solve_status_</b></td></tr>
<tr class="memdesc:aa2ad05c4bc4fd6aeb608866968cb7baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The status of the last linear solve performed. <br /></td></tr>
<tr class="separator:aa2ad05c4bc4fd6aeb608866968cb7baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d997e97bd3c334b8b88a25c56f2356" id="r_ab6d997e97bd3c334b8b88a25c56f2356"><td class="memItemLeft" align="right" valign="top"><a id="ab6d997e97bd3c334b8b88a25c56f2356" name="ab6d997e97bd3c334b8b88a25c56f2356"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>last_linear_solve_num_iters_</b></td></tr>
<tr class="memdesc:ab6d997e97bd3c334b8b88a25c56f2356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of iterations for last linear solve performed. <br /></td></tr>
<tr class="separator:ab6d997e97bd3c334b8b88a25c56f2356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24ea462b5c5411b8bbdfbe30840f453" id="r_ab24ea462b5c5411b8bbdfbe30840f453"><td class="memItemLeft" align="right" valign="top"><a id="ab24ea462b5c5411b8bbdfbe30840f453" name="ab24ea462b5c5411b8bbdfbe30840f453"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>last_linear_solve_achieved_tol_</b></td></tr>
<tr class="memdesc:ab24ea462b5c5411b8bbdfbe30840f453"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tolerance achieved by the last linear solver. <br /></td></tr>
<tr class="separator:ab24ea462b5c5411b8bbdfbe30840f453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6358d2d15389efc952bff5dc0380f91" id="r_ab6358d2d15389efc952bff5dc0380f91"><td class="memItemLeft" align="right" valign="top"><a id="ab6358d2d15389efc952bff5dc0380f91" name="ab6358d2d15389efc952bff5dc0380f91"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>use_pseudo_transient_terms_</b></td></tr>
<tr class="separator:ab6358d2d15389efc952bff5dc0380f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6fd014ca08934064b2d17797b191bf" id="r_a9b6fd014ca08934064b2d17797b191bf"><td class="memItemLeft" align="right" valign="top"><a id="a9b6fd014ca08934064b2d17797b191bf" name="a9b6fd014ca08934064b2d17797b191bf"></a>
Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1VectorBase.html">::Thyra::VectorBase</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>x_dot_</b></td></tr>
<tr class="separator:a9b6fd014ca08934064b2d17797b191bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07278a020a49f752d969599a35e8b48" id="r_ab07278a020a49f752d969599a35e8b48"><td class="memItemLeft" align="right" valign="top"><a id="ab07278a020a49f752d969599a35e8b48" name="ab07278a020a49f752d969599a35e8b48"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>alpha_</b></td></tr>
<tr class="separator:ab07278a020a49f752d969599a35e8b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eaccd4aee0617805d57476b4c73513d" id="r_a2eaccd4aee0617805d57476b4c73513d"><td class="memItemLeft" align="right" valign="top"><a id="a2eaccd4aee0617805d57476b4c73513d" name="a2eaccd4aee0617805d57476b4c73513d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>beta_</b></td></tr>
<tr class="separator:a2eaccd4aee0617805d57476b4c73513d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a82aef4af5b709a7a627ca4a99cc1e" id="r_ab4a82aef4af5b709a7a627ca4a99cc1e"><td class="memItemLeft" align="right" valign="top"><a id="ab4a82aef4af5b709a7a627ca4a99cc1e" name="ab4a82aef4af5b709a7a627ca4a99cc1e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>t_</b></td></tr>
<tr class="separator:ab4a82aef4af5b709a7a627ca4a99cc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8006af6cb8ed43b763845e943addf7f" id="r_ad8006af6cb8ed43b763845e943addf7f"><td class="memItemLeft" align="right" valign="top"><a id="ad8006af6cb8ed43b763845e943addf7f" name="ad8006af6cb8ed43b763845e943addf7f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>use_base_point_</b></td></tr>
<tr class="separator:ad8006af6cb8ed43b763845e943addf7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af97bb670426715dc30bfeba51f8519" id="r_a6af97bb670426715dc30bfeba51f8519"><td class="memItemLeft" align="right" valign="top"><a id="a6af97bb670426715dc30bfeba51f8519" name="a6af97bb670426715dc30bfeba51f8519"></a>
::Thyra::ModelEvaluatorBase::InArgs&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>base_point_</b></td></tr>
<tr class="separator:a6af97bb670426715dc30bfeba51f8519"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">"Get" functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Note that these function do not check whether or not the vectors are valid. Must use the "Is" functions for that purpose. </p>
</td></tr>
<tr class="memitem:af0b37547b56933c194dd60fe102f8b17" id="r_af0b37547b56933c194dd60fe102f8b17"><td class="memItemLeft" align="right" valign="top"><a id="af0b37547b56933c194dd60fe102f8b17" name="af0b37547b56933c194dd60fe102f8b17"></a>
Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1ModelEvaluator.html">::Thyra::ModelEvaluator</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>model_</b></td></tr>
<tr class="memdesc:af0b37547b56933c194dd60fe102f8b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Problem interface. <br /></td></tr>
<tr class="separator:af0b37547b56933c194dd60fe102f8b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4655073b47be741677beac8994e324a2" id="r_a4655073b47be741677beac8994e324a2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#a4655073b47be741677beac8994e324a2">getX</a> () const</td></tr>
<tr class="memdesc:a4655073b47be741677beac8994e324a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return solution vector.  <br /></td></tr>
<tr class="separator:a4655073b47be741677beac8994e324a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e76d78aadab2276e404d00d8a7e44a" id="r_a18e76d78aadab2276e404d00d8a7e44a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#a18e76d78aadab2276e404d00d8a7e44a">getScaledX</a> () const</td></tr>
<tr class="separator:a18e76d78aadab2276e404d00d8a7e44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a7dbf42ce853a1a3125730b42d1d34" id="r_a79a7dbf42ce853a1a3125730b42d1d34"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#a79a7dbf42ce853a1a3125730b42d1d34">getF</a> () const</td></tr>
<tr class="memdesc:a79a7dbf42ce853a1a3125730b42d1d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return F(x)  <br /></td></tr>
<tr class="separator:a79a7dbf42ce853a1a3125730b42d1d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12199ef815edc33b11e9e3cf38a9fab5" id="r_a12199ef815edc33b11e9e3cf38a9fab5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#a12199ef815edc33b11e9e3cf38a9fab5">getNormF</a> () const</td></tr>
<tr class="memdesc:a12199ef815edc33b11e9e3cf38a9fab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 2-norm of F(x).  <br /></td></tr>
<tr class="separator:a12199ef815edc33b11e9e3cf38a9fab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab77ba12a280f83bc68d52fdf5263fea" id="r_aab77ba12a280f83bc68d52fdf5263fea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#aab77ba12a280f83bc68d52fdf5263fea">getGradient</a> () const</td></tr>
<tr class="memdesc:aab77ba12a280f83bc68d52fdf5263fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return gradient.  <br /></td></tr>
<tr class="separator:aab77ba12a280f83bc68d52fdf5263fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b26c367e55ad74d0d63f68d1c483fd" id="r_a22b26c367e55ad74d0d63f68d1c483fd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#a22b26c367e55ad74d0d63f68d1c483fd">getNewton</a> () const</td></tr>
<tr class="memdesc:a22b26c367e55ad74d0d63f68d1c483fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Newton direction.  <br /></td></tr>
<tr class="separator:a22b26c367e55ad74d0d63f68d1c483fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9759acc62fbbeae442141619e8b8e8b" id="r_aa9759acc62fbbeae442141619e8b8e8b"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#aa9759acc62fbbeae442141619e8b8e8b">getXPtr</a> () const</td></tr>
<tr class="memdesc:aa9759acc62fbbeae442141619e8b8e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return RCP to solution vector.  <br /></td></tr>
<tr class="separator:aa9759acc62fbbeae442141619e8b8e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3bd837d4798709dc85047e49f76691c" id="r_af3bd837d4798709dc85047e49f76691c"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#af3bd837d4798709dc85047e49f76691c">getFPtr</a> () const</td></tr>
<tr class="memdesc:af3bd837d4798709dc85047e49f76691c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return RCP to F(x)  <br /></td></tr>
<tr class="separator:af3bd837d4798709dc85047e49f76691c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeacd9d7a7814dcf570dce46e5e9d818" id="r_adeacd9d7a7814dcf570dce46e5e9d818"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#adeacd9d7a7814dcf570dce46e5e9d818">getGradientPtr</a> () const</td></tr>
<tr class="memdesc:adeacd9d7a7814dcf570dce46e5e9d818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return RCP to gradient.  <br /></td></tr>
<tr class="separator:adeacd9d7a7814dcf570dce46e5e9d818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd53ba24dcd28cd0f03f9100ce53943b" id="r_afd53ba24dcd28cd0f03f9100ce53943b"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#afd53ba24dcd28cd0f03f9100ce53943b">getNewtonPtr</a> () const</td></tr>
<tr class="memdesc:afd53ba24dcd28cd0f03f9100ce53943b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return RCP to Newton direction.  <br /></td></tr>
<tr class="separator:afd53ba24dcd28cd0f03f9100ce53943b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4b485ba28c0fea085a5de0adf7bc29" id="r_a9f4b485ba28c0fea085a5de0adf7bc29"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#a9f4b485ba28c0fea085a5de0adf7bc29">logLastLinearSolveStats</a> (<a class="el" href="structNOX_1_1SolverStats.html">NOX::SolverStats</a> &amp;stats) const</td></tr>
<tr class="memdesc:a9f4b485ba28c0fea085a5de0adf7bc29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds statistics from last linear solve to the SovlerStats object.  <br /></td></tr>
<tr class="separator:a9f4b485ba28c0fea085a5de0adf7bc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa181cac89743f77556086ce2bd5acec5" id="r_aa181cac89743f77556086ce2bd5acec5"><td class="memItemLeft" align="right" valign="top">virtual Teuchos::RCP&lt; <a class="el" href="classNOX_1_1Abstract_1_1Group.html">NOX::Abstract::Group</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#aa181cac89743f77556086ce2bd5acec5">clone</a> (<a class="el" href="namespaceNOX.html#a053a1ab5b2b3bd9546883b949142c592">NOX::CopyType</a> type=<a class="el" href="namespaceNOX.html#a053a1ab5b2b3bd9546883b949142c592af22ab6417594618436dfab3f95f98261">NOX::DeepCopy</a>) const</td></tr>
<tr class="memdesc:aa181cac89743f77556086ce2bd5acec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new Group of the same derived type as this one by cloning this one, and return a ref count pointer to the new group.  <br /></td></tr>
<tr class="separator:aa181cac89743f77556086ce2bd5acec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2070e8f6cefa124d05004387fd2344" id="r_a8e2070e8f6cefa124d05004387fd2344"><td class="memItemLeft" align="right" valign="top"><a id="a8e2070e8f6cefa124d05004387fd2344" name="a8e2070e8f6cefa124d05004387fd2344"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print</b> () const</td></tr>
<tr class="memdesc:a8e2070e8f6cefa124d05004387fd2344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the group. <br /></td></tr>
<tr class="separator:a8e2070e8f6cefa124d05004387fd2344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed2a0772f96a7556b0c4bab081fefd8" id="r_afed2a0772f96a7556b0c4bab081fefd8"><td class="memItemLeft" align="right" valign="top"><a id="afed2a0772f96a7556b0c4bab081fefd8" name="afed2a0772f96a7556b0c4bab081fefd8"></a>
Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1ModelEvaluator.html">::Thyra::ModelEvaluator</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getModel</b> () const</td></tr>
<tr class="separator:afed2a0772f96a7556b0c4bab081fefd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54669b35899864e4866ba925e6dd4bb8" id="r_a54669b35899864e4866ba925e6dd4bb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#a54669b35899864e4866ba925e6dd4bb8">enablePseudoTransientTerms</a> (const Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1VectorBase.html">::Thyra::VectorBase</a>&lt; double &gt; &gt; &amp;x_dot, const double alpha, const double beta, const double t)</td></tr>
<tr class="memdesc:a54669b35899864e4866ba925e6dd4bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the transient terms on the <a class="el" href="classNOX_1_1Thyra_1_1Group.html" title="A concrete implementation of the NOX::Abstract::Group using Thyra.">Group</a> and use them in the underlying evalModelImpl() calls.  <br /></td></tr>
<tr class="separator:a54669b35899864e4866ba925e6dd4bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd44d8301e9a985c278ea150517d2f1" id="r_a7fd44d8301e9a985c278ea150517d2f1"><td class="memItemLeft" align="right" valign="top"><a id="a7fd44d8301e9a985c278ea150517d2f1" name="a7fd44d8301e9a985c278ea150517d2f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>disablePseudoTransientTerms</b> ()</td></tr>
<tr class="memdesc:a7fd44d8301e9a985c278ea150517d2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the pseudo traansient terms in the underlying evalModel() calls. Sets x_dot, alpha, beta and t back to steady state values. <br /></td></tr>
<tr class="separator:a7fd44d8301e9a985c278ea150517d2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5427f68d6b4934ee10db59276b4d4e4a" id="r_a5427f68d6b4934ee10db59276b4d4e4a"><td class="memItemLeft" align="right" valign="top"><a id="a5427f68d6b4934ee10db59276b4d4e4a" name="a5427f68d6b4934ee10db59276b4d4e4a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>usingPseudoTransientTerms</b> () const</td></tr>
<tr class="memdesc:a5427f68d6b4934ee10db59276b4d4e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for whether the pseudo transient support is enabled for residual and Jacobian evaluations. <br /></td></tr>
<tr class="separator:a5427f68d6b4934ee10db59276b4d4e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8996bad1937aa5cb62ce04432e8560e4" id="r_a8996bad1937aa5cb62ce04432e8560e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Thyra_1_1Group.html#a8996bad1937aa5cb62ce04432e8560e4">setBasePoint</a> (const ::Thyra::ModelEvaluatorBase::InArgs&lt; double &gt; &amp;base_point_params)</td></tr>
<tr class="separator:a8996bad1937aa5cb62ce04432e8560e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad613b0acca40fb9756e92ad34f41ee0" id="r_aad613b0acca40fb9756e92ad34f41ee0"><td class="memItemLeft" align="right" valign="top"><a id="aad613b0acca40fb9756e92ad34f41ee0" name="aad613b0acca40fb9756e92ad34f41ee0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unsetBasePoint</b> ()</td></tr>
<tr class="memdesc:aad613b0acca40fb9756e92ad34f41ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unset the base point parameters so that they are not used internally. <br /></td></tr>
<tr class="separator:aad613b0acca40fb9756e92ad34f41ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33fcb7343bf36cd7253ebcca53974f0" id="r_ad33fcb7343bf36cd7253ebcca53974f0"><td class="memItemLeft" align="right" valign="top"><a id="ad33fcb7343bf36cd7253ebcca53974f0" name="ad33fcb7343bf36cd7253ebcca53974f0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>usingBasePoint</b> () const</td></tr>
<tr class="memdesc:ad33fcb7343bf36cd7253ebcca53974f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a base point has been set. <br /></td></tr>
<tr class="separator:ad33fcb7343bf36cd7253ebcca53974f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085f4340e2a1b67e709047de0300ad5d" id="r_a085f4340e2a1b67e709047de0300ad5d"><td class="memItemLeft" align="right" valign="top"><a id="a085f4340e2a1b67e709047de0300ad5d" name="a085f4340e2a1b67e709047de0300ad5d"></a>
Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1LinearOpWithSolveFactoryBase.html">::Thyra::LinearOpWithSolveFactoryBase</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getLinearOpWithSolveFactory</b> () const</td></tr>
<tr class="memdesc:a085f4340e2a1b67e709047de0300ad5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the thyra linear solver factory. <br /></td></tr>
<tr class="separator:a085f4340e2a1b67e709047de0300ad5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c3242cef9e8503aa1576e3f9f77601" id="r_a63c3242cef9e8503aa1576e3f9f77601"><td class="memItemLeft" align="right" valign="top"><a id="a63c3242cef9e8503aa1576e3f9f77601" name="a63c3242cef9e8503aa1576e3f9f77601"></a>
Teuchos::RCP&lt;<a class="el" href="classThyra_1_1PreconditionerFactoryBase.html">::Thyra::PreconditionerFactoryBase</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getPreconditionerFactory</b> () const</td></tr>
<tr class="memdesc:a63c3242cef9e8503aa1576e3f9f77601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the thyra preconditioner factory. <br /></td></tr>
<tr class="separator:a63c3242cef9e8503aa1576e3f9f77601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5d3063ea7b49bd5a5bcb1dfef323e9" id="r_ace5d3063ea7b49bd5a5bcb1dfef323e9"><td class="memItemLeft" align="right" valign="top"><a id="ace5d3063ea7b49bd5a5bcb1dfef323e9" name="ace5d3063ea7b49bd5a5bcb1dfef323e9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>takeControlOfPreconditionerUpdates</b> (const Teuchos::RCP&lt; <a class="el" href="classThyra_1_1PreconditionerBase.html">::Thyra::PreconditionerBase</a>&lt; double &gt; &gt; &amp;prec)</td></tr>
<tr class="memdesc:ace5d3063ea7b49bd5a5bcb1dfef323e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">User will take control of updating an already registered preconditioner. Typically used with <a class="el" href="classNOX_1_1ObserverReusePreconditioner.html" title="Observer that controls when to update the preconditioner for the Thyra interface.">NOX::ObserverReusePreconditioner</a> observer. <br /></td></tr>
<tr class="separator:ace5d3063ea7b49bd5a5bcb1dfef323e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd8635f911793823473f961b1e9dbd5" id="r_a1bd8635f911793823473f961b1e9dbd5"><td class="memItemLeft" align="right" valign="top"><a id="a1bd8635f911793823473f961b1e9dbd5" name="a1bd8635f911793823473f961b1e9dbd5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resetIsValidFlags</b> ()</td></tr>
<tr class="memdesc:a1bd8635f911793823473f961b1e9dbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">resets the isValid flags to false <br /></td></tr>
<tr class="separator:a1bd8635f911793823473f961b1e9dbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ead0b08b415ec9dc4dfa2d4c563f288" id="r_a3ead0b08b415ec9dc4dfa2d4c563f288"><td class="memItemLeft" align="right" valign="top"><a id="a3ead0b08b415ec9dc4dfa2d4c563f288" name="a3ead0b08b415ec9dc4dfa2d4c563f288"></a>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>applyJacobianInverseMultiVector</b> (Teuchos::ParameterList &amp;p, const <a class="el" href="classThyra_1_1MultiVectorBase.html">::Thyra::MultiVectorBase</a>&lt; double &gt; &amp;input, <a class="el" href="classThyra_1_1MultiVectorBase.html">::Thyra::MultiVectorBase</a>&lt; double &gt; &amp;result) const</td></tr>
<tr class="memdesc:a3ead0b08b415ec9dc4dfa2d4c563f288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply Jacobian inverse using <a class="el" href="namespaceNOX_1_1Thyra.html" title="NOX Thyra support.">Thyra</a> objects. <br /></td></tr>
<tr class="separator:a3ead0b08b415ec9dc4dfa2d4c563f288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4aff3d777b74c24d16caa6b4479bca" id="r_a5a4aff3d777b74c24d16caa6b4479bca"><td class="memItemLeft" align="right" valign="top"><a id="a5a4aff3d777b74c24d16caa6b4479bca" name="a5a4aff3d777b74c24d16caa6b4479bca"></a>
::Thyra::ESolveMeasureNormType&#160;</td><td class="memItemRight" valign="bottom"><b>getThyraNormType</b> (const std::string &amp;name) const</td></tr>
<tr class="separator:a5a4aff3d777b74c24d16caa6b4479bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bd1ccd5ee1d845b0c1348cb1cd2580" id="r_ac9bd1ccd5ee1d845b0c1348cb1cd2580"><td class="memItemLeft" align="right" valign="top"><a id="ac9bd1ccd5ee1d845b0c1348cb1cd2580" name="ac9bd1ccd5ee1d845b0c1348cb1cd2580"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateLOWS</b> () const</td></tr>
<tr class="memdesc:ac9bd1ccd5ee1d845b0c1348cb1cd2580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes LOWS to be a valid solver for the Jacobian. <br /></td></tr>
<tr class="separator:ac9bd1ccd5ee1d845b0c1348cb1cd2580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8df8e34f63b59ca233a146669073e58" id="r_ad8df8e34f63b59ca233a146669073e58"><td class="memItemLeft" align="right" valign="top"><a id="ad8df8e34f63b59ca233a146669073e58" name="ad8df8e34f63b59ca233a146669073e58"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scaleResidualAndJacobian</b> () const</td></tr>
<tr class="separator:ad8df8e34f63b59ca233a146669073e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32602f1a8b9e1b72e73ff06cb6379dfe" id="r_a32602f1a8b9e1b72e73ff06cb6379dfe"><td class="memItemLeft" align="right" valign="top"><a id="a32602f1a8b9e1b72e73ff06cb6379dfe" name="a32602f1a8b9e1b72e73ff06cb6379dfe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unscaleResidualAndJacobian</b> () const</td></tr>
<tr class="separator:a32602f1a8b9e1b72e73ff06cb6379dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1332486e22c168e92f335f3a98592ba" id="r_ab1332486e22c168e92f335f3a98592ba"><td class="memItemLeft" align="right" valign="top"><a id="ab1332486e22c168e92f335f3a98592ba" name="ab1332486e22c168e92f335f3a98592ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>computeScaledSolution</b> ()</td></tr>
<tr class="separator:ab1332486e22c168e92f335f3a98592ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classNOX_1_1Abstract_1_1Group"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classNOX_1_1Abstract_1_1Group')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classNOX_1_1Abstract_1_1Group.html">NOX::Abstract::Group</a></td></tr>
<tr class="memitem:aa17ab5aa51d466fd6f2d5dc361d5c217 inherit pub_types_classNOX_1_1Abstract_1_1Group" id="r_aa17ab5aa51d466fd6f2d5dc361d5c217"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">ReturnType</a> { <br />
&#160;&#160;<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068">Ok</a>
, <a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a302fd2d44af4090ac9615234349db91f">NotDefined</a>
, <a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a3724fc7881d6483aac6286e1832468c2">BadDependency</a>
, <a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217ae2a529a0ab7b662115a1a2ac809d6c92">NotConverged</a>
, <br />
&#160;&#160;<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a68d385c7e85322afedcc9d4567a25f40">Failed</a>
<br />
 }</td></tr>
<tr class="memdesc:aa17ab5aa51d466fd6f2d5dc361d5c217"><td class="mdescLeft">&#160;</td><td class="mdescRight">The computation of, say, the Newton direction in <a class="el" href="classNOX_1_1Abstract_1_1Group.html#a0ea79dfbca4bb39b408bc472bcd8853e" title="Compute the Newton direction, using parameters for the linear solve.">computeNewton()</a> may fail in many different ways, so we have included a variety of return codes to describe the failures. Of course, we also have a code for success.  <a href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">More...</a><br /></td></tr>
<tr class="separator:aa17ab5aa51d466fd6f2d5dc361d5c217 inherit pub_types_classNOX_1_1Abstract_1_1Group"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A concrete implementation of the <a class="el" href="classNOX_1_1Abstract_1_1Group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F-vector,...">NOX::Abstract::Group</a> using <a class="el" href="namespaceNOX_1_1Thyra.html" title="NOX Thyra support.">Thyra</a>. </p>
<p>NOTE: This <a class="el" href="classNOX_1_1Thyra_1_1Group.html" title="A concrete implementation of the NOX::Abstract::Group using Thyra.">Group</a> supports row sum scaling of the function (residual and Jacobian). This is enabled by setting a weight vector on the initial guess vector in the <a class="el" href="classNOX_1_1Thyra_1_1Group.html" title="A concrete implementation of the NOX::Abstract::Group using Thyra.">Group</a> constructor. The residual and Jacobian must be scaled before and then unscaled after calls to construct the preconditioner and solve the linear system. This follows the nox epetra group. This design should be changed in a future nox refactor, but requires significant changes to the <a class="el" href="classNOX_1_1Thyra_1_1Group.html" title="A concrete implementation of the NOX::Abstract::Group using Thyra.">Group</a> object. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaaa6e80d0835dbf20391d0109277f528" name="aaaa6e80d0835dbf20391d0109277f528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa6e80d0835dbf20391d0109277f528">&#9670;&#160;</a></span>Group() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NOX::Thyra::Group::Group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNOX_1_1Thyra_1_1Vector.html">NOX::Thyra::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>initialGuess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1ModelEvaluator.html">::Thyra::ModelEvaluator</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1VectorBase.html">::Thyra::VectorBase</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>weightVector</em> = <code>Teuchos::null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1VectorBase.html">::Thyra::VectorBase</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rightWeightVector</em> = <code>Teuchos::null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::RCP&lt;<a class="el" href="classThyra_1_1VectorBase.html">::Thyra::VectorBase</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_rightWeightVector</em> = <code>Teuchos::null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>rightScalingFirst</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default constructor that uses the linear solver from the ModelEvaluator. </p>
<p>Most users should use this constructor. It is meant to be used in conjunction with a stratimikos linear solver that is built as part of the input model evaluator. For finer grained control over the use of the preconditioner and for Jacobian-Free Newton-Krylov cases, the power user constructor should be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">initialGuess</td><td>Initial guess for the solution vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>ModelEvaluator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weightVector</td><td>Optional diagonal weighting vector for the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rightWeightVector</td><td>Optional solution vector weighting </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inv_rightWeightVector</td><td>Optional inverse solution vector weighting </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rightScalingFirst</td><td>Optional bool to select if right scaling should be applied before left scaling </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespaceNOX.html#a053a1ab5b2b3bd9546883b949142c592af22ab6417594618436dfab3f95f98261">NOX::DeepCopy</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#addb658fede2093f47cfeb967e7aef398">f_vec_</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a4ed9f729edc671909bda0bbc04c2ea68">gradient_vec_</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a2ddf605880d6c0eb735ea2bd2e2bdbee">inv_right_weight_vec_</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a43c9efd44a2cb6932cf2d8702da0ecff">lop_</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#aed3f9ae401cbeea2bf5be964afd72e46">losb_</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a145eee12fd36e3bfc66d2eaa16b0b87a">lows_factory_</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#af8ce389db8ebf1cdac07839a617cb64b">newton_vec_</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a8d13fc6bde1c4bbe6cdcd740ff335c5f">prec_</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a521421339690059473e9a418ff2e3f9e">prec_factory_</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a1bd8635f911793823473f961b1e9dbd5">resetIsValidFlags()</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a9937bc0c654ecc33160f714904dbbe9d">right_weight_vec_</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#aa0d2f6a5bfa0cf096f80d4d74d0f387c">rightScalingFirst_</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a66f279ab32e8524880d0c159aaabed9a">scaled_x_vec_</a>, <a class="el" href="namespaceNOX.html#a053a1ab5b2b3bd9546883b949142c592a9e3ccd93557182819f2dbc8d7f5c7dee">NOX::ShapeCopy</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#abb3771b31b751f9d8e68d033fcbbdd0d">shared_jacobian_</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#aa0cf912ca40f1623d2ced6873917f52f">weight_vec_</a>, and <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a9845a8449218b0e04dc62197ab15c0c2">x_vec_</a>.</p>

</div>
</div>
<a id="a4619a2a8be71bd87ebce47e3517a14b1" name="a4619a2a8be71bd87ebce47e3517a14b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4619a2a8be71bd87ebce47e3517a14b1">&#9670;&#160;</a></span>Group() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NOX::Thyra::Group::Group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNOX_1_1Thyra_1_1Vector.html">NOX::Thyra::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>initialGuess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1ModelEvaluator.html">::Thyra::ModelEvaluator</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::RCP&lt; <a class="el" href="classThyra_1_1LinearOpBase.html">::Thyra::LinearOpBase</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>linearOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1LinearOpWithSolveFactoryBase.html">::Thyra::LinearOpWithSolveFactoryBase</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>lowsFactory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::RCP&lt; <a class="el" href="classThyra_1_1PreconditionerBase.html">::Thyra::PreconditionerBase</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>precOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::RCP&lt; <a class="el" href="classThyra_1_1PreconditionerFactoryBase.html">::Thyra::PreconditionerFactoryBase</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>precFactory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1VectorBase.html">::Thyra::VectorBase</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>weightVector</em> = <code>Teuchos::null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1VectorBase.html">::Thyra::VectorBase</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rightWeightVector</em> = <code>Teuchos::null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::RCP&lt;<a class="el" href="classThyra_1_1VectorBase.html">::Thyra::VectorBase</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_rightWeightVector</em> = <code>Teuchos::null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>rightScalingFirst</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>updatePreconditioner</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>jacobianIsEvaluated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Power user constructor that takes explicit linear solver objects to handle different combinations. </p>
<p>This class allows the user to set user-defined linear operators and preconditioners (and corresponding factories). The user can set the linear_op to be a Jacobian-Free Newton Krylov operator (use the class <a class="el" href="classNOX_1_1Thyra_1_1MatrixFreeJacobianOperator.html" title="Concrete implementation of a Thyra::LinearOpBase object that approximates a Jacobian operator based o...">NOX::Thyra::MatrixFreeJacobianOperator</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">initialGuess</td><td>(Required) Initial guess for the solution vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>(Required) ModelEvaluator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">linearOp</td><td>(Optional) Forward operator for the Jacobian. Must be non-null for Newton-based solvers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lowsFactory</td><td>(Optional) Factory for building and updating linear solver. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precOp</td><td>(Optional) Preconditioner operator. If set to Teuchos::null and a non-null prec_factory exists, the prec_op will be constructed using the preconditioner factory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precFactory</td><td>(Optional) Factory for updating the precondiitoner. If set to Teuchos::null and there is a non-null prec_op, then the preconditioner will be updated using the model evaluator as long as the ModelEvaluator::outArgs supports W_prec. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weightVector</td><td>(Optional) diagonal weighting vector for the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rightWeightVector</td><td>Optional solution vector weighting </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inv_rightWeightVector</td><td>Optional inverse solution vector weighting </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rightScalingFirst</td><td>Optional bool to select if right scaling should be applied before left scaling </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">updatePreconditioner</td><td>Optional bool to select if the <a class="el" href="classNOX_1_1Thyra_1_1Group.html" title="A concrete implementation of the NOX::Abstract::Group using Thyra.">Group</a> should auotmatically update the preconditioner matrix values between Newton iterations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">jacobianIsEvaluated</td><td>Optional bool, if true this means that the input Jacobian operator (linearOp) has been evaluated externally and is consistent with the initialGuess. In this case, the <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a597d0c628e70d5f0777a416786d58837" title="Return true if the Jacobian is valid.">isJacobian()</a> flag is initialized to true. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespaceNOX.html#a053a1ab5b2b3bd9546883b949142c592af22ab6417594618436dfab3f95f98261">NOX::DeepCopy</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#addb658fede2093f47cfeb967e7aef398">f_vec_</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a4ed9f729edc671909bda0bbc04c2ea68">gradient_vec_</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a2ddf605880d6c0eb735ea2bd2e2bdbee">inv_right_weight_vec_</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a43c9efd44a2cb6932cf2d8702da0ecff">lop_</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#aed3f9ae401cbeea2bf5be964afd72e46">losb_</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a145eee12fd36e3bfc66d2eaa16b0b87a">lows_factory_</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#af8ce389db8ebf1cdac07839a617cb64b">newton_vec_</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a8d13fc6bde1c4bbe6cdcd740ff335c5f">prec_</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a521421339690059473e9a418ff2e3f9e">prec_factory_</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a1bd8635f911793823473f961b1e9dbd5">resetIsValidFlags()</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a9937bc0c654ecc33160f714904dbbe9d">right_weight_vec_</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#aa0d2f6a5bfa0cf096f80d4d74d0f387c">rightScalingFirst_</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a66f279ab32e8524880d0c159aaabed9a">scaled_x_vec_</a>, <a class="el" href="namespaceNOX.html#a053a1ab5b2b3bd9546883b949142c592a9e3ccd93557182819f2dbc8d7f5c7dee">NOX::ShapeCopy</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#abb3771b31b751f9d8e68d033fcbbdd0d">shared_jacobian_</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#aa0cf912ca40f1623d2ced6873917f52f">weight_vec_</a>, and <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a9845a8449218b0e04dc62197ab15c0c2">x_vec_</a>.</p>

</div>
</div>
<a id="afe12d16061856e041389248a1fb901a7" name="afe12d16061856e041389248a1fb901a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe12d16061856e041389248a1fb901a7">&#9670;&#160;</a></span>~Group()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NOX::Thyra::Group::~Group </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Reimplemented from <a class="el" href="classNOX_1_1Abstract_1_1Group.html#a1e6fd1bfff8659f64b0000b6c3e64134">NOX::Abstract::Group</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4e72dd7baf41a2c83fb65fd5d30e86bb" name="a4e72dd7baf41a2c83fb65fd5d30e86bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e72dd7baf41a2c83fb65fd5d30e86bb">&#9670;&#160;</a></span>applyJacobian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a> NOX::Thyra::Group::applyJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies Jacobian to the given input vector and puts the answer in the result. </p>
<p>Computes </p><p class="formulaDsp">
<picture><source srcset="form_13_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[ v = J u, \]" src="form_13.png" width="41" height="13"/></picture>
</p>
<p> where <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ J$" src="form_4.png" width="8" height="10"/></picture> is the Jacobian, <picture><source srcset="form_14_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ u$" src="form_14.png" width="9" height="6"/></picture> is the input vector, and <picture><source srcset="form_15_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ v$" src="form_15.png" width="8" height="6"/></picture> is the result vector.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a302fd2d44af4090ac9615234349db91f" title="This function is not implemented.">NOX::Abstract::Group::NotDefined</a> - Returned by default implementation in <a class="el" href="classNOX_1_1Abstract_1_1Group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F-vector,...">NOX::Abstract::Group</a> </li>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a3724fc7881d6483aac6286e1832468c2" title="Data dependencies not satisfied.">NOX::Abstract::Group::BadDependency</a> - If the Jacobian <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ J$" src="form_4.png" width="8" height="10"/></picture> has not been computed </li>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a68d385c7e85322afedcc9d4567a25f40" title="Any other type of failure.">NOX::Abstract::Group::Failed</a> - If the computation fails </li>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068" title="Computation completed successfully.">NOX::Abstract::Group::Ok</a> - Otherwise </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="classNOX_1_1Abstract_1_1Group.html#a42998d8377e88b11b3c27fbd15aae422">NOX::Abstract::Group</a>.</p>

</div>
</div>
<a id="a591ca60a7e9414e06df5492bd37074e2" name="a591ca60a7e9414e06df5492bd37074e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591ca60a7e9414e06df5492bd37074e2">&#9670;&#160;</a></span>applyJacobianInverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a> NOX::Thyra::Group::applyJacobianInverse </td>
          <td>(</td>
          <td class="paramtype">Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the inverse of the Jacobian matrix to the given input vector and puts the answer in result. </p>
<p>Computes </p><p class="formulaDsp">
<picture><source srcset="form_17_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[ v = J^{-1} u, \]" src="form_17.png" width="55" height="15"/></picture>
</p>
<p> where <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ J$" src="form_4.png" width="8" height="10"/></picture> is the Jacobian, <picture><source srcset="form_14_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ u$" src="form_14.png" width="9" height="6"/></picture> is the input vector, and <picture><source srcset="form_15_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ v$" src="form_15.png" width="8" height="6"/></picture> is the result vector.</p>
<p>The "Tolerance" parameter specifies that the solution should be such that  </p><p class="formulaDsp">
<picture><source srcset="form_18_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\frac{\| J v - u \|_2}{\max \{ 1, \|u\|_2\} } &lt; \mbox{Tolerance}
\]" src="form_18.png" width="145" height="31"/></picture>
</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a302fd2d44af4090ac9615234349db91f" title="This function is not implemented.">NOX::Abstract::Group::NotDefined</a> - Returned by default implementation in <a class="el" href="classNOX_1_1Abstract_1_1Group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F-vector,...">NOX::Abstract::Group</a> </li>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a3724fc7881d6483aac6286e1832468c2" title="Data dependencies not satisfied.">NOX::Abstract::Group::BadDependency</a> - If <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ J$" src="form_4.png" width="8" height="10"/></picture> has not been computed </li>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217ae2a529a0ab7b662115a1a2ac809d6c92" title="Unable to satisfy convergence criteria.">NOX::Abstract::Group::NotConverged</a> - If the linear solve fails to satisfy the "Tolerance" specified in <code>params</code> </li>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a68d385c7e85322afedcc9d4567a25f40" title="Any other type of failure.">NOX::Abstract::Group::Failed</a> - If the computation fails </li>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068" title="Computation completed successfully.">NOX::Abstract::Group::Ok</a> - Otherwise </li>
</ul>
</dd></dl>
<p>The parameter "Tolerance" may be added/modified in the list of parameters - this is the ideal solution tolerance for an iterative linear solve. </p>

<p>Reimplemented from <a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa85242fccabcfe99c6cb66b07a7e57eb">NOX::Abstract::Group</a>.</p>

</div>
</div>
<a id="a8df36b427b54d34b527cd9e53c4dfffe" name="a8df36b427b54d34b527cd9e53c4dfffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df36b427b54d34b527cd9e53c4dfffe">&#9670;&#160;</a></span>applyJacobianInverseMultiVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a> NOX::Thyra::Group::applyJacobianInverseMultiVector </td>
          <td>(</td>
          <td class="paramtype">Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNOX_1_1Abstract_1_1MultiVector.html">NOX::Abstract::MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNOX_1_1Abstract_1_1MultiVector.html">NOX::Abstract::MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>applyJacobianInverse for multiple right-hand sides </p>
<p>The default implementation here calls <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a591ca60a7e9414e06df5492bd37074e2" title="Applies the inverse of the Jacobian matrix to the given input vector and puts the answer in result.">applyJacobianInverse()</a> for each right hand side serially but should be overloaded if a block solver is available. </p>

<p>Reimplemented from <a class="el" href="classNOX_1_1Abstract_1_1Group.html#ab9b1d35a67e37becccd069b29dc99af2">NOX::Abstract::Group</a>.</p>

<p class="reference">References <a class="el" href="classNOX_1_1Thyra_1_1MultiVector.html#a9129c5b02881005a4729af04ffd996e6">NOX::Thyra::MultiVector::getThyraMultiVector()</a>.</p>

</div>
</div>
<a id="ac176d23981d8fee9258a840dd5d9e3d2" name="ac176d23981d8fee9258a840dd5d9e3d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac176d23981d8fee9258a840dd5d9e3d2">&#9670;&#160;</a></span>applyJacobianMultiVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a> NOX::Thyra::Group::applyJacobianMultiVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNOX_1_1Abstract_1_1MultiVector.html">NOX::Abstract::MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNOX_1_1Abstract_1_1MultiVector.html">NOX::Abstract::MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>applyJacobian for multiple right-hand sides </p>
<p>The default implementation here calls <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a4e72dd7baf41a2c83fb65fd5d30e86bb" title="Applies Jacobian to the given input vector and puts the answer in the result.">applyJacobian()</a> for each right hand side serially but should be overloaded if a block method is available. </p>

<p>Reimplemented from <a class="el" href="classNOX_1_1Abstract_1_1Group.html#a1bd8117c1a5bb2ebd6061176b4e75444">NOX::Abstract::Group</a>.</p>

<p class="reference">References <a class="el" href="classNOX_1_1Thyra_1_1MultiVector.html#a9129c5b02881005a4729af04ffd996e6">NOX::Thyra::MultiVector::getThyraMultiVector()</a>, and <a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068">NOX::Abstract::Group::Ok</a>.</p>

</div>
</div>
<a id="a945d4022986d44d8fc9b62e9d6521a60" name="a945d4022986d44d8fc9b62e9d6521a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945d4022986d44d8fc9b62e9d6521a60">&#9670;&#160;</a></span>applyJacobianTranspose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a> NOX::Thyra::Group::applyJacobianTranspose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies Jacobian-Transpose to the given input vector and puts the answer in the result. </p>
<p>Computes </p><p class="formulaDsp">
<picture><source srcset="form_16_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[ v = J^T u, \]" src="form_16.png" width="50" height="15"/></picture>
</p>
<p> where <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ J$" src="form_4.png" width="8" height="10"/></picture> is the Jacobian, <picture><source srcset="form_14_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ u$" src="form_14.png" width="9" height="6"/></picture> is the input vector, and <picture><source srcset="form_15_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ v$" src="form_15.png" width="8" height="6"/></picture> is the result vector.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a302fd2d44af4090ac9615234349db91f" title="This function is not implemented.">NOX::Abstract::Group::NotDefined</a> - Returned by default implementation in <a class="el" href="classNOX_1_1Abstract_1_1Group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F-vector,...">NOX::Abstract::Group</a> </li>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a3724fc7881d6483aac6286e1832468c2" title="Data dependencies not satisfied.">NOX::Abstract::Group::BadDependency</a> - If <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ J$" src="form_4.png" width="8" height="10"/></picture> has not been computed </li>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a68d385c7e85322afedcc9d4567a25f40" title="Any other type of failure.">NOX::Abstract::Group::Failed</a> - If the computation fails </li>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068" title="Computation completed successfully.">NOX::Abstract::Group::Ok</a> - Otherwise </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="classNOX_1_1Abstract_1_1Group.html#a47d4233c05cc25501a3e2d3d8b5b942a">NOX::Abstract::Group</a>.</p>

</div>
</div>
<a id="a98de0a9bce446cee6a15b7cbc124fb93" name="a98de0a9bce446cee6a15b7cbc124fb93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98de0a9bce446cee6a15b7cbc124fb93">&#9670;&#160;</a></span>applyJacobianTransposeMultiVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a> NOX::Thyra::Group::applyJacobianTransposeMultiVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNOX_1_1Abstract_1_1MultiVector.html">NOX::Abstract::MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNOX_1_1Abstract_1_1MultiVector.html">NOX::Abstract::MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>applyJacobianTranspose for multiple right-hand sides </p>
<p>The default implementation here calls <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a945d4022986d44d8fc9b62e9d6521a60" title="Applies Jacobian-Transpose to the given input vector and puts the answer in the result.">applyJacobianTranspose()</a> for each right hand side serially but should be overloaded if a block method is available. </p>

<p>Reimplemented from <a class="el" href="classNOX_1_1Abstract_1_1Group.html#ac7432c61b8987bb060d0165d26a96e79">NOX::Abstract::Group</a>.</p>

<p class="reference">References <a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a68d385c7e85322afedcc9d4567a25f40">NOX::Abstract::Group::Failed</a>, <a class="el" href="classNOX_1_1Thyra_1_1MultiVector.html#a9129c5b02881005a4729af04ffd996e6">NOX::Thyra::MultiVector::getThyraMultiVector()</a>, and <a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068">NOX::Abstract::Group::Ok</a>.</p>

</div>
</div>
<a id="af9b10e40c5d7703952a75f41d8d7631e" name="af9b10e40c5d7703952a75f41d8d7631e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b10e40c5d7703952a75f41d8d7631e">&#9670;&#160;</a></span>applyRightPreconditioning()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a> NOX::Thyra::Group::applyRightPreconditioning </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useTranspose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply right preconditiong to the given input vector. </p>
<p>Let <picture><source srcset="form_19_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ M$" src="form_19.png" width="14" height="10"/></picture> be a right preconditioner for the Jacobian <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ J$" src="form_4.png" width="8" height="10"/></picture>; in other words, <picture><source srcset="form_19_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ M$" src="form_19.png" width="14" height="10"/></picture> is a matrix such that </p><p class="formulaDsp">
<picture><source srcset="form_20_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[ JM \approx I. \]" src="form_20.png" width="46" height="10"/></picture>
</p>
<p>Compute </p><p class="formulaDsp">
<picture><source srcset="form_21_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[ u = M^{-1} v, \]" src="form_21.png" width="61" height="15"/></picture>
</p>
<p> where <picture><source srcset="form_14_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ u$" src="form_14.png" width="9" height="6"/></picture> is the input vector and <picture><source srcset="form_15_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ v$" src="form_15.png" width="8" height="6"/></picture> is the result vector.</p>
<p>If <em>useTranspose</em> is true, then the transpose of the preconditioner is applied: </p><p class="formulaDsp">
<picture><source srcset="form_22_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[ u = {M^{-1}}^T v, \]" src="form_22.png" width="69" height="18"/></picture>
</p>
<p> The transpose preconditioner is currently only required for Tensor methods.</p>
<p>The "Tolerance" parameter specifies that the solution should be such that  </p><p class="formulaDsp">
<picture><source srcset="form_23_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\frac{\| M v - u \|_2}{\max \{ 1, \|u\|_2\} } &lt; \mbox{Tolerance}
\]" src="form_23.png" width="145" height="31"/></picture>
</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a302fd2d44af4090ac9615234349db91f" title="This function is not implemented.">NOX::Abstract::Group::NotDefined</a> - Returned by default implementation in <a class="el" href="classNOX_1_1Abstract_1_1Group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F-vector,...">NOX::Abstract::Group</a> </li>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217ae2a529a0ab7b662115a1a2ac809d6c92" title="Unable to satisfy convergence criteria.">NOX::Abstract::Group::NotConverged</a> - If the linear solve fails to satisfy the "Tolerance" specified in <code>params</code> </li>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a68d385c7e85322afedcc9d4567a25f40" title="Any other type of failure.">NOX::Abstract::Group::Failed</a> - If the computation fails </li>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068" title="Computation completed successfully.">NOX::Abstract::Group::Ok</a> - Otherwise </li>
</ul>
</dd></dl>
<p>The parameters are from the "Linear %Solver" sublist of the "Direction" sublist that is passed to solver during construction. </p>

<p>Reimplemented from <a class="el" href="classNOX_1_1Abstract_1_1Group.html#a154e8547559b81b77027cd98b927582a">NOX::Abstract::Group</a>.</p>

<p class="reference">References <a class="el" href="classNOX_1_1Thyra_1_1Vector.html#ad85f932a79d8b6fac8d53c46fbbb32a0">NOX::Thyra::Vector::getThyraRCPVector()</a>, and <a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068">NOX::Abstract::Group::Ok</a>.</p>

</div>
</div>
<a id="aa181cac89743f77556086ce2bd5acec5" name="aa181cac89743f77556086ce2bd5acec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa181cac89743f77556086ce2bd5acec5">&#9670;&#160;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; <a class="el" href="classNOX_1_1Abstract_1_1Group.html">NOX::Abstract::Group</a> &gt; NOX::Thyra::Group::clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceNOX.html#a053a1ab5b2b3bd9546883b949142c592">NOX::CopyType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="namespaceNOX.html#a053a1ab5b2b3bd9546883b949142c592af22ab6417594618436dfab3f95f98261">NOX::DeepCopy</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new Group of the same derived type as this one by cloning this one, and return a ref count pointer to the new group. </p>
<p>If type is <a class="el" href="namespaceNOX.html#a053a1ab5b2b3bd9546883b949142c592af22ab6417594618436dfab3f95f98261" title="Copy object including all data.">NOX::DeepCopy</a>, then we need to create an exact replica of "this". Otherwise, if type is <a class="el" href="namespaceNOX.html#a053a1ab5b2b3bd9546883b949142c592a9e3ccd93557182819f2dbc8d7f5c7dee" title="Copy the shape of the object only.">NOX::ShapeCopy</a>, we need only replicate the shape of "this" (only the memory is allocated, the values are not copied into the vectors and Jacobian). Returns NULL if clone is not supported.</p>
<dl class="section note"><dt>Note</dt><dd>Any <em>shared data</em> should have its ownership transfered to this group from the source for a <a class="el" href="namespaceNOX.html#a053a1ab5b2b3bd9546883b949142c592af22ab6417594618436dfab3f95f98261" title="Copy object including all data.">NOX::DeepCopy</a>. </dd></dl>

<p>Implements <a class="el" href="classNOX_1_1Abstract_1_1Group.html#a09c8db18731ba80e5d656f77b697eb17">NOX::Abstract::Group</a>.</p>

<p>Reimplemented in <a class="el" href="classLOCA_1_1Thyra_1_1Group.html#a3f972dc2c5ee7aace64a5635fa4f6756">LOCA::Thyra::Group</a>, and <a class="el" href="classLOCA_1_1Thyra_1_1GroupWrapper.html#a0bd2edec586088f6b93425d3cf2046e9">LOCA::Thyra::GroupWrapper</a>.</p>

</div>
</div>
<a id="a77844a29d5f6a02d95ab294f48a259bd" name="a77844a29d5f6a02d95ab294f48a259bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77844a29d5f6a02d95ab294f48a259bd">&#9670;&#160;</a></span>computeF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a> NOX::Thyra::Group::computeF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute and store F(x). </p>
<dl class="section note"><dt>Note</dt><dd>It's generally useful to also compute and store the 2-norm of F(x) at this point for later access by the <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a12199ef815edc33b11e9e3cf38a9fab5" title="Return 2-norm of F(x).">getNormF()</a> function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a68d385c7e85322afedcc9d4567a25f40" title="Any other type of failure.">NOX::Abstract::Group::Failed</a> - If the computation fails in any way </li>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068" title="Computation completed successfully.">NOX::Abstract::Group::Ok</a> - Otherwise </li>
</ul>
</dd></dl>

<p>Implements <a class="el" href="classNOX_1_1Abstract_1_1Group.html#afb0a17ceea78a12923bb9932fb0c7182">NOX::Abstract::Group</a>.</p>

<p class="reference">References <a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a68d385c7e85322afedcc9d4567a25f40">NOX::Abstract::Group::Failed</a>, and <a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068">NOX::Abstract::Group::Ok</a>.</p>

</div>
</div>
<a id="aebf0ee549de9fd7b013be91200f87290" name="aebf0ee549de9fd7b013be91200f87290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf0ee549de9fd7b013be91200f87290">&#9670;&#160;</a></span>computeGradient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a> NOX::Thyra::Group::computeGradient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute and store gradient. </p>
<p>We can pose the nonlinear equation problem <picture><source srcset="form_6_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F(x) = 0$" src="form_6.png" width="49" height="14"/></picture> as an optimization problem as follows:  </p><p class="formulaDsp">
<picture><source srcset="form_7_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\min f(x) \equiv \frac{1}{2} \|F(x)\|_2^2.
\]" src="form_7.png" width="121" height="26"/></picture>
</p>
<p>In that case, the <b>gradient</b> (of <picture><source srcset="form_8_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ f$" src="form_8.png" width="8" height="13"/></picture>) is defined as  </p><p class="formulaDsp">
<picture><source srcset="form_9_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
g \equiv J^T F.
\]" src="form_9.png" width="50" height="15"/></picture>
</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a302fd2d44af4090ac9615234349db91f" title="This function is not implemented.">NOX::Abstract::Group::NotDefined</a> - Returned by default implementation in <a class="el" href="classNOX_1_1Abstract_1_1Group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F-vector,...">NOX::Abstract::Group</a> </li>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a3724fc7881d6483aac6286e1832468c2" title="Data dependencies not satisfied.">NOX::Abstract::Group::BadDependency</a> - If either <picture><source srcset="form_10_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F$" src="form_10.png" width="10" height="10"/></picture> or <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ J$" src="form_4.png" width="8" height="10"/></picture> has not been computed </li>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a68d385c7e85322afedcc9d4567a25f40" title="Any other type of failure.">NOX::Abstract::Group::Failed</a> - If the computation fails in any other way </li>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068" title="Computation completed successfully.">NOX::Abstract::Group::Ok</a> - Otherwise </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="classNOX_1_1Abstract_1_1Group.html#a469ffcb3439a045b386c4ee2f3e8b9ec">NOX::Abstract::Group</a>.</p>

<p class="reference">References <a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a68d385c7e85322afedcc9d4567a25f40">NOX::Abstract::Group::Failed</a>.</p>

</div>
</div>
<a id="aeedffa57479128c777f78565902215a1" name="aeedffa57479128c777f78565902215a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeedffa57479128c777f78565902215a1">&#9670;&#160;</a></span>computeJacobian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a> NOX::Thyra::Group::computeJacobian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute and store Jacobian. </p>
<p>Recall that  </p><p class="formulaDsp">
<picture><source srcset="form_3_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
F(x) = \left[ \begin{array}{c} F_1(x) \\ F_2(x) \\ \vdots \\ F_n(x) \\ \end{array} \right].
\]" src="form_3.png" width="109" height="68"/></picture>
</p>
<p>The <b>Jacobian</b> is denoted by <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ J$" src="form_4.png" width="8" height="10"/></picture> and defined by  </p><p class="formulaDsp">
<picture><source srcset="form_5_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
J_{ij} = \frac{\partial F_i}{\partial x_j} (x).
\]" src="form_5.png" width="74" height="31"/></picture>
</p>
<dl class="section note"><dt>Note</dt><dd>If this is a <em>shared object</em>, this group should take ownership of the Jacobian before it computes it.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a302fd2d44af4090ac9615234349db91f" title="This function is not implemented.">NOX::Abstract::Group::NotDefined</a> - Returned by default implementation in <a class="el" href="classNOX_1_1Abstract_1_1Group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F-vector,...">NOX::Abstract::Group</a> </li>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a68d385c7e85322afedcc9d4567a25f40" title="Any other type of failure.">NOX::Abstract::Group::Failed</a> - If the computation fails in any other way </li>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068" title="Computation completed successfully.">NOX::Abstract::Group::Ok</a> - Otherwise </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="classNOX_1_1Abstract_1_1Group.html#ab763d80297f77eb10c78e88ddb00df6b">NOX::Abstract::Group</a>.</p>

<p class="reference">References <a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a68d385c7e85322afedcc9d4567a25f40">NOX::Abstract::Group::Failed</a>, and <a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068">NOX::Abstract::Group::Ok</a>.</p>

</div>
</div>
<a id="a88722de7a732f0d8eb58c8e2d3461d62" name="a88722de7a732f0d8eb58c8e2d3461d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88722de7a732f0d8eb58c8e2d3461d62">&#9670;&#160;</a></span>computeNewton()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a> NOX::Thyra::Group::computeNewton </td>
          <td>(</td>
          <td class="paramtype">Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Newton direction, using parameters for the linear solve. </p>
<p>The <b>Newton direction</b> is the solution, s, of  </p><p class="formulaDsp">
<picture><source srcset="form_11_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
J s = -F.
\]" src="form_11.png" width="51" height="10"/></picture>
</p>
<p>The parameters are from the "Linear %Solver" sublist of the "Direction" sublist that is passed to solver during construction.</p>
<p>The "Tolerance" parameter may be added/modified in the sublist of "Linear Solver" parameters that is passed into this function. The solution should be such that  </p><p class="formulaDsp">
<picture><source srcset="form_12_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\frac{\| J s - (-F) \|_2}{\max \{ 1, \|F\|_2\} } &lt; \mbox{Tolerance}
\]" src="form_12.png" width="148" height="31"/></picture>
</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a302fd2d44af4090ac9615234349db91f" title="This function is not implemented.">NOX::Abstract::Group::NotDefined</a> - Returned by default implementation in <a class="el" href="classNOX_1_1Abstract_1_1Group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F-vector,...">NOX::Abstract::Group</a> </li>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a3724fc7881d6483aac6286e1832468c2" title="Data dependencies not satisfied.">NOX::Abstract::Group::BadDependency</a> - If either <picture><source srcset="form_10_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F$" src="form_10.png" width="10" height="10"/></picture> or <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ J$" src="form_4.png" width="8" height="10"/></picture> has not been computed </li>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217ae2a529a0ab7b662115a1a2ac809d6c92" title="Unable to satisfy convergence criteria.">NOX::Abstract::Group::NotConverged</a> - If the linear solve fails to satisfy the "Tolerance" specified in <code>params</code> </li>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a68d385c7e85322afedcc9d4567a25f40" title="Any other type of failure.">NOX::Abstract::Group::Failed</a> - If the computation fails in any other way </li>
<li>
<a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068" title="Computation completed successfully.">NOX::Abstract::Group::Ok</a> - Otherwise </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="classNOX_1_1Abstract_1_1Group.html#a0ea79dfbca4bb39b408bc472bcd8853e">NOX::Abstract::Group</a>.</p>

</div>
</div>
<a id="ad15ae6058f024d77c053f0745c3ef94e" name="ad15ae6058f024d77c053f0745c3ef94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15ae6058f024d77c053f0745c3ef94e">&#9670;&#160;</a></span>computeX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NOX::Thyra::Group::computeX </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNOX_1_1Abstract_1_1Group.html">NOX::Abstract::Group</a> &amp;&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute x = grp.x + step * d. </p>
<p>Let <picture><source srcset="form_0_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ x$" src="form_0.png" width="8" height="6"/></picture> denote this group's solution vector. Let <picture><source srcset="form_1_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat x$" src="form_1.png" width="8" height="10"/></picture> denote the result of grp.getX(). Then set  </p><p class="formulaDsp">
<picture><source srcset="form_2_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
x = \hat x + \mbox{step} \; d.
\]" src="form_2.png" width="81" height="13"/></picture>
</p>
<dl class="section note"><dt>Note</dt><dd>This should invalidate the function value, Jacobian, gradient, and Newton direction.</dd>
<dd>
Throw an error if the copy fails.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this object </dd></dl>

<p>Implements <a class="el" href="classNOX_1_1Abstract_1_1Group.html#a567a5000e48967e6bbbe59daae97ea9d">NOX::Abstract::Group</a>.</p>

</div>
</div>
<a id="a54669b35899864e4866ba925e6dd4bb8" name="a54669b35899864e4866ba925e6dd4bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54669b35899864e4866ba925e6dd4bb8">&#9670;&#160;</a></span>enablePseudoTransientTerms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NOX::Thyra::Group::enablePseudoTransientTerms </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::RCP&lt; const <a class="el" href="classThyra_1_1VectorBase.html">::Thyra::VectorBase</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_dot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the transient terms on the <a class="el" href="classNOX_1_1Thyra_1_1Group.html" title="A concrete implementation of the NOX::Abstract::Group using Thyra.">Group</a> and use them in the underlying evalModelImpl() calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x_dot</td><td>Time derivative term. Can be set to null. </td></tr>
    <tr><td class="paramname">alpha</td><td>Model evaluator transient timer derivative multiplier </td></tr>
    <tr><td class="paramname">beta</td><td>Model evaluator transient Jacobian multiplier </td></tr>
    <tr><td class="paramname">t</td><td>Current time value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79a7dbf42ce853a1a3125730b42d1d34" name="a79a7dbf42ce853a1a3125730b42d1d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a7dbf42ce853a1a3125730b42d1d34">&#9670;&#160;</a></span>getF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp; NOX::Thyra::Group::getF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return F(x) </p>

<p>Implements <a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa0674a7c4392da14f7b3fbd5ac7a0cce">NOX::Abstract::Group</a>.</p>

</div>
</div>
<a id="af3bd837d4798709dc85047e49f76691c" name="af3bd837d4798709dc85047e49f76691c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3bd837d4798709dc85047e49f76691c">&#9670;&#160;</a></span>getFPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &gt; NOX::Thyra::Group::getFPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return RCP to F(x) </p>

<p>Implements <a class="el" href="classNOX_1_1Abstract_1_1Group.html#a7bbe10d8111428bdf294f325e5cb7328">NOX::Abstract::Group</a>.</p>

</div>
</div>
<a id="aab77ba12a280f83bc68d52fdf5263fea" name="aab77ba12a280f83bc68d52fdf5263fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab77ba12a280f83bc68d52fdf5263fea">&#9670;&#160;</a></span>getGradient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp; NOX::Thyra::Group::getGradient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return gradient. </p>

<p>Implements <a class="el" href="classNOX_1_1Abstract_1_1Group.html#a1957fb41818e609bfa8056ab477eb7bb">NOX::Abstract::Group</a>.</p>

</div>
</div>
<a id="adeacd9d7a7814dcf570dce46e5e9d818" name="adeacd9d7a7814dcf570dce46e5e9d818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeacd9d7a7814dcf570dce46e5e9d818">&#9670;&#160;</a></span>getGradientPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &gt; NOX::Thyra::Group::getGradientPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return RCP to gradient. </p>

<p>Implements <a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa1ced5670425d8479d1114d819eaa0e7">NOX::Abstract::Group</a>.</p>

</div>
</div>
<a id="a22b26c367e55ad74d0d63f68d1c483fd" name="a22b26c367e55ad74d0d63f68d1c483fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b26c367e55ad74d0d63f68d1c483fd">&#9670;&#160;</a></span>getNewton()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp; NOX::Thyra::Group::getNewton </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return Newton direction. </p>

<p>Implements <a class="el" href="classNOX_1_1Abstract_1_1Group.html#a59d4d0197fcfdb40a14cf9972a03eba8">NOX::Abstract::Group</a>.</p>

</div>
</div>
<a id="afd53ba24dcd28cd0f03f9100ce53943b" name="afd53ba24dcd28cd0f03f9100ce53943b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd53ba24dcd28cd0f03f9100ce53943b">&#9670;&#160;</a></span>getNewtonPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &gt; NOX::Thyra::Group::getNewtonPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return RCP to Newton direction. </p>

<p>Implements <a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa7d5cce406fcedf0308b93b2af7e0628">NOX::Abstract::Group</a>.</p>

</div>
</div>
<a id="a12199ef815edc33b11e9e3cf38a9fab5" name="a12199ef815edc33b11e9e3cf38a9fab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12199ef815edc33b11e9e3cf38a9fab5">&#9670;&#160;</a></span>getNormF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double NOX::Thyra::Group::getNormF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 2-norm of F(x). </p>
<p>In other words, </p><p class="formulaDsp">
<picture><source srcset="form_24_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[ \sqrt{\sum_{i=1}^n F_i^2} \]" src="form_24.png" width="49" height="46"/></picture>
</p>
 
<p>Implements <a class="el" href="classNOX_1_1Abstract_1_1Group.html#a83eecd9cdbff67a78bf71df3d0816081">NOX::Abstract::Group</a>.</p>

</div>
</div>
<a id="a18e76d78aadab2276e404d00d8a7e44a" name="a18e76d78aadab2276e404d00d8a7e44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e76d78aadab2276e404d00d8a7e44a">&#9670;&#160;</a></span>getScaledX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp; NOX::Thyra::Group::getScaledX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If right scaling vector exist, return a right scaled vector. </p><dl class="section note"><dt>Note</dt><dd>Default to getX </dd></dl>

<p>Reimplemented from <a class="el" href="classNOX_1_1Abstract_1_1Group.html#a51a2c4535ce545f7dd575c2cd5d0036e">NOX::Abstract::Group</a>.</p>

</div>
</div>
<a id="a4655073b47be741677beac8994e324a2" name="a4655073b47be741677beac8994e324a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4655073b47be741677beac8994e324a2">&#9670;&#160;</a></span>getX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp; NOX::Thyra::Group::getX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return solution vector. </p>

<p>Implements <a class="el" href="classNOX_1_1Abstract_1_1Group.html#a1244ddbfb3fe8402ffb6a3c5a8d43c12">NOX::Abstract::Group</a>.</p>

</div>
</div>
<a id="aa9759acc62fbbeae442141619e8b8e8b" name="aa9759acc62fbbeae442141619e8b8e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9759acc62fbbeae442141619e8b8e8b">&#9670;&#160;</a></span>getXPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &gt; NOX::Thyra::Group::getXPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return RCP to solution vector. </p>

<p>Implements <a class="el" href="classNOX_1_1Abstract_1_1Group.html#a58dfd31d549181866b51d55050b714eb">NOX::Abstract::Group</a>.</p>

</div>
</div>
<a id="adea192c39bba4d224179cc3c85b4d07d" name="adea192c39bba4d224179cc3c85b4d07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea192c39bba4d224179cc3c85b4d07d">&#9670;&#160;</a></span>isF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NOX::Thyra::Group::isF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if F is valid. </p>

<p>Implements <a class="el" href="classNOX_1_1Abstract_1_1Group.html#aaa2f67073452aaee10f1120cd6d242a3">NOX::Abstract::Group</a>.</p>

</div>
</div>
<a id="aa1016ca595b660b41f8a63e4b36841dd" name="aa1016ca595b660b41f8a63e4b36841dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1016ca595b660b41f8a63e4b36841dd">&#9670;&#160;</a></span>isGradient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NOX::Thyra::Group::isGradient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the gradient is valid. </p>
<dl class="section note"><dt>Note</dt><dd>Default implementation in <a class="el" href="classNOX_1_1Abstract_1_1Group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F-vector,...">NOX::Abstract::Group</a> returns false. </dd></dl>

<p>Reimplemented from <a class="el" href="classNOX_1_1Abstract_1_1Group.html#acba82791d635dc87013ccb73a01124af">NOX::Abstract::Group</a>.</p>

</div>
</div>
<a id="a597d0c628e70d5f0777a416786d58837" name="a597d0c628e70d5f0777a416786d58837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a597d0c628e70d5f0777a416786d58837">&#9670;&#160;</a></span>isJacobian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NOX::Thyra::Group::isJacobian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the Jacobian is valid. </p>
<dl class="section note"><dt>Note</dt><dd>Default implementation in <a class="el" href="classNOX_1_1Abstract_1_1Group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F-vector,...">NOX::Abstract::Group</a> returns false. </dd></dl>

<p>Reimplemented from <a class="el" href="classNOX_1_1Abstract_1_1Group.html#a6ce6cf0e1662c0c7bf7c472739b7a8d1">NOX::Abstract::Group</a>.</p>

<p class="reference">Referenced by <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a15e3afc46d56980b1c4cb45c7a7599fe">Group()</a>.</p>

</div>
</div>
<a id="a4d3939cb79b59f7424911529814b98db" name="a4d3939cb79b59f7424911529814b98db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d3939cb79b59f7424911529814b98db">&#9670;&#160;</a></span>isNewton()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NOX::Thyra::Group::isNewton </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the Newton direction is valid. </p>
<dl class="section note"><dt>Note</dt><dd>Default implementation in <a class="el" href="classNOX_1_1Abstract_1_1Group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F-vector,...">NOX::Abstract::Group</a> returns false. </dd></dl>

<p>Reimplemented from <a class="el" href="classNOX_1_1Abstract_1_1Group.html#a2d5d349096006a09a74daee1a9a3886c">NOX::Abstract::Group</a>.</p>

</div>
</div>
<a id="a9f4b485ba28c0fea085a5de0adf7bc29" name="a9f4b485ba28c0fea085a5de0adf7bc29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4b485ba28c0fea085a5de0adf7bc29">&#9670;&#160;</a></span>logLastLinearSolveStats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NOX::Thyra::Group::logLastLinearSolveStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNOX_1_1SolverStats.html">NOX::SolverStats</a> &amp;&#160;</td>
          <td class="paramname"><em>stats</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds statistics from last linear solve to the SovlerStats object. </p>

<p>Reimplemented from <a class="el" href="classNOX_1_1Abstract_1_1Group.html#a42dddac0f4ed5d8633130ef3b4f1fe2e">NOX::Abstract::Group</a>.</p>

<p class="reference">References <a class="el" href="classNOX_1_1Abstract_1_1Group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068">NOX::Abstract::Group::Ok</a>.</p>

</div>
</div>
<a id="aedc115d416746eb7ddda266006a915e8" name="aedc115d416746eb7ddda266006a915e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc115d416746eb7ddda266006a915e8">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNOX_1_1Abstract_1_1Group.html">NOX::Abstract::Group</a> &amp; NOX::Thyra::Group::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNOX_1_1Abstract_1_1Group.html">NOX::Abstract::Group</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the source group into this group. </p>
<dl class="section note"><dt>Note</dt><dd>Any <em>shared data</em> owned by the source should have its ownership transfered to this group. This may result in a secret modification to the source object. </dd></dl>

<p>Implements <a class="el" href="classNOX_1_1Abstract_1_1Group.html#ab1e51369cc13c52c1f10fc66c34552e0">NOX::Abstract::Group</a>.</p>

<p>Reimplemented in <a class="el" href="classLOCA_1_1Thyra_1_1GroupWrapper.html#af67499dd6d4cbf6ae5393f1c3634f0bd">LOCA::Thyra::GroupWrapper</a>.</p>

<p class="reference">Referenced by <a class="el" href="classLOCA_1_1Thyra_1_1Group.html#a2cc0da6fef7407ff3d5e7bb063901b13">LOCA::Thyra::Group::operator=()</a>.</p>

</div>
</div>
<a id="a8996bad1937aa5cb62ce04432e8560e4" name="a8996bad1937aa5cb62ce04432e8560e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8996bad1937aa5cb62ce04432e8560e4">&#9670;&#160;</a></span>setBasePoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NOX::Thyra::Group::setBasePoint </td>
          <td>(</td>
          <td class="paramtype">const ::Thyra::ModelEvaluatorBase::InArgs&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>base_point_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set default parameters to be used with inArgs. This is a hack to support a bad design in PIRO. PIRO wraps nox as a model evaluator. The PIRO inArgs suppots all inargs, but nox only knows about nonlinear solver realted inputs. It knows nothing about parameters. PIRO should have a model evaluator wrapper that populates the extra inArgs as needed to override nominal values. Instead, we have to hard code storage of all in arg parameters in nox groups. This is only used in the <a class="el" href="classThyra_1_1NOXNonlinearSolver.html" title="Concrete nonlinear solver for NOX.">Thyra::NOXNonlinearSolver</a> and only when wrapped within a PIRO model evaluator that calls the setBasePoint on <a class="el" href="classThyra_1_1NOXNonlinearSolver.html" title="Concrete nonlinear solver for NOX.">Thyra::NOXNonlinearSolver</a>. This function should eventually be deprecated in favor of addign a wrapper ME to the piro nox solver class. </p>

</div>
</div>
<a id="abce50aac0aaafc4c74527ef86a43a194" name="abce50aac0aaafc4c74527ef86a43a194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce50aac0aaafc4c74527ef86a43a194">&#9670;&#160;</a></span>setX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NOX::Thyra::Group::setX </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNOX_1_1Abstract_1_1Vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the solution vector x to y. </p>
<dl class="section note"><dt>Note</dt><dd>This should invalidate the function value, Jacobian, gradient, and Newton direction.</dd>
<dd>
Throw an error if the copy fails.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this object </dd></dl>

<p>Implements <a class="el" href="classNOX_1_1Abstract_1_1Group.html#aebc79123e1828ad14e94ba88d724844e">NOX::Abstract::Group</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa0cf912ca40f1623d2ced6873917f52f" name="aa0cf912ca40f1623d2ced6873917f52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0cf912ca40f1623d2ced6873917f52f">&#9670;&#160;</a></span>weight_vec_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt;const <a class="el" href="classThyra_1_1VectorBase.html">::Thyra::VectorBase</a>&lt;double&gt; &gt; NOX::Thyra::Group::weight_vec_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optional wieghting vector for function scaling. <a class="el" href="namespaceNOX.html" title="Nonlinear solvers package namespace.">NOX</a> assumes that this vector can be updated in between nonlinear iterations. </p>
<p>This is pulled out of the initial guess vector </p>

<p class="reference">Referenced by <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a15e3afc46d56980b1c4cb45c7a7599fe">Group()</a>, <a class="el" href="classNOX_1_1Thyra_1_1Group.html#a4619a2a8be71bd87ebce47e3517a14b1">Group()</a>, and <a class="el" href="classNOX_1_1Thyra_1_1Group.html#aaaa6e80d0835dbf20391d0109277f528">Group()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><b>NOX_Thyra_Group.H</b></li>
<li><b>NOX_Thyra_Group.C</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 9 2025 20:46:02 for NOX by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
