<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NOX: NOX::ObserverReusePreconditioner Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">NOX<span id="projectnumber">&#160;Development</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_n_o_x.html">NOX</a></li><li class="navelem"><a class="el" href="class_n_o_x_1_1_observer_reuse_preconditioner.html">ObserverReusePreconditioner</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="class_n_o_x_1_1_observer_reuse_preconditioner-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">NOX::ObserverReusePreconditioner Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_n_o_x_1_1_observer.html" title="NOX&#39;s pure virtual class to allow users to insert user defined operations into nox&#39;s solvers (before ...">Observer</a> that controls when to update the preconditioner for the <a class="el" href="namespace_n_o_x_1_1_thyra.html" title="NOX Thyra support.">Thyra</a> interface.  
 <a href="class_n_o_x_1_1_observer_reuse_preconditioner.html#details">More...</a></p>

<p><code>#include &lt;NOX_Observer_ReusePreconditioner.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for NOX::ObserverReusePreconditioner:</div>
<div class="dyncontent">
<div class="center"><img src="class_n_o_x_1_1_observer_reuse_preconditioner__inherit__graph.gif" border="0" usemap="#a_n_o_x_1_1_observer_reuse_preconditioner_inherit__map" alt="Inheritance graph"/></div>
<map name="a_n_o_x_1_1_observer_reuse_preconditioner_inherit__map" id="a_n_o_x_1_1_observer_reuse_preconditioner_inherit__map">
<area shape="rect" title="Observer that controls when to update the preconditioner for the Thyra interface." alt="" coords="5,79,257,104"/>
<area shape="rect" href="class_n_o_x_1_1_observer.html" title="NOX&#39;s pure virtual class to allow users to insert user defined operations into nox&#39;s solvers (before ..." alt="" coords="72,5,191,31"/>
<area shape="poly" title=" " alt="" coords="134,44,134,79,129,79,129,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for NOX::ObserverReusePreconditioner:</div>
<div class="dyncontent">
<div class="center"><img src="class_n_o_x_1_1_observer_reuse_preconditioner__coll__graph.gif" border="0" usemap="#a_n_o_x_1_1_observer_reuse_preconditioner_coll__map" alt="Collaboration graph"/></div>
<map name="a_n_o_x_1_1_observer_reuse_preconditioner_coll__map" id="a_n_o_x_1_1_observer_reuse_preconditioner_coll__map">
<area shape="rect" title="Observer that controls when to update the preconditioner for the Thyra interface." alt="" coords="5,79,257,104"/>
<area shape="rect" href="class_n_o_x_1_1_observer.html" title="NOX&#39;s pure virtual class to allow users to insert user defined operations into nox&#39;s solvers (before ..." alt="" coords="72,5,191,31"/>
<area shape="poly" title=" " alt="" coords="134,44,134,79,129,79,129,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af2fd95bf54457ea9f9826114265129cc" id="r_af2fd95bf54457ea9f9826114265129cc"><td class="memItemLeft" align="right" valign="top"><a id="af2fd95bf54457ea9f9826114265129cc" name="af2fd95bf54457ea9f9826114265129cc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Scalar</b> = double</td></tr>
<tr class="separator:af2fd95bf54457ea9f9826114265129cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Initialization methods</div></td></tr>
<tr class="memitem:a3e899a4737ce74dff88e3e44ff1b018e" id="r_a3e899a4737ce74dff88e3e44ff1b018e"><td class="memItemLeft" align="right" valign="top"><a id="a3e899a4737ce74dff88e3e44ff1b018e" name="a3e899a4737ce74dff88e3e44ff1b018e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setOperatorsAndFactory</b> (const Teuchos::RCP&lt;<a class="el" href="class_thyra_1_1_preconditioner_base.html">::Thyra::PreconditionerBase</a>&lt; Scalar &gt; &gt; &amp;precOperator, const Teuchos::RCP&lt;<a class="el" href="class_thyra_1_1_preconditioner_factory_base.html">::Thyra::PreconditionerFactoryBase</a>&lt; Scalar &gt; &gt; &amp;precFactory)</td></tr>
<tr class="memdesc:a3e899a4737ce74dff88e3e44ff1b018e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup the preconditioner objects used to update the preconditioner. <br /></td></tr>
<tr class="separator:a3e899a4737ce74dff88e3e44ff1b018e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3ae499cee62802b478860d983d5fdb" id="r_adb3ae499cee62802b478860d983d5fdb"><td class="memItemLeft" align="right" valign="top"><a id="adb3ae499cee62802b478860d983d5fdb" name="adb3ae499cee62802b478860d983d5fdb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateAtStartOfSolve</b> ()</td></tr>
<tr class="memdesc:adb3ae499cee62802b478860d983d5fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables updating the preconditioner at the start of each nonlinear solve. <br /></td></tr>
<tr class="separator:adb3ae499cee62802b478860d983d5fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e2e14ac99431f26e1a6a7c87d28cab" id="r_ad0e2e14ac99431f26e1a6a7c87d28cab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_observer_reuse_preconditioner.html#ad0e2e14ac99431f26e1a6a7c87d28cab">updateAfterNNonlinearSolves</a> (const int num_nonlinear_solves_for_update, const bool reset_nonlinear_solve_count_on_failed_solve=true)</td></tr>
<tr class="memdesc:ad0e2e14ac99431f26e1a6a7c87d28cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables updating of the preconditioner after a set number of nonlinear solves.  <br /></td></tr>
<tr class="separator:ad0e2e14ac99431f26e1a6a7c87d28cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461160a82e2817716830233059186c48" id="r_a461160a82e2817716830233059186c48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_observer_reuse_preconditioner.html#a461160a82e2817716830233059186c48">updateAfterNIterations</a> (const int num_iterations_for_update)</td></tr>
<tr class="memdesc:a461160a82e2817716830233059186c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables updating of the preconditioner after a set number of nonlinear iterations.  <br /></td></tr>
<tr class="separator:a461160a82e2817716830233059186c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e26d573c28650dd62f61941a74b684" id="r_a27e26d573c28650dd62f61941a74b684"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_observer_reuse_preconditioner.html#a27e26d573c28650dd62f61941a74b684">updateOnLinearSolverStall</a> (const int max_linear_iterations, const int max_count)</td></tr>
<tr class="memdesc:a27e26d573c28650dd62f61941a74b684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables updating of preconditioner if the observer detects a stall or failure in the linear solver.  <br /></td></tr>
<tr class="separator:a27e26d573c28650dd62f61941a74b684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods derived from NOX::Observer</div></td></tr>
<tr class="memitem:a25ae278fa7ac53badd450ab6f1440a82" id="r_a25ae278fa7ac53badd450ab6f1440a82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_observer_reuse_preconditioner.html#a25ae278fa7ac53badd450ab6f1440a82">runPreSolve</a> (const <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html">NOX::Solver::Generic</a> &amp;solver) override</td></tr>
<tr class="memdesc:a25ae278fa7ac53badd450ab6f1440a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">User defined method that will be executed at the start of a call to <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html#acaef442decf010cd1d970e4695ae0476" title="Solve the nonlinear problem and return final status.">NOX::Solver::Generic::solve()</a>.  <br /></td></tr>
<tr class="separator:a25ae278fa7ac53badd450ab6f1440a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84eefb47fee3e1f2ded56066dc6ce75" id="r_af84eefb47fee3e1f2ded56066dc6ce75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_observer_reuse_preconditioner.html#af84eefb47fee3e1f2ded56066dc6ce75">runPreIterate</a> (const <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html">NOX::Solver::Generic</a> &amp;solver) override</td></tr>
<tr class="memdesc:af84eefb47fee3e1f2ded56066dc6ce75"><td class="mdescLeft">&#160;</td><td class="mdescRight">User defined method that will be executed at the start of a call to <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html#a7f9d07e6b19cd316437bd695a57d80c7" title="Do one nonlinear step in the iteration sequence and return status.">NOX::Solver::Generic::step()</a>.  <br /></td></tr>
<tr class="separator:af84eefb47fee3e1f2ded56066dc6ce75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de14c3e44dbae3a5e828e515a0be20d" id="r_a3de14c3e44dbae3a5e828e515a0be20d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_observer_reuse_preconditioner.html#a3de14c3e44dbae3a5e828e515a0be20d">runPostIterate</a> (const <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html">NOX::Solver::Generic</a> &amp;solver) override</td></tr>
<tr class="memdesc:a3de14c3e44dbae3a5e828e515a0be20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">User defined method that will be executed at the end of a call to <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html#a7f9d07e6b19cd316437bd695a57d80c7" title="Do one nonlinear step in the iteration sequence and return status.">NOX::Solver::Generic::step()</a>.  <br /></td></tr>
<tr class="separator:a3de14c3e44dbae3a5e828e515a0be20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9938cbbf1f8fc9baa874528842170d0" id="r_ab9938cbbf1f8fc9baa874528842170d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_observer_reuse_preconditioner.html#ab9938cbbf1f8fc9baa874528842170d0">runPostSolve</a> (const <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html">NOX::Solver::Generic</a> &amp;solver) override</td></tr>
<tr class="memdesc:ab9938cbbf1f8fc9baa874528842170d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">User defined method that will be executed at the end of a call to <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html#acaef442decf010cd1d970e4695ae0476" title="Solve the nonlinear problem and return final status.">NOX::Solver::Generic::solve()</a>.  <br /></td></tr>
<tr class="separator:ab9938cbbf1f8fc9baa874528842170d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_n_o_x_1_1_observer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_n_o_x_1_1_observer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_n_o_x_1_1_observer.html">NOX::Observer</a></td></tr>
<tr class="memitem:a4494ffd832f71375c4a628df6426006f inherit pub_methods_class_n_o_x_1_1_observer" id="r_a4494ffd832f71375c4a628df6426006f"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Observer</b> ()</td></tr>
<tr class="memdesc:a4494ffd832f71375c4a628df6426006f inherit pub_methods_class_n_o_x_1_1_observer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a4494ffd832f71375c4a628df6426006f inherit pub_methods_class_n_o_x_1_1_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5bd5b47f713094439f55d26447a2b4a inherit pub_methods_class_n_o_x_1_1_observer" id="r_aa5bd5b47f713094439f55d26447a2b4a"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Observer</b> ()</td></tr>
<tr class="memdesc:aa5bd5b47f713094439f55d26447a2b4a inherit pub_methods_class_n_o_x_1_1_observer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:aa5bd5b47f713094439f55d26447a2b4a inherit pub_methods_class_n_o_x_1_1_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780d46a08d263d96d0ac02f85ee3c4d4 inherit pub_methods_class_n_o_x_1_1_observer" id="r_a780d46a08d263d96d0ac02f85ee3c4d4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_observer.html#a780d46a08d263d96d0ac02f85ee3c4d4">runPreSolutionUpdate</a> (const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;, const <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html">NOX::Solver::Generic</a> &amp;)</td></tr>
<tr class="memdesc:a780d46a08d263d96d0ac02f85ee3c4d4 inherit pub_methods_class_n_o_x_1_1_observer"><td class="mdescLeft">&#160;</td><td class="mdescRight">User defined method that will be executed prior to the update of the solution vector during a call to <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html#a7f9d07e6b19cd316437bd695a57d80c7" title="Do one nonlinear step in the iteration sequence and return status.">NOX::Solver::Generic::step()</a>. This is intended to allow users to adjust the direction before the solution update, typically based on knowledge of the problem formulation. The direction is const as we can't guarantee that changes to the direction won't violate assumptions of the solution algorithm. Users can change the update/direciton after a const cast, but <a class="el" href="namespace_n_o_x.html" title="Nonlinear solvers package namespace.">NOX</a> may not function as expected. Use at your own risk!  <br /></td></tr>
<tr class="separator:a780d46a08d263d96d0ac02f85ee3c4d4 inherit pub_methods_class_n_o_x_1_1_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea50b292cb1ee4b1ef753de9fd698bcc inherit pub_methods_class_n_o_x_1_1_observer" id="r_aea50b292cb1ee4b1ef753de9fd698bcc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_observer.html#aea50b292cb1ee4b1ef753de9fd698bcc">runPostSolutionUpdate</a> (const <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html">NOX::Solver::Generic</a> &amp;)</td></tr>
<tr class="memdesc:aea50b292cb1ee4b1ef753de9fd698bcc inherit pub_methods_class_n_o_x_1_1_observer"><td class="mdescLeft">&#160;</td><td class="mdescRight">User defined method that will be executed after the update of the solution vector during a call to <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html#a7f9d07e6b19cd316437bd695a57d80c7" title="Do one nonlinear step in the iteration sequence and return status.">NOX::Solver::Generic::step()</a>. This is intended to allow users to adjust the direction after the solution update, typically based on knowledge of the problem formulation (e.g. clipping negative mass fractions). The direction is const as we can't guarantee that changes to the direction won't violate assumptions of the solution algorithm. Users can change the update/direciton after a const cast, but <a class="el" href="namespace_n_o_x.html" title="Nonlinear solvers package namespace.">NOX</a> may not function as expected. Use at your own risk!  <br /></td></tr>
<tr class="separator:aea50b292cb1ee4b1ef753de9fd698bcc inherit pub_methods_class_n_o_x_1_1_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f722d08dcb0b0b4d26273399b06f31 inherit pub_methods_class_n_o_x_1_1_observer" id="r_a84f722d08dcb0b0b4d26273399b06f31"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_observer.html#a84f722d08dcb0b0b4d26273399b06f31">runPreLineSearch</a> (const <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html">NOX::Solver::Generic</a> &amp;)</td></tr>
<tr class="memdesc:a84f722d08dcb0b0b4d26273399b06f31 inherit pub_methods_class_n_o_x_1_1_observer"><td class="mdescLeft">&#160;</td><td class="mdescRight">User defined method that will be executed before a call to <a class="el" href="class_n_o_x_1_1_line_search_1_1_generic.html#a4cc419fb25b2e3597750ed5a27f4f55a" title="Perform a line search.">NOX::LineSearch::Generic::compute()</a>. Only to be used in <a class="el" href="class_n_o_x_1_1_solver_1_1_line_search_based.html" title="Nonlinear solver based on a line search (i.e., damping)">NOX::Solver::LineSearchBased</a>!  <br /></td></tr>
<tr class="separator:a84f722d08dcb0b0b4d26273399b06f31 inherit pub_methods_class_n_o_x_1_1_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7510849e6cd227e49de681d88fed2c inherit pub_methods_class_n_o_x_1_1_observer" id="r_a3c7510849e6cd227e49de681d88fed2c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_observer.html#a3c7510849e6cd227e49de681d88fed2c">runPostLineSearch</a> (const <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html">NOX::Solver::Generic</a> &amp;)</td></tr>
<tr class="memdesc:a3c7510849e6cd227e49de681d88fed2c inherit pub_methods_class_n_o_x_1_1_observer"><td class="mdescLeft">&#160;</td><td class="mdescRight">User defined method that will be executed after a call to <a class="el" href="class_n_o_x_1_1_line_search_1_1_generic.html#a4cc419fb25b2e3597750ed5a27f4f55a" title="Perform a line search.">NOX::LineSearch::Generic::compute()</a>. Only to be used in <a class="el" href="class_n_o_x_1_1_solver_1_1_line_search_based.html" title="Nonlinear solver based on a line search (i.e., damping)">NOX::Solver::LineSearchBased</a>!  <br /></td></tr>
<tr class="separator:a3c7510849e6cd227e49de681d88fed2c inherit pub_methods_class_n_o_x_1_1_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Query methods used in unit testing</h2></td></tr>
<tr class="memitem:ac704b141598ca9752e70278495c8600e" id="r_ac704b141598ca9752e70278495c8600e"><td class="memItemLeft" align="right" valign="top"><a id="ac704b141598ca9752e70278495c8600e" name="ac704b141598ca9752e70278495c8600e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getNumPreconditionerUpdates</b> () const</td></tr>
<tr class="memdesc:ac704b141598ca9752e70278495c8600e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of times the preconditioner has been updated. <br /></td></tr>
<tr class="separator:ac704b141598ca9752e70278495c8600e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9128f44359403764e9e96a1deb47cff" id="r_ae9128f44359403764e9e96a1deb47cff"><td class="memItemLeft" align="right" valign="top"><a id="ae9128f44359403764e9e96a1deb47cff" name="ae9128f44359403764e9e96a1deb47cff"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getNumNonlinearSolvesCount</b> () const</td></tr>
<tr class="memdesc:ae9128f44359403764e9e96a1deb47cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of nonlinear solves that have been run. <br /></td></tr>
<tr class="separator:ae9128f44359403764e9e96a1deb47cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_n_o_x_1_1_observer.html" title="NOX&#39;s pure virtual class to allow users to insert user defined operations into nox&#39;s solvers (before ...">Observer</a> that controls when to update the preconditioner for the <a class="el" href="namespace_n_o_x_1_1_thyra.html" title="NOX Thyra support.">Thyra</a> interface. </p>
<p>The preconditioner can be updated at the start of each new nonlinear solve and/or when convergence stalls out. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a3de14c3e44dbae3a5e828e515a0be20d" name="a3de14c3e44dbae3a5e828e515a0be20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de14c3e44dbae3a5e828e515a0be20d">&#9670;&#160;</a></span>runPostIterate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NOX::ObserverReusePreconditioner::runPostIterate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html">NOX::Solver::Generic</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User defined method that will be executed at the end of a call to <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html#a7f9d07e6b19cd316437bd695a57d80c7" title="Do one nonlinear step in the iteration sequence and return status.">NOX::Solver::Generic::step()</a>. </p>

<p>Reimplemented from <a class="el" href="class_n_o_x_1_1_observer.html#a1211525f43044703d9d6fcb15575439b">NOX::Observer</a>.</p>

</div>
</div>
<a id="ab9938cbbf1f8fc9baa874528842170d0" name="ab9938cbbf1f8fc9baa874528842170d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9938cbbf1f8fc9baa874528842170d0">&#9670;&#160;</a></span>runPostSolve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NOX::ObserverReusePreconditioner::runPostSolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html">NOX::Solver::Generic</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User defined method that will be executed at the end of a call to <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html#acaef442decf010cd1d970e4695ae0476" title="Solve the nonlinear problem and return final status.">NOX::Solver::Generic::solve()</a>. </p>

<p>Reimplemented from <a class="el" href="class_n_o_x_1_1_observer.html#a9b5130b551c04f121231bfb96df6efa7">NOX::Observer</a>.</p>

<p class="reference">References <a class="el" href="namespace_n_o_x_1_1_status_test.html#aa46b1f439192e784b8434b16a99665e1a55694826ff6ae1040df75058ed659211">NOX::StatusTest::Failed</a>, and <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html#a955b996221660544be2e9636f9f5b285">NOX::Solver::Generic::getStatus()</a>.</p>

</div>
</div>
<a id="af84eefb47fee3e1f2ded56066dc6ce75" name="af84eefb47fee3e1f2ded56066dc6ce75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84eefb47fee3e1f2ded56066dc6ce75">&#9670;&#160;</a></span>runPreIterate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NOX::ObserverReusePreconditioner::runPreIterate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html">NOX::Solver::Generic</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User defined method that will be executed at the start of a call to <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html#a7f9d07e6b19cd316437bd695a57d80c7" title="Do one nonlinear step in the iteration sequence and return status.">NOX::Solver::Generic::step()</a>. </p>

<p>Reimplemented from <a class="el" href="class_n_o_x_1_1_observer.html#a8ab8a573f05b8bb6efcd7242a8489922">NOX::Observer</a>.</p>

<p class="reference">References <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html#a549da6e19b8d823a39e623bf4e946a4d">NOX::Solver::Generic::getNumIterations()</a>, <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html#abf1756564aa2c6b5712466be9b711980">NOX::Solver::Generic::getSolutionGroup()</a>, and <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html#a0f627071e08c10cc5ab7fa969aa49d54">NOX::Solver::Generic::getSolverStatistics()</a>.</p>

</div>
</div>
<a id="a25ae278fa7ac53badd450ab6f1440a82" name="a25ae278fa7ac53badd450ab6f1440a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ae278fa7ac53badd450ab6f1440a82">&#9670;&#160;</a></span>runPreSolve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NOX::ObserverReusePreconditioner::runPreSolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html">NOX::Solver::Generic</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User defined method that will be executed at the start of a call to <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html#acaef442decf010cd1d970e4695ae0476" title="Solve the nonlinear problem and return final status.">NOX::Solver::Generic::solve()</a>. </p>

<p>Reimplemented from <a class="el" href="class_n_o_x_1_1_observer.html#a179fa92d870d80673759a6a0601f0d9f">NOX::Observer</a>.</p>

<p class="reference">References <a class="el" href="class_n_o_x_1_1_thyra_1_1_group.html#a085f4340e2a1b67e709047de0300ad5d">NOX::Thyra::Group::getLinearOpWithSolveFactory()</a>, and <a class="el" href="class_n_o_x_1_1_solver_1_1_generic.html#abf1756564aa2c6b5712466be9b711980">NOX::Solver::Generic::getSolutionGroup()</a>.</p>

</div>
</div>
<a id="a461160a82e2817716830233059186c48" name="a461160a82e2817716830233059186c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461160a82e2817716830233059186c48">&#9670;&#160;</a></span>updateAfterNIterations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NOX::ObserverReusePreconditioner::updateAfterNIterations </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_iterations_for_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables updating of the preconditioner after a set number of nonlinear iterations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_iterations_for_update</td><td>(int) Updates the preconditioner after this number of nonlinear iterations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0e2e14ac99431f26e1a6a7c87d28cab" name="ad0e2e14ac99431f26e1a6a7c87d28cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e2e14ac99431f26e1a6a7c87d28cab">&#9670;&#160;</a></span>updateAfterNNonlinearSolves()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NOX::ObserverReusePreconditioner::updateAfterNNonlinearSolves </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_nonlinear_solves_for_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>reset_nonlinear_solve_count_on_failed_solve</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables updating of the preconditioner after a set number of nonlinear solves. </p>
<p>This is intended to reuse a preconditioner across all stages of an RK method in a single time step. The parameter should be set to the number of RK stages. If a nonlinear solve fails</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_nonlinear_solves_for_update</td><td>(int) Updates the preconditioner after this number of nonlinear iterations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reset_nonlinear_solve_count_on_faile_solve</td><td>(bool) If set to true, when a nonlinear solve fails, the nonlinear solve count will be reset. When a nonlinear solve fails in the middle of an RK stage, we assume a new time step will start for the next nonlinear solve. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27e26d573c28650dd62f61941a74b684" name="a27e26d573c28650dd62f61941a74b684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e26d573c28650dd62f61941a74b684">&#9670;&#160;</a></span>updateOnLinearSolverStall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NOX::ObserverReusePreconditioner::updateOnLinearSolverStall </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max_linear_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables updating of preconditioner if the observer detects a stall or failure in the linear solver. </p>
<p>This algorithm tries to assess a stalled computation due to reusing the preconditioner. It will always recompute for a failed linear solve. It will also recompute if the last max_count number of iterations each had linear solves that took more iterations than max_linear_iterations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_linear_iterations</td><td>(int) Declare a stalled iteraiton if the number of linear solver iterations is above this value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_count</td><td>(int) Recompute the preconditioner after this many stalled iterations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><b>NOX_Observer_ReusePreconditioner.hpp</b></li>
<li><b>NOX_Observer_ReusePreconditioner.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
