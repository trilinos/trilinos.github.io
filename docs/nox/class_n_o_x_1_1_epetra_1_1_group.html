<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NOX: NOX::Epetra::Group Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">NOX<span id="projectnumber">&#160;Development</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_n_o_x.html">NOX</a></li><li class="navelem"><a class="el" href="namespace_n_o_x_1_1_epetra.html">Epetra</a></li><li class="navelem"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html">Group</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_n_o_x_1_1_epetra_1_1_group-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">NOX::Epetra::Group Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Concrete implementation of <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F-vector,...">NOX::Abstract::Group</a> for Trilinos/Epetra.  
 <a href="class_n_o_x_1_1_epetra_1_1_group.html#details">More...</a></p>

<p><code>#include &lt;NOX_Epetra_Group.H&gt;</code></p>
<div class="dynheader">
Inheritance diagram for NOX::Epetra::Group:</div>
<div class="dyncontent">
<div class="center"><img src="class_n_o_x_1_1_epetra_1_1_group__inherit__graph.gif" border="0" usemap="#a_n_o_x_1_1_epetra_1_1_group_inherit__map" alt="Inheritance graph"/></div>
<map name="a_n_o_x_1_1_epetra_1_1_group_inherit__map" id="a_n_o_x_1_1_epetra_1_1_group_inherit__map">
<area shape="rect" title="Concrete implementation of NOX::Abstract::Group for Trilinos/Epetra." alt="" coords="11,79,159,104"/>
<area shape="rect" href="class_l_o_c_a_1_1_epetra_1_1_group.html" title="Extension of the NOX::Epetra::Group to LOCA." alt="" coords="8,152,163,177"/>
<area shape="poly" title=" " alt="" coords="88,118,88,152,83,152,83,118"/>
<area shape="rect" href="class_n_o_x_1_1_abstract_1_1_group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F&#45;vector,..." alt="" coords="5,5,165,31"/>
<area shape="poly" title=" " alt="" coords="88,44,88,79,83,79,83,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for NOX::Epetra::Group:</div>
<div class="dyncontent">
<div class="center"><img src="class_n_o_x_1_1_epetra_1_1_group__coll__graph.gif" border="0" usemap="#a_n_o_x_1_1_epetra_1_1_group_coll__map" alt="Collaboration graph"/></div>
<map name="a_n_o_x_1_1_epetra_1_1_group_coll__map" id="a_n_o_x_1_1_epetra_1_1_group_coll__map">
<area shape="rect" title="Concrete implementation of NOX::Abstract::Group for Trilinos/Epetra." alt="" coords="526,86,674,111"/>
<area shape="rect" href="class_n_o_x_1_1_shared_object.html" title=" " alt="" coords="927,43,1133,98"/>
<area shape="poly" title=" " alt="" coords="688,90,926,75,927,80,688,96"/>
<area shape="rect" href="class_n_o_x_1_1_abstract_1_1_group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F&#45;vector,..." alt="" coords="217,37,377,62"/>
<area shape="poly" title=" " alt="" coords="392,59,498,76,537,83,536,89,497,81,391,65"/>
<area shape="rect" href="class_n_o_x_1_1_utils.html" title="Provides printing utilities." alt="" coords="253,86,342,111"/>
<area shape="poly" title=" " alt="" coords="356,96,526,96,526,101,356,101"/>
<area shape="rect" href="class_n_o_x_1_1_epetra_1_1_vector.html" title="Implementation of NOX::Abstract::Vector for Epetra vectors." alt="" coords="222,175,373,201"/>
<area shape="poly" title=" " alt="" coords="386,182,442,175,496,160,544,136,582,109,585,114,547,140,498,165,443,180,387,188"/>
<area shape="rect" href="class_n_o_x_1_1_abstract_1_1_vector.html" title="NOX&#39;s pure abstract vector interface for vectors that are used by the nonlinear solver." alt="" coords="5,175,168,201"/>
<area shape="poly" title=" " alt="" coords="182,185,222,185,222,191,182,191"/>
<area shape="poly" title=" " alt="" coords="951,105,903,117,843,124,782,124,673,114,674,109,782,119,843,118,902,112,950,100"/>
<area shape="rect" href="class_n_o_x_1_1_shared_object.html" title="Holder for objects that are shared between NOX::Abstract::Groups." alt="" coords="521,5,679,45"/>
<area shape="poly" title=" " alt="" coords="692,32,927,57,926,62,692,38"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a235d0540d1b7a81f9fe293d2e40f9a83" id="r_a235d0540d1b7a81f9fe293d2e40f9a83"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a235d0540d1b7a81f9fe293d2e40f9a83">Group</a> (Teuchos::ParameterList &amp;printingParams, const Teuchos::RCP&lt; <a class="el" href="class_n_o_x_1_1_epetra_1_1_interface_1_1_required.html">NOX::Epetra::Interface::Required</a> &gt; &amp;i, const <a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html">NOX::Epetra::Vector</a> &amp;initialGuess)</td></tr>
<tr class="memdesc:a235d0540d1b7a81f9fe293d2e40f9a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with NO linear system (VERY LIMITED).  <br /></td></tr>
<tr class="separator:a235d0540d1b7a81f9fe293d2e40f9a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89d1c72fb136f638ea296bf2bcf029e" id="r_af89d1c72fb136f638ea296bf2bcf029e"><td class="memItemLeft" align="right" valign="top"><a id="af89d1c72fb136f638ea296bf2bcf029e" name="af89d1c72fb136f638ea296bf2bcf029e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Group</b> (Teuchos::ParameterList &amp;printingParams, const Teuchos::RCP&lt; <a class="el" href="class_n_o_x_1_1_epetra_1_1_interface_1_1_required.html">NOX::Epetra::Interface::Required</a> &gt; &amp;i, const <a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html">NOX::Epetra::Vector</a> &amp;initialGuess, const Teuchos::RCP&lt; <a class="el" href="class_n_o_x_1_1_epetra_1_1_linear_system.html">NOX::Epetra::LinearSystem</a> &gt; &amp;linSys)</td></tr>
<tr class="memdesc:af89d1c72fb136f638ea296bf2bcf029e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard Constructor. <br /></td></tr>
<tr class="separator:af89d1c72fb136f638ea296bf2bcf029e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2376b5186018058863cbd33e109e201d" id="r_a2376b5186018058863cbd33e109e201d"><td class="memItemLeft" align="right" valign="top"><a id="a2376b5186018058863cbd33e109e201d" name="a2376b5186018058863cbd33e109e201d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Group</b> (const <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html">NOX::Epetra::Group</a> &amp;source, <a class="el" href="namespace_n_o_x.html#a053a1ab5b2b3bd9546883b949142c592">NOX::CopyType</a> type=<a class="el" href="namespace_n_o_x.html#a053a1ab5b2b3bd9546883b949142c592af22ab6417594618436dfab3f95f98261">NOX::DeepCopy</a>)</td></tr>
<tr class="memdesc:a2376b5186018058863cbd33e109e201d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. If type is DeepCopy, takes ownership of valid shared linear system. <br /></td></tr>
<tr class="separator:a2376b5186018058863cbd33e109e201d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed00a22ff227ee2657ae44a5cbcedf7c" id="r_aed00a22ff227ee2657ae44a5cbcedf7c"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#aed00a22ff227ee2657ae44a5cbcedf7c">~Group</a> ()</td></tr>
<tr class="memdesc:aed00a22ff227ee2657ae44a5cbcedf7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:aed00a22ff227ee2657ae44a5cbcedf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461641a567f337a7aa3249b6dfdd8d69" id="r_a461641a567f337a7aa3249b6dfdd8d69"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html">NOX::Abstract::Group</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a461641a567f337a7aa3249b6dfdd8d69">operator=</a> (const <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html">NOX::Abstract::Group</a> &amp;source)</td></tr>
<tr class="memdesc:a461641a567f337a7aa3249b6dfdd8d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source group into this group.  <br /></td></tr>
<tr class="separator:a461641a567f337a7aa3249b6dfdd8d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ede301b13e5617b905b2234fe74ab2" id="r_a74ede301b13e5617b905b2234fe74ab2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html">NOX::Abstract::Group</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a74ede301b13e5617b905b2234fe74ab2">operator=</a> (const <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html">NOX::Epetra::Group</a> &amp;source)</td></tr>
<tr class="memdesc:a74ede301b13e5617b905b2234fe74ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a461641a567f337a7aa3249b6dfdd8d69" title="Copies the source group into this group.">operator=(const NOX::Abstract::Group&amp;)</a>;.  <br /></td></tr>
<tr class="separator:a74ede301b13e5617b905b2234fe74ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">"Compute" functions.</div></td></tr>
<tr class="memitem:aad85d7bb1bfff16fd7b0b88f2cfad5c2" id="r_aad85d7bb1bfff16fd7b0b88f2cfad5c2"><td class="memItemLeft" align="right" valign="top"><a id="aad85d7bb1bfff16fd7b0b88f2cfad5c2" name="aad85d7bb1bfff16fd7b0b88f2cfad5c2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setX</b> (const <a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html">NOX::Epetra::Vector</a> &amp;y)</td></tr>
<tr class="separator:aad85d7bb1bfff16fd7b0b88f2cfad5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098f135e50238d2a690636f5ae536e2a" id="r_a098f135e50238d2a690636f5ae536e2a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a098f135e50238d2a690636f5ae536e2a">setX</a> (const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;y)</td></tr>
<tr class="memdesc:a098f135e50238d2a690636f5ae536e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the solution vector x to y.  <br /></td></tr>
<tr class="separator:a098f135e50238d2a690636f5ae536e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91834c40378fd4a68ff012d8a3e0231d" id="r_a91834c40378fd4a68ff012d8a3e0231d"><td class="memItemLeft" align="right" valign="top"><a id="a91834c40378fd4a68ff012d8a3e0231d" name="a91834c40378fd4a68ff012d8a3e0231d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>computeX</b> (const <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html">Group</a> &amp;grp, const <a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html">NOX::Epetra::Vector</a> &amp;d, double step)</td></tr>
<tr class="separator:a91834c40378fd4a68ff012d8a3e0231d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494995fa24d49afedaa319089eb5b9ab" id="r_a494995fa24d49afedaa319089eb5b9ab"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a494995fa24d49afedaa319089eb5b9ab">computeX</a> (const <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html">NOX::Abstract::Group</a> &amp;grp, const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;d, double step)</td></tr>
<tr class="memdesc:a494995fa24d49afedaa319089eb5b9ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute x = grp.x + step * d.  <br /></td></tr>
<tr class="separator:a494995fa24d49afedaa319089eb5b9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef10f7019097fe83ea055dcf29df0402" id="r_aef10f7019097fe83ea055dcf29df0402"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#aef10f7019097fe83ea055dcf29df0402">computeF</a> ()</td></tr>
<tr class="memdesc:aef10f7019097fe83ea055dcf29df0402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and store F(x).  <br /></td></tr>
<tr class="separator:aef10f7019097fe83ea055dcf29df0402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2870acb70eca31d6c56b27a960a16f" id="r_abe2870acb70eca31d6c56b27a960a16f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#abe2870acb70eca31d6c56b27a960a16f">computeJacobian</a> ()</td></tr>
<tr class="memdesc:abe2870acb70eca31d6c56b27a960a16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and store Jacobian.  <br /></td></tr>
<tr class="separator:abe2870acb70eca31d6c56b27a960a16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aaa7683fb5f41bffec408a185e000bb" id="r_a2aaa7683fb5f41bffec408a185e000bb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a2aaa7683fb5f41bffec408a185e000bb">computeGradient</a> ()</td></tr>
<tr class="memdesc:a2aaa7683fb5f41bffec408a185e000bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and store gradient.  <br /></td></tr>
<tr class="separator:a2aaa7683fb5f41bffec408a185e000bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2066b02281a058f146c2aeafd654f7fe" id="r_a2066b02281a058f146c2aeafd654f7fe"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a2066b02281a058f146c2aeafd654f7fe">computeNewton</a> (Teuchos::ParameterList &amp;params)</td></tr>
<tr class="memdesc:a2066b02281a058f146c2aeafd654f7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Newton direction, using parameters for the linear solve.  <br /></td></tr>
<tr class="separator:a2066b02281a058f146c2aeafd654f7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Jacobian operations.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Operations using the Jacobian matrix. These may not be defined in matrix-free scenarios. </p>
</div></td></tr>
<tr class="memitem:ae6fbd2fec3dc0b5e81b527e6a4c11584" id="r_ae6fbd2fec3dc0b5e81b527e6a4c11584"><td class="memItemLeft" align="right" valign="top"><a id="ae6fbd2fec3dc0b5e81b527e6a4c11584" name="ae6fbd2fec3dc0b5e81b527e6a4c11584"></a>
virtual <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>applyJacobian</b> (const <a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html">NOX::Epetra::Vector</a> &amp;input, <a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html">NOX::Epetra::Vector</a> &amp;result) const</td></tr>
<tr class="separator:ae6fbd2fec3dc0b5e81b527e6a4c11584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b596500cbe1d9b3f1620506f5b56d5" id="r_a47b596500cbe1d9b3f1620506f5b56d5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a47b596500cbe1d9b3f1620506f5b56d5">applyJacobian</a> (const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;input, <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;result) const</td></tr>
<tr class="memdesc:a47b596500cbe1d9b3f1620506f5b56d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies Jacobian to the given input vector and puts the answer in the result.  <br /></td></tr>
<tr class="separator:a47b596500cbe1d9b3f1620506f5b56d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8f888e5854a74170eb07ddf96e2112" id="r_a7e8f888e5854a74170eb07ddf96e2112"><td class="memItemLeft" align="right" valign="top"><a id="a7e8f888e5854a74170eb07ddf96e2112" name="a7e8f888e5854a74170eb07ddf96e2112"></a>
virtual <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>applyJacobianTranspose</b> (const <a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html">NOX::Epetra::Vector</a> &amp;input, <a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html">NOX::Epetra::Vector</a> &amp;result) const</td></tr>
<tr class="separator:a7e8f888e5854a74170eb07ddf96e2112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30d543c58f3044ca9694cde09ceaf60" id="r_ad30d543c58f3044ca9694cde09ceaf60"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#ad30d543c58f3044ca9694cde09ceaf60">applyJacobianTranspose</a> (const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;input, <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;result) const</td></tr>
<tr class="memdesc:ad30d543c58f3044ca9694cde09ceaf60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies Jacobian-Transpose to the given input vector and puts the answer in the result.  <br /></td></tr>
<tr class="separator:ad30d543c58f3044ca9694cde09ceaf60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b165f0bbeda5df078458c77811a9f88" id="r_a7b165f0bbeda5df078458c77811a9f88"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a7b165f0bbeda5df078458c77811a9f88">applyJacobianInverse</a> (Teuchos::ParameterList &amp;params, const <a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html">NOX::Epetra::Vector</a> &amp;input, <a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html">NOX::Epetra::Vector</a> &amp;result) const</td></tr>
<tr class="separator:a7b165f0bbeda5df078458c77811a9f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2eb4837a2746131731128516f3b0f2" id="r_ade2eb4837a2746131731128516f3b0f2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#ade2eb4837a2746131731128516f3b0f2">applyJacobianInverse</a> (Teuchos::ParameterList &amp;params, const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;input, <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;result) const</td></tr>
<tr class="memdesc:ade2eb4837a2746131731128516f3b0f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the inverse of the Jacobian matrix to the given input vector and puts the answer in result.  <br /></td></tr>
<tr class="separator:ade2eb4837a2746131731128516f3b0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb115d7dd10f07a2230e3abd0273c112" id="r_adb115d7dd10f07a2230e3abd0273c112"><td class="memItemLeft" align="right" valign="top"><a id="adb115d7dd10f07a2230e3abd0273c112" name="adb115d7dd10f07a2230e3abd0273c112"></a>
virtual <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>applyRightPreconditioning</b> (bool useTranspose, Teuchos::ParameterList &amp;params, const <a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html">NOX::Epetra::Vector</a> &amp;input, <a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html">NOX::Epetra::Vector</a> &amp;result) const</td></tr>
<tr class="separator:adb115d7dd10f07a2230e3abd0273c112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f6e860350d39f53a9013baf9936b51" id="r_ab0f6e860350d39f53a9013baf9936b51"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#ab0f6e860350d39f53a9013baf9936b51">applyRightPreconditioning</a> (bool useTranspose, Teuchos::ParameterList &amp;params, const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;input, <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;result) const</td></tr>
<tr class="memdesc:ab0f6e860350d39f53a9013baf9936b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply right preconditiong to the given input vector.  <br /></td></tr>
<tr class="separator:ab0f6e860350d39f53a9013baf9936b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">"Is" functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Checks to see if various objects have been computed. Returns true if the corresponding "compute" function has been called since the last update to the solution vector (via instantiation or computeX). </p>
</div></td></tr>
<tr class="memitem:aa7c7b9206bc1516eb334f0ce0f2e5139" id="r_aa7c7b9206bc1516eb334f0ce0f2e5139"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#aa7c7b9206bc1516eb334f0ce0f2e5139">isF</a> () const</td></tr>
<tr class="memdesc:aa7c7b9206bc1516eb334f0ce0f2e5139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if F is valid.  <br /></td></tr>
<tr class="separator:aa7c7b9206bc1516eb334f0ce0f2e5139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ed3521b30ced87988cf947ef7ddc49" id="r_ab4ed3521b30ced87988cf947ef7ddc49"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#ab4ed3521b30ced87988cf947ef7ddc49">isJacobian</a> () const</td></tr>
<tr class="memdesc:ab4ed3521b30ced87988cf947ef7ddc49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the Jacobian is valid.  <br /></td></tr>
<tr class="separator:ab4ed3521b30ced87988cf947ef7ddc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1814ca3eef1cf58cddf7031ffb4c50e" id="r_ab1814ca3eef1cf58cddf7031ffb4c50e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#ab1814ca3eef1cf58cddf7031ffb4c50e">isGradient</a> () const</td></tr>
<tr class="memdesc:ab1814ca3eef1cf58cddf7031ffb4c50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the gradient is valid.  <br /></td></tr>
<tr class="separator:ab1814ca3eef1cf58cddf7031ffb4c50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af349ae1b320dd9b5f720c33699ee6e3e" id="r_af349ae1b320dd9b5f720c33699ee6e3e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#af349ae1b320dd9b5f720c33699ee6e3e">isNewton</a> () const</td></tr>
<tr class="memdesc:af349ae1b320dd9b5f720c33699ee6e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the Newton direction is valid.  <br /></td></tr>
<tr class="separator:af349ae1b320dd9b5f720c33699ee6e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a85bb6b4a20eb4f709c6d8c03f7730" id="r_aa2a85bb6b4a20eb4f709c6d8c03f7730"><td class="memItemLeft" align="right" valign="top"><a id="aa2a85bb6b4a20eb4f709c6d8c03f7730" name="aa2a85bb6b4a20eb4f709c6d8c03f7730"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isNormNewtonSolveResidual</b> () const</td></tr>
<tr class="memdesc:aa2a85bb6b4a20eb4f709c6d8c03f7730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the value of the Norm of the linear model for a full Newton step ||Js + f|| is valid with respect to the current solution vector. <br /></td></tr>
<tr class="separator:aa2a85bb6b4a20eb4f709c6d8c03f7730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba882f748d518d0a3595329beb9fde3" id="r_a1ba882f748d518d0a3595329beb9fde3"><td class="memItemLeft" align="right" valign="top"><a id="a1ba882f748d518d0a3595329beb9fde3" name="a1ba882f748d518d0a3595329beb9fde3"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isPreconditioner</b> () const</td></tr>
<tr class="memdesc:a1ba882f748d518d0a3595329beb9fde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if an explicitly constructed preconditioner exists (i.e. one that is computed and saved for further use in multiple calls to applyRightPreconditioner). <br /></td></tr>
<tr class="separator:a1ba882f748d518d0a3595329beb9fde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add59f3f84510f3a93e616bb8c37d553f" id="r_add59f3f84510f3a93e616bb8c37d553f"><td class="memItemLeft" align="right" valign="top"><a id="add59f3f84510f3a93e616bb8c37d553f" name="add59f3f84510f3a93e616bb8c37d553f"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isConditionNumber</b> () const</td></tr>
<tr class="memdesc:add59f3f84510f3a93e616bb8c37d553f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the condition number has been computed. <br /></td></tr>
<tr class="separator:add59f3f84510f3a93e616bb8c37d553f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_n_o_x_1_1_abstract_1_1_group"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_n_o_x_1_1_abstract_1_1_group')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html">NOX::Abstract::Group</a></td></tr>
<tr class="memitem:af49179db064ac14246c4386d1b5bff0b inherit pub_methods_class_n_o_x_1_1_abstract_1_1_group" id="r_af49179db064ac14246c4386d1b5bff0b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#af49179db064ac14246c4386d1b5bff0b">Group</a> ()</td></tr>
<tr class="memdesc:af49179db064ac14246c4386d1b5bff0b inherit pub_methods_class_n_o_x_1_1_abstract_1_1_group"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:af49179db064ac14246c4386d1b5bff0b inherit pub_methods_class_n_o_x_1_1_abstract_1_1_group"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd8117c1a5bb2ebd6061176b4e75444 inherit pub_methods_class_n_o_x_1_1_abstract_1_1_group" id="r_a1bd8117c1a5bb2ebd6061176b4e75444"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#a1bd8117c1a5bb2ebd6061176b4e75444">applyJacobianMultiVector</a> (const <a class="el" href="class_n_o_x_1_1_abstract_1_1_multi_vector.html">NOX::Abstract::MultiVector</a> &amp;input, <a class="el" href="class_n_o_x_1_1_abstract_1_1_multi_vector.html">NOX::Abstract::MultiVector</a> &amp;result) const</td></tr>
<tr class="memdesc:a1bd8117c1a5bb2ebd6061176b4e75444 inherit pub_methods_class_n_o_x_1_1_abstract_1_1_group"><td class="mdescLeft">&#160;</td><td class="mdescRight">applyJacobian for multiple right-hand sides  <br /></td></tr>
<tr class="separator:a1bd8117c1a5bb2ebd6061176b4e75444 inherit pub_methods_class_n_o_x_1_1_abstract_1_1_group"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7432c61b8987bb060d0165d26a96e79 inherit pub_methods_class_n_o_x_1_1_abstract_1_1_group" id="r_ac7432c61b8987bb060d0165d26a96e79"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#ac7432c61b8987bb060d0165d26a96e79">applyJacobianTransposeMultiVector</a> (const <a class="el" href="class_n_o_x_1_1_abstract_1_1_multi_vector.html">NOX::Abstract::MultiVector</a> &amp;input, <a class="el" href="class_n_o_x_1_1_abstract_1_1_multi_vector.html">NOX::Abstract::MultiVector</a> &amp;result) const</td></tr>
<tr class="memdesc:ac7432c61b8987bb060d0165d26a96e79 inherit pub_methods_class_n_o_x_1_1_abstract_1_1_group"><td class="mdescLeft">&#160;</td><td class="mdescRight">applyJacobianTranspose for multiple right-hand sides  <br /></td></tr>
<tr class="separator:ac7432c61b8987bb060d0165d26a96e79 inherit pub_methods_class_n_o_x_1_1_abstract_1_1_group"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b1d35a67e37becccd069b29dc99af2 inherit pub_methods_class_n_o_x_1_1_abstract_1_1_group" id="r_ab9b1d35a67e37becccd069b29dc99af2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#ab9b1d35a67e37becccd069b29dc99af2">applyJacobianInverseMultiVector</a> (Teuchos::ParameterList &amp;params, const <a class="el" href="class_n_o_x_1_1_abstract_1_1_multi_vector.html">NOX::Abstract::MultiVector</a> &amp;input, <a class="el" href="class_n_o_x_1_1_abstract_1_1_multi_vector.html">NOX::Abstract::MultiVector</a> &amp;result) const</td></tr>
<tr class="memdesc:ab9b1d35a67e37becccd069b29dc99af2 inherit pub_methods_class_n_o_x_1_1_abstract_1_1_group"><td class="mdescLeft">&#160;</td><td class="mdescRight">applyJacobianInverse for multiple right-hand sides  <br /></td></tr>
<tr class="separator:ab9b1d35a67e37becccd069b29dc99af2 inherit pub_methods_class_n_o_x_1_1_abstract_1_1_group"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ebd348f91e6e06a08d1f71e3031462 inherit pub_methods_class_n_o_x_1_1_abstract_1_1_group" id="r_a44ebd348f91e6e06a08d1f71e3031462"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#a44ebd348f91e6e06a08d1f71e3031462">applyRightPreconditioningMultiVector</a> (bool useTranspose, Teuchos::ParameterList &amp;params, const <a class="el" href="class_n_o_x_1_1_abstract_1_1_multi_vector.html">NOX::Abstract::MultiVector</a> &amp;input, <a class="el" href="class_n_o_x_1_1_abstract_1_1_multi_vector.html">NOX::Abstract::MultiVector</a> &amp;result) const</td></tr>
<tr class="memdesc:a44ebd348f91e6e06a08d1f71e3031462 inherit pub_methods_class_n_o_x_1_1_abstract_1_1_group"><td class="mdescLeft">&#160;</td><td class="mdescRight">applyRightPreconditioning for multiple right-hand sides  <br /></td></tr>
<tr class="separator:a44ebd348f91e6e06a08d1f71e3031462 inherit pub_methods_class_n_o_x_1_1_abstract_1_1_group"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a2c4535ce545f7dd575c2cd5d0036e inherit pub_methods_class_n_o_x_1_1_abstract_1_1_group" id="r_a51a2c4535ce545f7dd575c2cd5d0036e"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#a51a2c4535ce545f7dd575c2cd5d0036e">getScaledX</a> () const</td></tr>
<tr class="separator:a51a2c4535ce545f7dd575c2cd5d0036e inherit pub_methods_class_n_o_x_1_1_abstract_1_1_group"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14cca8c4e8df87fe08e97b1946a11f6b inherit pub_methods_class_n_o_x_1_1_abstract_1_1_group" id="r_a14cca8c4e8df87fe08e97b1946a11f6b"><td class="memItemLeft" align="right" valign="top">virtual Teuchos::RCP&lt; <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html">NOX::Abstract::Group</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#a14cca8c4e8df87fe08e97b1946a11f6b">getNestedGroup</a> ()</td></tr>
<tr class="memdesc:a14cca8c4e8df87fe08e97b1946a11f6b inherit pub_methods_class_n_o_x_1_1_abstract_1_1_group"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an internally stored group from this group.  <br /></td></tr>
<tr class="separator:a14cca8c4e8df87fe08e97b1946a11f6b inherit pub_methods_class_n_o_x_1_1_abstract_1_1_group"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6579e907d15c56b80bc3156e31fb55a inherit pub_methods_class_n_o_x_1_1_abstract_1_1_group" id="r_ab6579e907d15c56b80bc3156e31fb55a"><td class="memItemLeft" align="right" valign="top">virtual Teuchos::RCP&lt; const <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html">NOX::Abstract::Group</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#ab6579e907d15c56b80bc3156e31fb55a">getNestedGroup</a> () const</td></tr>
<tr class="memdesc:ab6579e907d15c56b80bc3156e31fb55a inherit pub_methods_class_n_o_x_1_1_abstract_1_1_group"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an internally stored group from this group.  <br /></td></tr>
<tr class="separator:ab6579e907d15c56b80bc3156e31fb55a inherit pub_methods_class_n_o_x_1_1_abstract_1_1_group"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Vectors</div></td></tr>
<tr class="memitem:aeeacb5c18a2e60e78fd9a891c945cd34" id="r_aeeacb5c18a2e60e78fd9a891c945cd34"><td class="memItemLeft" align="right" valign="top"><a id="aeeacb5c18a2e60e78fd9a891c945cd34" name="aeeacb5c18a2e60e78fd9a891c945cd34"></a>
Teuchos::RCP&lt; <a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html">NOX::Epetra::Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>xVectorPtr</b></td></tr>
<tr class="memdesc:aeeacb5c18a2e60e78fd9a891c945cd34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solution vector pointer. <br /></td></tr>
<tr class="separator:aeeacb5c18a2e60e78fd9a891c945cd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebb1b6ecf2d328428fcbd190f098ea2" id="r_a7ebb1b6ecf2d328428fcbd190f098ea2"><td class="memItemLeft" align="right" valign="top"><a id="a7ebb1b6ecf2d328428fcbd190f098ea2" name="a7ebb1b6ecf2d328428fcbd190f098ea2"></a>
<a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html">NOX::Epetra::Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>xVector</b></td></tr>
<tr class="memdesc:a7ebb1b6ecf2d328428fcbd190f098ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solution vector. <br /></td></tr>
<tr class="separator:a7ebb1b6ecf2d328428fcbd190f098ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c778c58708b3a53a38234963aa05fa" id="r_ab2c778c58708b3a53a38234963aa05fa"><td class="memItemLeft" align="right" valign="top"><a id="ab2c778c58708b3a53a38234963aa05fa" name="ab2c778c58708b3a53a38234963aa05fa"></a>
Teuchos::RCP&lt; <a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html">NOX::Epetra::Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RHSVectorPtr</b></td></tr>
<tr class="memdesc:ab2c778c58708b3a53a38234963aa05fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-hand-side vector (function evaluation). <br /></td></tr>
<tr class="separator:ab2c778c58708b3a53a38234963aa05fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f29786ff4d1f5d85d21f0bb6c3c17a" id="r_a20f29786ff4d1f5d85d21f0bb6c3c17a"><td class="memItemLeft" align="right" valign="top"><a id="a20f29786ff4d1f5d85d21f0bb6c3c17a" name="a20f29786ff4d1f5d85d21f0bb6c3c17a"></a>
<a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html">NOX::Epetra::Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>RHSVector</b></td></tr>
<tr class="memdesc:a20f29786ff4d1f5d85d21f0bb6c3c17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-hand-side vector pointer (function evaluation). <br /></td></tr>
<tr class="separator:a20f29786ff4d1f5d85d21f0bb6c3c17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b22e8b615a59dbdb9b981771dea8f2" id="r_a63b22e8b615a59dbdb9b981771dea8f2"><td class="memItemLeft" align="right" valign="top"><a id="a63b22e8b615a59dbdb9b981771dea8f2" name="a63b22e8b615a59dbdb9b981771dea8f2"></a>
Teuchos::RCP&lt; <a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html">NOX::Epetra::Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>gradVectorPtr</b></td></tr>
<tr class="memdesc:a63b22e8b615a59dbdb9b981771dea8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gradient vector pointer(steepest descent vector). <br /></td></tr>
<tr class="separator:a63b22e8b615a59dbdb9b981771dea8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4209dfbe651ff2b9d0a6af0fe34d5b4" id="r_aa4209dfbe651ff2b9d0a6af0fe34d5b4"><td class="memItemLeft" align="right" valign="top"><a id="aa4209dfbe651ff2b9d0a6af0fe34d5b4" name="aa4209dfbe651ff2b9d0a6af0fe34d5b4"></a>
<a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html">NOX::Epetra::Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>gradVector</b></td></tr>
<tr class="memdesc:aa4209dfbe651ff2b9d0a6af0fe34d5b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gradient vector (steepest descent vector). <br /></td></tr>
<tr class="separator:aa4209dfbe651ff2b9d0a6af0fe34d5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593c67dc05a4dbf7de6e52b0a68b6c48" id="r_a593c67dc05a4dbf7de6e52b0a68b6c48"><td class="memItemLeft" align="right" valign="top"><a id="a593c67dc05a4dbf7de6e52b0a68b6c48" name="a593c67dc05a4dbf7de6e52b0a68b6c48"></a>
Teuchos::RCP&lt; <a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html">NOX::Epetra::Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NewtonVectorPtr</b></td></tr>
<tr class="memdesc:a593c67dc05a4dbf7de6e52b0a68b6c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Newton direction vector pointer. <br /></td></tr>
<tr class="separator:a593c67dc05a4dbf7de6e52b0a68b6c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456bbd737c3713b8234c2f4ab48e23d9" id="r_a456bbd737c3713b8234c2f4ab48e23d9"><td class="memItemLeft" align="right" valign="top"><a id="a456bbd737c3713b8234c2f4ab48e23d9" name="a456bbd737c3713b8234c2f4ab48e23d9"></a>
<a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html">NOX::Epetra::Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>NewtonVector</b></td></tr>
<tr class="memdesc:a456bbd737c3713b8234c2f4ab48e23d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Newton direction vector. <br /></td></tr>
<tr class="separator:a456bbd737c3713b8234c2f4ab48e23d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b8b40c323efac008ec628cde2b8a6d" id="r_ae4b8b40c323efac008ec628cde2b8a6d"><td class="memItemLeft" align="right" valign="top"><a id="ae4b8b40c323efac008ec628cde2b8a6d" name="ae4b8b40c323efac008ec628cde2b8a6d"></a>
Teuchos::RCP&lt; Epetra_Vector &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tmpVectorPtr</b></td></tr>
<tr class="memdesc:ae4b8b40c323efac008ec628cde2b8a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">An extra temporary vector, only allocated if needed. <br /></td></tr>
<tr class="separator:ae4b8b40c323efac008ec628cde2b8a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">IsValid flags</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>True if the current solution is up-to-date with respect to the currect xVector. </p>
</div></td></tr>
<tr class="memitem:a2202e00fd2a908876807d9f7c72f08e8" id="r_a2202e00fd2a908876807d9f7c72f08e8"><td class="memItemLeft" align="right" valign="top"><a id="a2202e00fd2a908876807d9f7c72f08e8" name="a2202e00fd2a908876807d9f7c72f08e8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidRHS</b></td></tr>
<tr class="separator:a2202e00fd2a908876807d9f7c72f08e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc4fd54393a69d7afcbb9fb9bac0d3a" id="r_a1bc4fd54393a69d7afcbb9fb9bac0d3a"><td class="memItemLeft" align="right" valign="top"><a id="a1bc4fd54393a69d7afcbb9fb9bac0d3a" name="a1bc4fd54393a69d7afcbb9fb9bac0d3a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidJacobian</b></td></tr>
<tr class="separator:a1bc4fd54393a69d7afcbb9fb9bac0d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8277bf010ebadf9afe5861fd5e1ab796" id="r_a8277bf010ebadf9afe5861fd5e1ab796"><td class="memItemLeft" align="right" valign="top"><a id="a8277bf010ebadf9afe5861fd5e1ab796" name="a8277bf010ebadf9afe5861fd5e1ab796"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidGrad</b></td></tr>
<tr class="separator:a8277bf010ebadf9afe5861fd5e1ab796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4330be808524208e521ea7ed772c3f0e" id="r_a4330be808524208e521ea7ed772c3f0e"><td class="memItemLeft" align="right" valign="top"><a id="a4330be808524208e521ea7ed772c3f0e" name="a4330be808524208e521ea7ed772c3f0e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidNewton</b></td></tr>
<tr class="separator:a4330be808524208e521ea7ed772c3f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa497c36943c375c90667ecb07b456c5c" id="r_aa497c36943c375c90667ecb07b456c5c"><td class="memItemLeft" align="right" valign="top"><a id="aa497c36943c375c90667ecb07b456c5c" name="aa497c36943c375c90667ecb07b456c5c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidNormNewtonSolveResidual</b></td></tr>
<tr class="separator:aa497c36943c375c90667ecb07b456c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3dc8a8c3f6030ce4b7bb46b59e7b480" id="r_ac3dc8a8c3f6030ce4b7bb46b59e7b480"><td class="memItemLeft" align="right" valign="top"><a id="ac3dc8a8c3f6030ce4b7bb46b59e7b480" name="ac3dc8a8c3f6030ce4b7bb46b59e7b480"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidPreconditioner</b></td></tr>
<tr class="separator:ac3dc8a8c3f6030ce4b7bb46b59e7b480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad466b1ecc68c0fdabc79172f566eb724" id="r_ad466b1ecc68c0fdabc79172f566eb724"><td class="memItemLeft" align="right" valign="top"><a id="ad466b1ecc68c0fdabc79172f566eb724" name="ad466b1ecc68c0fdabc79172f566eb724"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidSolverJacOp</b></td></tr>
<tr class="separator:ad466b1ecc68c0fdabc79172f566eb724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1998b683581e80c92510078f36d2a03" id="r_aa1998b683581e80c92510078f36d2a03"><td class="memItemLeft" align="right" valign="top"><a id="aa1998b683581e80c92510078f36d2a03" name="aa1998b683581e80c92510078f36d2a03"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidConditionNumber</b></td></tr>
<tr class="separator:aa1998b683581e80c92510078f36d2a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af24396fb54983866a65c4a82b1660c" id="r_a1af24396fb54983866a65c4a82b1660c"><td class="memItemLeft" align="right" valign="top"><a id="a1af24396fb54983866a65c4a82b1660c" name="a1af24396fb54983866a65c4a82b1660c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>normNewtonSolveResidual</b></td></tr>
<tr class="memdesc:a1af24396fb54983866a65c4a82b1660c"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-Norm of the Newton solve residual: ||Js+f|| <br /></td></tr>
<tr class="separator:a1af24396fb54983866a65c4a82b1660c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5c2aa5dc41fe1e1215c67427f03911" id="r_aeb5c2aa5dc41fe1e1215c67427f03911"><td class="memItemLeft" align="right" valign="top"><a id="aeb5c2aa5dc41fe1e1215c67427f03911" name="aeb5c2aa5dc41fe1e1215c67427f03911"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>conditionNumber</b></td></tr>
<tr class="memdesc:aeb5c2aa5dc41fe1e1215c67427f03911"><td class="mdescLeft">&#160;</td><td class="mdescRight">condition number of Jacobian <br /></td></tr>
<tr class="separator:aeb5c2aa5dc41fe1e1215c67427f03911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1f684afd373d0f5933c5fed1838a45" id="r_a7a1f684afd373d0f5933c5fed1838a45"><td class="memItemLeft" align="right" valign="top"><a id="a7a1f684afd373d0f5933c5fed1838a45" name="a7a1f684afd373d0f5933c5fed1838a45"></a>
Teuchos::RCP&lt; AztecOOConditionNumber &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>azConditionNumberPtr</b></td></tr>
<tr class="memdesc:a7a1f684afd373d0f5933c5fed1838a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the condition number object. <br /></td></tr>
<tr class="separator:a7a1f684afd373d0f5933c5fed1838a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Shared Operators</div></td></tr>
<tr class="memitem:acaa5eb71342ddff27a6df14a18ed3126" id="r_acaa5eb71342ddff27a6df14a18ed3126"><td class="memItemLeft" align="right" valign="top"><a id="acaa5eb71342ddff27a6df14a18ed3126" name="acaa5eb71342ddff27a6df14a18ed3126"></a>
Teuchos::RCP&lt; <a class="el" href="class_n_o_x_1_1_shared_object.html">NOX::SharedObject</a>&lt; <a class="el" href="class_n_o_x_1_1_epetra_1_1_linear_system.html">NOX::Epetra::LinearSystem</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html">NOX::Epetra::Group</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>sharedLinearSystemPtr</b></td></tr>
<tr class="memdesc:acaa5eb71342ddff27a6df14a18ed3126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to shared Jacobian matrix. <br /></td></tr>
<tr class="separator:acaa5eb71342ddff27a6df14a18ed3126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfe5a323d9ce273e0eb8dbf5bc69741" id="r_abcfe5a323d9ce273e0eb8dbf5bc69741"><td class="memItemLeft" align="right" valign="top"><a id="abcfe5a323d9ce273e0eb8dbf5bc69741" name="abcfe5a323d9ce273e0eb8dbf5bc69741"></a>
<a class="el" href="class_n_o_x_1_1_shared_object.html">NOX::SharedObject</a>&lt; <a class="el" href="class_n_o_x_1_1_epetra_1_1_linear_system.html">NOX::Epetra::LinearSystem</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html">NOX::Epetra::Group</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>sharedLinearSystem</b></td></tr>
<tr class="memdesc:abcfe5a323d9ce273e0eb8dbf5bc69741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to shared Jacobian matrix. <br /></td></tr>
<tr class="separator:abcfe5a323d9ce273e0eb8dbf5bc69741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64274e002a2e6a55384282af3f486d86" id="r_a64274e002a2e6a55384282af3f486d86"><td class="memItemLeft" align="right" valign="top"><a id="a64274e002a2e6a55384282af3f486d86" name="a64274e002a2e6a55384282af3f486d86"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>linearResidCompDisabled</b></td></tr>
<tr class="separator:a64274e002a2e6a55384282af3f486d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35678c6f63a1cb5348b48a84694334eb" id="r_a35678c6f63a1cb5348b48a84694334eb"><td class="memItemLeft" align="right" valign="top"><a id="a35678c6f63a1cb5348b48a84694334eb" name="a35678c6f63a1cb5348b48a84694334eb"></a>
Teuchos::RCP&lt; <a class="el" href="class_n_o_x_1_1_epetra_1_1_interface_1_1_required.html">NOX::Epetra::Interface::Required</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>userInterfacePtr</b></td></tr>
<tr class="memdesc:a35678c6f63a1cb5348b48a84694334eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the user supplied interface functions. <br /></td></tr>
<tr class="separator:a35678c6f63a1cb5348b48a84694334eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642a0e92d3f34a2ed721419d30eed2f1" id="r_a642a0e92d3f34a2ed721419d30eed2f1"><td class="memItemLeft" align="right" valign="top"><a id="a642a0e92d3f34a2ed721419d30eed2f1" name="a642a0e92d3f34a2ed721419d30eed2f1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>linearSolveConverged</b></td></tr>
<tr class="separator:a642a0e92d3f34a2ed721419d30eed2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4c5f4ce55125ff622cf7fcd0116a6c" id="r_afe4c5f4ce55125ff622cf7fcd0116a6c"><td class="memItemLeft" align="right" valign="top"><a id="afe4c5f4ce55125ff622cf7fcd0116a6c" name="afe4c5f4ce55125ff622cf7fcd0116a6c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numIterations</b></td></tr>
<tr class="separator:afe4c5f4ce55125ff622cf7fcd0116a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2736ba319786d5d028d47149951e2402" id="r_a2736ba319786d5d028d47149951e2402"><td class="memItemLeft" align="right" valign="top"><a id="a2736ba319786d5d028d47149951e2402" name="a2736ba319786d5d028d47149951e2402"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>achievedTol</b></td></tr>
<tr class="separator:a2736ba319786d5d028d47149951e2402"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">"Get" functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Note that these function do not check whether or not the vectors are valid. Must use the "Is" functions for that purpose. </p>
</td></tr>
<tr class="memitem:a49718a11017b881578d01d8a868a7349" id="r_a49718a11017b881578d01d8a868a7349"><td class="memItemLeft" align="right" valign="top"><a id="a49718a11017b881578d01d8a868a7349" name="a49718a11017b881578d01d8a868a7349"></a>
const <a class="el" href="class_n_o_x_1_1_utils.html">NOX::Utils</a>&#160;</td><td class="memItemRight" valign="bottom"><b>utils</b></td></tr>
<tr class="memdesc:a49718a11017b881578d01d8a868a7349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Printing Utilities object. <br /></td></tr>
<tr class="separator:a49718a11017b881578d01d8a868a7349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8f9860818e4f33c526bd6afa3d55a6" id="r_a3b8f9860818e4f33c526bd6afa3d55a6"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a3b8f9860818e4f33c526bd6afa3d55a6">getX</a> () const</td></tr>
<tr class="memdesc:a3b8f9860818e4f33c526bd6afa3d55a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return solution vector.  <br /></td></tr>
<tr class="separator:a3b8f9860818e4f33c526bd6afa3d55a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8a67ec663e8c4ea74d39ccc1d9d765" id="r_afe8a67ec663e8c4ea74d39ccc1d9d765"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#afe8a67ec663e8c4ea74d39ccc1d9d765">getF</a> () const</td></tr>
<tr class="memdesc:afe8a67ec663e8c4ea74d39ccc1d9d765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return F(x)  <br /></td></tr>
<tr class="separator:afe8a67ec663e8c4ea74d39ccc1d9d765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63875a84603bca3d1e2e7c762bf82e9f" id="r_a63875a84603bca3d1e2e7c762bf82e9f"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a63875a84603bca3d1e2e7c762bf82e9f">getNormF</a> () const</td></tr>
<tr class="memdesc:a63875a84603bca3d1e2e7c762bf82e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 2-norm of F(x).  <br /></td></tr>
<tr class="separator:a63875a84603bca3d1e2e7c762bf82e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ca4b9a5bb33cbad1b11eedb93c35db" id="r_a67ca4b9a5bb33cbad1b11eedb93c35db"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a67ca4b9a5bb33cbad1b11eedb93c35db">getGradient</a> () const</td></tr>
<tr class="memdesc:a67ca4b9a5bb33cbad1b11eedb93c35db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return gradient.  <br /></td></tr>
<tr class="separator:a67ca4b9a5bb33cbad1b11eedb93c35db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5aaea15cd1b2fb6af4200c730b627ef" id="r_ab5aaea15cd1b2fb6af4200c730b627ef"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#ab5aaea15cd1b2fb6af4200c730b627ef">getNewton</a> () const</td></tr>
<tr class="memdesc:ab5aaea15cd1b2fb6af4200c730b627ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Newton direction.  <br /></td></tr>
<tr class="separator:ab5aaea15cd1b2fb6af4200c730b627ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac6fcaa3b35fcb895095a73f281e6d2" id="r_aaac6fcaa3b35fcb895095a73f281e6d2"><td class="memItemLeft" align="right" valign="top">virtual Teuchos::RCP&lt; const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#aaac6fcaa3b35fcb895095a73f281e6d2">getXPtr</a> () const</td></tr>
<tr class="memdesc:aaac6fcaa3b35fcb895095a73f281e6d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return RCP to solution vector.  <br /></td></tr>
<tr class="separator:aaac6fcaa3b35fcb895095a73f281e6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec94e8872c58836a721f240737afd3bf" id="r_aec94e8872c58836a721f240737afd3bf"><td class="memItemLeft" align="right" valign="top">virtual Teuchos::RCP&lt; const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#aec94e8872c58836a721f240737afd3bf">getFPtr</a> () const</td></tr>
<tr class="memdesc:aec94e8872c58836a721f240737afd3bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return RCP to F(x)  <br /></td></tr>
<tr class="separator:aec94e8872c58836a721f240737afd3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5739654db4b905cdd72dbeb719b87aa" id="r_aa5739654db4b905cdd72dbeb719b87aa"><td class="memItemLeft" align="right" valign="top">virtual Teuchos::RCP&lt; const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#aa5739654db4b905cdd72dbeb719b87aa">getGradientPtr</a> () const</td></tr>
<tr class="memdesc:aa5739654db4b905cdd72dbeb719b87aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return RCP to gradient.  <br /></td></tr>
<tr class="separator:aa5739654db4b905cdd72dbeb719b87aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0739d9bc51df58e1162f4a963ac5048b" id="r_a0739d9bc51df58e1162f4a963ac5048b"><td class="memItemLeft" align="right" valign="top">virtual Teuchos::RCP&lt; const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a0739d9bc51df58e1162f4a963ac5048b">getNewtonPtr</a> () const</td></tr>
<tr class="memdesc:a0739d9bc51df58e1162f4a963ac5048b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return RCP to Newton direction.  <br /></td></tr>
<tr class="separator:a0739d9bc51df58e1162f4a963ac5048b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67646a0b5325f4df7e3b0920e0b591d7" id="r_a67646a0b5325f4df7e3b0920e0b591d7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a67646a0b5325f4df7e3b0920e0b591d7">getNormLastLinearSolveResidual</a> (double &amp;residual) const</td></tr>
<tr class="memdesc:a67646a0b5325f4df7e3b0920e0b591d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 2-norm of the residual of the linear model used in the Newton solve computation, ||Js+f||. This does not account for line search adjustments to the step length!  <br /></td></tr>
<tr class="separator:a67646a0b5325f4df7e3b0920e0b591d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9594fb984fbc08c249b7763fa9a7eff" id="r_af9594fb984fbc08c249b7763fa9a7eff"><td class="memItemLeft" align="right" valign="top">virtual Teuchos::RCP&lt; <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html">NOX::Abstract::Group</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#af9594fb984fbc08c249b7763fa9a7eff">clone</a> (<a class="el" href="namespace_n_o_x.html#a053a1ab5b2b3bd9546883b949142c592">CopyType</a> type=<a class="el" href="namespace_n_o_x.html#a053a1ab5b2b3bd9546883b949142c592af22ab6417594618436dfab3f95f98261">DeepCopy</a>) const</td></tr>
<tr class="memdesc:af9594fb984fbc08c249b7763fa9a7eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new Group of the same derived type as this one by cloning this one, and return a ref count pointer to the new group.  <br /></td></tr>
<tr class="separator:af9594fb984fbc08c249b7763fa9a7eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969d4dc946960028ea42d2211b0ce129" id="r_a969d4dc946960028ea42d2211b0ce129"><td class="memItemLeft" align="right" valign="top"><a id="a969d4dc946960028ea42d2211b0ce129" name="a969d4dc946960028ea42d2211b0ce129"></a>
virtual Teuchos::RCP&lt; <a class="el" href="class_n_o_x_1_1_epetra_1_1_interface_1_1_required.html">NOX::Epetra::Interface::Required</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getRequiredInterface</b> ()</td></tr>
<tr class="memdesc:a969d4dc946960028ea42d2211b0ce129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the userInterface. <br /></td></tr>
<tr class="separator:a969d4dc946960028ea42d2211b0ce129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9cedcfec5279404e29c134a21c96b6" id="r_a5d9cedcfec5279404e29c134a21c96b6"><td class="memItemLeft" align="right" valign="top"><a id="a5d9cedcfec5279404e29c134a21c96b6" name="a5d9cedcfec5279404e29c134a21c96b6"></a>
virtual Teuchos::RCP&lt; const <a class="el" href="class_n_o_x_1_1_epetra_1_1_linear_system.html">NOX::Epetra::LinearSystem</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getLinearSystem</b> () const</td></tr>
<tr class="memdesc:a5d9cedcfec5279404e29c134a21c96b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Linear System. <br /></td></tr>
<tr class="separator:a5d9cedcfec5279404e29c134a21c96b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb3f1eba4080ef46f13e3d2ab0a445d" id="r_abfb3f1eba4080ef46f13e3d2ab0a445d"><td class="memItemLeft" align="right" valign="top"><a id="abfb3f1eba4080ef46f13e3d2ab0a445d" name="abfb3f1eba4080ef46f13e3d2ab0a445d"></a>
virtual Teuchos::RCP&lt; <a class="el" href="class_n_o_x_1_1_epetra_1_1_linear_system.html">NOX::Epetra::LinearSystem</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getLinearSystem</b> ()</td></tr>
<tr class="memdesc:abfb3f1eba4080ef46f13e3d2ab0a445d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Linear System. <br /></td></tr>
<tr class="separator:abfb3f1eba4080ef46f13e3d2ab0a445d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85b6c500bb0e4949016a4662682cd79" id="r_aa85b6c500bb0e4949016a4662682cd79"><td class="memItemLeft" align="right" valign="top"><a id="aa85b6c500bb0e4949016a4662682cd79" name="aa85b6c500bb0e4949016a4662682cd79"></a>
virtual <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">NOX::Abstract::Group::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>computeJacobianConditionNumber</b> (int maxIters, double tolerance, int krylovSubspaceSize=100, bool printOutput=false)</td></tr>
<tr class="separator:aa85b6c500bb0e4949016a4662682cd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f898845c97c4497af106906a51549b2" id="r_a2f898845c97c4497af106906a51549b2"><td class="memItemLeft" align="right" valign="top"><a id="a2f898845c97c4497af106906a51549b2" name="a2f898845c97c4497af106906a51549b2"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><b>getJacobianConditionNumber</b> () const</td></tr>
<tr class="memdesc:a2f898845c97c4497af106906a51549b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the condition number of the Jacobian matrix. <br /></td></tr>
<tr class="separator:a2f898845c97c4497af106906a51549b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3f1b0a93241367ffe80def2c33ae54" id="r_aba3f1b0a93241367ffe80def2c33ae54"><td class="memItemLeft" align="right" valign="top"><a id="aba3f1b0a93241367ffe80def2c33ae54" name="aba3f1b0a93241367ffe80def2c33ae54"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>disableLinearResidualComputation</b> (const bool disableChoice)</td></tr>
<tr class="memdesc:aba3f1b0a93241367ffe80def2c33ae54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets option to disable linear resid computation. If disabled, this saves on a MatVec per Newton but disallows inexact Newton methods. <br /></td></tr>
<tr class="separator:aba3f1b0a93241367ffe80def2c33ae54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7dde8d4226ddd1c1b8ee63464862192" id="r_ab7dde8d4226ddd1c1b8ee63464862192"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#ab7dde8d4226ddd1c1b8ee63464862192">resetIsValid</a> ()</td></tr>
<tr class="memdesc:ab7dde8d4226ddd1c1b8ee63464862192"><td class="mdescLeft">&#160;</td><td class="mdescRight">resets the isValid flags to false  <br /></td></tr>
<tr class="separator:ab7dde8d4226ddd1c1b8ee63464862192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd7b861a43a17874399c6b6baedcd95" id="r_aacd7b861a43a17874399c6b6baedcd95"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#aacd7b861a43a17874399c6b6baedcd95">logLastLinearSolveStats</a> (<a class="el" href="struct_n_o_x_1_1_solver_stats.html">NOX::SolverStats</a> &amp;stats) const</td></tr>
<tr class="memdesc:aacd7b861a43a17874399c6b6baedcd95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds statistics from last linear solve to the SovlerStats object.  <br /></td></tr>
<tr class="separator:aacd7b861a43a17874399c6b6baedcd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5e1517ffe0318a8089496b5b576c9e" id="r_a1f5e1517ffe0318a8089496b5b576c9e"><td class="memItemLeft" align="right" valign="top"><a id="a1f5e1517ffe0318a8089496b5b576c9e" name="a1f5e1517ffe0318a8089496b5b576c9e"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>computeNormNewtonSolveResidual</b> ()</td></tr>
<tr class="memdesc:a1f5e1517ffe0318a8089496b5b576c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the 2-norm of the residual of the linear model used in the Newton solve computation, ||Js+f||. <br /></td></tr>
<tr class="separator:a1f5e1517ffe0318a8089496b5b576c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_class_n_o_x_1_1_abstract_1_1_group"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_n_o_x_1_1_abstract_1_1_group')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html">NOX::Abstract::Group</a></td></tr>
<tr class="memitem:aa17ab5aa51d466fd6f2d5dc361d5c217 inherit pub_types_class_n_o_x_1_1_abstract_1_1_group" id="r_aa17ab5aa51d466fd6f2d5dc361d5c217"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">ReturnType</a> { <br />
&#160;&#160;<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068">Ok</a>
, <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a302fd2d44af4090ac9615234349db91f">NotDefined</a>
, <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a3724fc7881d6483aac6286e1832468c2">BadDependency</a>
, <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217ae2a529a0ab7b662115a1a2ac809d6c92">NotConverged</a>
, <br />
&#160;&#160;<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a68d385c7e85322afedcc9d4567a25f40">Failed</a>
<br />
 }</td></tr>
<tr class="memdesc:aa17ab5aa51d466fd6f2d5dc361d5c217"><td class="mdescLeft">&#160;</td><td class="mdescRight">The computation of, say, the Newton direction in <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#a0ea79dfbca4bb39b408bc472bcd8853e" title="Compute the Newton direction, using parameters for the linear solve.">computeNewton()</a> may fail in many different ways, so we have included a variety of return codes to describe the failures. Of course, we also have a code for success.  <a href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">More...</a><br /></td></tr>
<tr class="separator:aa17ab5aa51d466fd6f2d5dc361d5c217 inherit pub_types_class_n_o_x_1_1_abstract_1_1_group"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Concrete implementation of <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F-vector,...">NOX::Abstract::Group</a> for Trilinos/Epetra. </p>
<p>This group is set up to use the linear algebra services provided through the Trilinos/Epetra package with AztecOO for the linear solver. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a235d0540d1b7a81f9fe293d2e40f9a83" name="a235d0540d1b7a81f9fe293d2e40f9a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235d0540d1b7a81f9fe293d2e40f9a83">&#9670;&#160;</a></span>Group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Group::Group </td>
          <td>(</td>
          <td class="paramtype">Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>printingParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::RCP&lt; <a class="el" href="class_n_o_x_1_1_epetra_1_1_interface_1_1_required.html">NOX::Epetra::Interface::Required</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html">NOX::Epetra::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>initialGuess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor with NO linear system (VERY LIMITED). </p>
<p>WARNING: If this constructor is used, then methods that require a Jacobian or preconditioning will not be available. You will be limited to simple algorithms like nonlinear-CG with no preconditioning. </p>

<p class="reference">References <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#ab7dde8d4226ddd1c1b8ee63464862192">resetIsValid()</a>.</p>

</div>
</div>
<a id="aed00a22ff227ee2657ae44a5cbcedf7c" name="aed00a22ff227ee2657ae44a5cbcedf7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed00a22ff227ee2657ae44a5cbcedf7c">&#9670;&#160;</a></span>~Group()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Group::~Group </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Reimplemented from <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#a1e6fd1bfff8659f64b0000b6c3e64134">NOX::Abstract::Group</a>.</p>

<p>Reimplemented in <a class="el" href="class_l_o_c_a_1_1_epetra_1_1_group.html#a93c55a29d0307405ae2736e92d0bc7da">LOCA::Epetra::Group</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a47b596500cbe1d9b3f1620506f5b56d5" name="a47b596500cbe1d9b3f1620506f5b56d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b596500cbe1d9b3f1620506f5b56d5">&#9670;&#160;</a></span>applyJacobian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">Abstract::Group::ReturnType</a> Group::applyJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies Jacobian to the given input vector and puts the answer in the result. </p>
<p>Computes </p><p class="formulaDsp">
<picture><source srcset="form_13_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[ v = J u, \]" src="form_13.png" width="41" height="13"/></picture>
</p>
<p> where <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ J$" src="form_4.png" width="8" height="10"/></picture> is the Jacobian, <picture><source srcset="form_14_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ u$" src="form_14.png" width="9" height="6"/></picture> is the input vector, and <picture><source srcset="form_15_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ v$" src="form_15.png" width="8" height="6"/></picture> is the result vector.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a302fd2d44af4090ac9615234349db91f" title="This function is not implemented.">NOX::Abstract::Group::NotDefined</a> - Returned by default implementation in <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F-vector,...">NOX::Abstract::Group</a> </li>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a3724fc7881d6483aac6286e1832468c2" title="Data dependencies not satisfied.">NOX::Abstract::Group::BadDependency</a> - If the Jacobian <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ J$" src="form_4.png" width="8" height="10"/></picture> has not been computed </li>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a68d385c7e85322afedcc9d4567a25f40" title="Any other type of failure.">NOX::Abstract::Group::Failed</a> - If the computation fails </li>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068" title="Computation completed successfully.">NOX::Abstract::Group::Ok</a> - Otherwise </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#a42998d8377e88b11b3c27fbd15aae422">NOX::Abstract::Group</a>.</p>

</div>
</div>
<a id="ade2eb4837a2746131731128516f3b0f2" name="ade2eb4837a2746131731128516f3b0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2eb4837a2746131731128516f3b0f2">&#9670;&#160;</a></span>applyJacobianInverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">Abstract::Group::ReturnType</a> Group::applyJacobianInverse </td>
          <td>(</td>
          <td class="paramtype">Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the inverse of the Jacobian matrix to the given input vector and puts the answer in result. </p>
<p>Computes </p><p class="formulaDsp">
<picture><source srcset="form_17_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[ v = J^{-1} u, \]" src="form_17.png" width="55" height="15"/></picture>
</p>
<p> where <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ J$" src="form_4.png" width="8" height="10"/></picture> is the Jacobian, <picture><source srcset="form_14_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ u$" src="form_14.png" width="9" height="6"/></picture> is the input vector, and <picture><source srcset="form_15_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ v$" src="form_15.png" width="8" height="6"/></picture> is the result vector.</p>
<p>The "Tolerance" parameter specifies that the solution should be such that  </p><p class="formulaDsp">
<picture><source srcset="form_18_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\frac{\| J v - u \|_2}{\max \{ 1, \|u\|_2\} } &lt; \mbox{Tolerance}
\]" src="form_18.png" width="145" height="31"/></picture>
</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a302fd2d44af4090ac9615234349db91f" title="This function is not implemented.">NOX::Abstract::Group::NotDefined</a> - Returned by default implementation in <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F-vector,...">NOX::Abstract::Group</a> </li>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a3724fc7881d6483aac6286e1832468c2" title="Data dependencies not satisfied.">NOX::Abstract::Group::BadDependency</a> - If <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ J$" src="form_4.png" width="8" height="10"/></picture> has not been computed </li>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217ae2a529a0ab7b662115a1a2ac809d6c92" title="Unable to satisfy convergence criteria.">NOX::Abstract::Group::NotConverged</a> - If the linear solve fails to satisfy the "Tolerance" specified in <code>params</code> </li>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a68d385c7e85322afedcc9d4567a25f40" title="Any other type of failure.">NOX::Abstract::Group::Failed</a> - If the computation fails </li>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068" title="Computation completed successfully.">NOX::Abstract::Group::Ok</a> - Otherwise </li>
</ul>
</dd></dl>
<p>The parameter "Tolerance" may be added/modified in the list of parameters - this is the ideal solution tolerance for an iterative linear solve. </p>

<p>Reimplemented from <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa85242fccabcfe99c6cb66b07a7e57eb">NOX::Abstract::Group</a>.</p>

<p class="reference">References <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a7b165f0bbeda5df078458c77811a9f88">applyJacobianInverse()</a>.</p>

</div>
</div>
<a id="a7b165f0bbeda5df078458c77811a9f88" name="a7b165f0bbeda5df078458c77811a9f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b165f0bbeda5df078458c77811a9f88">&#9670;&#160;</a></span>applyJacobianInverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">Abstract::Group::ReturnType</a> Group::applyJacobianInverse </td>
          <td>(</td>
          <td class="paramtype">Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html">NOX::Epetra::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html">NOX::Epetra::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment"> \brief Applies the inverse of the Jacobian matrix to the given
 input vector and puts the answer in result.

 Computes
 \f[ v = J^{-1} u, \f]
 where \f$ J\f$ is the Jacobian, \f$ u\f$ is the input vector, and \f$ v\f$ is
</pre><p> the result vector. </p><pre class="fragment"> The "Tolerance" parameter specifies that the
 solution should be such that
 \f[
 \frac{\| J v - u \|_2}{\max \{ 1, \|u\|_2\} } &lt; \mbox{Tolerance}
 \f]

 \return
 &lt;ul&gt;
 &lt;li&gt; NOX::Abstract::Group::NotDefined - Returned by default
      implementation in NOX::Abstract::Group
 &lt;li&gt; NOX::Abstract::Group::BadDependency - If \f$ J\f$ has not been computed
 &lt;li&gt; NOX::Abstract::Group::NotConverged - If the linear solve
      fails to satisfy the "Tolerance" specified in \c params
 &lt;li&gt; NOX::Abstract::Group::Failed - If the computation fails
 &lt;li&gt; NOX::Abstract::Group::Ok - Otherwise
 &lt;/ul&gt;

 The parameter "Tolerance" may be added/modified in the list of
 parameters - this is the ideal solution tolerance for an iterative
 linear solve.

 The parameter "Reuse Preconditioner" is a boolean that tells the group to turn off control of preconditioner recalculation.  This is a dangerous flag but can really speed the computations if the user knows what they are doing.  Toggling this flag is left to the user (ideally it should be done through a status test).  Defaults to false.
</pre> 
<p class="reference">References <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a3724fc7881d6483aac6286e1832468c2">NOX::Abstract::Group::BadDependency</a>, <a class="el" href="class_n_o_x_1_1_shared_object.html#a507ae3724d071afe423d0ea88f818827">NOX::SharedObject&lt; Object, Owner &gt;::getObject()</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#ab4ed3521b30ced87988cf947ef7ddc49">isJacobian()</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a1ba882f748d518d0a3595329beb9fde3">isPreconditioner()</a>, <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217ae2a529a0ab7b662115a1a2ac809d6c92">NOX::Abstract::Group::NotConverged</a>, <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068">NOX::Abstract::Group::Ok</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_linear_system.html#ae34f9249eed5ec99227b53885fd067cea48321244a17afb664cdd75bd53a8a7b6">NOX::Epetra::LinearSystem::PRPT_REBUILD</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_linear_system.html#ae34f9249eed5ec99227b53885fd067cea9d23a1b901c58cebfe6c62cf7fce3ec4">NOX::Epetra::LinearSystem::PRPT_RECOMPUTE</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_linear_system.html#ae34f9249eed5ec99227b53885fd067ceab92123e13e1eaac1cdf0b36dd14dff13">NOX::Epetra::LinearSystem::PRPT_REUSE</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#abcfe5a323d9ce273e0eb8dbf5bc69741">sharedLinearSystem</a>, and <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a7ebb1b6ecf2d328428fcbd190f098ea2">xVector</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#ade2eb4837a2746131731128516f3b0f2">applyJacobianInverse()</a>, and <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a2066b02281a058f146c2aeafd654f7fe">computeNewton()</a>.</p>

</div>
</div>
<a id="ad30d543c58f3044ca9694cde09ceaf60" name="ad30d543c58f3044ca9694cde09ceaf60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30d543c58f3044ca9694cde09ceaf60">&#9670;&#160;</a></span>applyJacobianTranspose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">Abstract::Group::ReturnType</a> Group::applyJacobianTranspose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies Jacobian-Transpose to the given input vector and puts the answer in the result. </p>
<p>Computes </p><p class="formulaDsp">
<picture><source srcset="form_16_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[ v = J^T u, \]" src="form_16.png" width="50" height="15"/></picture>
</p>
<p> where <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ J$" src="form_4.png" width="8" height="10"/></picture> is the Jacobian, <picture><source srcset="form_14_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ u$" src="form_14.png" width="9" height="6"/></picture> is the input vector, and <picture><source srcset="form_15_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ v$" src="form_15.png" width="8" height="6"/></picture> is the result vector.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a302fd2d44af4090ac9615234349db91f" title="This function is not implemented.">NOX::Abstract::Group::NotDefined</a> - Returned by default implementation in <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F-vector,...">NOX::Abstract::Group</a> </li>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a3724fc7881d6483aac6286e1832468c2" title="Data dependencies not satisfied.">NOX::Abstract::Group::BadDependency</a> - If <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ J$" src="form_4.png" width="8" height="10"/></picture> has not been computed </li>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a68d385c7e85322afedcc9d4567a25f40" title="Any other type of failure.">NOX::Abstract::Group::Failed</a> - If the computation fails </li>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068" title="Computation completed successfully.">NOX::Abstract::Group::Ok</a> - Otherwise </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#a47d4233c05cc25501a3e2d3d8b5b942a">NOX::Abstract::Group</a>.</p>

</div>
</div>
<a id="ab0f6e860350d39f53a9013baf9936b51" name="ab0f6e860350d39f53a9013baf9936b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f6e860350d39f53a9013baf9936b51">&#9670;&#160;</a></span>applyRightPreconditioning()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">Abstract::Group::ReturnType</a> Group::applyRightPreconditioning </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useTranspose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply right preconditiong to the given input vector. </p>
<p>Let <picture><source srcset="form_19_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ M$" src="form_19.png" width="14" height="10"/></picture> be a right preconditioner for the Jacobian <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ J$" src="form_4.png" width="8" height="10"/></picture>; in other words, <picture><source srcset="form_19_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ M$" src="form_19.png" width="14" height="10"/></picture> is a matrix such that </p><p class="formulaDsp">
<picture><source srcset="form_20_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[ JM \approx I. \]" src="form_20.png" width="46" height="10"/></picture>
</p>
<p>Compute </p><p class="formulaDsp">
<picture><source srcset="form_21_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[ u = M^{-1} v, \]" src="form_21.png" width="61" height="15"/></picture>
</p>
<p> where <picture><source srcset="form_14_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ u$" src="form_14.png" width="9" height="6"/></picture> is the input vector and <picture><source srcset="form_15_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ v$" src="form_15.png" width="8" height="6"/></picture> is the result vector.</p>
<p>If <em>useTranspose</em> is true, then the transpose of the preconditioner is applied: </p><p class="formulaDsp">
<picture><source srcset="form_22_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[ u = {M^{-1}}^T v, \]" src="form_22.png" width="69" height="18"/></picture>
</p>
<p> The transpose preconditioner is currently only required for Tensor methods.</p>
<p>The "Tolerance" parameter specifies that the solution should be such that  </p><p class="formulaDsp">
<picture><source srcset="form_23_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\frac{\| M v - u \|_2}{\max \{ 1, \|u\|_2\} } &lt; \mbox{Tolerance}
\]" src="form_23.png" width="145" height="31"/></picture>
</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a302fd2d44af4090ac9615234349db91f" title="This function is not implemented.">NOX::Abstract::Group::NotDefined</a> - Returned by default implementation in <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F-vector,...">NOX::Abstract::Group</a> </li>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217ae2a529a0ab7b662115a1a2ac809d6c92" title="Unable to satisfy convergence criteria.">NOX::Abstract::Group::NotConverged</a> - If the linear solve fails to satisfy the "Tolerance" specified in <code>params</code> </li>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a68d385c7e85322afedcc9d4567a25f40" title="Any other type of failure.">NOX::Abstract::Group::Failed</a> - If the computation fails </li>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068" title="Computation completed successfully.">NOX::Abstract::Group::Ok</a> - Otherwise </li>
</ul>
</dd></dl>
<p>The parameters are from the "Linear %Solver" sublist of the "Direction" sublist that is passed to solver during construction. </p>

<p>Reimplemented from <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#a154e8547559b81b77027cd98b927582a">NOX::Abstract::Group</a>.</p>

</div>
</div>
<a id="af9594fb984fbc08c249b7763fa9a7eff" name="af9594fb984fbc08c249b7763fa9a7eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9594fb984fbc08c249b7763fa9a7eff">&#9670;&#160;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html">NOX::Abstract::Group</a> &gt; Group::clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_n_o_x.html#a053a1ab5b2b3bd9546883b949142c592">CopyType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="namespace_n_o_x.html#a053a1ab5b2b3bd9546883b949142c592af22ab6417594618436dfab3f95f98261">DeepCopy</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new Group of the same derived type as this one by cloning this one, and return a ref count pointer to the new group. </p>
<p>If type is <a class="el" href="namespace_n_o_x.html#a053a1ab5b2b3bd9546883b949142c592af22ab6417594618436dfab3f95f98261" title="Copy object including all data.">NOX::DeepCopy</a>, then we need to create an exact replica of "this". Otherwise, if type is <a class="el" href="namespace_n_o_x.html#a053a1ab5b2b3bd9546883b949142c592a9e3ccd93557182819f2dbc8d7f5c7dee" title="Copy the shape of the object only.">NOX::ShapeCopy</a>, we need only replicate the shape of "this" (only the memory is allocated, the values are not copied into the vectors and Jacobian). Returns NULL if clone is not supported.</p>
<dl class="section note"><dt>Note</dt><dd>Any <em>shared data</em> should have its ownership transfered to this group from the source for a <a class="el" href="namespace_n_o_x.html#a053a1ab5b2b3bd9546883b949142c592af22ab6417594618436dfab3f95f98261" title="Copy object including all data.">NOX::DeepCopy</a>. </dd></dl>

<p>Implements <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#a09c8db18731ba80e5d656f77b697eb17">NOX::Abstract::Group</a>.</p>

<p>Reimplemented in <a class="el" href="class_l_o_c_a_1_1_epetra_1_1_group.html#acc0b45543769aab7893aefa075c83450">LOCA::Epetra::Group</a>.</p>

</div>
</div>
<a id="aef10f7019097fe83ea055dcf29df0402" name="aef10f7019097fe83ea055dcf29df0402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef10f7019097fe83ea055dcf29df0402">&#9670;&#160;</a></span>computeF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">Abstract::Group::ReturnType</a> Group::computeF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute and store F(x). </p>
<dl class="section note"><dt>Note</dt><dd>It's generally useful to also compute and store the 2-norm of F(x) at this point for later access by the <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a63875a84603bca3d1e2e7c762bf82e9f" title="Return 2-norm of F(x).">getNormF()</a> function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a68d385c7e85322afedcc9d4567a25f40" title="Any other type of failure.">NOX::Abstract::Group::Failed</a> - If the computation fails in any way </li>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068" title="Computation completed successfully.">NOX::Abstract::Group::Ok</a> - Otherwise </li>
</ul>
</dd></dl>

<p>Implements <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#afb0a17ceea78a12923bb9932fb0c7182">NOX::Abstract::Group</a>.</p>

<p>Reimplemented in <a class="el" href="class_l_o_c_a_1_1_epetra_1_1_group.html#a0b3a8b4bdc4446a10481f8ad1e3c8f66">LOCA::Epetra::Group</a>.</p>

<p class="reference">References <a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html#acd76cacb729373d1934d7c42469a71c8">NOX::Epetra::Vector::getEpetraVector()</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#aa7c7b9206bc1516eb334f0ce0f2e5139">isF()</a>, <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068">NOX::Abstract::Group::Ok</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_interface_1_1_required.html#ac80d341073c0df754fb80179f6a2ae0dad0eabcb24fe8529b1836be69ad65e156">NOX::Epetra::Interface::Required::Residual</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a20f29786ff4d1f5d85d21f0bb6c3c17a">RHSVector</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a35678c6f63a1cb5348b48a84694334eb">userInterfacePtr</a>, and <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a7ebb1b6ecf2d328428fcbd190f098ea2">xVector</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_l_o_c_a_1_1_epetra_1_1_group.html#a0b3a8b4bdc4446a10481f8ad1e3c8f66">LOCA::Epetra::Group::computeF()</a>.</p>

</div>
</div>
<a id="a2aaa7683fb5f41bffec408a185e000bb" name="a2aaa7683fb5f41bffec408a185e000bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aaa7683fb5f41bffec408a185e000bb">&#9670;&#160;</a></span>computeGradient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">Abstract::Group::ReturnType</a> Group::computeGradient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute and store gradient. </p>
<p>We can pose the nonlinear equation problem <picture><source srcset="form_6_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F(x) = 0$" src="form_6.png" width="49" height="14"/></picture> as an optimization problem as follows:  </p><p class="formulaDsp">
<picture><source srcset="form_7_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\min f(x) \equiv \frac{1}{2} \|F(x)\|_2^2.
\]" src="form_7.png" width="121" height="26"/></picture>
</p>
<p>In that case, the <b>gradient</b> (of <picture><source srcset="form_8_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ f$" src="form_8.png" width="8" height="13"/></picture>) is defined as  </p><p class="formulaDsp">
<picture><source srcset="form_9_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
g \equiv J^T F.
\]" src="form_9.png" width="50" height="15"/></picture>
</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a302fd2d44af4090ac9615234349db91f" title="This function is not implemented.">NOX::Abstract::Group::NotDefined</a> - Returned by default implementation in <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F-vector,...">NOX::Abstract::Group</a> </li>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a3724fc7881d6483aac6286e1832468c2" title="Data dependencies not satisfied.">NOX::Abstract::Group::BadDependency</a> - If either <picture><source srcset="form_10_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F$" src="form_10.png" width="10" height="10"/></picture> or <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ J$" src="form_4.png" width="8" height="10"/></picture> has not been computed </li>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a68d385c7e85322afedcc9d4567a25f40" title="Any other type of failure.">NOX::Abstract::Group::Failed</a> - If the computation fails in any other way </li>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068" title="Computation completed successfully.">NOX::Abstract::Group::Ok</a> - Otherwise </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#a469ffcb3439a045b386c4ee2f3e8b9ec">NOX::Abstract::Group</a>.</p>

<p class="reference">References <a class="el" href="class_n_o_x_1_1_shared_object.html#a507ae3724d071afe423d0ea88f818827">NOX::SharedObject&lt; Object, Owner &gt;::getObject()</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#aa4209dfbe651ff2b9d0a6af0fe34d5b4">gradVector</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#aa7c7b9206bc1516eb334f0ce0f2e5139">isF()</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#ab1814ca3eef1cf58cddf7031ffb4c50e">isGradient()</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#ab4ed3521b30ced87988cf947ef7ddc49">isJacobian()</a>, <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068">NOX::Abstract::Group::Ok</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a20f29786ff4d1f5d85d21f0bb6c3c17a">RHSVector</a>, and <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#abcfe5a323d9ce273e0eb8dbf5bc69741">sharedLinearSystem</a>.</p>

</div>
</div>
<a id="abe2870acb70eca31d6c56b27a960a16f" name="abe2870acb70eca31d6c56b27a960a16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2870acb70eca31d6c56b27a960a16f">&#9670;&#160;</a></span>computeJacobian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">Abstract::Group::ReturnType</a> Group::computeJacobian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute and store Jacobian. </p>
<p>Recall that  </p><p class="formulaDsp">
<picture><source srcset="form_3_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
F(x) = \left[ \begin{array}{c} F_1(x) \\ F_2(x) \\ \vdots \\ F_n(x) \\ \end{array} \right].
\]" src="form_3.png" width="109" height="68"/></picture>
</p>
<p>The <b>Jacobian</b> is denoted by <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ J$" src="form_4.png" width="8" height="10"/></picture> and defined by  </p><p class="formulaDsp">
<picture><source srcset="form_5_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
J_{ij} = \frac{\partial F_i}{\partial x_j} (x).
\]" src="form_5.png" width="74" height="31"/></picture>
</p>
<dl class="section note"><dt>Note</dt><dd>If this is a <em>shared object</em>, this group should take ownership of the Jacobian before it computes it.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a302fd2d44af4090ac9615234349db91f" title="This function is not implemented.">NOX::Abstract::Group::NotDefined</a> - Returned by default implementation in <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F-vector,...">NOX::Abstract::Group</a> </li>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a68d385c7e85322afedcc9d4567a25f40" title="Any other type of failure.">NOX::Abstract::Group::Failed</a> - If the computation fails in any other way </li>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068" title="Computation completed successfully.">NOX::Abstract::Group::Ok</a> - Otherwise </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#ab763d80297f77eb10c78e88ddb00df6b">NOX::Abstract::Group</a>.</p>

<p>Reimplemented in <a class="el" href="class_l_o_c_a_1_1_epetra_1_1_group.html#a034c7612859f31f606acbdba0f182fde">LOCA::Epetra::Group</a>.</p>

<p class="reference">References <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#abe2870acb70eca31d6c56b27a960a16f">computeJacobian()</a>, <a class="el" href="class_n_o_x_1_1_shared_object.html#a507ae3724d071afe423d0ea88f818827">NOX::SharedObject&lt; Object, Owner &gt;::getObject()</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#ab4ed3521b30ced87988cf947ef7ddc49">isJacobian()</a>, <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068">NOX::Abstract::Group::Ok</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#abcfe5a323d9ce273e0eb8dbf5bc69741">sharedLinearSystem</a>, and <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a7ebb1b6ecf2d328428fcbd190f098ea2">xVector</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#abe2870acb70eca31d6c56b27a960a16f">computeJacobian()</a>, and <a class="el" href="class_l_o_c_a_1_1_epetra_1_1_group.html#a034c7612859f31f606acbdba0f182fde">LOCA::Epetra::Group::computeJacobian()</a>.</p>

</div>
</div>
<a id="a2066b02281a058f146c2aeafd654f7fe" name="a2066b02281a058f146c2aeafd654f7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2066b02281a058f146c2aeafd654f7fe">&#9670;&#160;</a></span>computeNewton()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">Abstract::Group::ReturnType</a> Group::computeNewton </td>
          <td>(</td>
          <td class="paramtype">Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Newton direction, using parameters for the linear solve. </p>
<p>The <b>Newton direction</b> is the solution, s, of  </p><p class="formulaDsp">
<picture><source srcset="form_11_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
J s = -F.
\]" src="form_11.png" width="51" height="10"/></picture>
</p>
<p>The parameters are from the "Linear %Solver" sublist of the "Direction" sublist that is passed to solver during construction.</p>
<p>The "Tolerance" parameter may be added/modified in the sublist of "Linear Solver" parameters that is passed into this function. The solution should be such that  </p><p class="formulaDsp">
<picture><source srcset="form_12_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
\frac{\| J s - (-F) \|_2}{\max \{ 1, \|F\|_2\} } &lt; \mbox{Tolerance}
\]" src="form_12.png" width="148" height="31"/></picture>
</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a302fd2d44af4090ac9615234349db91f" title="This function is not implemented.">NOX::Abstract::Group::NotDefined</a> - Returned by default implementation in <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F-vector,...">NOX::Abstract::Group</a> </li>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a3724fc7881d6483aac6286e1832468c2" title="Data dependencies not satisfied.">NOX::Abstract::Group::BadDependency</a> - If either <picture><source srcset="form_10_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F$" src="form_10.png" width="10" height="10"/></picture> or <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ J$" src="form_4.png" width="8" height="10"/></picture> has not been computed </li>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217ae2a529a0ab7b662115a1a2ac809d6c92" title="Unable to satisfy convergence criteria.">NOX::Abstract::Group::NotConverged</a> - If the linear solve fails to satisfy the "Tolerance" specified in <code>params</code> </li>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a68d385c7e85322afedcc9d4567a25f40" title="Any other type of failure.">NOX::Abstract::Group::Failed</a> - If the computation fails in any other way </li>
<li>
<a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068" title="Computation completed successfully.">NOX::Abstract::Group::Ok</a> - Otherwise </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#a0ea79dfbca4bb39b408bc472bcd8853e">NOX::Abstract::Group</a>.</p>

<p class="reference">References <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a7b165f0bbeda5df078458c77811a9f88">applyJacobianInverse()</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a1f5e1517ffe0318a8089496b5b576c9e">computeNormNewtonSolveResidual()</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html#a7f81a9671cfe5a8439119a03024b9f6c">NOX::Epetra::Vector::init()</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#aa7c7b9206bc1516eb334f0ce0f2e5139">isF()</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#ab4ed3521b30ced87988cf947ef7ddc49">isJacobian()</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#af349ae1b320dd9b5f720c33699ee6e3e">isNewton()</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a456bbd737c3713b8234c2f4ab48e23d9">NewtonVector</a>, <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068">NOX::Abstract::Group::Ok</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a20f29786ff4d1f5d85d21f0bb6c3c17a">RHSVector</a>, and <a class="el" href="class_n_o_x_1_1_epetra_1_1_vector.html#a2c4de1d927c961e5574be51533c7f568">NOX::Epetra::Vector::scale()</a>.</p>

</div>
</div>
<a id="a494995fa24d49afedaa319089eb5b9ab" name="a494995fa24d49afedaa319089eb5b9ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a494995fa24d49afedaa319089eb5b9ab">&#9670;&#160;</a></span>computeX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Group::computeX </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html">NOX::Abstract::Group</a> &amp;&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute x = grp.x + step * d. </p>
<p>Let <picture><source srcset="form_0_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ x$" src="form_0.png" width="8" height="6"/></picture> denote this group's solution vector. Let <picture><source srcset="form_1_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\hat x$" src="form_1.png" width="8" height="10"/></picture> denote the result of grp.getX(). Then set  </p><p class="formulaDsp">
<picture><source srcset="form_2_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[
x = \hat x + \mbox{step} \; d.
\]" src="form_2.png" width="81" height="13"/></picture>
</p>
<dl class="section note"><dt>Note</dt><dd>This should invalidate the function value, Jacobian, gradient, and Newton direction.</dd>
<dd>
Throw an error if the copy fails.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this object </dd></dl>

<p>Implements <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#a567a5000e48967e6bbbe59daae97ea9d">NOX::Abstract::Group</a>.</p>

</div>
</div>
<a id="afe8a67ec663e8c4ea74d39ccc1d9d765" name="afe8a67ec663e8c4ea74d39ccc1d9d765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8a67ec663e8c4ea74d39ccc1d9d765">&#9670;&#160;</a></span>getF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">Abstract::Vector</a> &amp; Group::getF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return F(x) </p>

<p>Implements <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa0674a7c4392da14f7b3fbd5ac7a0cce">NOX::Abstract::Group</a>.</p>

<p class="reference">References <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#aa7c7b9206bc1516eb334f0ce0f2e5139">isF()</a>, and <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a20f29786ff4d1f5d85d21f0bb6c3c17a">RHSVector</a>.</p>

</div>
</div>
<a id="aec94e8872c58836a721f240737afd3bf" name="aec94e8872c58836a721f240737afd3bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec94e8872c58836a721f240737afd3bf">&#9670;&#160;</a></span>getFPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Teuchos::RCP&lt; const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &gt; NOX::Epetra::Group::getFPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return RCP to F(x) </p>

<p>Implements <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#a7bbe10d8111428bdf294f325e5cb7328">NOX::Abstract::Group</a>.</p>

<p class="reference">References <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#ab2c778c58708b3a53a38234963aa05fa">RHSVectorPtr</a>.</p>

</div>
</div>
<a id="a67ca4b9a5bb33cbad1b11eedb93c35db" name="a67ca4b9a5bb33cbad1b11eedb93c35db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ca4b9a5bb33cbad1b11eedb93c35db">&#9670;&#160;</a></span>getGradient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">Abstract::Vector</a> &amp; Group::getGradient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return gradient. </p>

<p>Implements <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#a1957fb41818e609bfa8056ab477eb7bb">NOX::Abstract::Group</a>.</p>

<p class="reference">References <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#aa4209dfbe651ff2b9d0a6af0fe34d5b4">gradVector</a>, and <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#ab1814ca3eef1cf58cddf7031ffb4c50e">isGradient()</a>.</p>

</div>
</div>
<a id="aa5739654db4b905cdd72dbeb719b87aa" name="aa5739654db4b905cdd72dbeb719b87aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5739654db4b905cdd72dbeb719b87aa">&#9670;&#160;</a></span>getGradientPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Teuchos::RCP&lt; const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &gt; NOX::Epetra::Group::getGradientPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return RCP to gradient. </p>

<p>Implements <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa1ced5670425d8479d1114d819eaa0e7">NOX::Abstract::Group</a>.</p>

<p class="reference">References <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a63b22e8b615a59dbdb9b981771dea8f2">gradVectorPtr</a>.</p>

</div>
</div>
<a id="ab5aaea15cd1b2fb6af4200c730b627ef" name="ab5aaea15cd1b2fb6af4200c730b627ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5aaea15cd1b2fb6af4200c730b627ef">&#9670;&#160;</a></span>getNewton()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">Abstract::Vector</a> &amp; Group::getNewton </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return Newton direction. </p>

<p>Implements <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#a59d4d0197fcfdb40a14cf9972a03eba8">NOX::Abstract::Group</a>.</p>

<p class="reference">References <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#af349ae1b320dd9b5f720c33699ee6e3e">isNewton()</a>, and <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a456bbd737c3713b8234c2f4ab48e23d9">NewtonVector</a>.</p>

</div>
</div>
<a id="a0739d9bc51df58e1162f4a963ac5048b" name="a0739d9bc51df58e1162f4a963ac5048b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0739d9bc51df58e1162f4a963ac5048b">&#9670;&#160;</a></span>getNewtonPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Teuchos::RCP&lt; const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &gt; NOX::Epetra::Group::getNewtonPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return RCP to Newton direction. </p>

<p>Implements <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa7d5cce406fcedf0308b93b2af7e0628">NOX::Abstract::Group</a>.</p>

<p class="reference">References <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a593c67dc05a4dbf7de6e52b0a68b6c48">NewtonVectorPtr</a>.</p>

</div>
</div>
<a id="a63875a84603bca3d1e2e7c762bf82e9f" name="a63875a84603bca3d1e2e7c762bf82e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63875a84603bca3d1e2e7c762bf82e9f">&#9670;&#160;</a></span>getNormF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Group::getNormF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 2-norm of F(x). </p>
<p>In other words, </p><p class="formulaDsp">
<picture><source srcset="form_24_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[ \sqrt{\sum_{i=1}^n F_i^2} \]" src="form_24.png" width="49" height="46"/></picture>
</p>
 
<p>Implements <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#a83eecd9cdbff67a78bf71df3d0816081">NOX::Abstract::Group</a>.</p>

<p class="reference">References <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#aa7c7b9206bc1516eb334f0ce0f2e5139">isF()</a>, and <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#ab2c778c58708b3a53a38234963aa05fa">RHSVectorPtr</a>.</p>

</div>
</div>
<a id="a67646a0b5325f4df7e3b0920e0b591d7" name="a67646a0b5325f4df7e3b0920e0b591d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67646a0b5325f4df7e3b0920e0b591d7">&#9670;&#160;</a></span>getNormLastLinearSolveResidual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217">Abstract::Group::ReturnType</a> NOX::Epetra::Group::getNormLastLinearSolveResidual </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>residual</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the 2-norm of the residual of the linear model used in the Newton solve computation, ||Js+f||. This does not account for line search adjustments to the step length! </p>

<p>Reimplemented from <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#ad1d38546018154b4e7cf9ddd74557279">NOX::Abstract::Group</a>.</p>

<p class="reference">References <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217a3724fc7881d6483aac6286e1832468c2">NOX::Abstract::Group::BadDependency</a>, <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aa17ab5aa51d466fd6f2d5dc361d5c217aac87f53fa40531f3330d4f5be59c3068">NOX::Abstract::Group::Ok</a>, and <a class="el" href="class_n_o_x_1_1_utils.html#ab30f60438649426b2490e4646754c856a460d575464fc6e5c6fd43abd62bc7cf3">NOX::Utils::Warning</a>.</p>

</div>
</div>
<a id="a3b8f9860818e4f33c526bd6afa3d55a6" name="a3b8f9860818e4f33c526bd6afa3d55a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8f9860818e4f33c526bd6afa3d55a6">&#9670;&#160;</a></span>getX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">Abstract::Vector</a> &amp; Group::getX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return solution vector. </p>

<p>Implements <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#a1244ddbfb3fe8402ffb6a3c5a8d43c12">NOX::Abstract::Group</a>.</p>

<p class="reference">References <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a7ebb1b6ecf2d328428fcbd190f098ea2">xVector</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_l_o_c_a_1_1_epetra_1_1_model_evaluator_interface.html#ac38d437b699911dc30e9e46a21e45b29">LOCA::Epetra::ModelEvaluatorInterface::postProcessContinuationStep()</a>.</p>

</div>
</div>
<a id="aaac6fcaa3b35fcb895095a73f281e6d2" name="aaac6fcaa3b35fcb895095a73f281e6d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac6fcaa3b35fcb895095a73f281e6d2">&#9670;&#160;</a></span>getXPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Teuchos::RCP&lt; const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &gt; NOX::Epetra::Group::getXPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return RCP to solution vector. </p>

<p>Implements <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#a58dfd31d549181866b51d55050b714eb">NOX::Abstract::Group</a>.</p>

<p class="reference">References <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#aeeacb5c18a2e60e78fd9a891c945cd34">xVectorPtr</a>.</p>

</div>
</div>
<a id="aa7c7b9206bc1516eb334f0ce0f2e5139" name="aa7c7b9206bc1516eb334f0ce0f2e5139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c7b9206bc1516eb334f0ce0f2e5139">&#9670;&#160;</a></span>isF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Group::isF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if F is valid. </p>

<p>Implements <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aaa2f67073452aaee10f1120cd6d242a3">NOX::Abstract::Group</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#aef10f7019097fe83ea055dcf29df0402">computeF()</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a2aaa7683fb5f41bffec408a185e000bb">computeGradient()</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a2066b02281a058f146c2aeafd654f7fe">computeNewton()</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#afe8a67ec663e8c4ea74d39ccc1d9d765">getF()</a>, and <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a63875a84603bca3d1e2e7c762bf82e9f">getNormF()</a>.</p>

</div>
</div>
<a id="ab1814ca3eef1cf58cddf7031ffb4c50e" name="ab1814ca3eef1cf58cddf7031ffb4c50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1814ca3eef1cf58cddf7031ffb4c50e">&#9670;&#160;</a></span>isGradient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Group::isGradient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the gradient is valid. </p>
<dl class="section note"><dt>Note</dt><dd>Default implementation in <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F-vector,...">NOX::Abstract::Group</a> returns false. </dd></dl>

<p>Reimplemented from <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#acba82791d635dc87013ccb73a01124af">NOX::Abstract::Group</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a2aaa7683fb5f41bffec408a185e000bb">computeGradient()</a>, and <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a67ca4b9a5bb33cbad1b11eedb93c35db">getGradient()</a>.</p>

</div>
</div>
<a id="ab4ed3521b30ced87988cf947ef7ddc49" name="ab4ed3521b30ced87988cf947ef7ddc49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ed3521b30ced87988cf947ef7ddc49">&#9670;&#160;</a></span>isJacobian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Group::isJacobian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the Jacobian is valid. </p>
<dl class="section note"><dt>Note</dt><dd>Default implementation in <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F-vector,...">NOX::Abstract::Group</a> returns false. </dd></dl>

<p>Reimplemented from <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#a6ce6cf0e1662c0c7bf7c472739b7a8d1">NOX::Abstract::Group</a>.</p>

<p class="reference">References <a class="el" href="class_n_o_x_1_1_shared_object.html#a97ee0d330df6b62798cca21019548921">NOX::SharedObject&lt; Object, Owner &gt;::isOwner()</a>, and <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#abcfe5a323d9ce273e0eb8dbf5bc69741">sharedLinearSystem</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a7b165f0bbeda5df078458c77811a9f88">applyJacobianInverse()</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a2aaa7683fb5f41bffec408a185e000bb">computeGradient()</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#abe2870acb70eca31d6c56b27a960a16f">computeJacobian()</a>, and <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a2066b02281a058f146c2aeafd654f7fe">computeNewton()</a>.</p>

</div>
</div>
<a id="af349ae1b320dd9b5f720c33699ee6e3e" name="af349ae1b320dd9b5f720c33699ee6e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af349ae1b320dd9b5f720c33699ee6e3e">&#9670;&#160;</a></span>isNewton()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Group::isNewton </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the Newton direction is valid. </p>
<dl class="section note"><dt>Note</dt><dd>Default implementation in <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html" title="NOX pure abstract interface to a &quot;group&quot;; i.e., a solution vector and the corresponding F-vector,...">NOX::Abstract::Group</a> returns false. </dd></dl>

<p>Reimplemented from <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#a2d5d349096006a09a74daee1a9a3886c">NOX::Abstract::Group</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a2066b02281a058f146c2aeafd654f7fe">computeNewton()</a>, and <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#ab5aaea15cd1b2fb6af4200c730b627ef">getNewton()</a>.</p>

</div>
</div>
<a id="aacd7b861a43a17874399c6b6baedcd95" name="aacd7b861a43a17874399c6b6baedcd95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd7b861a43a17874399c6b6baedcd95">&#9670;&#160;</a></span>logLastLinearSolveStats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Group::logLastLinearSolveStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_o_x_1_1_solver_stats.html">NOX::SolverStats</a> &amp;&#160;</td>
          <td class="paramname"><em>stats</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds statistics from last linear solve to the SovlerStats object. </p>

<p>Reimplemented from <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#a42dddac0f4ed5d8633130ef3b4f1fe2e">NOX::Abstract::Group</a>.</p>

</div>
</div>
<a id="a461641a567f337a7aa3249b6dfdd8d69" name="a461641a567f337a7aa3249b6dfdd8d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461641a567f337a7aa3249b6dfdd8d69">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html">Abstract::Group</a> &amp; Group::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html">NOX::Abstract::Group</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the source group into this group. </p>
<dl class="section note"><dt>Note</dt><dd>Any <em>shared data</em> owned by the source should have its ownership transfered to this group. This may result in a secret modification to the source object. </dd></dl>

<p>Implements <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#ab1e51369cc13c52c1f10fc66c34552e0">NOX::Abstract::Group</a>.</p>

<p>Reimplemented in <a class="el" href="class_l_o_c_a_1_1_epetra_1_1_group.html#a60791c77710eab832624b0b2791aa3b8">LOCA::Epetra::Group</a>.</p>

<p class="reference">References <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a461641a567f337a7aa3249b6dfdd8d69">operator=()</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_l_o_c_a_1_1_epetra_1_1_group.html#a5087510740be731b35d98192c99aae60">LOCA::Epetra::Group::operator=()</a>, and <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a461641a567f337a7aa3249b6dfdd8d69">operator=()</a>.</p>

</div>
</div>
<a id="a74ede301b13e5617b905b2234fe74ab2" name="a74ede301b13e5617b905b2234fe74ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ede301b13e5617b905b2234fe74ab2">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html">Abstract::Group</a> &amp; Group::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html">NOX::Epetra::Group</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a461641a567f337a7aa3249b6dfdd8d69" title="Copies the source group into this group.">operator=(const NOX::Abstract::Group&amp;)</a>;. </p>

<p>Reimplemented in <a class="el" href="class_l_o_c_a_1_1_epetra_1_1_group.html#a0f1a18cfeb7e556dfdd0673ac3622b71">LOCA::Epetra::Group</a>.</p>

<p class="reference">References <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#aeb5c2aa5dc41fe1e1215c67427f03911">conditionNumber</a>, <a class="el" href="class_n_o_x_1_1_shared_object.html#a507ae3724d071afe423d0ea88f818827">NOX::SharedObject&lt; Object, Owner &gt;::getObject()</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#aa4209dfbe651ff2b9d0a6af0fe34d5b4">gradVector</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a456bbd737c3713b8234c2f4ab48e23d9">NewtonVector</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a1af24396fb54983866a65c4a82b1660c">normNewtonSolveResidual</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a20f29786ff4d1f5d85d21f0bb6c3c17a">RHSVector</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#abcfe5a323d9ce273e0eb8dbf5bc69741">sharedLinearSystem</a>, and <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a7ebb1b6ecf2d328428fcbd190f098ea2">xVector</a>.</p>

</div>
</div>
<a id="ab7dde8d4226ddd1c1b8ee63464862192" name="ab7dde8d4226ddd1c1b8ee63464862192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7dde8d4226ddd1c1b8ee63464862192">&#9670;&#160;</a></span>resetIsValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Group::resetIsValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>resets the isValid flags to false </p>

<p>Reimplemented in <a class="el" href="class_l_o_c_a_1_1_epetra_1_1_group.html#a1564228abc386e4da5e87d1b53adc70d">LOCA::Epetra::Group</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a2376b5186018058863cbd33e109e201d">Group()</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#a235d0540d1b7a81f9fe293d2e40f9a83">Group()</a>, <a class="el" href="class_n_o_x_1_1_epetra_1_1_group.html#af89d1c72fb136f638ea296bf2bcf029e">Group()</a>, and <a class="el" href="class_l_o_c_a_1_1_epetra_1_1_group.html#a1564228abc386e4da5e87d1b53adc70d">LOCA::Epetra::Group::resetIsValid()</a>.</p>

</div>
</div>
<a id="a098f135e50238d2a690636f5ae536e2a" name="a098f135e50238d2a690636f5ae536e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098f135e50238d2a690636f5ae536e2a">&#9670;&#160;</a></span>setX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Group::setX </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_o_x_1_1_abstract_1_1_vector.html">NOX::Abstract::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the solution vector x to y. </p>
<dl class="section note"><dt>Note</dt><dd>This should invalidate the function value, Jacobian, gradient, and Newton direction.</dd>
<dd>
Throw an error if the copy fails.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this object </dd></dl>

<p>Implements <a class="el" href="class_n_o_x_1_1_abstract_1_1_group.html#aebc79123e1828ad14e94ba88d724844e">NOX::Abstract::Group</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><b>NOX_Epetra_Group.H</b></li>
<li><b>NOX_Epetra_Group.C</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
