<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NOX: The Epetra Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">NOX<span id="projectnumber">&#160;Development</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">The Epetra Interface</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="epetra_interface_derived"></a>
Implementing the Interfaces</h1>
<p>The Epetra support code in NOX implements a concrete Group and Vector class using Epetra objects. The user only needs to write an interface that supplies the nonlinear equations in residual form, <picture><source srcset="form_49_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$
F(x)=0 $" src="form_49.png" width="49" height="14"/></picture>. Additionally, the user may provide details such as the Jacobian and Preconditioner if using an iterative linear solver. Below, we describe each of these interfaces.</p>
<p>To link your code to NOX using the epetra interface, you must write a concrete class derived from the <a class="el" href="classNOX_1_1Epetra_1_1Interface_1_1Required.html" title="Supplies NOX with the set nonlinear equations.">NOX::Epetra::Interface::Required</a> object. This object defines the method for evaluating the set of nonlinear equations to be solved:</p>
<p>computeF(const Epetra_Vector&amp; x, Epetra_Vector&amp; RHS, const FillType flag) - Computes the set of nonlinear equations, <picture><source srcset="form_50_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F $" src="form_50.png" width="10" height="10"/></picture>, to be solved by NOX. This method must be supplied by the user.</p><ul>
<li>x - solution vector specified from NOX.</li>
<li>RHS - the <a class="elRef" href="../../../epetra/doc/html/classEpetra__Vector.html">Epetra_Vector</a> to be filled with the <picture><source srcset="form_50_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F $" src="form_50.png" width="10" height="10"/></picture> values that correspond to the input solution vector x.</li>
<li>flag - enumerated type (see NOX::Epetra::FillType) that tells a users interface why computeF() was called. NOX has the ability to generate Jacobians based on numerical differencing using calls to computeF(). In this case, the user may want to compute an inexact (and hopefully cheaper) <picture><source srcset="form_50_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F $" src="form_50.png" width="10" height="10"/></picture> since it is only used in the Jacobian (or preconditioner).</li>
</ul>
<p>Additonally if the user wishes to provide a Jacobian operator, they will need to implement a concrete class derived from the <a class="el" href="classNOX_1_1Epetra_1_1Interface_1_1Jacobian.html" title="Used by NOX::Epetra to provide a link to the external code for Jacobian fills.">NOX::Epetra::Interface::Jacobian</a> object. This object defined the method for evaluating the Jacobian:</p>
<p>computeJacobian(const Epetra_Vector&amp; x, Epetra_Operator&amp; Jac) - this is an optional method that the user can implement if they wish to supply their own evaluation of the Jacobian. If the user does not wish to supply their own Jacobian, they should implement this method so that it throws an error if it is called. This method should update the Jac operator so that subsequent <a class="elRef" href="../../../epetra/doc/html/classEpetra__Operator.html#a44ff0c479186b0e3db841404dbd80491">Epetra_Operator::Apply()</a> calls on that operator correspond to the Jacobian at the current solution vector x.</p><ul>
<li>x - solution vector specified from NOX.</li>
<li>Jac - a reference to the Jacobian operator that the user supplied in the <a class="el" href="classNOX_1_1Epetra_1_1Group.html" title="Concrete implementation of NOX::Abstract::Group for Trilinos/Epetra.">NOX::Epetra::Group</a> constructor.</li>
</ul>
<p>Additonally if the user wishes to provide a preconditioner operator, they will need to implement a concrete class derived from the <a class="el" href="classNOX_1_1Epetra_1_1Interface_1_1Preconditioner.html" title="Used by NOX::Epetra to provide a link to the external code for Precondtioner fills.">NOX::Epetra::Interface::Preconditioner</a> object. This object defined the method for evaluating the Preconditioner or a Matrix to be used with an interal preconditioner:</p>
<p>computePreconditioner(const Epetra_Vector&amp; x, Epetra_Operator&amp;
     M, Teuchos::ParameterList* precParams) - This method allows a user to supply their own preconditioner. The method should compute a preconditioner based upon the solution vector x and store it in the <a class="elRef" href="../../../epetra/doc/html/classEpetra__Operator.html">Epetra_Operator</a> M. Subsequent calls to the <a class="elRef" href="../../../epetra/doc/html/classEpetra__Operator.html#a44ff0c479186b0e3db841404dbd80491">Epetra_Operator::Apply</a> method will apply this user supplied preconditioner to epetra vectors. The <a class="elRef" href="../../../epetra/doc/html/classEpetra__Operator.html">Epetra_Operator</a> M can also be an <a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> that can be used by internally constructed preconditioner objects such as AztecOO, Ipfack, and ML.</p>
<ul>
<li>x - solution vector specified from NOX.</li>
<li>M - a reference to the operator that is to be filled. This operator should be updated to correspond to the current solution vector x.</li>
<li>precParams - a pointer to a parameter list that can be used by the preconditioner.</li>
</ul>
<h1><a class="anchor" id="epetra_interface_operators"></a>
Optional Operators</h1>
<p>The user can write their own operators for the Jacobian or preconditioner as discussed above, or they can use one of the NOX pre-supplied operators. Available Operators include:</p>
<ul>
<li>Jacobian-Free Newton-Krylov Operator (see <a class="el" href="classNOX_1_1Epetra_1_1MatrixFree.html" title="Concrete implementation for creating an Epetra_Operator Jacobian based on the Matrix-Free Newton-Kryl...">NOX::Epetra::MatrixFree</a>)</li>
<li>Finite Difference Operator (see <a class="el" href="classNOX_1_1Epetra_1_1FiniteDifference.html" title="Concrete implementation for creating an Epetra_RowMatrix Jacobian via finite differencing of the resi...">NOX::Epetra::FiniteDifference</a>)</li>
<li>Colored Finite Difference Operator (see <a class="el" href="classNOX_1_1Epetra_1_1FiniteDifferenceColoring.html" title="Concrete implementation for creating an Epetra_RowMatrix Jacobian via finite differencing of the resi...">NOX::Epetra::FiniteDifferenceColoring</a>)</li>
<li>Broyden Operator (see <a class="el" href="classNOX_1_1Epetra_1_1BroydenOperator.html" title="A concrete implementation of a Broyden-type operator for NOX.">NOX::Epetra::BroydenOperator</a>)</li>
</ul>
<p>These operators are built automatically by the linear system object depending on the constuctor used.</p>
<h1><a class="anchor" id="epetra_interface_notes"></a>
Notes on NOX/Epetra:</h1>
<ul>
<li>The concrete Epetra implementations for the NOX Group and Vector are in a separate library from the nox solver algorithms. To build the library for nox epetra support use the flag &ndash;enable-nox-epetra in <a class="el" href="namespaceNOX.html" title="Nonlinear solvers package namespace.">NOX</a>'s configure script. This will generate a separate library called libnoxepetra.a</li>
<li>In addition to the NOX headers, be sure to include the NOX Epetra support specific headers in your interface: <pre class="fragment">   // NOX headers for an epetra interface
   #include "NOX.H"
   #include "NOX_Epetra.H"</pre></li>
</ul>
<h1><a class="anchor" id="epetra_features"></a>
Special Epetra Features</h1>
<p>The Epetra support in NOX provides a number of tools that allow users to perform complex algorithms. This section lists some of the important features.</p>
<ul>
<li>
Multivector Support. NOX has an implementation of multivector support that is typically used for solving multiple RHS vectors in an efficeint manner. See NOX::Abstract::Multivector for more information. </li>
<li>
Scaling. NOX supports a scaling object that allows users to specify diagonal scaling matrices as Epetra_Vectors that will scale the linear system using either right or left scaling. See <a class="el" href="classNOX_1_1Epetra_1_1Scaling.html" title="Object to control scaling of vectors and linear systems.">NOX::Epetra::Scaling</a> for more information. </li>
<li>
Arbitrary vector space. The NOX algorithms were written to support arbitrary vectors spaces. This allows users to define scaled norms and dot products and have them used consistently throughout the code. See <a class="el" href="classNOX_1_1Epetra_1_1VectorSpace.html" title="Pure virtual base class for the vector space used by NOX::Epetra::Vectors.">NOX::Epetra::VectorSpace</a> for more details. </li>
<li>
Model evaluator interface. NOX supports a concrete implementation of the <a class="el" href="namespaceNOX_1_1Epetra_1_1Interface.html" title="Provides a set of interfaces for users to provide information about the nonlinear problem to NOX.">NOX::Epetra::Interface</a> objects that wraps an EpetraExt::ModelEvaluator. If a code implements their residual evaluation, Jacobian, or preconditioner via the EpetraExt::ModelEvaluator class, then it can be automatically used by the NOX's Epetra Group. See NOX::Epetra::ModelEvaluatorInterface for more details. </li>
<li>
The <a class="el" href="classNOX_1_1Epetra_1_1Group.html" title="Concrete implementation of NOX::Abstract::Group for Trilinos/Epetra.">NOX::Epetra::Group</a> implementation allows users to define their own linear solver via the <a class="el" href="classNOX_1_1Epetra_1_1LinearSystem.html" title="Pure virtual class interface for allowing different linear solvers to be used by the NOX::Epetra::Gro...">NOX::Epetra::LinearSystem</a> pure virtual class. NOX comes with the concrete <a class="el" href="classNOX_1_1Epetra_1_1LinearSystemAztecOO.html" title="Concrete implementation of NOX::Epetra::LinearSolver for AztecOO.">NOX::Epetra::LinearSystemAztecOO</a> class the uses iterative Krylov subspace methods. See <a class="el" href="classNOX_1_1Epetra_1_1LinearSystem.html" title="Pure virtual class interface for allowing different linear solvers to be used by the NOX::Epetra::Gro...">NOX::Epetra::LinearSystem</a> for more details. </li>
</ul>
<h1><a class="anchor" id="nox_tutorial_link"></a>
NOX Epetra Tutorial</h1>
<p>See the page <a class="el" href="nox_epetra_tutorial.html">NOX Epetra Tutorial</a> for more information on how to use the epetra support group.</p>
<p>The directory Trilinos/packages/nox/test/epetra/1Dfem contains many examples and is the best resource on how to use NOX with Epetra. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
