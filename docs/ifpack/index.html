<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IFPACK: Trilinos/IFPACK: Object-oriented Algebraic Preconditioner Package</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">IFPACK<span id="projectnumber">&#160;Development</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Trilinos/IFPACK: Object-oriented Algebraic Preconditioner Package </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="IFPACKLogo.gif" alt=""/>
</div>
<h1><a class="anchor" id="ifp_table"></a>
Table of Contents</h1>
<ul>
<li><a class="el" href="index.html#ifp_intro">Introduction</a></li>
<li><a class="el" href="index.html#ifp_download">Download IFPACK</a></li>
<li><a class="el" href="index.html#ifp_configure">Configuring IFPACK</a></li>
<li><a class="el" href="index.html#ifp_example">Examples of Usage</a></li>
<li><a class="el" href="index.html#ifp_params">List of Supported Parameters</a></li>
<li><a class="el" href="index.html#ifp_tools">Brief Description IFPACK Classes</a></li>
<li><a class="el" href="index.html#ifp_error">Error Table</a></li>
<li><a class="el" href="index.html#ifp_bugs">Known Bugs and Future Developments</a></li>
<li><a class="el" href="index.html#ifp_copyright">Copyright</a></li>
<li><a class="el" href="index.html#ifp_browser">Browse all of Ifpack as a single doxygen collection</a></li>
</ul>
<h1><a class="anchor" id="ifp_intro"></a>
Introduction</h1>
<p>IFPACK, developed by Marzio Sala (ETHZ/D-INFK) and Micheal Heroux (SNL 9214), provides a suite of object-oriented algebraic preconditioners for the solution of preconditioned iterative solvers. IFPACK constructors expect an <a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> object for construction. IFPACK is part of the Trilinos Solver Project and IFPACK object interacts well with other Trilinos classes. In particular, IFPACK can be used as a preconditioner for AztecOO.</p>
<p>Most IFPACK preconditioners can be rewritten as additive Schwarz methods, of overlapping domain decomposition type. The user can adopt a minimal-overlap (that is, zero-row overlap), or ask IFPACK to extend the overlap. The resulting preconditioner reads:  </p><p class="formulaDsp">
\[
P_{IFPACK}^{-1} = \sum_{i = 0}^{NumProcs-1} P_i A_i^{-1} R_i
\]
</p>
<p> where \(R_i\) is the restriction operator from the global vector, to the overlapping subdomain \(i\), and \(P_i\) is the prolongator operator. \(P_i\) is generally the transpose of \(R_i\) (in which case the resulting preconditioner is symmetic). It is assumed that each subdomain is assigned to a different processor.</p>
<p>A key component of the previous formula is a strategy to apply \(A_i^{-1}\). Using IFPACK, this can be defined by one of the following:</p><ul>
<li>one or more steps of a point/block method (like Jacobi and Gauss-Seidel);</li>
<li>an incomplete factorization (for symmetric and non-symmetric matrices, with dropping based on graph or on values);</li>
<li>an exact LU solve on each subdomain (using Amesos' factorizations).</li>
</ul>
<p>More precisely, the choices for \(A_i^{-1}\) are:</p>
<ul>
<li>
<p class="startli">Point relaxation preconditioners (through class <a class="el" href="classIfpack__PointRelaxation.html" title="Ifpack_PointRelaxation: a class to define point relaxation preconditioners of for Epetra_RowMatrix&#39;s.">Ifpack_PointRelaxation</a>). Point relaxation preconditioners are probably the simplest iterative methods, and are generally used as smoothers in multilevel methods (for instance, within ML). Available choices are:</p><ul>
<li>Jacobi</li>
<li>Gauss-Seidel</li>
<li>symmetric Guass-Seidel</li>
</ul>
<p class="endli"></p>
</li>
<li>
<p class="startli">Block relaxation preconditioners (through class <a class="el" href="classIfpack__BlockRelaxation.html" title="Ifpack_BlockRelaxation: a class to define block relaxation preconditioners of Epetra_RowMatrix&#39;s.">Ifpack_BlockRelaxation</a>). Block relaxation preconditioners represent an extension of point preconditioners. The local matrix \(A_i\) is divided into blocks, then a relaxation method is applied on the block structure of \(A_i\). Available choices are:</p><ul>
<li>block Jacobi</li>
<li>block Gauss-Seidel</li>
<li>block symmetric Gauss-Seidel</li>
</ul>
<p class="interli">The code extracts the diagonal blocks (the application of whose inverses is required), and stored them either as dense or as sparse matrices. Dense matrices should be used if the dimension of each block is small, since LAPACK routines are used to factorize the block and to perform the backsolve. For large blocks, instead, it is suggested to store the blocks are sparse matrices (<a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a>'s). Any IFPACK preconditioner derived from <a class="el" href="classIfpack__Preconditioner.html" title="Ifpack_Preconditioner: basic class for preconditioning in Ifpack.">Ifpack_Preconditioner</a> can be used to apply the inverse of the diagonal blocks.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Point incomplete factorizations (through classes <a class="el" href="classIfpack__IC.html" title="Ifpack_IC: A class for constructing and using an incomplete Cholesky factorization of a given Epetra_...">Ifpack_IC</a>, <a class="el" href="classIfpack__ICT.html" title="Ifpack_ICT: A class for constructing and using an incomplete Cholesky factorization of a given Epetra...">Ifpack_ICT</a>, <a class="el" href="classIfpack__ILU.html" title="Ifpack_ILU: A class for constructing and using an incomplete lower/upper (ILU) factorization of a giv...">Ifpack_ILU</a>, <a class="el" href="classIfpack__ILUT.html" title="Ifpack_ILUT: A class for constructing and using an incomplete LU factorization of a given Epetra_RowM...">Ifpack_ILUT</a>). See <a class="el" href="ifp_ilu.html">General description of incomplete factorizations</a> .</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Exact factorizations (through class <a class="el" href="classIfpack__Amesos.html" title="Ifpack_Amesos: a class to use Amesos&#39; factorizations as preconditioners.">Ifpack_Amesos</a>):</p><ul>
<li>all Amesos classes can be used to compute the LU factorization of a given matrix.</li>
</ul>
<p class="endli"></p>
</li>
<li>
<p class="startli">Chebyshev polynomials (through class <a class="el" href="classIfpack__Chebyshev.html" title="Ifpack_Chebyshev: class for preconditioning with Chebyshev polynomials in Ifpack.">Ifpack_Chebyshev</a>).</p>
<p class="endli"></p>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>IFPACK preconditioners can be used as smoothers for multilevel solvers, like ML.</dd></dl>
<h1><a class="anchor" id="ifp_download"></a>
Download IFPACK</h1>
<p>IFPACK can be downloaded from the web page <a href="http://trilinos.sandia.gov/download/">http://trilinos.sandia.gov/download/</a></p>
<h1><a class="anchor" id="ifp_configure"></a>
Configuring IFPACK</h1>
<p>IFPACK is configured with autotools. IFPACK is enabled by default if configured at the Trilinos level (please refer to the Trilinos documentation for more details). This section briefly recalls some of the configure parameters that affect the IFPACK compilation. For a complete list of parameters, please type </p><div class="fragment"><div class="line">% $TRILINOS_HOME/packages/ifpack/configure --help</div>
</div><!-- fragment --><p>An (incomplete) list of parameters recognized by the IFPACK configure is reported below.</p>
<ul>
<li><code>"enable-amesos"</code> enables the support for Amesos (off by default).</li>
<li><code>"enable-aztecoo"</code> enables the support for AztecOO (on by default).</li>
<li><code>"enable-teuchos"</code> enables the support for Teuchos (off by default).</li>
<li><code>"enable-thyra"</code> enables the support for Thyra (off by default).</li>
<li><code>"enable-triutils"</code> enables the support for Triutils (on by default).</li>
<li><code>"enable-ifpack-metis"</code> enables the support for the METIS package. The location of the header files should be specified using <code>"--with-incdirs=-I/include/location"</code>, the path of the METIS library with <code>"--with-ldflags=-L/lib/location"</code>, and the library name using <code>"--with-libs=-lmetis-name."</code>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>IFPACK cannot be build without Epetra. Most of IFPACK preconditioners cannot be used without the Teuchos library. Most of the examples requires triutils and AztecOO.</dd></dl>
<h1><a class="anchor" id="ifp_example"></a>
Examples of Usage</h1>
<p>This section details how to use the IFPACK Factory class.</p>
<p>Probably, the easiest way to use IFPACK is through the function class <a class="el" href="classIfpack.html" title="Ifpack: a function class to define Ifpack preconditioners.">Ifpack</a>. This is a <em>factory</em> class, that contains only one method, Create(). A call to Create() returns a pointer to a newly-created IFPACK object. The user is responsible of deleting this object.</p>
<p>An example of usage is reported by the following code: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Ifpack.h&quot;</span></div>
<div class="line">...</div>
<div class="line">Ifpack Factory;</div>
<div class="line"><a class="code hl_classRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a>* A; <span class="comment">// A is already FillComplete()&#39;d</span></div>
<div class="line">                     <span class="comment">// but its values can still change (not its structure)</span></div>
<div class="line"><span class="keywordtype">string</span> PrecType = <span class="stringliteral">&quot;Amesos&quot;</span>; <span class="comment">// exact solve on each subdomain </span></div>
<div class="line"><span class="keywordtype">int</span> OverlapLevel = 1; <span class="comment">// one row of overlap among the processes</span></div>
<div class="line"><a class="code hl_class" href="classIfpack__Preconditioner.html">Ifpack_Preconditioner</a>* Prec = Factory.Create(PrecType, A, OverlapLevel);</div>
<div class="line">assert (Prec != 0);</div>
<div class="line"> </div>
<div class="line">IFPACK_CHK_ERR(Prec-&gt;<a class="code hl_function" href="classIfpack__Preconditioner.html#aa7a00ade2cbd8b77e545cf1acb132df6">SetParameters</a>(List));</div>
<div class="line">IFPACK_CHK_ERR(Prec-&gt;<a class="code hl_function" href="classIfpack__Preconditioner.html#afcc3a9d1bf622ce8264074aa2066f7c3">Initialize</a>());</div>
<div class="line">IFPACK_CHK_ERR(Prec-&gt;<a class="code hl_function" href="classIfpack__Preconditioner.html#a245b11b9f09575682b7d9584e5ddb67f">Compute</a>());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// we can query the status of the preconditioner</span></div>
<div class="line">assert (Prec-&gt;<a class="code hl_function" href="classIfpack__Preconditioner.html#a07115a91f531105a43eeff8bfc30ca56">IsInitialized</a>() == <span class="keyword">true</span>);</div>
<div class="line">assert (Prec-&gt;<a class="code hl_function" href="classIfpack__Preconditioner.html#a9e82c8ba1b4a437ee30ddcbbe36835b4">IsComputed</a>() == <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// information about the preconditioner</span></div>
<div class="line"><span class="comment">// 1.- number of initialization phases</span></div>
<div class="line">cout &lt;&lt; Prec-&gt;<a class="code hl_function" href="classIfpack__Preconditioner.html#ab77e4f913e7037f2908741d21d0012bd">NumInitialize</a>() &lt;&lt; endl; </div>
<div class="line"><span class="comment">// 2.- number of computation phases</span></div>
<div class="line">cout &lt;&lt; Prec-&gt;<a class="code hl_function" href="classIfpack__Preconditioner.html#a6f3f04accce38ce55c252d93c804e37d">NumCompute</a>() &lt;&lt; endl; </div>
<div class="line"><span class="comment">// 3.- number of applications of the prconditioner</span></div>
<div class="line">cout &lt;&lt; Prec-&gt;<a class="code hl_function" href="classIfpack__Preconditioner.html#aa014c77003a7ebbdcb9a2172b2487dd2">NumApplyInverse</a>() &lt;&lt; endl; </div>
<div class="line"><span class="comment">// we can query for flops and CPU time as well, consult the</span></div>
<div class="line"><span class="comment">// documentation of Ifpack_Preconditioner, or simply write</span></div>
<div class="line">cout &lt;&lt; *Prec;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// now destroy the preconditioner</span></div>
<div class="line"><span class="keyword">delete</span> Prec;</div>
<div class="ttc" id="aclassEpetra__RowMatrix_html"><div class="ttname"><a href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a></div></div>
<div class="ttc" id="aclassIfpack__Preconditioner_html"><div class="ttname"><a href="classIfpack__Preconditioner.html">Ifpack_Preconditioner</a></div><div class="ttdoc">Ifpack_Preconditioner: basic class for preconditioning in Ifpack.</div><div class="ttdef"><b>Definition</b> <a href="Ifpack__Preconditioner_8h_source.html#l00142">Ifpack_Preconditioner.h:142</a></div></div>
<div class="ttc" id="aclassIfpack__Preconditioner_html_a07115a91f531105a43eeff8bfc30ca56"><div class="ttname"><a href="classIfpack__Preconditioner.html#a07115a91f531105a43eeff8bfc30ca56">Ifpack_Preconditioner::IsInitialized</a></div><div class="ttdeci">virtual bool IsInitialized() const =0</div><div class="ttdoc">Returns true if the preconditioner has been successfully initialized, false otherwise.</div></div>
<div class="ttc" id="aclassIfpack__Preconditioner_html_a245b11b9f09575682b7d9584e5ddb67f"><div class="ttname"><a href="classIfpack__Preconditioner.html#a245b11b9f09575682b7d9584e5ddb67f">Ifpack_Preconditioner::Compute</a></div><div class="ttdeci">virtual int Compute()=0</div><div class="ttdoc">Computes all it is necessary to apply the preconditioner.</div></div>
<div class="ttc" id="aclassIfpack__Preconditioner_html_a6f3f04accce38ce55c252d93c804e37d"><div class="ttname"><a href="classIfpack__Preconditioner.html#a6f3f04accce38ce55c252d93c804e37d">Ifpack_Preconditioner::NumCompute</a></div><div class="ttdeci">virtual int NumCompute() const =0</div><div class="ttdoc">Returns the number of calls to Compute().</div></div>
<div class="ttc" id="aclassIfpack__Preconditioner_html_a9e82c8ba1b4a437ee30ddcbbe36835b4"><div class="ttname"><a href="classIfpack__Preconditioner.html#a9e82c8ba1b4a437ee30ddcbbe36835b4">Ifpack_Preconditioner::IsComputed</a></div><div class="ttdeci">virtual bool IsComputed() const =0</div><div class="ttdoc">Returns true if the preconditioner has been successfully computed, false otherwise.</div></div>
<div class="ttc" id="aclassIfpack__Preconditioner_html_aa014c77003a7ebbdcb9a2172b2487dd2"><div class="ttname"><a href="classIfpack__Preconditioner.html#aa014c77003a7ebbdcb9a2172b2487dd2">Ifpack_Preconditioner::NumApplyInverse</a></div><div class="ttdeci">virtual int NumApplyInverse() const =0</div><div class="ttdoc">Returns the number of calls to ApplyInverse().</div></div>
<div class="ttc" id="aclassIfpack__Preconditioner_html_aa7a00ade2cbd8b77e545cf1acb132df6"><div class="ttname"><a href="classIfpack__Preconditioner.html#aa7a00ade2cbd8b77e545cf1acb132df6">Ifpack_Preconditioner::SetParameters</a></div><div class="ttdeci">virtual int SetParameters(Teuchos::ParameterList &amp;List)=0</div><div class="ttdoc">Sets all parameters for the preconditioner.</div></div>
<div class="ttc" id="aclassIfpack__Preconditioner_html_ab77e4f913e7037f2908741d21d0012bd"><div class="ttname"><a href="classIfpack__Preconditioner.html#ab77e4f913e7037f2908741d21d0012bd">Ifpack_Preconditioner::NumInitialize</a></div><div class="ttdeci">virtual int NumInitialize() const =0</div><div class="ttdoc">Returns the number of calls to Initialize().</div></div>
<div class="ttc" id="aclassIfpack__Preconditioner_html_afcc3a9d1bf622ce8264074aa2066f7c3"><div class="ttname"><a href="classIfpack__Preconditioner.html#afcc3a9d1bf622ce8264074aa2066f7c3">Ifpack_Preconditioner::Initialize</a></div><div class="ttdeci">virtual int Initialize()=0</div><div class="ttdoc">Computes all it is necessary to initialize the preconditioner.</div></div>
</div><!-- fragment --><p>Although the <a class="el" href="classIfpack.html" title="Ifpack: a function class to define Ifpack preconditioners.">Ifpack</a> factory is appropriate for most users, it is possible to create IFPACK preconditioners by handling directly an <a class="el" href="classIfpack__AdditiveSchwarz.html" title="Ifpack_AdditiveSchwarz: a class to define Additive Schwarz preconditioners of Epetra_RowMatrix&#39;s.">Ifpack_AdditiveSchwarz</a> object. The preconditioner of the previous example is equivalent to the one created in the following fragment of code: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Ifpack_AdditiveSchwarz.h&quot;</span></div>
<div class="line">...</div>
<div class="line">Epetra_RowMatrix* A; </div>
<div class="line"><span class="keywordtype">int</span> OverlapLevel = 1;</div>
<div class="line"><a class="code hl_class" href="classIfpack__AdditiveSchwarz.html">Ifpack_AdditiveSchwarz</a> Prec&lt;Ifpack_Amesos&gt; (A, OverlapLevel);</div>
<div class="ttc" id="aclassIfpack__AdditiveSchwarz_html"><div class="ttname"><a href="classIfpack__AdditiveSchwarz.html">Ifpack_AdditiveSchwarz</a></div><div class="ttdoc">Ifpack_AdditiveSchwarz: a class to define Additive Schwarz preconditioners of Epetra_RowMatrix's.</div><div class="ttdef"><b>Definition</b> <a href="Ifpack__AdditiveSchwarz_8h_source.html#l00148">Ifpack_AdditiveSchwarz.h:148</a></div></div>
</div><!-- fragment --><p>Another example is the following, where the local solve is a block Jacobi method, which uses dense containers (LAPACK). </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Ifpack_AdditiveSchwarz.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Ifpack_DenseContainer.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Ifpack_BlockJacobi.h&quot;</span></div>
<div class="line">...</div>
<div class="line">Epetra_RowMatrix* A; </div>
<div class="line"><span class="keywordtype">int</span> OverlapLevel = 1;</div>
<div class="line"><a class="code hl_class" href="classIfpack__AdditiveSchwarz.html">Ifpack_AdditiveSchwarz</a> Prec&lt;Ifpack_BlockJacobi&lt;Ifpack_DenseContainer&gt; &gt; (A, OverlapLevel);</div>
</div><!-- fragment --><p>Using sparse containers and Amesos the code may look as follows. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Ifpack_AdditiveSchwarz.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Ifpack_SparseContainer.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Ifpack_BlockJacobi.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Ifpack_Amesos.h&quot;</span></div>
<div class="line">...</div>
<div class="line">Epetra_RowMatrix* A; </div>
<div class="line"><span class="keywordtype">int</span> OverlapLevel = 1;</div>
<div class="line"><a class="code hl_class" href="classIfpack__AdditiveSchwarz.html">Ifpack_AdditiveSchwarz</a> Prec&lt;Ifpack_BlockJacobi&lt;Ifpack_SparseContainer&lt;Ifpack_Amesos&gt; &gt; &gt; (A, OverlapLevel);</div>
</div><!-- fragment --><p>Other examples are reported in the <code>example</code> subdirectory with several comments:</p><ul>
<li><a class="el" href="ifp_ex_factory.html">Ex_Factory</a> shows how to use <a class="el" href="classIfpack.html" title="Ifpack: a function class to define Ifpack preconditioners.">Ifpack</a> factory to create a variety of IFPACK preconditioners. This is the simplest way to use IFPACK. The example details all the phases of IFPACK. Difficulty level: beginners.</li>
<li><a class="el" href="ifp_ex_mm.html">Ex_MatrixMarket</a> reads an MatrixMarket matrix (a simple format that contains i,j and a(i,j) of all nonzero elements), redistribute the matrix to all avaialble processes (using a linear distribution), and solve the problem with AztecOO and IFPACK. Matrices downloaded from math.nist.gov/MatrixMarket/ in .mtx format can be used with this example. A small example is reported. Difficulty level: beginners.</li>
<li><a class="el" href="ifp_ex_amesos.html">Ex_AmesosPrec</a> shows how to use exact LU solvers on each subdomain, using Amesos. This example is very similar to the previous one. Difficulty level: beginners.</li>
<li><a class="el" href="ifp_ex_vict.html">Ex_vIctPrec</a> shows how to define incomplete Cholesky factorizations (with dropping based on values), and tune parameters. Although an vICT factorization can be constructed using the Factory (as done in file Ifpack_ex_Factory.cpp), this example tells the real story: how to define an Ifpack_AdditiveSchwar which uses vICT on each subdomain. Difficulty level: intermediate.</li>
<li><a class="el" href="ifp_ex_block.html">Ex_BlockRelaxationPrec</a> shows how to define block preconditioner in the more general case, using <a class="el" href="classIfpack__AdditiveSchwarz.html" title="Ifpack_AdditiveSchwarz: a class to define Additive Schwarz preconditioners of Epetra_RowMatrix&#39;s.">Ifpack_AdditiveSchwarz</a>. Difficulty: advanced.</li>
</ul>
<h1><a class="anchor" id="ifp_params"></a>
List of Supported Parameters</h1>
<p>The complete list of supported parameters is reported below.</p>
<ul>
<li><code>"relaxation: type"</code>: specifies the type of point and block relaxation scheme. Valid values:<ul>
<li><code>"Jacobi"</code>;</li>
<li><code>"Gauss-Seidel"</code>;</li>
<li><code>"symmetric Gauss-Seidel"</code>;</li>
</ul>
</li>
<li><code>"relaxation: sweeps"</code>: specifies the number of sweeps in the application of point relaxation schemes.</li>
<li><code>"relaxation: damping factor"</code>: specifies the damping factor in the application of point relaxation schemes.</li>
<li><code>"relaxation: min diagonal value"</code>: replace diagonal values below this value with this value (only for point relaxation).</li>
<li><code>"relaxation: zero starting solution"</code>: if <code>true</code>, uses the values in the vector to be preconditioned as starting solution. Otherwise, use the zero vector as starting solution.</li>
<li><code>"relaxation: backward mode"</code>: Does Gauss-Seidel in backward order (rather than forward)</li>
<li><code>"relaxation: use l1"</code>: Use the "L1-Gauss-Seidel" method of Baker, Falgout, Kolev and Yang (SISC 2011). This can be especially advantageous for using Gauss-Seidel and symmetric Gauss-Seidel in parallel.</li>
<li><code>"relaxation: l1 eta"</code>: Sets the "eta" parameter used by the L1 GS/SGS method.</li>
<li><code>"relaxation: number of local smoothing indices"</code>: Sets the number of local unknowns over which to smooth. This is used for selective (local) smoothing.</li>
<li><code>"relaxation: local smoothing indices"</code>: A list of local unknowns over which to smooth. This can be used for selective (local) smoothing or to force the method to smooth unknowns in a particular order (such as upwind smoothing).</li>
<li><code>"partitioner: type"</code>: specifies the scheme to adopt to partition the graph (for block relaxation methods only). Valid values:<ul>
<li><code>"linear"</code> (uses a linear decomposition);</li>
<li><code>"greedy"</code> (uses a simple greedy algorithm);</li>
<li><code>"metis"</code> (calls METIS, this required <code>--enable-ifpack-metis</code>).</li>
<li><code>"equation"</code> (groups together all the nodes belonging to the same equation. The number of equation is specified using <code>"partitioner: local
    parts"</code>, and it is supposed that the equation for each grid node are ordered consecutevely).</li>
</ul>
</li>
<li><code>"partitioner: overlap"</code>: specifies the overlap among the blocks which can differ from the overlap among the processors. Note that only the Jacobi block relaxation scheme can take advantage of non-zero overlaps.</li>
<li><code>"partitioner: local parts"</code>: specifies the number of local blocks.</li>
<li><code>"partitioner: root node"</code>: specifies the root node for greedy algorithm.</li>
<li><code>"partitioner: use symmetric graph"</code>: if <code>true</code>, METIS will partition the graph of A + A<sup>T</sup>. If <code>false</code>, METIS will partition the graph of A. Note that METIS can core dump if the input graph is non-symmetric. Users should set this option to <code>false</code> only when the graph is symmetric. If the non-symmetry is determined by Dirichlet nodes, then the singleton filter should create a symmetric graph. Note also that dropping techniques applied to non-symmetric matrices can result in non-symmetric graph.</li>
<li><code>"amesos: solver type"</code>: defines the Amesos solver to be used by class <a class="el" href="classIfpack__Amesos.html" title="Ifpack_Amesos: a class to use Amesos&#39; factorizations as preconditioners.">Ifpack_Amesos</a>. Valid values:<ul>
<li><code>"Amesos_Lapack"</code> (use Amesos interface to LAPACK);</li>
<li><code>"Amesos_Klu"</code> (use Amesos' internal solver KLU);</li>
<li><code>"Amesos_Umfpack"</code> (use UMFPACK interface);</li>
<li><code>"Amesos_Superlu"</code> (use serial SuperLU interface);</li>
<li><code>"Amesos_Mumps"</code> (use MUMPS interface);</li>
<li><code>"Amesos_Dscpack"</code> (use DSCPACK interface).</li>
</ul>
</li>
<li><code>"fact: level-of-fill"</code>: defines the level of fill for ILU factorizations. This is based on powers of the graph, so the value 0 means no-fill.</li>
<li><code>"fact: ilut level-of-fill"</code>: defines the level of fill for ILUT factorizations. This is a ratio, so 1.0 means same number of nonzeros for the ILU factors as in the original matrix.</li>
<li><code>"fact: ict level-of-fill"</code>: defines the level of fill for ICT factorizations, and is a fill-ratio as for ILUT. Currently this parameter is used in both <a class="el" href="classIfpack__IC.html" title="Ifpack_IC: A class for constructing and using an incomplete Cholesky factorization of a given Epetra_...">Ifpack_IC</a> and <a class="el" href="classIfpack__ICT.html" title="Ifpack_ICT: A class for constructing and using an incomplete Cholesky factorization of a given Epetra...">Ifpack_ICT</a>.</li>
<li><code>"fact: absolute threshold"</code>: defines the value \(\alpha\) to add to each diagonal element (times the signum of the actual diagonal element), for incomplete factorizations only.</li>
<li><code>"fact: relative threshold"</code>: defines \(\rho\), so that the diagonal element of the matrix (without the contribution specified by <code>"fact: absolute threshold"</code>) is multiplied by \(rho \).</li>
<li><code>"fact: relax value"</code>: if different from zero, the elements dropped during the factorization process will be added to the diagonal term, multiplied by the specified value.</li>
<li><code>"schwarz: combine mode"</code>: defines how values corresponding to overlapping nodes are handled (after the solution of the local problem). Any Epetra_CombineMode is valid. Users should set this value to <code>Add</code> if interested in a symmetric preconditioner. Otherwise, the default value of <code>"Zero"</code> usually results in better convergence. Other details on combine mode are reported. All <a class="el" href="classIfpack.html" title="Ifpack: a function class to define Ifpack preconditioners.">Ifpack</a> preconditioners work on parallel distributed memory computers by using the row partitioning the user input matrix to determine the partitioning for local ILU factors. If the level of overlap is set to zero, the rows of the user matrix that are stored on a given processor are treated as a self-contained local matrix and all column entries that reach to off-processor entries are ignored. Setting the level of overlap to one tells <a class="el" href="classIfpack.html" title="Ifpack: a function class to define Ifpack preconditioners.">Ifpack</a> to increase the size of the local matrix by adding rows that are reached to by rows owned by this processor. Increasing levels of overlap are defined recursively in the same way. For sufficiently large levels of overlap, the entire matrix would be part of each processor's local ILU factorization process. Level of overlap is defined during the construction of the <a class="el" href="classIfpack__IlukGraph.html" title="Ifpack_IlukGraph: A class for constructing level filled graphs for use with ILU(k) class precondition...">Ifpack_IlukGraph</a> object. The application of the inverse of the local matrix results in redundant approximations for any elements of y that correspond to rows that are part of more than one local ILU factor. The combine mode defines how these redundancies are handled using the Epetra_CombineMode enum. The default (<code>Zero</code>) means to zero out all values of y for rows that were not part of the original matrix row distribution.</li>
<li><code>"schwarz: compute condest"</code>: it <code>true</code>, compute a cheap estimate of the condition number. Warning: this is not the REAL conditioner number, but only a very light-weight indication of how well the current preconditioner is expected to behave.</li>
<li><code>"schwarz: filter singletons"</code>: it <code>true</code>, singletons in the local matrix are removed.</li>
<li><code>"schwarz: reordering type"</code>: it <code>none</code>, no reordering is applied. If <code>rcm</code> or <code>metis</code>, a reverse Cuthill-McKee or METIS are used to reorder to local matrix.</li>
</ul>
<p>The table below reports the C++ type and the default value of each parameter. </p><center> <table class="doxtable">
<tr>
<td><b>Parameter name</b></td><td><b>C++ type</b></td><td><b>Defaut value</b>  </td></tr>
<tr>
<td><code>"relaxation: type"</code> </td><td><code>string</code> </td><td><code>"Jacobi"</code>   </td></tr>
<tr>
<td><code>"relaxation: sweeps"</code> </td><td><code>int</code> </td><td><code>"1"</code>   </td></tr>
<tr>
<td><code>"relaxation: damping factor"</code> </td><td><code>double</code> </td><td><code>"1.0"</code>   </td></tr>
<tr>
<td><code>"relaxation: min diagonal value"</code> </td><td><code>double</code> </td><td><code>"0.0"</code>   </td></tr>
<tr>
<td><code>"relaxation: zero starting solution"</code> </td><td><code>bool</code> </td><td><code>"true"</code>   </td></tr>
<tr>
<td><code>"relaxation: backward mode"</code> </td><td><code>bool</code> </td><td><code>"false"</code>   </td></tr>
<tr>
<td><code>"relaxation: use l1"</code> </td><td><code>bool</code> </td><td><code>"false"</code>   </td></tr>
<tr>
<td><code>"relaxation: l1 eta"</code> </td><td><code>double</code> </td><td><code>"1.5"</code>   </td></tr>
<tr>
<td><code>"relaxation: number of local smoothing indices"</code> </td><td><code>int</code> </td><td><code>"A-&gt;NumMyRows()"</code>   </td></tr>
<tr>
<td><code>"relaxation: local smoothing indices"</code> </td><td><code>int*</code> </td><td><code>"0"</code>   </td></tr>
<tr>
<td><code>"partitioner: type"</code> </td><td><code>string</code> </td><td><code>"greedy"</code>   </td></tr>
<tr>
<td><code>"partitioner: overlap"</code> </td><td><code>int</code> </td><td><code>"0"</code>   </td></tr>
<tr>
<td><code>"partitioner: local parts"</code> </td><td><code>int</code> </td><td><code>"1"</code>   </td></tr>
<tr>
<td><code>"partitioner: root node"</code> </td><td><code>int</code> </td><td><code>"0"</code>   </td></tr>
<tr>
<td><code>"partitioner: use symmetric graph"</code> </td><td><code>bool</code> </td><td><code>"true"</code>   </td></tr>
<tr>
<td><code>"amesos: solver type"</code> </td><td><code>string</code> </td><td><code>"Amesos_Klu"</code>   </td></tr>
<tr>
<td><code>"fact: absolute threshold"</code> </td><td><code>double</code> </td><td><code>"0.0"</code>   </td></tr>
<tr>
<td><code>"fact: relative threshold"</code> </td><td><code>double</code> </td><td><code>"0.0"</code>   </td></tr>
<tr>
<td><code>"fact: relax value"</code> </td><td><code>double</code> </td><td><code>"0.0"</code>   </td></tr>
<tr>
<td><code>"schwarz: combine mode"</code> </td><td><code>Epetra_CombineMode</code> </td><td><code>"Zero"</code>   </td></tr>
<tr>
<td><code>"schwarz: compute condest"</code> </td><td><code>bool</code> </td><td><code>"true"</code>   </td></tr>
<tr>
<td><code>"schwarz: reordering type"</code> </td><td><code>string</code> </td><td><code>"none"</code>   </td></tr>
<tr>
<td><code>"schwarz: filter singletons"</code> </td><td><code>string</code> </td><td><code>"false"</code>   </td></tr>
</table>
</center><dl class="section note"><dt>Note</dt><dd>Whenever possible, the Teuchos::ParameterList given in input to SetParameters() is only parsed. There are cases, however, where the solver needs to store a copy of this list, because it will be used in a later stage. This happens, for example, in block relaxation schemes that use Amesos as local solver. As the the list given in input to SetParameters() is parsed or copied, this list can go out of scope after this function returns.</dd></dl>
<h1><a class="anchor" id="ifp_tools"></a>
Brief Description IFPACK Classes</h1>
<p>IFPACK classes are divided into classes for users and classes for developers.</p>
<p>Users' Tools</p>
<ul>
<li><a class="el" href="classIfpack__PointRelaxation.html" title="Ifpack_PointRelaxation: a class to define point relaxation preconditioners of for Epetra_RowMatrix&#39;s.">Ifpack_PointRelaxation</a> and <a class="el" href="classIfpack__BlockRelaxation.html" title="Ifpack_BlockRelaxation: a class to define block relaxation preconditioners of Epetra_RowMatrix&#39;s.">Ifpack_BlockRelaxation</a> should be considered to define relaxation preconditioners (or smoothers);</li>
<li><a class="el" href="classIfpack__IC.html" title="Ifpack_IC: A class for constructing and using an incomplete Cholesky factorization of a given Epetra_...">Ifpack_IC</a>, <a class="el" href="classIfpack__ICT.html" title="Ifpack_ICT: A class for constructing and using an incomplete Cholesky factorization of a given Epetra...">Ifpack_ICT</a> are incomplete Cholesky factorizations;</li>
<li><a class="el" href="classIfpack__ILU.html" title="Ifpack_ILU: A class for constructing and using an incomplete lower/upper (ILU) factorization of a giv...">Ifpack_ILU</a>, <a class="el" href="classIfpack__ILUT.html" title="Ifpack_ILUT: A class for constructing and using an incomplete LU factorization of a given Epetra_RowM...">Ifpack_ILUT</a> are incomplete LU factorizations;</li>
<li><a class="el" href="classIfpack__AdditiveSchwarz.html" title="Ifpack_AdditiveSchwarz: a class to define Additive Schwarz preconditioners of Epetra_RowMatrix&#39;s.">Ifpack_AdditiveSchwarz</a> is the general handle to define overlapping Schwarz methods with overlap.</li>
<li>The matrix to be preconditioned can be filtered before performing the actual factorization. Available filters are <a class="el" href="classIfpack__LocalFilter.html" title="Ifpack_LocalFilter a class for light-weight extraction of the submatrix corresponding to local rows a...">Ifpack_LocalFilter</a>, <a class="el" href="classIfpack__DropFilter.html" title="Ifpack_DropFilter: Filter based on matrix entries.">Ifpack_DropFilter</a>, <a class="el" href="classIfpack__SparsityFilter.html" title="Ifpack_SparsityFilter: a class to drop based on sparsity.">Ifpack_SparsityFilter</a>, <a class="el" href="classIfpack__DiagonalFilter.html" title="Ifpack_DiagonalFilter: Filter to modify the diagonal entries of a given Epetra_RowMatrix.">Ifpack_DiagonalFilter</a>, Ifpack_ReoderFilter, <a class="el" href="classIfpack__SingletonFilter.html" title="Ifpack_SingletonFilter: Filter based on matrix entries.">Ifpack_SingletonFilter</a>;</li>
<li>Function Ifpack_PrintSparsity() and Ifpack_PrintSparsity_Simple() can be used to print out the sparsity pattern of an <a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> (as PS, or on screen);</li>
<li>Function Ifpack_Analyze() can be used to analyze basic properties of a given <a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a>; see an example of output <a class="el" href="ifp_analyze.html">Usage of Ifpack_Analyze().</a>.</li>
<li>Function Ifpack_AnalyzeMatrixElements() can be used to evaluate the distribution of matrix elements; see an example of output <a class="el" href="ifp_matrix.html">Usage of Ifpack_AnalyzeMatrixElements()</a>.</li>
<li>Function Ifpack_AnalyzeVectorElements() can be used to evaluate the distribution of vector elements; see an example of output <a class="el" href="ifp_vector.html">Usage of Ifpack_AnalyzeVectorElements()</a>.</li>
</ul>
<p>Developers' Tools</p>
<ul>
<li>Graphs are derived from the pure virtual class <a class="el" href="classIfpack__Graph.html" title="Ifpack_Graph: a pure virtual class that defines graphs for IFPACK.">Ifpack_Graph</a> (whose documentation details the concept of graphs for IFPACK). Concrete implementations are <a class="el" href="classIfpack__Graph__Epetra__CrsGraph.html" title="Ifpack_Graph_Epetra_CrsGraph: a class to define Ifpack_Graph as a light-weight conversion of Epetra_C...">Ifpack_Graph_Epetra_CrsGraph</a> and <a class="el" href="classIfpack__Graph__Epetra__RowMatrix.html" title="Ifpack_Graph_Epetra_RowMatrix: a class to define Ifpack_Graph as a light-weight conversion of Epetra_...">Ifpack_Graph_Epetra_RowMatrix</a>;</li>
<li>Containers are derived from the pure virtual class <a class="el" href="classIfpack__Container.html" title="Ifpack_Container: a pure virtual class for creating and solving local linear problems.">Ifpack_Container</a> (whose documentation describes what a container is). Concrete implementations are <a class="el" href="classIfpack__DenseContainer.html" title="Ifpack_DenseContainer: a class to define containers for dense matrices.">Ifpack_DenseContainer</a> and <a class="el" href="classIfpack__SparseContainer.html" title="Ifpack_SparseContainer: a class for storing and solving linear systems using sparse matrices.">Ifpack_SparseContainer</a>;</li>
<li>Reorderings are derived from the pure virtual class <a class="el" href="classIfpack__Reordering.html" title="Ifpack_Reordering: basic class for reordering for a Ifpack_Graph object.">Ifpack_Reordering</a>. Concrete implementations are <a class="el" href="classIfpack__RCMReordering.html" title="Ifpack_RCMReordering: reverse Cuthill-McKee reordering.">Ifpack_RCMReordering</a> and <a class="el" href="classIfpack__METISReordering.html" title="Ifpack_METISReordering: A class to reorder a graph using METIS.">Ifpack_METISReordering</a>;</li>
<li>Partitioners are derived from the pure virtual class <a class="el" href="classIfpack__Partitioner.html" title="Ifpack_Partitioner: A class to decompose local Ifpack_Graph&#39;s.">Ifpack_Partitioner</a>. Concrete implementations are <a class="el" href="classIfpack__LinearPartitioner.html" title="Ifpack_LinearPartitioner: A class to define linear partitions.">Ifpack_LinearPartitioner</a>, <a class="el" href="classIfpack__METISPartitioner.html" title="Ifpack_METISPartitioner: A class to decompose Ifpack_Graph&#39;s using METIS.">Ifpack_METISPartitioner</a>, <a class="el" href="classIfpack__GreedyPartitioner.html" title="Ifpack_GreedyPartitioner: A class to decompose Ifpack_Graph&#39;s using a simple greedy algorithm.">Ifpack_GreedyPartitioner</a>, <a class="el" href="classIfpack__EquationPartitioner.html" title="Ifpack_EquationPartitioner: A class to decompose an Ifpack_Graph so that each block will contain all ...">Ifpack_EquationPartitioner</a>, and <a class="el" href="classIfpack__UserPartitioner.html" title="Ifpack_UserPartitioner: A class to define linear partitions.">Ifpack_UserPartitioner</a>. See <a class="el" href="classIfpack__OverlappingPartitioner.html">Ifpack_OverlappingPartitioner</a>;</li>
<li><a class="el" href="classIfpack__ReorderFilter.html" title="Ifpack_ReorderFilter: a class for light-weight reorder of local rows and columns of an Epetra_RowMatr...">Ifpack_ReorderFilter</a> and <a class="el" href="classIfpack__SingletonFilter.html" title="Ifpack_SingletonFilter: Filter based on matrix entries.">Ifpack_SingletonFilter</a> are used in <a class="el" href="classIfpack__AdditiveSchwarz.html" title="Ifpack_AdditiveSchwarz: a class to define Additive Schwarz preconditioners of Epetra_RowMatrix&#39;s.">Ifpack_AdditiveSchwarz</a>.</li>
</ul>
<h1><a class="anchor" id="ifp_error"></a>
Error Table</h1>
<p>The following table defines the class of IFPACK errors. Return code should be checked using the IFPACK_CHK_ERR() macro. In general terms, we follow this convention:</p><ul>
<li>a return value of 0 means that the called function or method successfully completed;</li>
<li>a negative return function means that an error occurred;</li>
<li>a positive value is a warning for the user.</li>
</ul>
<center> <table class="doxtable">
<tr>
<td><b>Error Code</b></td><td><b>Meaning</b>  </td></tr>
<tr>
<td>-1</td><td>Generic Error (called method or function returned an error)  </td></tr>
<tr>
<td>-2</td><td>Input data not valid (wrong parameter, out-of-bounds, wrong dimensions, matrix is not square,...)  </td></tr>
<tr>
<td>-3</td><td>Data has not been correctly pre-processed  </td></tr>
<tr>
<td>-4</td><td>Problem encountered during application of the algorithm (division by zero, out-of-bounds, ...)  </td></tr>
<tr>
<td>-5</td><td>Memory allocation error  </td></tr>
<tr>
<td>-98</td><td>Feature is not supported  </td></tr>
<tr>
<td>-99</td><td>Feature is not implemented yet (check <a class="el" href="index.html#ifp_bugs">Known Bugs and Future Developments</a>, or submit a bug)  </td></tr>
</table>
</center><h1><a class="anchor" id="ifp_bugs"></a>
Known Bugs and Future Developments</h1>
<ul>
<li>IFPACK does not support Epetra matrices whose OperatorDomainMap() is different from the OperatorRangeMap() and from RowMatrixRowMap(). Handling of this particular case is under development for class <a class="el" href="classIfpack__AdditiveSchwarz.html" title="Ifpack_AdditiveSchwarz: a class to define Additive Schwarz preconditioners of Epetra_RowMatrix&#39;s.">Ifpack_AdditiveSchwarz</a> only.</li>
<li>not all IFPACK preconditioners work correctly when <code>UseTranspose()</code> <code>==</code> true. <a class="el" href="classIfpack__PointRelaxation.html" title="Ifpack_PointRelaxation: a class to define point relaxation preconditioners of for Epetra_RowMatrix&#39;s.">Ifpack_PointRelaxation</a> and <a class="el" href="classIfpack__BlockRelaxation.html" title="Ifpack_BlockRelaxation: a class to define block relaxation preconditioners of Epetra_RowMatrix&#39;s.">Ifpack_BlockRelaxation</a> do not support <code>UseTranspose</code>, while <a class="el" href="classIfpack__ILU.html" title="Ifpack_ILU: A class for constructing and using an incomplete lower/upper (ILU) factorization of a giv...">Ifpack_ILU</a>, <a class="el" href="classIfpack__ILUT.html" title="Ifpack_ILUT: A class for constructing and using an incomplete LU factorization of a given Epetra_RowM...">Ifpack_ILUT</a> and <a class="el" href="classIfpack__Amesos.html" title="Ifpack_Amesos: a class to use Amesos&#39; factorizations as preconditioners.">Ifpack_Amesos</a> do.</li>
</ul>
<h1><a class="anchor" id="ifp_copyright"></a>
Copyright</h1>
<pre class="fragment">Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
license for use of this work by or on behalf of the U.S. Government.

This library is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301
USA
</pre><h1><a class="anchor" id="ifp_browser"></a>
Browse all of Ifpack as a single doxygen collection</h1>
<p>You can browse all of <a class="el" href="classIfpack.html" title="Ifpack: a function class to define Ifpack preconditioners.">Ifpack</a> as a <a href="../../browser/doc/html/index.html">single doxygen collection</a>. Warning, this is not the recommended way to learn about <a class="el" href="classIfpack.html" title="Ifpack: a function class to define Ifpack preconditioners.">Ifpack</a> software. However, this is a good way to browse the <a href="../../browser/doc/html/dirs.html">directory structure of ifpack</a>, to <a href="../../browser/doc/html/files.html">locate files</a>, etc. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 9 2025 20:38:00 for IFPACK by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
