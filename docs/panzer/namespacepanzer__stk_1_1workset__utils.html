<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Panzer: panzer_stk::workset_utils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Panzer<span id="projectnumber">&#160;Version of the Day</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepanzer__stk.html">panzer_stk</a></li><li class="navelem"><a class="el" href="namespacepanzer__stk_1_1workset__utils.html">workset_utils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">panzer_stk::workset_utils Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afc5a100b667415f1253ed2782d27025f" id="r_afc5a100b667415f1253ed2782d27025f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepanzer__stk_1_1workset__utils.html#afc5a100b667415f1253ed2782d27025f">getSubcellElements</a> (const <a class="el" href="classpanzer__stk_1_1STK__Interface.html">panzer_stk::STK_Interface</a> &amp;mesh, const std::string &amp;blockId, const std::vector&lt; stk::mesh::Entity &gt; &amp;entities, std::vector&lt; std::size_t &gt; &amp;localEntityIds, std::vector&lt; stk::mesh::Entity &gt; &amp;elements)</td></tr>
<tr class="separator:afc5a100b667415f1253ed2782d27025f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d83d36318b6e3e92e645427fc48427" id="r_a78d83d36318b6e3e92e645427fc48427"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepanzer__stk_1_1workset__utils.html#a78d83d36318b6e3e92e645427fc48427">getUniversalSubcellElements</a> (const <a class="el" href="classpanzer__stk_1_1STK__Interface.html">panzer_stk::STK_Interface</a> &amp;mesh, const std::string &amp;blockId, const std::vector&lt; stk::mesh::Entity &gt; &amp;entities, std::vector&lt; std::size_t &gt; &amp;localEntityIds, std::vector&lt; stk::mesh::Entity &gt; &amp;elements, std::vector&lt; std::size_t &gt; &amp;missingElementIndices)</td></tr>
<tr class="separator:a78d83d36318b6e3e92e645427fc48427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae844494dc5aabd253a71ba71f7ec5324" id="r_ae844494dc5aabd253a71ba71f7ec5324"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepanzer__stk_1_1workset__utils.html#ae844494dc5aabd253a71ba71f7ec5324">getSideElementCascade</a> (const <a class="el" href="classpanzer__stk_1_1STK__Interface.html">panzer_stk::STK_Interface</a> &amp;mesh, const std::string &amp;blockId, const std::vector&lt; stk::mesh::Entity &gt; &amp;sides, std::vector&lt; std::size_t &gt; &amp;localSubcellDim, std::vector&lt; std::size_t &gt; &amp;localSubcellIds, std::vector&lt; stk::mesh::Entity &gt; &amp;elements)</td></tr>
<tr class="separator:ae844494dc5aabd253a71ba71f7ec5324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641d6a4e35d6958de816809285bbac8f" id="r_a641d6a4e35d6958de816809285bbac8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepanzer__stk_1_1workset__utils.html#a641d6a4e35d6958de816809285bbac8f">getSideElements</a> (const <a class="el" href="classpanzer__stk_1_1STK__Interface.html">panzer_stk::STK_Interface</a> &amp;mesh, const std::string &amp;blockId, const std::vector&lt; stk::mesh::Entity &gt; &amp;sides, std::vector&lt; std::size_t &gt; &amp;localSideIds, std::vector&lt; stk::mesh::Entity &gt; &amp;elements)</td></tr>
<tr class="separator:a641d6a4e35d6958de816809285bbac8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9314ade8687ee1a31f80a9c0784f1d" id="r_ade9314ade8687ee1a31f80a9c0784f1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepanzer__stk_1_1workset__utils.html#ade9314ade8687ee1a31f80a9c0784f1d">getSideElements</a> (const <a class="el" href="classpanzer__stk_1_1STK__Interface.html">panzer_stk::STK_Interface</a> &amp;mesh, const std::string &amp;blockId_a, const std::string &amp;blockId_b, const std::vector&lt; stk::mesh::Entity &gt; &amp;sides, std::vector&lt; std::size_t &gt; &amp;localSideIds_a, std::vector&lt; stk::mesh::Entity &gt; &amp;elements_a, std::vector&lt; std::size_t &gt; &amp;localSideIds_b, std::vector&lt; stk::mesh::Entity &gt; &amp;elements_b)</td></tr>
<tr class="separator:ade9314ade8687ee1a31f80a9c0784f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64c9cc823a82c49f489c66ee3351dfe" id="r_ae64c9cc823a82c49f489c66ee3351dfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepanzer__stk_1_1workset__utils.html#ae64c9cc823a82c49f489c66ee3351dfe">getNodeElements</a> (const <a class="el" href="classpanzer__stk_1_1STK__Interface.html">panzer_stk::STK_Interface</a> &amp;mesh, const std::string &amp;blockId, const std::vector&lt; stk::mesh::Entity &gt; &amp;nodes, std::vector&lt; std::size_t &gt; &amp;localNodeIds, std::vector&lt; stk::mesh::Entity &gt; &amp;elements)</td></tr>
<tr class="separator:ae64c9cc823a82c49f489c66ee3351dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe54d141aea41a52787a5a285fbcf0df" id="r_abe54d141aea41a52787a5a285fbcf0df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepanzer__stk_1_1workset__utils.html#abe54d141aea41a52787a5a285fbcf0df">getSubcellEntities</a> (const <a class="el" href="classpanzer__stk_1_1STK__Interface.html">panzer_stk::STK_Interface</a> &amp;mesh, const std::vector&lt; stk::mesh::Entity &gt; &amp;entities, std::vector&lt; std::vector&lt; stk::mesh::Entity &gt; &gt; &amp;subcells)</td></tr>
<tr class="separator:abe54d141aea41a52787a5a285fbcf0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61533531e2c9c9c6c7506a3cf0a579b3" id="r_a61533531e2c9c9c6c7506a3cf0a579b3"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:a61533531e2c9c9c6c7506a3cf0a579b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepanzer__stk_1_1workset__utils.html#a61533531e2c9c9c6c7506a3cf0a579b3">getIdsAndVertices</a> (const <a class="el" href="classpanzer__stk_1_1STK__Interface.html">panzer_stk::STK_Interface</a> &amp;mesh, std::string blockId, std::vector&lt; std::size_t &gt; &amp;localIds, ArrayT &amp;vertices)</td></tr>
<tr class="separator:a61533531e2c9c9c6c7506a3cf0a579b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09593c9261f473755f1572423e5b2dc3" id="r_a09593c9261f473755f1572423e5b2dc3"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:a09593c9261f473755f1572423e5b2dc3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepanzer__stk_1_1workset__utils.html#a09593c9261f473755f1572423e5b2dc3">getIdsAndNodes</a> (const <a class="el" href="classpanzer__stk_1_1STK__Interface.html">panzer_stk::STK_Interface</a> &amp;mesh, std::string blockId, std::vector&lt; std::size_t &gt; &amp;localIds, ArrayT &amp;nodes)</td></tr>
<tr class="separator:a09593c9261f473755f1572423e5b2dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="afc5a100b667415f1253ed2782d27025f" name="afc5a100b667415f1253ed2782d27025f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5a100b667415f1253ed2782d27025f">&#9670;&#160;</a></span>getSubcellElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void panzer_stk::workset_utils::getSubcellElements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanzer__stk_1_1STK__Interface.html">panzer_stk::STK_Interface</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>blockId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; stk::mesh::Entity &gt; &amp;&#160;</td>
          <td class="paramname"><em>entities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>localEntityIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; stk::mesh::Entity &gt; &amp;&#160;</td>
          <td class="paramname"><em>elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function loops over the passed in set of entities and looks at their related elements. It is then determined which elements belong in the requested element block, and what the local ID of the entitiy is.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>STK mesh interface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockId</td><td>Requested element block identifier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>Set of subcell entities where there is assumed part membership (induced or not) in the requested element block. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">localEntityIds</td><td>On output this will contain the local entity ids. Assumed that on input <code>entities.size()==0</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">elements</td><td>On output this will contain the elements associated with each entity in the requested block. Assumed that on input <code>elements.size()==0</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onProcOnly</td><td>Only return the elements owned by this processor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Some elements may be repeated in the lists, however the local entity ID should be distinct for each of those. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Panzer__STK__SetupUtilities_8cpp_source.html#l00327">327</a> of file <a class="el" href="Panzer__STK__SetupUtilities_8cpp_source.html">Panzer_STK_SetupUtilities.cpp</a>.</p>

</div>
</div>
<a id="a78d83d36318b6e3e92e645427fc48427" name="a78d83d36318b6e3e92e645427fc48427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78d83d36318b6e3e92e645427fc48427">&#9670;&#160;</a></span>getUniversalSubcellElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void panzer_stk::workset_utils::getUniversalSubcellElements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanzer__stk_1_1STK__Interface.html">panzer_stk::STK_Interface</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>blockId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; stk::mesh::Entity &gt; &amp;&#160;</td>
          <td class="paramname"><em>entities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>localEntityIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; stk::mesh::Entity &gt; &amp;&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>missingElementIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function loops over the passed in set of entities and looks at their related elements. It is then determined which elements belong in the requested element block, and what the local ID of the entitiy is. It also collects the element indices related to the set of entities that do not belong to the requested element block and its neighbor is ghosted. This will return both local and ghosted entities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>STK mesh interface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockId</td><td>Requested element block identifier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>Set of subcell entities where there is assumed part membership (induced or not) in the requested element block. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">localEntityIds</td><td>On output this will contain the local entity ids. Assumed that on input <code>entities.size()==0</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">elements</td><td>On output this will contain the elements associated with each entity in the requested block. Assumed that on input <code>elements.size()==0</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">missingElementIndices</td><td>On output this will contain the elements associated with each entity in the passed set, but it is not in the requested block and its neighbor belonging the to the block is a ghost element. Assumed that on input <code>entities.size()==0</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Some elements may be repeated in the lists, however the local entity ID should be distinct for each of those. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Panzer__STK__SetupUtilities_8cpp_source.html#l00364">364</a> of file <a class="el" href="Panzer__STK__SetupUtilities_8cpp_source.html">Panzer_STK_SetupUtilities.cpp</a>.</p>

</div>
</div>
<a id="ae844494dc5aabd253a71ba71f7ec5324" name="ae844494dc5aabd253a71ba71f7ec5324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae844494dc5aabd253a71ba71f7ec5324">&#9670;&#160;</a></span>getSideElementCascade()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void panzer_stk::workset_utils::getSideElementCascade </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanzer__stk_1_1STK__Interface.html">panzer_stk::STK_Interface</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>blockId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; stk::mesh::Entity &gt; &amp;&#160;</td>
          <td class="paramname"><em>sides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>localSubcellDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcellIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; stk::mesh::Entity &gt; &amp;&#160;</td>
          <td class="paramname"><em>elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function builds the "element cascade" contained within a specfied element block. That is given a set of "sides" extract all elements that live in the block and touch those sides on a node, edge or face. It returns the local sub cell index and sub cell dimension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>
<p>param [in] mesh STK mesh interface </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blockId</td><td>Requested element block identifier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sides</td><td>Set of sides (entities of dimension-1) where there is assumed part membership (induced or not) in the requested element block. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">subcellDim</td><td>On output this will contain the subcell dimensions. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">localSubcellIds</td><td>On output this will contain the local subcell ids. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">elements</td><td>On output this will contain the elements associated with each subcell in the requested block. Assumed that on input <code>elements.size()==0</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Panzer__STK__SetupUtilities_8cpp_source.html#l00408">408</a> of file <a class="el" href="Panzer__STK__SetupUtilities_8cpp_source.html">Panzer_STK_SetupUtilities.cpp</a>.</p>

</div>
</div>
<a id="a641d6a4e35d6958de816809285bbac8f" name="a641d6a4e35d6958de816809285bbac8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641d6a4e35d6958de816809285bbac8f">&#9670;&#160;</a></span>getSideElements() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void panzer_stk::workset_utils::getSideElements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanzer__stk_1_1STK__Interface.html">panzer_stk::STK_Interface</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>blockId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; stk::mesh::Entity &gt; &amp;&#160;</td>
          <td class="paramname"><em>sides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>localSideIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; stk::mesh::Entity &gt; &amp;&#160;</td>
          <td class="paramname"><em>elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function loops over the passed in set of "Sides" and looks at there related elements. It is then determined which elements belong in the requested element block, and what the local ID of the side is.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>STK mesh interface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockId</td><td>Requested element block identifier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sides</td><td>Set of sides (entities of dimension-1) where there is assumed part membership (induced or not) in the requested element block. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">localSideIds</td><td>On output this will contain the local side ids. Assumed that on input <code>sides.size()==0</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">elements</td><td>On output this will contain the elements associated with each side in the requested block. Assumed that on input <code>elements.size()==0</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Some elements may be repeated in the lists, however the local side ID should be distinct for each of those. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Panzer__STK__SetupUtilities_8cpp_source.html#l00444">444</a> of file <a class="el" href="Panzer__STK__SetupUtilities_8cpp_source.html">Panzer_STK_SetupUtilities.cpp</a>.</p>

</div>
</div>
<a id="ade9314ade8687ee1a31f80a9c0784f1d" name="ade9314ade8687ee1a31f80a9c0784f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9314ade8687ee1a31f80a9c0784f1d">&#9670;&#160;</a></span>getSideElements() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void panzer_stk::workset_utils::getSideElements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanzer__stk_1_1STK__Interface.html">panzer_stk::STK_Interface</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>blockId_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>blockId_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; stk::mesh::Entity &gt; &amp;&#160;</td>
          <td class="paramname"><em>sides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>localSideIds_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; stk::mesh::Entity &gt; &amp;&#160;</td>
          <td class="paramname"><em>elements_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>localSideIds_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; stk::mesh::Entity &gt; &amp;&#160;</td>
          <td class="paramname"><em>elements_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function loops over the passed in set of "Sides" and looks at there related elements. It is then determined which elements belong in the requested element block, and what the local ID of the side is. This version is for sides where you want elements that live in two element blocks. The "a" elements are required to be owned, the "b" elements maybe ghosted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>STK mesh interface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockId_a</td><td>Requested element block identifier (owned only) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockId_b</td><td>Requested element block identifier (owned and ghosted) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sides</td><td>Set of sides (entities of dimension-1) where there is assumed part membership (induced or not) in the requested element block. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">localSideIds_a</td><td>On output this will contain the local side ids for elements in block "a". Assumed that on input <code>sides.size()==0</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">elements_a</td><td>On output this will contain the elements associated with each side in the "a" block. Assumed that on input <code>elements.size()==0</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">localSideIds_b</td><td>On output this will contain the local side ids for elements in block "b". Assumed that on input <code>sides.size()==0</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">elements_b</td><td>On output this will contain the elements associated with each side in the "b" block. Assumed that on input <code>elements.size()==0</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Some elements may be repeated in the lists, however the local side ID should be distinct for each of those. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Panzer__STK__SetupUtilities_8cpp_source.html#l00453">453</a> of file <a class="el" href="Panzer__STK__SetupUtilities_8cpp_source.html">Panzer_STK_SetupUtilities.cpp</a>.</p>

</div>
</div>
<a id="ae64c9cc823a82c49f489c66ee3351dfe" name="ae64c9cc823a82c49f489c66ee3351dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64c9cc823a82c49f489c66ee3351dfe">&#9670;&#160;</a></span>getNodeElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void panzer_stk::workset_utils::getNodeElements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanzer__stk_1_1STK__Interface.html">panzer_stk::STK_Interface</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>blockId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; stk::mesh::Entity &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>localNodeIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; stk::mesh::Entity &gt; &amp;&#160;</td>
          <td class="paramname"><em>elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function loops over the passed in set of "Nodes" and looks at there related elements. It is then determined which elements belong in the requested element block, and what the local ID of the node is.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>STK mesh interface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockId</td><td>Requested element block identifier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodes</td><td>Set of nodes (entities of dimension 0) where there is assumed part membership (induced or not) in the requested element block. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">localNodeIds</td><td>On output this will contain the local node ids. Assumed that on input <code>node.size()==0</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">elements</td><td>On output this will contain the elements associated with each node in the requested block. Assumed that on input <code>elements.size()==0</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Some elements may be repeated in the lists, however the local node ID should be distinct for each of those. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Panzer__STK__SetupUtilities_8cpp_source.html#l00516">516</a> of file <a class="el" href="Panzer__STK__SetupUtilities_8cpp_source.html">Panzer_STK_SetupUtilities.cpp</a>.</p>

</div>
</div>
<a id="abe54d141aea41a52787a5a285fbcf0df" name="abe54d141aea41a52787a5a285fbcf0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe54d141aea41a52787a5a285fbcf0df">&#9670;&#160;</a></span>getSubcellEntities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void panzer_stk::workset_utils::getSubcellEntities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanzer__stk_1_1STK__Interface.html">panzer_stk::STK_Interface</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; stk::mesh::Entity &gt; &amp;&#160;</td>
          <td class="paramname"><em>entities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; stk::mesh::Entity &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get all the subcells that are contained within the list of entities. The resulting vector is organized by dimension and it is guranteed that no entity is included more then once.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>STK mesh interface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>Set of entities of the same dimension, these the parent entities whose subcells are extracted. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">subcells</td><td>Set of subcells catoragized by dimension. The first index is the physical dimension. Each entity in the vector will be unique. Note that this vector is <code>clear</code>ed at the beginning of this method. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Panzer__STK__SetupUtilities_8cpp_source.html#l00525">525</a> of file <a class="el" href="Panzer__STK__SetupUtilities_8cpp_source.html">Panzer_STK_SetupUtilities.cpp</a>.</p>

</div>
</div>
<a id="a61533531e2c9c9c6c7506a3cf0a579b3" name="a61533531e2c9c9c6c7506a3cf0a579b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61533531e2c9c9c6c7506a3cf0a579b3">&#9670;&#160;</a></span>getIdsAndVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void panzer_stk::workset_utils::getIdsAndVertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanzer__stk_1_1STK__Interface.html">panzer_stk::STK_Interface</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>blockId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>localIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayT &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get vertices and local cell IDs of a paricular element block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Reference to <a class="el" href="classpanzer__stk_1_1STK__Interface.html">STK_Interface</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockId</td><td>Element block identifier string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">localIds</td><td>On processor local element IDs for the element block </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vertices</td><td>Abstract array type (requires resize) containing the coordinates of the vertices. Of size (#Cells, #Vertices, #Dim). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Panzer__STK__SetupUtilities__impl_8hpp_source.html#l00019">19</a> of file <a class="el" href="Panzer__STK__SetupUtilities__impl_8hpp_source.html">Panzer_STK_SetupUtilities_impl.hpp</a>.</p>

</div>
</div>
<a id="a09593c9261f473755f1572423e5b2dc3" name="a09593c9261f473755f1572423e5b2dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09593c9261f473755f1572423e5b2dc3">&#9670;&#160;</a></span>getIdsAndNodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void panzer_stk::workset_utils::getIdsAndNodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanzer__stk_1_1STK__Interface.html">panzer_stk::STK_Interface</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>blockId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>localIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayT &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get nodes and local cell IDs of a particular element block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Reference to <a class="el" href="classpanzer__stk_1_1STK__Interface.html">STK_Interface</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockId</td><td>Element block identifier string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">localIds</td><td>On processor local element IDs for the element block </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nodes</td><td>Abstract array type (requires resize) containing the coordinates of the nodes. Of size (#Cells, #Nodes, #Dim). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Panzer__STK__SetupUtilities__impl_8hpp_source.html#l00040">40</a> of file <a class="el" href="Panzer__STK__SetupUtilities__impl_8hpp_source.html">Panzer_STK_SetupUtilities_impl.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 9 2025 20:46:31 for Panzer by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
