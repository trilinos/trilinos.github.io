<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EpetraExt: EpetraExt::MatrixMatrix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">EpetraExt<span id="projectnumber">&#160;Development</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceEpetraExt.html">EpetraExt</a></li><li class="navelem"><a class="el" href="classEpetraExt_1_1MatrixMatrix.html">MatrixMatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classEpetraExt_1_1MatrixMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">EpetraExt::MatrixMatrix Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Collection of matrix-matrix operations.  
 <a href="classEpetraExt_1_1MatrixMatrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="EpetraExt__MatrixMatrix_8h_source.html">EpetraExt_MatrixMatrix.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acd6c77b14d12b914c542dba20e4aee28" id="r_acd6c77b14d12b914c542dba20e4aee28"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetraExt_1_1MatrixMatrix.html#acd6c77b14d12b914c542dba20e4aee28">~MatrixMatrix</a> ()</td></tr>
<tr class="memdesc:acd6c77b14d12b914c542dba20e4aee28"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor  <br /></td></tr>
<tr class="separator:acd6c77b14d12b914c542dba20e4aee28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac05e8a39cf442523e45779b2cc1803af" id="r_ac05e8a39cf442523e45779b2cc1803af"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetraExt_1_1MatrixMatrix.html#ac05e8a39cf442523e45779b2cc1803af">Multiply</a> (const <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;A, bool transposeA, const <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;B, bool transposeB, <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;C, bool call_FillComplete_on_result=true, bool keep_all_hard_zeros=false)</td></tr>
<tr class="memdesc:ac05e8a39cf442523e45779b2cc1803af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> objects A, B and C, form the product C = A*B.  <br /></td></tr>
<tr class="separator:ac05e8a39cf442523e45779b2cc1803af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb18e4c84059790b9ae0f7a37e5c4b73" id="r_abb18e4c84059790b9ae0f7a37e5c4b73"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetraExt_1_1MatrixMatrix.html#abb18e4c84059790b9ae0f7a37e5c4b73">Add</a> (const <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;A, bool transposeA, double scalarA, <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;B, double scalarB)</td></tr>
<tr class="memdesc:abb18e4c84059790b9ae0f7a37e5c4b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> objects A and B, form the sum B = a*A + b*B.  <br /></td></tr>
<tr class="separator:abb18e4c84059790b9ae0f7a37e5c4b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b83cfb3d697e3916a343220cc8173f" id="r_af5b83cfb3d697e3916a343220cc8173f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetraExt_1_1MatrixMatrix.html#af5b83cfb3d697e3916a343220cc8173f">Add</a> (const <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;A, bool transposeA, double scalarA, const <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;B, bool transposeB, double scalarB, <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> *&amp;C)</td></tr>
<tr class="memdesc:af5b83cfb3d697e3916a343220cc8173f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> objects A and B, form the sum C = a*A + b*B.  <br /></td></tr>
<tr class="separator:af5b83cfb3d697e3916a343220cc8173f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b23cecb1491b7f2a1fb0bc67f0995c" id="r_a01b23cecb1491b7f2a1fb0bc67f0995c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetraExt_1_1MatrixMatrix.html#a01b23cecb1491b7f2a1fb0bc67f0995c">Jacobi</a> (double omega, const <a class="elRef" href="../../../epetra/doc/html/classEpetra__Vector.html">Epetra_Vector</a> &amp;Dinv, const <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;A, const <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;B, <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;C, bool call_FillComplete_on_result=true)</td></tr>
<tr class="memdesc:a01b23cecb1491b7f2a1fb0bc67f0995c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> objects A, B and C, and <a class="elRef" href="../../../epetra/doc/html/classEpetra__Vector.html">Epetra_Vector</a> Dinv, form the product C = (I-omega * Dinv A)*B In a parallel setting, A and B need not have matching distributions, but C needs to have the same row-map as A.  <br /></td></tr>
<tr class="separator:a01b23cecb1491b7f2a1fb0bc67f0995c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Collection of matrix-matrix operations. </p>
<p>This class basically functions as a namespace, containing only static methods. See the program epetraext/test/MatrixMatrix/cxx_main.cpp for a usage example. </p>

<p class="definition">Definition at line <a class="el" href="EpetraExt__MatrixMatrix_8h_source.html#l00069">69</a> of file <a class="el" href="EpetraExt__MatrixMatrix_8h_source.html">EpetraExt_MatrixMatrix.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acd6c77b14d12b914c542dba20e4aee28" name="acd6c77b14d12b914c542dba20e4aee28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6c77b14d12b914c542dba20e4aee28">&#9670;&#160;</a></span>~MatrixMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual EpetraExt::MatrixMatrix::~MatrixMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destructor </p>

<p class="definition">Definition at line <a class="el" href="EpetraExt__MatrixMatrix_8h_source.html#l00073">73</a> of file <a class="el" href="EpetraExt__MatrixMatrix_8h_source.html">EpetraExt_MatrixMatrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac05e8a39cf442523e45779b2cc1803af" name="ac05e8a39cf442523e45779b2cc1803af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05e8a39cf442523e45779b2cc1803af">&#9670;&#160;</a></span>Multiply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int EpetraExt::MatrixMatrix::Multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transposeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transposeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>call_FillComplete_on_result</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keep_all_hard_zeros</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> objects A, B and C, form the product C = A*B. </p>
<p>In a parallel setting, A and B need not have matching distributions, but C needs to have the same row-map as A.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Input, must already have had 'FillComplete()' called. </td></tr>
    <tr><td class="paramname">transposeA</td><td>Input, whether to use transpose of matrix A. </td></tr>
    <tr><td class="paramname">B</td><td>Input, must already have had 'FillComplete()' called. </td></tr>
    <tr><td class="paramname">transposeB</td><td>Input, whether to use transpose of matrix B. </td></tr>
    <tr><td class="paramname">C</td><td>Result. On entry to this method, it doesn't matter whether FillComplete() has already been called on C or not. If it has, then C's graph must already contain all nonzero locations that will be produced when forming the product A*B. On exit, C.FillComplete() will have been called, unless the last argument to this function is specified to be false. </td></tr>
    <tr><td class="paramname">call_FillComplete_on_result</td><td>Optional argument, defaults to true. Power users may specify this argument to be false if they <em>DON'T</em> want this function to call C.FillComplete. (It is often useful to allow this function to call C.FillComplete, in cases where one or both of the input matrices are rectangular and it is not trivial to know which maps to use for the domain- and range-maps.) </td></tr>
    <tr><td class="paramname">keep_all_hard_zeros</td><td>Optional argument, defaults to false. If true, Multiply, keeps all entries in C corresponding to hard zeros. <br  />
 If false, the following happens by case: A*B^T, A^T*B^T - Does not store entries caused by hard zeros in C. A^T*B (unoptimized) - Hard zeros are always stored (this option has no effect) A*B, A^T*B (optimized) - Hard zeros in corresponding to hard zeros in A are not stored, There are certain cases involving reuse of C, where this can be useful. <br  />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error-code, 0 if successful. non-zero returns may result if A or B are not already Filled, or if errors occur in putting values into C, etc. </dd></dl>

<p class="definition">Definition at line <a class="el" href="EpetraExt__MatrixMatrix_8cpp_source.html#l01304">1304</a> of file <a class="el" href="EpetraExt__MatrixMatrix_8cpp_source.html">EpetraExt_MatrixMatrix.cpp</a>.</p>

</div>
</div>
<a id="abb18e4c84059790b9ae0f7a37e5c4b73" name="abb18e4c84059790b9ae0f7a37e5c4b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb18e4c84059790b9ae0f7a37e5c4b73">&#9670;&#160;</a></span>Add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int EpetraExt::MatrixMatrix::Add </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transposeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalarA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalarB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> objects A and B, form the sum B = a*A + b*B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Input, must already have had 'FillComplete()' called. </td></tr>
    <tr><td class="paramname">transposeA</td><td>Input, whether to use transpose of matrix A. </td></tr>
    <tr><td class="paramname">scalarA</td><td>Input, scalar multiplier for matrix A. </td></tr>
    <tr><td class="paramname">B</td><td>Result. On entry to this method, it doesn't matter whether FillComplete() has already been called on B or not. If it has, then B's graph must already contain all nonzero locations that will be produced when forming the sum. </td></tr>
    <tr><td class="paramname">scalarB</td><td>Input, scalar multiplier for matrix B.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error-code, 0 if successful. non-zero returns may result if A is not already Filled, or if errors occur in putting values into B, etc. </dd></dl>

<p class="definition">Definition at line <a class="el" href="EpetraExt__MatrixMatrix_8cpp_source.html#l01423">1423</a> of file <a class="el" href="EpetraExt__MatrixMatrix_8cpp_source.html">EpetraExt_MatrixMatrix.cpp</a>.</p>

</div>
</div>
<a id="af5b83cfb3d697e3916a343220cc8173f" name="af5b83cfb3d697e3916a343220cc8173f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b83cfb3d697e3916a343220cc8173f">&#9670;&#160;</a></span>Add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int EpetraExt::MatrixMatrix::Add </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transposeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalarA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transposeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalarB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> *&amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> objects A and B, form the sum C = a*A + b*B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Input, must already have had 'FillComplete()' called. </td></tr>
    <tr><td class="paramname">transposeA</td><td>Input, whether to use transpose of matrix A. </td></tr>
    <tr><td class="paramname">scalarA</td><td>Input, scalar multiplier for matrix A. </td></tr>
    <tr><td class="paramname">B</td><td>Input, must already have had 'FillComplete()' called. </td></tr>
    <tr><td class="paramname">transposeB</td><td>Input, whether to use transpose of matrix B. </td></tr>
    <tr><td class="paramname">scalarB</td><td>Input, scalar multiplier for matrix B. </td></tr>
    <tr><td class="paramname">C</td><td>Result. On entry to this method, C can be NULL or a pointer to an unfilled or filled matrix. If C is NULL then a new object is allocated and must be deleted by the user. If C is not NULL and FillComplete has already been called then the sparsity pattern is assumed to be fixed and compatible with the sparsity of A+B. If FillComplete has not been called then the sum is completed and the function returns without calling FillComplete on C.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error-code, 0 if successful. non-zero returns may result if A or is not already Filled, or if errors occur in putting values into C, etc. </dd></dl>

<p class="definition">Definition at line <a class="el" href="EpetraExt__MatrixMatrix_8cpp_source.html#l01532">1532</a> of file <a class="el" href="EpetraExt__MatrixMatrix_8cpp_source.html">EpetraExt_MatrixMatrix.cpp</a>.</p>

</div>
</div>
<a id="a01b23cecb1491b7f2a1fb0bc67f0995c" name="a01b23cecb1491b7f2a1fb0bc67f0995c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b23cecb1491b7f2a1fb0bc67f0995c">&#9670;&#160;</a></span>Jacobi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int EpetraExt::MatrixMatrix::Jacobi </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../../../epetra/doc/html/classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>Dinv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>call_FillComplete_on_result</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> objects A, B and C, and <a class="elRef" href="../../../epetra/doc/html/classEpetra__Vector.html">Epetra_Vector</a> Dinv, form the product C = (I-omega * Dinv A)*B In a parallel setting, A and B need not have matching distributions, but C needs to have the same row-map as A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">omega</td><td>Input, scalar multiplier for Dinverse A </td></tr>
    <tr><td class="paramname">Dinv</td><td>Input, <a class="elRef" href="../../../epetra/doc/html/classEpetra__Vector.html">Epetra_Vector</a> representing a diagonal matrix, must match A's RowMap </td></tr>
    <tr><td class="paramname">A</td><td>Input, must already have had 'FillComplete()' called. </td></tr>
    <tr><td class="paramname">B</td><td>Input, must already have had 'FillComplete()' called. </td></tr>
    <tr><td class="paramname">C</td><td>Result. On entry to this method, it doesn't matter whether FillComplete() has already been called on C or not. If it has, then C's graph must already contain all nonzero locations that will be produced when forming the product A*B. On exit, C.FillComplete() will have been called, unless the last argument to this function is specified to be false. </td></tr>
    <tr><td class="paramname">call_FillComplete_on_result</td><td>Optional argument, defaults to true. Power users may specify this argument to be false if they <em>DON'T</em> want this function to call C.FillComplete. (It is often useful to allow this function to call C.FillComplete, in cases where one or both of the input matrices are rectangular and it is not trivial to know which maps to use for the domain- and range-maps.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error-code, 0 if successful. non-zero returns may result if A or B are not already Filled, or if errors occur in putting values into C, etc. </dd></dl>

<p class="definition">Definition at line <a class="el" href="EpetraExt__MatrixMatrix_8cpp_source.html#l01695">1695</a> of file <a class="el" href="EpetraExt__MatrixMatrix_8cpp_source.html">EpetraExt_MatrixMatrix.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="EpetraExt__MatrixMatrix_8h_source.html">EpetraExt_MatrixMatrix.h</a></li>
<li><a class="el" href="EpetraExt__MatrixMatrix_8cpp_source.html">EpetraExt_MatrixMatrix.cpp</a></li>
<li><a class="el" href="EpetraExt__MatrixMatrix__mult__A__B_8cpp_source.html">EpetraExt_MatrixMatrix_mult_A_B.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 9 2025 20:37:18 for EpetraExt by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
