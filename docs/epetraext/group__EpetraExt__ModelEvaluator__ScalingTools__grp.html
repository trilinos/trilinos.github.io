<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EpetraExt: Scaling Tools for EpetraExt::ModelEvaluator.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">EpetraExt<span id="projectnumber">&#160;Development</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Scaling Tools for EpetraExt::ModelEvaluator.</div></div>
</div><!--header-->
<div class="contents">

<p>These scaling functions implement scaling of input variables and output functions and their derivatives.  
</p>
<p>These scaling functions implement scaling of input variables and output functions and their derivatives. </p>
<p>The scaling vectors are stored in <code><a class="el" href="classEpetraExt_1_1ModelEvaluator_1_1InArgs.html">EpetraExt::ModelEvaluator::InArgs</a></code> and <code><a class="el" href="classEpetraExt_1_1ModelEvaluator_1_1OutArgs.html">EpetraExt::ModelEvaluator::OutArgs</a></code> objects in order to enhance maintainability and to avoid programming errors. This will result in some wasted space but it should not be excessive if used carefully.</p>
<p>First, consider scaling of the state function. Reguardless of how the state function scaling is computed, it will be represented as a positive vector <code>s_f</code> that defines a diagonal matrix <code>S_f = diag(s_f)</code> that transforms the state function:</p>
<pre class="fragment">   f(...) = S_f * f_hat(...)</pre><p>where <code>f_hat(...)</code> is the original unscaled state function as computed by the underlying <code><a class="el" href="classEpetraExt_1_1ModelEvaluator.html" title="Base interface for evaluating a stateless &quot;model&quot;.">EpetraExt::ModelEvaluator</a></code> object and <code>f(...)</code> is the scaled state function.</p>
<p>Next, consider the scaling of the state varaibles. The scaling for the state variables is defined by a positive vector <code>s_x&gt;/tt&gt; defines a diagonal scaling matrix <code>S_x = diag(s_x)</code> that transforms the variables as:</code></p>
<p><code></p><pre class="fragment">   x = S_x * x_hat</pre><p></code></p>
<p><code> where <code>x_hat</code> is the original unscaled state variable vector as defined by the underlying <code><a class="el" href="classEpetraExt_1_1ModelEvaluator.html" title="Base interface for evaluating a stateless &quot;model&quot;.">EpetraExt::ModelEvaluator</a></code> object and <code>x</code> is the scaled state varaible vector. Note that when the scaled variables <code>x</code> are passed into <code>evalModel</code> that they must be unscaled as:</code></p>
<p><code></p><pre class="fragment">   x_hat = inv(S_x) * x</pre><p></code></p>
<p><code> where <code>inv(S_x)</code> is the inverse of the diagonals of <code>S_x</code> which is stored as a positive vector <code>inv_s_x</code>. Since unscaling the variables as shown above is more common than scaling the original variables, the scaling vector will be stored as <code>inv_s_x</code> and not as <code>s_x</code>.</code></p>
<p><code> Note how these scalings affect the state function:</code></p>
<p><code></p><pre class="fragment">   f( x_dot, x, ... ) = S_f * f_hat( inv(S_x)*x_dot, inv(S_x)*x, ... )</pre><p></code></p>
<p><code> which has the state/state Jacobian:</code></p>
<p><code></p><pre class="fragment">   W = alpha * d(f)/d(x_dot) + beta * d(f)/d(x)
     = S_f * ( alpha * d(f_hat)/d(x_hat) + beta * d(f_hat)/d(x) ) * inv(S_x)</pre><p></code></p>
<p><code> Currently, these functions do not handle scalings of the parameters <code>p(l)</code> or of the auxilary response functions <code>g(j)(...)</code>.</code></p>
<p><code> The state varaible and state function scaling gives the following scaled quantities:</code></p>
<p><code></p><pre class="fragment">   f = S_f * f_hat

   W = S_f * W_hat * inv(S_x)

   DfDp(l) = S_f * DfDp_hat(l), for l=0...Np-1

   g(j) = g_hat(j), for j=0...Ng-1

   DgDx_dot(j) = DgDx_dot_hat(j) * inv(S_x), for j=0...Ng-1

   DgDx(j) = DgDx_hat(j) * inv(S_x), for j=0...Ng-1

   DgDp(j,l) = DgDp_hat(j,l), for j=0...Ng-1, l=0...Np-1</pre><p></code></p>
<p><code> ToDo: Describe how scaling of the state function <code>S_f</code> affects the Hessian-vector products an how you just need to scale the Lagrange mutipliers as:</code></p>
<p><code></p><pre class="fragment"> u^T * f(...) = u^T * (S_f * f_hat(...)) = u_f^T * f_hat(...)</pre><p></code></p>
<p><code> where <code>u_f = S_f * u</code>.</code></p>
<p><code> ToDo: Also describe how scaling of the state varaibles <code>S_x</code> affects Hessian-vector products and other related quantities.</code></p>
<p><code></code></p>
<h1><a class="anchor" id="EpetraExt_ModelEvaluator_ScalingTools_Maintenance_sec"></a>
Maintenance of these tools</h1>
<p><code></code></p>
<p><code> These scaling tools must be updated whenever the <code>InArgs</code> or <code>OutArgs</code> classes are augmented. However, not every use case with the model evaluator requires scaling so scaling with respect to some inputs and some outputs may never be needed and therefore never need to be seen by these tools. However, there is some danger in ignoring inputs and outputs in these scaling tools since some objects may be silently unscaled and could cause hard to track down bugs.</code></p>
<p><code> ToDo: Finish documentation! </code></p>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 9 2025 20:37:18 for EpetraExt by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
