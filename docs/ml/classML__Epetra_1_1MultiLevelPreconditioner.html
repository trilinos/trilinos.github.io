<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ML: ML_Epetra::MultiLevelPreconditioner Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ML<span id="projectnumber">&#160;Version of the Day</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceML__Epetra.html">ML_Epetra</a></li><li class="navelem"><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html">MultiLevelPreconditioner</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classML__Epetra_1_1MultiLevelPreconditioner-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ML_Epetra::MultiLevelPreconditioner Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html" title="MultiLevelPreconditioner: a class to define black-box multilevel preconditioners using aggregation me...">MultiLevelPreconditioner</a>: a class to define black-box multilevel preconditioners using aggregation methods.  
 <a href="classML__Epetra_1_1MultiLevelPreconditioner.html#details">More...</a></p>

<p><code>#include &lt;ml_MultiLevelPreconditioner.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ML_Epetra::MultiLevelPreconditioner:</div>
<div class="dyncontent">
<div class="center"><img src="classML__Epetra_1_1MultiLevelPreconditioner__inherit__graph.gif" border="0" usemap="#aML__Epetra_1_1MultiLevelPreconditioner_inherit__map" alt="Inheritance graph"/></div>
<map name="aML__Epetra_1_1MultiLevelPreconditioner_inherit__map" id="aML__Epetra_1_1MultiLevelPreconditioner_inherit__map">
<area shape="rect" title="MultiLevelPreconditioner: a class to define black&#45;box multilevel preconditioners using aggregation me..." alt="" coords="5,79,265,104"/>
<area shape="rect" target="_parent" href="../../../epetra/doc/html/classEpetra__Operator.html" title=" " alt="" coords="71,5,199,31"/>
<area shape="poly" title=" " alt="" coords="138,44,138,79,133,79,133,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ML_Epetra::MultiLevelPreconditioner:</div>
<div class="dyncontent">
<div class="center"><img src="classML__Epetra_1_1MultiLevelPreconditioner__coll__graph.gif" border="0" usemap="#aML__Epetra_1_1MultiLevelPreconditioner_coll__map" alt="Collaboration graph"/></div>
<map name="aML__Epetra_1_1MultiLevelPreconditioner_coll__map" id="aML__Epetra_1_1MultiLevelPreconditioner_coll__map">
<area shape="rect" title="MultiLevelPreconditioner: a class to define black&#45;box multilevel preconditioners using aggregation me..." alt="" coords="5,79,265,104"/>
<area shape="rect" target="_parent" href="../../../epetra/doc/html/classEpetra__Operator.html" title=" " alt="" coords="71,5,199,31"/>
<area shape="poly" title=" " alt="" coords="138,44,138,79,133,79,133,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a67347841c24bebda9e38ad628db145ba" id="r_a67347841c24bebda9e38ad628db145ba"><td class="memItemLeft" align="right" valign="top"><a id="a67347841c24bebda9e38ad628db145ba" name="a67347841c24bebda9e38ad628db145ba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MultiLevelPreconditioner</b> (const <a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> &amp;<a class="el" href="classML__Epetra_1_1RowMatrix.html">RowMatrix</a>, const bool ComputePrec=true)</td></tr>
<tr class="memdesc:a67347841c24bebda9e38ad628db145ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html" title="MultiLevelPreconditioner: a class to define black-box multilevel preconditioners using aggregation me...">MultiLevelPreconditioner</a> with default values. <br /></td></tr>
<tr class="separator:a67347841c24bebda9e38ad628db145ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ce4d3dd21908f8379fcf0ae41d2ffc" id="r_a86ce4d3dd21908f8379fcf0ae41d2ffc"><td class="memItemLeft" align="right" valign="top"><a id="a86ce4d3dd21908f8379fcf0ae41d2ffc" name="a86ce4d3dd21908f8379fcf0ae41d2ffc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MultiLevelPreconditioner</b> (const <a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> &amp;<a class="el" href="classML__Epetra_1_1RowMatrix.html">RowMatrix</a>, const Teuchos::ParameterList &amp;List, const bool ComputePrec=true)</td></tr>
<tr class="memdesc:a86ce4d3dd21908f8379fcf0ae41d2ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html" title="MultiLevelPreconditioner: a class to define black-box multilevel preconditioners using aggregation me...">MultiLevelPreconditioner</a>. Retrieves parameters from <code>List</code>. <br /></td></tr>
<tr class="separator:a86ce4d3dd21908f8379fcf0ae41d2ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809f3f842ef718ef97fc7b27a6ba21b5" id="r_a809f3f842ef718ef97fc7b27a6ba21b5"><td class="memItemLeft" align="right" valign="top"><a id="a809f3f842ef718ef97fc7b27a6ba21b5" name="a809f3f842ef718ef97fc7b27a6ba21b5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MultiLevelPreconditioner</b> (<a class="el" href="structML__Operator__Struct.html">ML_Operator</a> *Operator, const Teuchos::ParameterList &amp;List, const bool ComputePrec=true)</td></tr>
<tr class="memdesc:a809f3f842ef718ef97fc7b27a6ba21b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html" title="MultiLevelPreconditioner: a class to define black-box multilevel preconditioners using aggregation me...">MultiLevelPreconditioner</a> from an ML_Operator. Retrieves parameters from <code>List</code>. <br /></td></tr>
<tr class="separator:a809f3f842ef718ef97fc7b27a6ba21b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953ea2d18629c19c0b67e0a28338718a" id="r_a953ea2d18629c19c0b67e0a28338718a"><td class="memItemLeft" align="right" valign="top"><a id="a953ea2d18629c19c0b67e0a28338718a" name="a953ea2d18629c19c0b67e0a28338718a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MultiLevelPreconditioner</b> (<a class="el" href="structML__Operator__Struct.html">ML_Operator</a> *Operator, const Teuchos::ParameterList &amp;List, <a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> **DiagOperators, Teuchos::ParameterList *DiagLists, int NBlocks=1, const bool ComputePrec=true)</td></tr>
<tr class="memdesc:a953ea2d18629c19c0b67e0a28338718a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html" title="MultiLevelPreconditioner: a class to define black-box multilevel preconditioners using aggregation me...">MultiLevelPreconditioner</a> which is actually a composite AMG hierarchy using an array of ML_Operator's and an array of parameter lists. <br /></td></tr>
<tr class="separator:a953ea2d18629c19c0b67e0a28338718a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59203ed1c62ac76884e252f50e05a405" id="r_a59203ed1c62ac76884e252f50e05a405"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a59203ed1c62ac76884e252f50e05a405">MultiLevelPreconditioner</a> (const <a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> &amp;EdgeMatrix, const <a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> &amp;GradMatrix, const <a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> &amp;NodeMatrix, const Teuchos::ParameterList &amp;List, const bool ComputePrec=true, const bool UseNodeMatrixForSmoother=false)</td></tr>
<tr class="memdesc:a59203ed1c62ac76884e252f50e05a405"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html" title="MultiLevelPreconditioner: a class to define black-box multilevel preconditioners using aggregation me...">MultiLevelPreconditioner</a> constructor for Maxwell's equations.  <br /></td></tr>
<tr class="separator:a59203ed1c62ac76884e252f50e05a405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecdb34d13aaceb48767950ed50d1b24" id="r_a0ecdb34d13aaceb48767950ed50d1b24"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a0ecdb34d13aaceb48767950ed50d1b24">MultiLevelPreconditioner</a> (const <a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> &amp;CurlCurlMatrix, const <a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> &amp;MassMatrix, const <a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> &amp;TMatrix, const <a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> &amp;NodeMatrix, const Teuchos::ParameterList &amp;List, const bool ComputePrec=true)</td></tr>
<tr class="memdesc:a0ecdb34d13aaceb48767950ed50d1b24"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html" title="MultiLevelPreconditioner: a class to define black-box multilevel preconditioners using aggregation me...">MultiLevelPreconditioner</a> constructor for Maxwell's equations.  <br /></td></tr>
<tr class="separator:a0ecdb34d13aaceb48767950ed50d1b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3e3380ddad9bf64d3bf36bc3802f8f" id="r_a0e3e3380ddad9bf64d3bf36bc3802f8f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a0e3e3380ddad9bf64d3bf36bc3802f8f">MultiLevelPreconditioner</a> (<a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> &amp;<a class="el" href="classML__Epetra_1_1RowMatrix.html">RowMatrix</a>, const Teuchos::ParameterList &amp;List, const int &amp;nNodes, const int &amp;maxDofPerNode, bool *dofPresent, <a class="elRef" href="../../../epetra/doc/html/classEpetra__Vector.html">Epetra_Vector</a> &amp;Lhs, <a class="elRef" href="../../../epetra/doc/html/classEpetra__Vector.html">Epetra_Vector</a> &amp;Rhs, const bool rhsAndsolProvided, const bool ComputePrec=true)</td></tr>
<tr class="memdesc:a0e3e3380ddad9bf64d3bf36bc3802f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html" title="MultiLevelPreconditioner: a class to define black-box multilevel preconditioners using aggregation me...">MultiLevelPreconditioner</a> for multiphysics with variable dofs per node.  <br /></td></tr>
<tr class="separator:a0e3e3380ddad9bf64d3bf36bc3802f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78bf31e9762299427fe43de01f5c0de" id="r_ae78bf31e9762299427fe43de01f5c0de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#ae78bf31e9762299427fe43de01f5c0de">MultiLevelPreconditioner</a> (<a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> &amp;<a class="el" href="classML__Epetra_1_1RowMatrix.html">RowMatrix</a>, const Teuchos::ParameterList &amp;List, const double distTol, const double tol, <a class="elRef" href="../../../epetra/doc/html/classEpetra__Vector.html">Epetra_Vector</a> &amp;Lhs, <a class="elRef" href="../../../epetra/doc/html/classEpetra__Vector.html">Epetra_Vector</a> &amp;Rhs, const bool rhsAndsolProvided, const bool ComputePrec=true)</td></tr>
<tr class="separator:ae78bf31e9762299427fe43de01f5c0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd2ea24704e439cc3e87df1923cc883" id="r_a5dd2ea24704e439cc3e87df1923cc883"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a5dd2ea24704e439cc3e87df1923cc883">MultiLevelPreconditioner</a> (const <a class="elRef" href="../../../epetra/doc/html/classEpetra__MsrMatrix.html">Epetra_MsrMatrix</a> &amp;EdgeMatrix, <a class="el" href="structML__Operator__Struct.html">ML_Operator</a> *GradMatrix, AZ_MATRIX *NodeMatrix, int *proc_config, const Teuchos::ParameterList &amp;List, const bool ComputePrec=true)</td></tr>
<tr class="memdesc:a5dd2ea24704e439cc3e87df1923cc883"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html" title="MultiLevelPreconditioner: a class to define black-box multilevel preconditioners using aggregation me...">MultiLevelPreconditioner</a> constructor for Maxwell's equations.  <br /></td></tr>
<tr class="separator:a5dd2ea24704e439cc3e87df1923cc883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b15a8eb8beeaddc47e1eb96061e982d" id="r_a8b15a8eb8beeaddc47e1eb96061e982d"><td class="memItemLeft" align="right" valign="top"><a id="a8b15a8eb8beeaddc47e1eb96061e982d" name="a8b15a8eb8beeaddc47e1eb96061e982d"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~MultiLevelPreconditioner</b> ()</td></tr>
<tr class="memdesc:a8b15a8eb8beeaddc47e1eb96061e982d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the preconditioner. <br /></td></tr>
<tr class="separator:a8b15a8eb8beeaddc47e1eb96061e982d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a75aec17af5db17843110eeae75b0d" id="r_a05a75aec17af5db17843110eeae75b0d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a05a75aec17af5db17843110eeae75b0d">Label</a> () const</td></tr>
<tr class="memdesc:a05a75aec17af5db17843110eeae75b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints label associated to this object.  <br /></td></tr>
<tr class="separator:a05a75aec17af5db17843110eeae75b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16598f2eb932306426aebd561af4dc15" id="r_a16598f2eb932306426aebd561af4dc15"><td class="memItemLeft" align="right" valign="top"><a id="a16598f2eb932306426aebd561af4dc15" name="a16598f2eb932306426aebd561af4dc15"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PrintUnused</b> () const</td></tr>
<tr class="memdesc:a16598f2eb932306426aebd561af4dc15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints unused parameters in the input ParameterList on standard output. <br /></td></tr>
<tr class="separator:a16598f2eb932306426aebd561af4dc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5df095d99ef1754f7dc980eda9b11da" id="r_aa5df095d99ef1754f7dc980eda9b11da"><td class="memItemLeft" align="right" valign="top"><a id="aa5df095d99ef1754f7dc980eda9b11da" name="aa5df095d99ef1754f7dc980eda9b11da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PrintUnused</b> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:aa5df095d99ef1754f7dc980eda9b11da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints unused parameters in the input ParameterList on the specified stream. <br /></td></tr>
<tr class="separator:aa5df095d99ef1754f7dc980eda9b11da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366acb855d2c57ada05465ff983bbb4e" id="r_a366acb855d2c57ada05465ff983bbb4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a366acb855d2c57ada05465ff983bbb4e">PrintUnused</a> (const int MyPID) const</td></tr>
<tr class="memdesc:a366acb855d2c57ada05465ff983bbb4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints unused parameters in the input ParameterList to std::cout on proc <code>MyPID</code>.  <br /></td></tr>
<tr class="separator:a366acb855d2c57ada05465ff983bbb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac7b73efa8cff54b6ef225f8e630b73" id="r_a7ac7b73efa8cff54b6ef225f8e630b73"><td class="memItemLeft" align="right" valign="top"><a id="a7ac7b73efa8cff54b6ef225f8e630b73" name="a7ac7b73efa8cff54b6ef225f8e630b73"></a>
Teuchos::ParameterList &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetList</b> ()</td></tr>
<tr class="memdesc:a7ac7b73efa8cff54b6ef225f8e630b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to the internally stored parameters' list. <br /></td></tr>
<tr class="separator:a7ac7b73efa8cff54b6ef225f8e630b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de58a80721cdbcc076ad73b1030d6d3" id="r_a4de58a80721cdbcc076ad73b1030d6d3"><td class="memItemLeft" align="right" valign="top"><a id="a4de58a80721cdbcc076ad73b1030d6d3" name="a4de58a80721cdbcc076ad73b1030d6d3"></a>
Teuchos::ParameterList&#160;</td><td class="memItemRight" valign="bottom"><b>GetOutputList</b> ()</td></tr>
<tr class="separator:a4de58a80721cdbcc076ad73b1030d6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df61ccbf8cefd809ea6880c2ac0ed9c" id="r_a2df61ccbf8cefd809ea6880c2ac0ed9c"><td class="memItemLeft" align="right" valign="top"><a id="a2df61ccbf8cefd809ea6880c2ac0ed9c" name="a2df61ccbf8cefd809ea6880c2ac0ed9c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PrintList</b> ()</td></tr>
<tr class="memdesc:a2df61ccbf8cefd809ea6880c2ac0ed9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints on <code>std::cout</code> the values of the internally stored parameter list. <br /></td></tr>
<tr class="separator:a2df61ccbf8cefd809ea6880c2ac0ed9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4c973625931d48f3393c8f09a033bf" id="r_a2c4c973625931d48f3393c8f09a033bf"><td class="memItemLeft" align="right" valign="top"><a id="a2c4c973625931d48f3393c8f09a033bf" name="a2c4c973625931d48f3393c8f09a033bf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>SetParameterList</b> (const Teuchos::ParameterList &amp;List)</td></tr>
<tr class="memdesc:a2c4c973625931d48f3393c8f09a033bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies <code>List</code> into the internally stored parameter list object. <br /></td></tr>
<tr class="separator:a2c4c973625931d48f3393c8f09a033bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc79cb59984e7382f79a757de90a565" id="r_a3dc79cb59984e7382f79a757de90a565"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a3dc79cb59984e7382f79a757de90a565">Apply</a> (const <a class="elRef" href="../../../epetra/doc/html/classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;, <a class="elRef" href="../../../epetra/doc/html/classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;) const</td></tr>
<tr class="memdesc:a3dc79cb59984e7382f79a757de90a565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the inverse of the preconditioner to an <a class="elRef" href="../../../epetra/doc/html/classEpetra__MultiVector.html">Epetra_MultiVector</a> (NOT AVAILABLE)  <br /></td></tr>
<tr class="separator:a3dc79cb59984e7382f79a757de90a565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d656c3f65010a1391d71ad44128c35" id="r_ac9d656c3f65010a1391d71ad44128c35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#ac9d656c3f65010a1391d71ad44128c35">ApplyInverse</a> (const <a class="elRef" href="../../../epetra/doc/html/classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;X, <a class="elRef" href="../../../epetra/doc/html/classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;Y) const</td></tr>
<tr class="memdesc:ac9d656c3f65010a1391d71ad44128c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the preconditioner to an <a class="elRef" href="../../../epetra/doc/html/classEpetra__MultiVector.html">Epetra_MultiVector</a> X, puts the result in Y.  <br /></td></tr>
<tr class="separator:ac9d656c3f65010a1391d71ad44128c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5c1d47c6938d2ec1cb9bb710723c1e" id="r_a0a5c1d47c6938d2ec1cb9bb710723c1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a0a5c1d47c6938d2ec1cb9bb710723c1e">ComputePreconditioner</a> (const bool CheckFiltering=false)</td></tr>
<tr class="memdesc:a0a5c1d47c6938d2ec1cb9bb710723c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the multilevel hierarchy.  <br /></td></tr>
<tr class="separator:a0a5c1d47c6938d2ec1cb9bb710723c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab166a38be6d3d6b9c3400f256af9a4" id="r_a1ab166a38be6d3d6b9c3400f256af9a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a1ab166a38be6d3d6b9c3400f256af9a4">ReComputePreconditioner</a> (bool keepFineLevelSmoother=false)</td></tr>
<tr class="memdesc:a1ab166a38be6d3d6b9c3400f256af9a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recompute the preconditioner (not implemented for Maxwell).  <br /></td></tr>
<tr class="separator:a1ab166a38be6d3d6b9c3400f256af9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9303867b4ffe267f3962ab66f36d21e1" id="r_a9303867b4ffe267f3962ab66f36d21e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a9303867b4ffe267f3962ab66f36d21e1">Print</a> (int level=-2)</td></tr>
<tr class="memdesc:a9303867b4ffe267f3962ab66f36d21e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the individual operators in the multigrid hierarchy.  <br /></td></tr>
<tr class="separator:a9303867b4ffe267f3962ab66f36d21e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ea601a37840d315f7bc38bd490fa02" id="r_ab5ea601a37840d315f7bc38bd490fa02"><td class="memItemLeft" align="right" valign="top"><a id="ab5ea601a37840d315f7bc38bd490fa02" name="ab5ea601a37840d315f7bc38bd490fa02"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ComputeAdaptivePreconditioner</b> (int TentativeNullSpaceSize, double *TentativeNullSpace)</td></tr>
<tr class="separator:ab5ea601a37840d315f7bc38bd490fa02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a0ac12d79158cff1d3b11b320beb2d" id="r_aa5a0ac12d79158cff1d3b11b320beb2d"><td class="memItemLeft" align="right" valign="top"><a id="aa5a0ac12d79158cff1d3b11b320beb2d" name="aa5a0ac12d79158cff1d3b11b320beb2d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>IsPreconditionerComputed</b> () const</td></tr>
<tr class="memdesc:aa5a0ac12d79158cff1d3b11b320beb2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries whether multilevel hierarchy has been computed or not. <br /></td></tr>
<tr class="separator:aa5a0ac12d79158cff1d3b11b320beb2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8d7791705f87deab0b4b2523f8ea53" id="r_aad8d7791705f87deab0b4b2523f8ea53"><td class="memItemLeft" align="right" valign="top"><a id="aad8d7791705f87deab0b4b2523f8ea53" name="aad8d7791705f87deab0b4b2523f8ea53"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>SetOwnership</b> (bool ownership)</td></tr>
<tr class="memdesc:aad8d7791705f87deab0b4b2523f8ea53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets ownership. <br /></td></tr>
<tr class="separator:aad8d7791705f87deab0b4b2523f8ea53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5109c611fa38a77f300325aef7fadfc2" id="r_a5109c611fa38a77f300325aef7fadfc2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a5109c611fa38a77f300325aef7fadfc2">SetUseTranspose</a> (bool)</td></tr>
<tr class="memdesc:a5109c611fa38a77f300325aef7fadfc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets use transpose (not implemented).  <br /></td></tr>
<tr class="separator:a5109c611fa38a77f300325aef7fadfc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e19b5e4464961633f6f0f25c88723b" id="r_aa1e19b5e4464961633f6f0f25c88723b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#aa1e19b5e4464961633f6f0f25c88723b">NormInf</a> () const</td></tr>
<tr class="memdesc:aa1e19b5e4464961633f6f0f25c88723b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the infinity norm (not implemented).  <br /></td></tr>
<tr class="separator:aa1e19b5e4464961633f6f0f25c88723b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2748209079d87b63ca3f6d89203b49" id="r_a5c2748209079d87b63ca3f6d89203b49"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a5c2748209079d87b63ca3f6d89203b49">UseTranspose</a> () const</td></tr>
<tr class="memdesc:a5c2748209079d87b63ca3f6d89203b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current UseTranspose setting.  <br /></td></tr>
<tr class="separator:a5c2748209079d87b63ca3f6d89203b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae393475696a21db3dea5eca93c252d5b" id="r_ae393475696a21db3dea5eca93c252d5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#ae393475696a21db3dea5eca93c252d5b">HasNormInf</a> () const</td></tr>
<tr class="memdesc:ae393475696a21db3dea5eca93c252d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <em>this</em> object can provide an approximate Inf-norm, false otherwise.  <br /></td></tr>
<tr class="separator:ae393475696a21db3dea5eca93c252d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254d8bd7b113e82191fc9d224f210807" id="r_a254d8bd7b113e82191fc9d224f210807"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="../../../epetra/doc/html/classEpetra__Comm.html">Epetra_Comm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a254d8bd7b113e82191fc9d224f210807">Comm</a> () const</td></tr>
<tr class="memdesc:a254d8bd7b113e82191fc9d224f210807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the <a class="elRef" href="../../../epetra/doc/html/classEpetra__Comm.html">Epetra_Comm</a> communicator associated with this operator.  <br /></td></tr>
<tr class="separator:a254d8bd7b113e82191fc9d224f210807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966d6b6b561506a1e072eed3fc457b64" id="r_a966d6b6b561506a1e072eed3fc457b64"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="../../../epetra/doc/html/classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a966d6b6b561506a1e072eed3fc457b64">OperatorDomainMap</a> () const</td></tr>
<tr class="memdesc:a966d6b6b561506a1e072eed3fc457b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="elRef" href="../../../epetra/doc/html/classEpetra__Map.html">Epetra_Map</a> object associated with the domain of this operator.  <br /></td></tr>
<tr class="separator:a966d6b6b561506a1e072eed3fc457b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb079af993c5b5f28572f27147241287" id="r_acb079af993c5b5f28572f27147241287"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="../../../epetra/doc/html/classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#acb079af993c5b5f28572f27147241287">OperatorRangeMap</a> () const</td></tr>
<tr class="memdesc:acb079af993c5b5f28572f27147241287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="elRef" href="../../../epetra/doc/html/classEpetra__Map.html">Epetra_Map</a> object associated with the range of this operator.  <br /></td></tr>
<tr class="separator:acb079af993c5b5f28572f27147241287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5510672a594a1b136b57d1650f136d58" id="r_a5510672a594a1b136b57d1650f136d58"><td class="memItemLeft" align="right" valign="top"><a id="a5510672a594a1b136b57d1650f136d58" name="a5510672a594a1b136b57d1650f136d58"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>DestroyPreconditioner</b> ()</td></tr>
<tr class="memdesc:a5510672a594a1b136b57d1650f136d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys all structures allocated in <code><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a0a5c1d47c6938d2ec1cb9bb710723c1e" title="Computes the multilevel hierarchy.">ComputePreconditioner()</a></code> if the preconditioner has been computed. <br /></td></tr>
<tr class="separator:a5510672a594a1b136b57d1650f136d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32582ffc9d9b49d5a41a88ee98b0fff1" id="r_a32582ffc9d9b49d5a41a88ee98b0fff1"><td class="memItemLeft" align="right" valign="top"><a id="a32582ffc9d9b49d5a41a88ee98b0fff1" name="a32582ffc9d9b49d5a41a88ee98b0fff1"></a>
const <a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>RowMatrix</b> () const</td></tr>
<tr class="memdesc:a32582ffc9d9b49d5a41a88ee98b0fff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the internally stored <a class="el" href="classML__Epetra_1_1RowMatrix.html" title="Basic wrapper from ML_Operator to Epetra_RowMatrix.">RowMatrix</a>. <br /></td></tr>
<tr class="separator:a32582ffc9d9b49d5a41a88ee98b0fff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29da13baf5802713e6fb90ae906b1e68" id="r_a29da13baf5802713e6fb90ae906b1e68"><td class="memItemLeft" align="right" valign="top"><a id="a29da13baf5802713e6fb90ae906b1e68" name="a29da13baf5802713e6fb90ae906b1e68"></a>
const <a class="elRef" href="../../../epetra/doc/html/classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Map</b> () const</td></tr>
<tr class="memdesc:a29da13baf5802713e6fb90ae906b1e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to RowMatrix-&gt;<a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a29da13baf5802713e6fb90ae906b1e68" title="Returns a reference to RowMatrix-&gt;Map().">Map()</a>. <br /></td></tr>
<tr class="separator:a29da13baf5802713e6fb90ae906b1e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400bbe208483571e10ba9b4e8e8d92f2" id="r_a400bbe208483571e10ba9b4e8e8d92f2"><td class="memItemLeft" align="right" valign="top"><a id="a400bbe208483571e10ba9b4e8e8d92f2" name="a400bbe208483571e10ba9b4e8e8d92f2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>NumGlobalRows</b> () const</td></tr>
<tr class="memdesc:a400bbe208483571e10ba9b4e8e8d92f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the global number of rows in the matrix. <br /></td></tr>
<tr class="separator:a400bbe208483571e10ba9b4e8e8d92f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427d4b7175a852447c3a9f618f9c1a5b" id="r_a427d4b7175a852447c3a9f618f9c1a5b"><td class="memItemLeft" align="right" valign="top"><a id="a427d4b7175a852447c3a9f618f9c1a5b" name="a427d4b7175a852447c3a9f618f9c1a5b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>NumGlobalCols</b> () const</td></tr>
<tr class="memdesc:a427d4b7175a852447c3a9f618f9c1a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the global number of columns in the matrix. <br /></td></tr>
<tr class="separator:a427d4b7175a852447c3a9f618f9c1a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af956b7da74d1df4b29c3b8f9f3d0f277" id="r_af956b7da74d1df4b29c3b8f9f3d0f277"><td class="memItemLeft" align="right" valign="top"><a id="af956b7da74d1df4b29c3b8f9f3d0f277" name="af956b7da74d1df4b29c3b8f9f3d0f277"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>NumMyRows</b> () const</td></tr>
<tr class="memdesc:af956b7da74d1df4b29c3b8f9f3d0f277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the local number of rows in the matrix. <br /></td></tr>
<tr class="separator:af956b7da74d1df4b29c3b8f9f3d0f277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a07932321784e2e70b895ff6ed93e8" id="r_a08a07932321784e2e70b895ff6ed93e8"><td class="memItemLeft" align="right" valign="top"><a id="a08a07932321784e2e70b895ff6ed93e8" name="a08a07932321784e2e70b895ff6ed93e8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>NumMyCols</b> () const</td></tr>
<tr class="memdesc:a08a07932321784e2e70b895ff6ed93e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the local number of columns in the matrix. <br /></td></tr>
<tr class="separator:a08a07932321784e2e70b895ff6ed93e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0250fca18c73c4675907bbae2b2fc58e" id="r_a0250fca18c73c4675907bbae2b2fc58e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a0250fca18c73c4675907bbae2b2fc58e">PrintStencil2D</a> (const int nx, const int ny, int NodeID=-1, const int EquationID=0)</td></tr>
<tr class="memdesc:a0250fca18c73c4675907bbae2b2fc58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the computational stencil for the specified row and equation (for 2D Cartesian grids only)  <br /></td></tr>
<tr class="separator:a0250fca18c73c4675907bbae2b2fc58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3f352613d2efe0524b0d608ab82aca" id="r_aad3f352613d2efe0524b0d608ab82aca"><td class="memItemLeft" align="right" valign="top"><a id="aad3f352613d2efe0524b0d608ab82aca" name="aad3f352613d2efe0524b0d608ab82aca"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>AnalyzeHierarchy</b> (const bool AnalyzeMatrices, const int PreCycles, const int PostCycles, const int MLCycles)</td></tr>
<tr class="memdesc:aad3f352613d2efe0524b0d608ab82aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cheap analysis of each level matrix. <br /></td></tr>
<tr class="separator:aad3f352613d2efe0524b0d608ab82aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7960fc2ac3906e24925454f977acb158" id="r_a7960fc2ac3906e24925454f977acb158"><td class="memItemLeft" align="right" valign="top"><a id="a7960fc2ac3906e24925454f977acb158" name="a7960fc2ac3906e24925454f977acb158"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>AnalyzeSmoothers</b> (const int NumPreCycles=1, const int NumPostCycles=1)</td></tr>
<tr class="memdesc:a7960fc2ac3906e24925454f977acb158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze the effect of each level's smoother on a random std::vector. <br /></td></tr>
<tr class="separator:a7960fc2ac3906e24925454f977acb158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90526df20598a4d1fbfa73ed62d64b2" id="r_ad90526df20598a4d1fbfa73ed62d64b2"><td class="memItemLeft" align="right" valign="top"><a id="ad90526df20598a4d1fbfa73ed62d64b2" name="ad90526df20598a4d1fbfa73ed62d64b2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>AnalyzeCoarse</b> ()</td></tr>
<tr class="memdesc:ad90526df20598a4d1fbfa73ed62d64b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze the effect of the coarse solver on a random std::vector. <br /></td></tr>
<tr class="separator:ad90526df20598a4d1fbfa73ed62d64b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf72f32c5d51a4ea81804772c019db0" id="r_aebf72f32c5d51a4ea81804772c019db0"><td class="memItemLeft" align="right" valign="top"><a id="aebf72f32c5d51a4ea81804772c019db0" name="aebf72f32c5d51a4ea81804772c019db0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>AnalyzeCycle</b> (const int NumCycles=1)</td></tr>
<tr class="memdesc:aebf72f32c5d51a4ea81804772c019db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze the effect of the ML cycle on a random std::vector. <br /></td></tr>
<tr class="separator:aebf72f32c5d51a4ea81804772c019db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7c0666a162fac38cf6d67f734271bc" id="r_aee7c0666a162fac38cf6d67f734271bc"><td class="memItemLeft" align="right" valign="top"><a id="aee7c0666a162fac38cf6d67f734271bc" name="aee7c0666a162fac38cf6d67f734271bc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>TestSmoothers</b> (Teuchos::ParameterList &amp;InputList, const bool IsSymmetric=false)</td></tr>
<tr class="memdesc:aee7c0666a162fac38cf6d67f734271bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test several smoothers on fine-level matrix. <br /></td></tr>
<tr class="separator:aee7c0666a162fac38cf6d67f734271bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa7eb152a06a7a01fe63632f5824304" id="r_a2fa7eb152a06a7a01fe63632f5824304"><td class="memItemLeft" align="right" valign="top"><a id="a2fa7eb152a06a7a01fe63632f5824304" name="a2fa7eb152a06a7a01fe63632f5824304"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>TestSmoothers</b> (const bool IsSymmetric=false)</td></tr>
<tr class="memdesc:a2fa7eb152a06a7a01fe63632f5824304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test several smoothers on fine-level matrix using the current parameters. <br /></td></tr>
<tr class="separator:a2fa7eb152a06a7a01fe63632f5824304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90dc3584aa3a7ec601527913729f6ffe" id="r_a90dc3584aa3a7ec601527913729f6ffe"><td class="memItemLeft" align="right" valign="top"><a id="a90dc3584aa3a7ec601527913729f6ffe" name="a90dc3584aa3a7ec601527913729f6ffe"></a>
const <a class="el" href="structML__Struct.html">ML</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetML</b> (const int WhichML=-1) const</td></tr>
<tr class="memdesc:a90dc3584aa3a7ec601527913729f6ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the internally stored ml pointer. <br /></td></tr>
<tr class="separator:a90dc3584aa3a7ec601527913729f6ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e337c6553b06afde207869b5dc7e5cb" id="r_a8e337c6553b06afde207869b5dc7e5cb"><td class="memItemLeft" align="right" valign="top"><a id="a8e337c6553b06afde207869b5dc7e5cb" name="a8e337c6553b06afde207869b5dc7e5cb"></a>
const <a class="el" href="structML__Aggregate__Struct.html">ML_Aggregate</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetML_Aggregate</b> () const</td></tr>
<tr class="memdesc:a8e337c6553b06afde207869b5dc7e5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the internally stored agg pointer. <br /></td></tr>
<tr class="separator:a8e337c6553b06afde207869b5dc7e5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fb3f860653a999349c47053c13a798" id="r_ad6fb3f860653a999349c47053c13a798"><td class="memItemLeft" align="right" valign="top"><a id="ad6fb3f860653a999349c47053c13a798" name="ad6fb3f860653a999349c47053c13a798"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Visualize</b> (bool VizAggre, bool VizPreSmoother, bool VizPostSmoother, bool VizCycle, int NumApplPreSmoother, int NumApplPostSmoother, int NumCycleSmoother)</td></tr>
<tr class="memdesc:ad6fb3f860653a999349c47053c13a798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic interface to visualization methods. <br /></td></tr>
<tr class="separator:ad6fb3f860653a999349c47053c13a798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9006beb44fcd09703759b96ec80b6ed" id="r_ac9006beb44fcd09703759b96ec80b6ed"><td class="memItemLeft" align="right" valign="top"><a id="ac9006beb44fcd09703759b96ec80b6ed" name="ac9006beb44fcd09703759b96ec80b6ed"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>VisualizeAggregates</b> ()</td></tr>
<tr class="memdesc:ac9006beb44fcd09703759b96ec80b6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visualizes the shape of the aggregates. <br /></td></tr>
<tr class="separator:ac9006beb44fcd09703759b96ec80b6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee16b64ffa2632ec49003d01075b9a4" id="r_a5ee16b64ffa2632ec49003d01075b9a4"><td class="memItemLeft" align="right" valign="top"><a id="a5ee16b64ffa2632ec49003d01075b9a4" name="a5ee16b64ffa2632ec49003d01075b9a4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>VisualizeSmoothers</b> (int NumPrecCycles=1, int NumPostCycles=1)</td></tr>
<tr class="memdesc:a5ee16b64ffa2632ec49003d01075b9a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visualizes the effect of smoothers on a random std::vector. <br /></td></tr>
<tr class="separator:a5ee16b64ffa2632ec49003d01075b9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770b9637ed6b5f8b1affa48979ea0f57" id="r_a770b9637ed6b5f8b1affa48979ea0f57"><td class="memItemLeft" align="right" valign="top"><a id="a770b9637ed6b5f8b1affa48979ea0f57" name="a770b9637ed6b5f8b1affa48979ea0f57"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>VisualizeCycle</b> (int NumCycles=1)</td></tr>
<tr class="memdesc:a770b9637ed6b5f8b1affa48979ea0f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visualizes the effect of the ML cycle on a random std::vector. <br /></td></tr>
<tr class="separator:a770b9637ed6b5f8b1affa48979ea0f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7299deaa41b375504533f87a6e76b1b5" id="r_a7299deaa41b375504533f87a6e76b1b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a7299deaa41b375504533f87a6e76b1b5">CreateLabel</a> ()</td></tr>
<tr class="separator:a7299deaa41b375504533f87a6e76b1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7897cbe8750c15c334c8bd4d42ff3b87" id="r_a7897cbe8750c15c334c8bd4d42ff3b87"><td class="memItemLeft" align="right" valign="top"><a id="a7897cbe8750c15c334c8bd4d42ff3b87" name="a7897cbe8750c15c334c8bd4d42ff3b87"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ReportTime</b> ()</td></tr>
<tr class="separator:a7897cbe8750c15c334c8bd4d42ff3b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444d355346756356c2ee4b29647ec53e" id="r_a444d355346756356c2ee4b29647ec53e"><td class="memItemLeft" align="right" valign="top"><a id="a444d355346756356c2ee4b29647ec53e" name="a444d355346756356c2ee4b29647ec53e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Complexities</b> (double &amp;complexity, double &amp;fineNnz)</td></tr>
<tr class="memdesc:a444d355346756356c2ee4b29647ec53e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return operator complexity and #nonzeros in fine grid matrix. <br /></td></tr>
<tr class="separator:a444d355346756356c2ee4b29647ec53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html" title="MultiLevelPreconditioner: a class to define black-box multilevel preconditioners using aggregation me...">MultiLevelPreconditioner</a>: a class to define black-box multilevel preconditioners using aggregation methods. </p>
<p>Class <a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html" title="MultiLevelPreconditioner: a class to define black-box multilevel preconditioners using aggregation me...">ML_Epetra::MultiLevelPreconditioner</a> defined black-box algebraic multilevel preconditioners of matrices defined as <a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> derived objects. The resulting preconditioner can be used in AztecOO, and in any other solver that accepts <a class="elRef" href="../../../epetra/doc/html/classEpetra__Operator.html">Epetra_Operator</a> derived objects, and apply the action of the given <a class="elRef" href="../../../epetra/doc/html/classEpetra__Operator.html">Epetra_Operator</a> using <a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#ac9d656c3f65010a1391d71ad44128c35" title="Apply the preconditioner to an Epetra_MultiVector X, puts the result in Y.">ApplyInverse()</a>.</p>
<p>Please refer to the user's guide for a detailed introduction to this class, examples, and description of input parameters.</p>
<p>This file requires ML to be configured with the following options:</p><ul>
<li><code>--enable-epetra</code> </li>
<li><code>--enable-teuchos</code> </li>
</ul>
<p>The following option is suggested:</p><ul>
<li><code>--enable-amesos</code> </li>
<li><code>--enable-ifpack</code> </li>
</ul>
<p>Some part of this class needs the following options:</p><ul>
<li><code>--enable-aztecoo</code> </li>
<li><code>--enable-anasazi</code> </li>
</ul>
<p>It is important to note that ML is more restrictive than Epetra for the definition of maps. It is required that RowMatrixRowMap() is equal to <a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#acb079af993c5b5f28572f27147241287" title="Returns the Epetra_Map object associated with the range of this operator.">OperatorRangeMap()</a>. This is because ML needs to perform matrix-std::vector product, as well as getrow() functions, on the same data distribution.</p>
<p>Also, for square matrices, <a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a966d6b6b561506a1e072eed3fc457b64" title="Returns the Epetra_Map object associated with the domain of this operator.">OperatorDomainMap()</a> must be as <a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#acb079af993c5b5f28572f27147241287" title="Returns the Epetra_Map object associated with the range of this operator.">OperatorRangeMap()</a>.</p>
<p>Several examples are provided in the <code>examples</code> subdirectories:</p><ul>
<li><a class="el" href="ml_preconditioner_cpp.html">ml_preconditioner.cpp</a> is an introductory example;</li>
<li><a class="el" href="ml_2level_DD_cpp.html">ml_2level_DD.cpp</a> shows how to define a 2-level domain decomposition preconditioner using this class;</li>
<li><a class="el" href="ml_viz_cpp.html">ml_viz.cpp</a> details how to visualize the aggregates;</li>
<li>ml_maxwell_cpp reports how to use this class for Maxwell problems.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Namespace <a class="el" href="namespaceML__Epetra.html" title="ML_Epetra: default namespace for all Epetra interfaces.">ML_Epetra</a> contains another <a class="elRef" href="../../../epetra/doc/html/classEpetra__Operator.html">Epetra_Operator</a> derived class, <a class="el" href="classML__Epetra_1_1MultiLevelOperator.html" title="MultiLevelOperator: An implementation of the Epetra_Operator class.">ML_Epetra::MultiLevelOperator</a>.<ul>
<li>you should use <a class="el" href="classML__Epetra_1_1MultiLevelOperator.html" title="MultiLevelOperator: An implementation of the Epetra_Operator class.">MultiLevelOperator</a> when your code already defines the required ML objects, with the optimal choice of parameters, and you just want to wrap the already defined ML preconditioners for AztecOO problems;</li>
<li>you should use <a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html" title="MultiLevelPreconditioner: a class to define black-box multilevel preconditioners using aggregation me...">MultiLevelPreconditioner</a> when you have an <a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a>, and you don't want to code the conversion to ML_Operator, the creation of the hierarchy and the aggregates, and/or you want to experiment various combinations of the parameters, simply changing some parameters in a Teuchos::ParameterList.</li>
</ul>
</dd></dl>
<p>Defaults parameters can be specified using function <a class="el" href="namespaceML__Epetra.html#a56d4ce3baee9b349ed2333326e0ec2b6" title="Sets default parameters for aggregation-based preconditioners.">SetDefaults()</a>.</p>
<dl class="section author"><dt>Author</dt><dd>Marzio Sala, SNL 9214 </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a59203ed1c62ac76884e252f50e05a405" name="a59203ed1c62ac76884e252f50e05a405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59203ed1c62ac76884e252f50e05a405">&#9670;&#160;</a></span>MultiLevelPreconditioner() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ML_Epetra::MultiLevelPreconditioner::MultiLevelPreconditioner </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>EdgeMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>GradMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>NodeMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>List</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ComputePrec</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>UseNodeMatrixForSmoother</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html" title="MultiLevelPreconditioner: a class to define black-box multilevel preconditioners using aggregation me...">MultiLevelPreconditioner</a> constructor for Maxwell's equations. </p>
<p>Takes the stiffness and mass terms of the matrix combined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">EdgeMatrix</td><td>- (In) Linear matrix to be solved. </td></tr>
    <tr><td class="paramname">GradMatrix</td><td>- (In) Node-to-edge connectivity matrix, a.k.a, topological gradient </td></tr>
    <tr><td class="paramname">NodeMatrix</td><td>- (In) Auxiliary nodal finite element matrix </td></tr>
    <tr><td class="paramname">List</td><td>- (In) Teuchos parameter list containing solver options. </td></tr>
    <tr><td class="paramname">ComputePrec</td><td>- (In) Optional argument that specifies whether to create preconditioner immediately. Default is true. </td></tr>
    <tr><td class="paramname">UseNodeMatrixForSmoother</td><td>- (In) Use the nodal matrix for the nodal portion of the Hipmair smoother (if used). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ecdb34d13aaceb48767950ed50d1b24" name="a0ecdb34d13aaceb48767950ed50d1b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ecdb34d13aaceb48767950ed50d1b24">&#9670;&#160;</a></span>MultiLevelPreconditioner() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ML_Epetra::MultiLevelPreconditioner::MultiLevelPreconditioner </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>CurlCurlMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>MassMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>TMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>NodeMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>List</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ComputePrec</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html" title="MultiLevelPreconditioner: a class to define black-box multilevel preconditioners using aggregation me...">MultiLevelPreconditioner</a> constructor for Maxwell's equations. </p>
<p>Takes the stiffness and mass terms of the matrix separately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CurlCurlMatrix</td><td>- (In) The curl-curl (stiffness) term of the matrix to be solved. </td></tr>
    <tr><td class="paramname">MassMatrix</td><td>- (In) The mass term of the matrix to be solved. </td></tr>
    <tr><td class="paramname">GradMatrix</td><td>- (In) Node-to-edge connectivity matrix, a.k.a, topological gradient </td></tr>
    <tr><td class="paramname">NodeMatrix</td><td>- (In) Auxiliary nodal finite element matrix </td></tr>
    <tr><td class="paramname">List</td><td>- (In) Teuchos parameter list containing solver options. </td></tr>
    <tr><td class="paramname">ComputePrec</td><td>- (In) Optional argument that specifies whether to create preconditioner immediately. Default is true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e3e3380ddad9bf64d3bf36bc3802f8f" name="a0e3e3380ddad9bf64d3bf36bc3802f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3e3380ddad9bf64d3bf36bc3802f8f">&#9670;&#160;</a></span>MultiLevelPreconditioner() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MultiLevelPreconditioner::MultiLevelPreconditioner </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>RowMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>List</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>maxDofPerNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>NotMLVecDofPresent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../../epetra/doc/html/classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>Lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../../epetra/doc/html/classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>Rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>rhsAndsolProvided</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ComputePrec</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html" title="MultiLevelPreconditioner: a class to define black-box multilevel preconditioners using aggregation me...">MultiLevelPreconditioner</a> for multiphysics with variable dofs per node. </p>
<p>Constructor for multiphysics problems with variable dofs per node. This version uses a discrete laplacian and padding on coarse grids to make a hierarchy. It also allows for the removal of column nonzeros associated with Dirichlet points. To use this option the rhs and initial guess must be provided. </p>

<p class="reference">References <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html#aab3589bfaac41458ab698d3d53780e61">Epetra_CrsMatrix::ColMap()</a>, <a class="el" href="structML__Struct.html#ae0f8f1ecdd98112ff6bc300b21f3a96d">ML_Struct::comm</a>, <a class="el" href="classML__Epetra_1_1RowMatrix.html#a9829bda5661703b6bebdb758f94619b7">ML_Epetra::RowMatrix::Comm()</a>, <a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a0a5c1d47c6938d2ec1cb9bb710723c1e">ComputePreconditioner()</a>, <a class="elRef" href="../../../epetra/doc/html/Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928aad81934e8f3b9399beea932f0b0e57d8">Copy</a>, <a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a7299deaa41b375504533f87a6e76b1b5">CreateLabel()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html#a9fc55fd3394fc25867ba0d2e8a730fdc">Epetra_CrsMatrix::ExtractCrsDataPointers()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__Vector.html#a4be57875ba9f6abd7202f293983757b5">Epetra_Vector::ExtractView()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f">Epetra_CrsMatrix::FillComplete()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html#ada0a4c3e447466758bd8608b077e90a0">Epetra_CrsMatrix::InsertMyValues()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__Comm.html#a04039ddd27c1aae04104d62992a58787">Epetra_Comm::MaxAll()</a>, <a class="el" href="structML__Struct.html#aff036cd1faf8335804804958fbf5b9ae">ML_Struct::ML_num_actual_levels</a>, <a class="el" href="ml__MultiLevelPreconditioner_8cpp.html#a836762a510f8cb162ba774058eb0d6aa">MLShove()</a>, <a class="el" href="ml__MultiLevelPreconditioner_8cpp.html#a8781fec714f89054aabeb624af67b3ff">MLunamalgP()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__Comm.html#a60135f8b72809635695dd2b8f539da6b">Epetra_Comm::MyPID()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html#a1aa8e055646a0cddde3c45047d6502cf">Epetra_CrsMatrix::NumMyCols()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html#ace6713140122dc58a27a79064705215e">Epetra_CrsMatrix::NumMyRows()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__Comm.html#a08ed286ec280a7bae33ea6b6e772ff1a">Epetra_Comm::NumProc()</a>, <a class="el" href="classML__Epetra_1_1RowMatrix.html#a7192f0cbdcda1aa0bd43ec8cb5a2e9c8">ML_Epetra::RowMatrix::OperatorDomainMap()</a>, <a class="el" href="classML__Epetra_1_1RowMatrix.html#a3515116c02996524b21aac463cd2d1a5">ML_Epetra::RowMatrix::OperatorRangeMap()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html#a24855eec1cf6aeb201be88ba654d22bf">Epetra_CrsMatrix::RowMap()</a>, <a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a32582ffc9d9b49d5a41a88ee98b0fff1">RowMatrix()</a>, and <a class="elRef" href="../../../epetra/doc/html/classEpetra__Comm.html#af81a51a85a8756371c6005de62378dbb">Epetra_Comm::SumAll()</a>.</p>

</div>
</div>
<a id="ae78bf31e9762299427fe43de01f5c0de" name="ae78bf31e9762299427fe43de01f5c0de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78bf31e9762299427fe43de01f5c0de">&#9670;&#160;</a></span>MultiLevelPreconditioner() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MultiLevelPreconditioner::MultiLevelPreconditioner </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>RowMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>List</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>distTol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../../epetra/doc/html/classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>Lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../../epetra/doc/html/classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>Rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>rhsAndsolProvided</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ComputePrec</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for scalar PDE problems based on applying AMG to the distance Laplacian operator when constructing grid transfers. The main unique feature is that there may be some dofs that correspond to the same node location. These shared dofs fall into two categories. If these dofs are strongly connected to each other (as determined by tol), they are explicitly elminated from the Laplacian (merged into a supernode). Once a P is obtained, this P is then expanded to account for shared nodes by simply duplicating the supernodes row of P for each of the individual vertices that contribute to the supernode. If share dofs are weakly connected (or not connected at all), nothing special is done (other than the ususal ignoring of weak connections). One last trick is employed, connections between supernodes and non-supernodes (i.e., regular nodes) are always assumed to be weak. Shared nodes are often used to capture interfaces or other features. By breaking these connections, the AMG can better maintain these features throughout the hierarchy. Finally, the constructor also allows for * the removal of column nonzeros associated with Dirichlet points. To use this option the rhs and initial guess must be provided. Modification of the matrix, rhs, and initial guess must be allowable to use this option. </p>

<p class="reference">References <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html#aab3589bfaac41458ab698d3d53780e61">Epetra_CrsMatrix::ColMap()</a>, <a class="el" href="structML__Struct.html#ae0f8f1ecdd98112ff6bc300b21f3a96d">ML_Struct::comm</a>, <a class="el" href="classML__Epetra_1_1RowMatrix.html#a9829bda5661703b6bebdb758f94619b7">ML_Epetra::RowMatrix::Comm()</a>, <a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a0a5c1d47c6938d2ec1cb9bb710723c1e">ComputePreconditioner()</a>, <a class="elRef" href="../../../epetra/doc/html/Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928aad81934e8f3b9399beea932f0b0e57d8">Copy</a>, <a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a7299deaa41b375504533f87a6e76b1b5">CreateLabel()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html#a9fc55fd3394fc25867ba0d2e8a730fdc">Epetra_CrsMatrix::ExtractCrsDataPointers()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__Vector.html#a4be57875ba9f6abd7202f293983757b5">Epetra_Vector::ExtractView()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f">Epetra_CrsMatrix::FillComplete()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html#ada0a4c3e447466758bd8608b077e90a0">Epetra_CrsMatrix::InsertMyValues()</a>, <a class="el" href="structML__Struct.html#aff036cd1faf8335804804958fbf5b9ae">ML_Struct::ML_num_actual_levels</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__Comm.html#a60135f8b72809635695dd2b8f539da6b">Epetra_Comm::MyPID()</a>, <a class="el" href="structML__Operator__Struct.html#ad677c429387d105339faa17ce0257012">ML_Operator_Struct::N_nonzeros</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html#a1aa8e055646a0cddde3c45047d6502cf">Epetra_CrsMatrix::NumMyCols()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__BlockMap.html#acdb9f7c41ae4fb986326a8fff49b1b17">Epetra_BlockMap::NumMyElements()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html#ace6713140122dc58a27a79064705215e">Epetra_CrsMatrix::NumMyRows()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__Comm.html#a08ed286ec280a7bae33ea6b6e772ff1a">Epetra_Comm::NumProc()</a>, <a class="el" href="classML__Epetra_1_1RowMatrix.html#a7192f0cbdcda1aa0bd43ec8cb5a2e9c8">ML_Epetra::RowMatrix::OperatorDomainMap()</a>, <a class="el" href="classML__Epetra_1_1RowMatrix.html#a3515116c02996524b21aac463cd2d1a5">ML_Epetra::RowMatrix::OperatorRangeMap()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__CrsMatrix.html#a24855eec1cf6aeb201be88ba654d22bf">Epetra_CrsMatrix::RowMap()</a>, and <a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a32582ffc9d9b49d5a41a88ee98b0fff1">RowMatrix()</a>.</p>

</div>
</div>
<a id="a5dd2ea24704e439cc3e87df1923cc883" name="a5dd2ea24704e439cc3e87df1923cc883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd2ea24704e439cc3e87df1923cc883">&#9670;&#160;</a></span>MultiLevelPreconditioner() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ML_Epetra::MultiLevelPreconditioner::MultiLevelPreconditioner </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../../../epetra/doc/html/classEpetra__MsrMatrix.html">Epetra_MsrMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>EdgeMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structML__Operator__Struct.html">ML_Operator</a> *&#160;</td>
          <td class="paramname"><em>GradMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZ_MATRIX *&#160;</td>
          <td class="paramname"><em>NodeMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>proc_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>List</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ComputePrec</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html" title="MultiLevelPreconditioner: a class to define black-box multilevel preconditioners using aggregation me...">MultiLevelPreconditioner</a> constructor for Maxwell's equations. </p>
<p>Takes the stiffness and mass terms of the matrix combined. The edge matrix is of type Epetra_Msr, a light-weight wrapper for old-style Aztec MSR matrices. This is intended as transition code for Aztec users.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">EdgeMatrix</td><td>- (In) Linear matrix to be solved. </td></tr>
    <tr><td class="paramname">GradMatrix</td><td>- (In) Node-to-edge connectivity matrix, a.k.a, topological gradient </td></tr>
    <tr><td class="paramname">NodeMatrix</td><td>- (In) Auxiliary nodal finite element matrix </td></tr>
    <tr><td class="paramname">proc_config</td><td>- (In) Aztec array specifying processor layout. </td></tr>
    <tr><td class="paramname">List</td><td>- (In) Teuchos parameter list containing solver options. </td></tr>
    <tr><td class="paramname">ComputePrec</td><td>- (In) Optional argument that specifies whether to create preconditioner immediately. Default is true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3dc79cb59984e7382f79a757de90a565" name="a3dc79cb59984e7382f79a757de90a565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc79cb59984e7382f79a757de90a565">&#9670;&#160;</a></span>Apply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ML_Epetra::MultiLevelPreconditioner::Apply </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../../../epetra/doc/html/classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../../epetra/doc/html/classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the inverse of the preconditioner to an <a class="elRef" href="../../../epetra/doc/html/classEpetra__MultiVector.html">Epetra_MultiVector</a> (NOT AVAILABLE) </p>

<p>Implements <a class="elRef" href="../../../epetra/doc/html/classEpetra__Operator.html#a44ff0c479186b0e3db841404dbd80491">Epetra_Operator</a>.</p>

</div>
</div>
<a id="ac9d656c3f65010a1391d71ad44128c35" name="ac9d656c3f65010a1391d71ad44128c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d656c3f65010a1391d71ad44128c35">&#9670;&#160;</a></span>ApplyInverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MultiLevelPreconditioner::ApplyInverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../../../epetra/doc/html/classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../../epetra/doc/html/classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the preconditioner to an <a class="elRef" href="../../../epetra/doc/html/classEpetra__MultiVector.html">Epetra_MultiVector</a> X, puts the result in Y. </p>

<p>Implements <a class="elRef" href="../../../epetra/doc/html/classEpetra__Operator.html#aac0eb3b0061a6e67a5666194e744c343">Epetra_Operator</a>.</p>

<p class="reference">References <a class="elRef" href="../../../epetra/doc/html/classEpetra__Time.html#aeee0f6f73cfd6888122bed827b55dd3c">Epetra_Time::ElapsedTime()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__MultiVector.html#a4d513146280b1ad49b6cb0df0d999921">Epetra_MultiVector::ExtractView()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__MultiVector.html#a1d29dedcbf070b11dfda5eb043c90b85">Epetra_MultiVector::NumVectors()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__MultiVector.html#ad6f671d0d84d754bd103afc8dbfd5e01">Epetra_MultiVector::PutScalar()</a>, and <a class="el" href="structML__Struct.html#a951db8ae96d601c1f5f4b0d2bf1abba8">ML_Struct::void_options</a>.</p>

<p class="reference">Referenced by <a class="el" href="classML__Epetra_1_1Ifpack__ML.html#aa287f6154adf1367becda1f1b926dfed">ML_Epetra::Ifpack_ML::ApplyInverse()</a>.</p>

</div>
</div>
<a id="a254d8bd7b113e82191fc9d224f210807" name="a254d8bd7b113e82191fc9d224f210807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254d8bd7b113e82191fc9d224f210807">&#9670;&#160;</a></span>Comm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="../../../epetra/doc/html/classEpetra__Comm.html">Epetra_Comm</a> &amp; ML_Epetra::MultiLevelPreconditioner::Comm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the <a class="elRef" href="../../../epetra/doc/html/classEpetra__Comm.html">Epetra_Comm</a> communicator associated with this operator. </p>

<p>Implements <a class="elRef" href="../../../epetra/doc/html/classEpetra__Operator.html#a7a49f63f905838687a623e6438c3d760">Epetra_Operator</a>.</p>

<p class="reference">Referenced by <a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#aee7c0666a162fac38cf6d67f734271bc">TestSmoothers()</a>.</p>

</div>
</div>
<a id="a0a5c1d47c6938d2ec1cb9bb710723c1e" name="a0a5c1d47c6938d2ec1cb9bb710723c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5c1d47c6938d2ec1cb9bb710723c1e">&#9670;&#160;</a></span>ComputePreconditioner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MultiLevelPreconditioner::ComputePreconditioner </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>CheckFiltering</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the multilevel hierarchy. </p>
<p>Computes the multilevel hierarchy. This function retrives the user's defines parameters (as specified in the input ParameterList), or takes default values otherwise, and creates the ML objects for aggregation and hierarchy. Allocated data can be freed used <a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a5510672a594a1b136b57d1650f136d58" title="Destroys all structures allocated in ComputePreconditioner() if the preconditioner has been computed.">DestroyPreconditioner()</a>, or by the destructor,</p>
<p>In a Newton-type procedure, several linear systems have to be solved, Often, these systems are not too different. In this case, it might be convenient to keep the already computed preconditioner (with hierarchy, coarse solver, smoothers), and use it to precondition the next linear system. ML offers a way to determine whether the already available preconditioner is "good enough" for the next linear system. The user should proceed as follows:</p><ul>
<li>define <code>"reuse: enable"</code> == <code>true</code> </li>
<li>solve the first linear system. ML tries to estimate the rate of convergence, and record it;</li>
<li>change the values of the linear system matrix (but NOT its structure)</li>
<li>compute the new preconditioner as <code>ComputePreconditioner(true)</code> It is supposed that the pointer to the <a class="elRef" href="../../../epetra/doc/html/classEpetra__RowMatrix.html">Epetra_RowMatrix</a> remains constant. Currently, it is not possible to modify this pointer (other than creating a new preconditioner) </li>
</ul>

<p class="reference">References <a class="el" href="namespaceML__Epetra.html#acacbd0af46df3fb65b3f6a917b0ff5cf">ML_Epetra::Apply_BCsToGradient()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__MpiComm.html#a54675f175a0800516f68d76d928c9834">Epetra_MpiComm::Comm()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__Time.html#aeee0f6f73cfd6888122bed827b55dd3c">Epetra_Time::ElapsedTime()</a>, <a class="el" href="ml__epetra__utils_8h.html#a95ce6bb2ede3c08998fd809337aeecfa">ML_BreakForDebugger()</a>, <a class="el" href="ml__epetra__utils_8h.html#a30b3b37502da93593be45f3b0470ca93">ML_Epetra_comm_wrapper()</a>, <a class="el" href="ml__epetra__utils_8h.html#a89650707c325d59be395edffdb526e6e">ML_Epetra_getrow()</a>, <a class="el" href="ml__epetra__utils_8h.html#a6de70ce338301d6ae28f8857fd3c0cf8">ML_Epetra_matvec()</a>, <a class="el" href="structML__Struct.html#aff036cd1faf8335804804958fbf5b9ae">ML_Struct::ML_num_actual_levels</a>, <a class="el" href="ml__epetra__utils_8h.html#a8ed6c6e293f53531a4043762f71c3cb4">ML_Operator_WrapEpetraMatrix()</a>, <a class="el" href="namespaceML__Epetra.html#a811b261de17a343a087c2aadd3c2115e">ML_Epetra::ModifyEpetraMatrixColMap()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__BlockMap.html#abc70320a09789d1bf51871c5262ed835">Epetra_BlockMap::NumGlobalElements()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__BlockMap.html#ae16fe243431c514ef8977f7c20340887">Epetra_BlockMap::NumGlobalPoints()</a>, <a class="el" href="namespaceML__Epetra.html#aa15a238c96fdcafd8f5625a49ed53d03">ML_Epetra::ReadXML()</a>, <a class="elRef" href="../../../epetra/doc/html/classEpetra__Time.html#a9a347630f131d1f3ded19a8e2bf73512">Epetra_Time::ResetStartTime()</a>, and <a class="elRef" href="../../../epetra/doc/html/classEpetra__VbrMatrix.html#abaeada098d3ec0541a224e3eebcd91dc">Epetra_VbrMatrix::RowMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a67347841c24bebda9e38ad628db145ba">MultiLevelPreconditioner()</a>, <a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#ae78bf31e9762299427fe43de01f5c0de">MultiLevelPreconditioner()</a>, and <a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a0e3e3380ddad9bf64d3bf36bc3802f8f">MultiLevelPreconditioner()</a>.</p>

</div>
</div>
<a id="a7299deaa41b375504533f87a6e76b1b5" name="a7299deaa41b375504533f87a6e76b1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7299deaa41b375504533f87a6e76b1b5">&#9670;&#160;</a></span>CreateLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MultiLevelPreconditioner::CreateLabel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates label for this object (printed out by AztecOO). This does not allocate/reallocate any memory. </p>

<p class="reference">Referenced by <a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#ae78bf31e9762299427fe43de01f5c0de">MultiLevelPreconditioner()</a>, and <a class="el" href="classML__Epetra_1_1MultiLevelPreconditioner.html#a0e3e3380ddad9bf64d3bf36bc3802f8f">MultiLevelPreconditioner()</a>.</p>

</div>
</div>
<a id="ae393475696a21db3dea5eca93c252d5b" name="ae393475696a21db3dea5eca93c252d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae393475696a21db3dea5eca93c252d5b">&#9670;&#160;</a></span>HasNormInf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ML_Epetra::MultiLevelPreconditioner::HasNormInf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the <em>this</em> object can provide an approximate Inf-norm, false otherwise. </p>

<p>Implements <a class="elRef" href="../../../epetra/doc/html/classEpetra__Operator.html#abc8b47f905c2183fa0da93bd5b13bd0f">Epetra_Operator</a>.</p>

</div>
</div>
<a id="a05a75aec17af5db17843110eeae75b0d" name="a05a75aec17af5db17843110eeae75b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a75aec17af5db17843110eeae75b0d">&#9670;&#160;</a></span>Label()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * ML_Epetra::MultiLevelPreconditioner::Label </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints label associated to this object. </p>

<p>Implements <a class="elRef" href="../../../epetra/doc/html/classEpetra__Operator.html#a9d335971f6b2342d8ba54c0cb65fb859">Epetra_Operator</a>.</p>

</div>
</div>
<a id="aa1e19b5e4464961633f6f0f25c88723b" name="aa1e19b5e4464961633f6f0f25c88723b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e19b5e4464961633f6f0f25c88723b">&#9670;&#160;</a></span>NormInf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ML_Epetra::MultiLevelPreconditioner::NormInf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the infinity norm (not implemented). </p>

<p>Implements <a class="elRef" href="../../../epetra/doc/html/classEpetra__Operator.html#ae33b0e1fd2b0ea82171636da74c6f3f1">Epetra_Operator</a>.</p>

</div>
</div>
<a id="a966d6b6b561506a1e072eed3fc457b64" name="a966d6b6b561506a1e072eed3fc457b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a966d6b6b561506a1e072eed3fc457b64">&#9670;&#160;</a></span>OperatorDomainMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="../../../epetra/doc/html/classEpetra__Map.html">Epetra_Map</a> &amp; ML_Epetra::MultiLevelPreconditioner::OperatorDomainMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="elRef" href="../../../epetra/doc/html/classEpetra__Map.html">Epetra_Map</a> object associated with the domain of this operator. </p>

<p>Implements <a class="elRef" href="../../../epetra/doc/html/classEpetra__Operator.html#ab6e6c17974c47fcdd1faaa7e5894f7da">Epetra_Operator</a>.</p>

</div>
</div>
<a id="acb079af993c5b5f28572f27147241287" name="acb079af993c5b5f28572f27147241287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb079af993c5b5f28572f27147241287">&#9670;&#160;</a></span>OperatorRangeMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="../../../epetra/doc/html/classEpetra__Map.html">Epetra_Map</a> &amp; ML_Epetra::MultiLevelPreconditioner::OperatorRangeMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="elRef" href="../../../epetra/doc/html/classEpetra__Map.html">Epetra_Map</a> object associated with the range of this operator. </p>

<p>Implements <a class="elRef" href="../../../epetra/doc/html/classEpetra__Operator.html#ac97667dbc739ef5863f90f717f51275e">Epetra_Operator</a>.</p>

</div>
</div>
<a id="a9303867b4ffe267f3962ab66f36d21e1" name="a9303867b4ffe267f3962ab66f36d21e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9303867b4ffe267f3962ab66f36d21e1">&#9670;&#160;</a></span>Print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MultiLevelPreconditioner::Print </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em> = <code>-2</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the individual operators in the multigrid hierarchy. </p>
<p>Print the individual operators in the multigrid hierarchy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>(In) By default, this method prints the entire multigrid hierarchy. If you desire only the operators associated with a particular level, pass in the level number. The fine level is 0, coarser levels are positive integers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0250fca18c73c4675907bbae2b2fc58e" name="a0250fca18c73c4675907bbae2b2fc58e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0250fca18c73c4675907bbae2b2fc58e">&#9670;&#160;</a></span>PrintStencil2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MultiLevelPreconditioner::PrintStencil2D </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NodeID</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>EquationID</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the computational stencil for the specified row and equation (for 2D Cartesian grids only) </p>
<p>For problems defined on 2D Cartesian grids (with node numbering increasing along the x-axis), this function prints out the stencil in an intelligible form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nx</td><td>(In) : number of nodes along the X-axis </td></tr>
    <tr><td class="paramname">ny</td><td>(In) : number of nodes along the Y-axis </td></tr>
    <tr><td class="paramname">NodeID</td><td>(In) : (local) ID of node that will be used to print the stencil. If set to -1, the code will automatically chose an internal node. Default: -1. </td></tr>
    <tr><td class="paramname">EquationID</td><td>(In) : ID of the equation that will be used to print the stencil (default = 0) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a366acb855d2c57ada05465ff983bbb4e" name="a366acb855d2c57ada05465ff983bbb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366acb855d2c57ada05465ff983bbb4e">&#9670;&#160;</a></span>PrintUnused()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MultiLevelPreconditioner::PrintUnused </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>MyPID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints unused parameters in the input ParameterList to std::cout on proc <code>MyPID</code>. </p>
<p>Mispelled parameters are simply ignored. Therefore, it is often the best choice to print out the parameters that have not been used in the construction phase.</p><ul>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MyPID</td><td>(In) : ID of process that should print the unused parameters. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="a1ab166a38be6d3d6b9c3400f256af9a4" name="a1ab166a38be6d3d6b9c3400f256af9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab166a38be6d3d6b9c3400f256af9a4">&#9670;&#160;</a></span>ReComputePreconditioner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MultiLevelPreconditioner::ReComputePreconditioner </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepFineLevelSmoother</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recompute the preconditioner (not implemented for Maxwell). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keepFineLevelSmoother</td><td>(In) : If true, the fine level smoother is not recomputed. This is useful if the smoother is expensive to create, e.g., an incomplete factorization, and the fine level matrix has not changed. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="elRef" href="../../../epetra/doc/html/classEpetra__Time.html#aeee0f6f73cfd6888122bed827b55dd3c">Epetra_Time::ElapsedTime()</a>, and <a class="elRef" href="../../../epetra/doc/html/classEpetra__Time.html#a9a347630f131d1f3ded19a8e2bf73512">Epetra_Time::ResetStartTime()</a>.</p>

</div>
</div>
<a id="a5109c611fa38a77f300325aef7fadfc2" name="a5109c611fa38a77f300325aef7fadfc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5109c611fa38a77f300325aef7fadfc2">&#9670;&#160;</a></span>SetUseTranspose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ML_Epetra::MultiLevelPreconditioner::SetUseTranspose </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets use transpose (not implemented). </p>

<p>Implements <a class="elRef" href="../../../epetra/doc/html/classEpetra__Operator.html#a3aedc73c2ef58b21bacb12bdc04130d7">Epetra_Operator</a>.</p>

</div>
</div>
<a id="a5c2748209079d87b63ca3f6d89203b49" name="a5c2748209079d87b63ca3f6d89203b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c2748209079d87b63ca3f6d89203b49">&#9670;&#160;</a></span>UseTranspose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ML_Epetra::MultiLevelPreconditioner::UseTranspose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current UseTranspose setting. </p>

<p>Implements <a class="elRef" href="../../../epetra/doc/html/classEpetra__Operator.html#adae8757220ea247aaebe08da978cfbf5">Epetra_Operator</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ml__MultiLevelPreconditioner_8h.html">ml_MultiLevelPreconditioner.h</a></li>
<li><a class="el" href="ml__MultiLevelPreconditioner_8cpp.html">ml_MultiLevelPreconditioner.cpp</a></li>
<li><a class="el" href="ml__MultiLevelPreconditioner__Adapt_8cpp.html">ml_MultiLevelPreconditioner_Adapt.cpp</a></li>
<li><a class="el" href="ml__MultiLevelPreconditioner__Analyze_8cpp.html">ml_MultiLevelPreconditioner_Analyze.cpp</a></li>
<li><b>ml_MultiLevelPreconditioner_Aux.cpp</b></li>
<li><b>ml_MultiLevelPreconditioner_Filtering.cpp</b></li>
<li><b>ml_MultiLevelPreconditioner_NullSpace.cpp</b></li>
<li><a class="el" href="ml__MultiLevelPreconditioner__Smoothers_8cpp.html">ml_MultiLevelPreconditioner_Smoothers.cpp</a></li>
<li><b>ml_MultiLevelPreconditioner_Test.cpp</b></li>
<li><a class="el" href="ml__MultiLevelPreconditioner__Viz_8cpp.html">ml_MultiLevelPreconditioner_Viz.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 9 2025 20:41:06 for ML by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
