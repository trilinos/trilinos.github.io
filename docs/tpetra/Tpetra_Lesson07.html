<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tpetra parallel linear algebra: Tpetra Lesson 07: Thread-Parallel Fill</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tpetra parallel linear algebra<span id="projectnumber">&#160;Version of the Day</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Tpetra Lesson 07: Thread-Parallel Fill</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Construct a sparse matrix in paralel using Kokkos.</p>
<h1><a class="anchor" id="Tpetra_Lesson07_Topics"></a>
Lesson topics</h1>
<p>This lesson shows an example of how to go from a simple finite-element discretization, to a linear system to solve, in a thread-parallel way, using Kokkos.</p>
<h1><a class="anchor" id="Tpetra_Lesson07_Example"></a>
Code example</h1>
<p>This is an example code that uses Kokkos to thread-parallelize linear system construction.</p>
<div class="fragment"><div class="line"><span class="comment">// @HEADER</span></div>
<div class="line"><span class="comment">// *****************************************************************************</span></div>
<div class="line"><span class="comment">//          Tpetra: Templated Linear Algebra Services Package</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Copyright 2008 NTESS and the Tpetra contributors.</span></div>
<div class="line"><span class="comment">// SPDX-License-Identifier: BSD-3-Clause</span></div>
<div class="line"><span class="comment">// *****************************************************************************</span></div>
<div class="line"><span class="comment">// @HEADER</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Tpetra__Core_8hpp.html">Tpetra_Core.hpp</a>&gt;</span></div>
<div class="line"><span class="comment">// This is the only header file you need to include for the &quot;core&quot;</span></div>
<div class="line"><span class="comment">// part of Kokkos.  That includes Kokkos::View, Kokkos::parallel_*,</span></div>
<div class="line"><span class="comment">// and atomic updates.</span></div>
<div class="line"><span class="preprocessor">#include &lt;Kokkos_Core.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Tpetra_CrsMatrix.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Tpetra_Vector.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Tpetra__Import__Util2_8hpp.html">Tpetra_Import_Util2.hpp</a>&gt;</span>  <span class="comment">//for sortCrsEntries</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Exact solution of the partial differential equation that main()</span></div>
<div class="line"><span class="comment">// discretizes.  We include it here to check the error.</span></div>
<div class="line">KOKKOS_INLINE_FUNCTION <span class="keywordtype">double</span></div>
<div class="line">exactSolution(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> T_left, <span class="keyword">const</span> <span class="keywordtype">double</span> T_right) {</div>
<div class="line">  <span class="keywordflow">return</span> -4.0 * (x - 0.5) * (x - 0.5) + 1.0 + (T_left - T_right) * x;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Attempt to solve Ax=b using CG (the Method of Conjugate Gradients),</span></div>
<div class="line"><span class="comment">// and return the number of iterations.</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> CrsMatrixType, <span class="keyword">class</span> VectorType&gt;</div>
<div class="line"><span class="keywordtype">int</span> solve(VectorType&amp; x, <span class="keyword">const</span> CrsMatrixType&amp; A, <span class="keyword">const</span> VectorType&amp; b, <span class="keyword">const</span> <span class="keywordtype">double</span> dx) {</div>
<div class="line">  <span class="keyword">using </span>std::cout;</div>
<div class="line">  <span class="keyword">using </span>std::endl;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> myRank   = x.getMap()-&gt;getComm()-&gt;getRank();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> verbose = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// In practice, one would call Belos using a preconditioner from</span></div>
<div class="line">  <span class="comment">// MueLu, Ifpack2, or some other package.  For now, we implement CG</span></div>
<div class="line">  <span class="comment">// by hand.</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> convTol = std::max(dx * dx, 1.0e-8);</div>
<div class="line">  <span class="comment">// Don&#39;t do more CG iterations than the problem&#39;s dimension.</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> maxNumIters = std::min(<span class="keyword">static_cast&lt;</span><a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::global_size_t</a><span class="keyword">&gt;</span>(100),</div>
<div class="line">                                   A.getGlobalNumRows());</div>
<div class="line">  VectorType r(A.getRangeMap());</div>
<div class="line">  A.apply(x, r);</div>
<div class="line">  r.update(1.0, b, -1.0);  <span class="comment">// r := -(A*x) + b</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> origResNorm = r.norm2();</div>
<div class="line">  <span class="keywordflow">if</span> (myRank == 0 &amp;&amp; verbose) {</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Original residual norm: &quot;</span> &lt;&lt; origResNorm &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> (origResNorm &lt;= convTol) {</div>
<div class="line">    <span class="keywordflow">return</span> 0;  <span class="comment">// the solution is already close enough</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> r_dot_r = origResNorm * origResNorm;</div>
<div class="line">  VectorType p(r, Teuchos::Copy);</div>
<div class="line">  VectorType Ap(A.getRangeMap());</div>
<div class="line">  <span class="keywordtype">int</span> numIters = 1;</div>
<div class="line">  <span class="keywordflow">for</span> (; numIters &lt;= maxNumIters; ++numIters) {</div>
<div class="line">    A.apply(p, Ap);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> p_dot_Ap = p.dot(Ap);</div>
<div class="line">    <span class="keywordflow">if</span> (p_dot_Ap &lt;= 0.0) {</div>
<div class="line">      <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;At iteration &quot;</span> &lt;&lt; numIters &lt;&lt; <span class="stringliteral">&quot;, p.dot(Ap) = &quot;</span> &lt;&lt; p_dot_Ap &lt;&lt; <span class="stringliteral">&quot; &lt;= 0.&quot;</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// Revert to approximate solution x from previous iteration.</span></div>
<div class="line">      <span class="keywordflow">return</span> numIters - 1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = r_dot_r / p_dot_Ap;</div>
<div class="line">    <span class="keywordflow">if</span> (alpha &lt;= 0.0) {</div>
<div class="line">      <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;At iteration &quot;</span> &lt;&lt; numIters &lt;&lt; <span class="stringliteral">&quot;, alpha = &quot;</span> &lt;&lt; alpha &lt;&lt; <span class="stringliteral">&quot; &lt;= 0.&quot;</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// Revert to approximate solution x from previous iteration.</span></div>
<div class="line">      <span class="keywordflow">return</span> numIters - 1;</div>
<div class="line">    }</div>
<div class="line">    x.update(alpha, p, 1.0);    <span class="comment">// x := alpha*p + x</span></div>
<div class="line">    r.update(-alpha, Ap, 1.0);  <span class="comment">// r := -alpha*Ap + r</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> newResNorm    = r.norm2();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> r_dot_r_next  = newResNorm * newResNorm;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> newRelResNorm = newResNorm / origResNorm;</div>
<div class="line">    <span class="keywordflow">if</span> (myRank == 0 &amp;&amp; verbose) {</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;Iteration &quot;</span> &lt;&lt; numIters &lt;&lt; <span class="stringliteral">&quot;: r_dot_r = &quot;</span> &lt;&lt; r_dot_r</div>
<div class="line">           &lt;&lt; <span class="stringliteral">&quot;, r_dot_r_next = &quot;</span> &lt;&lt; r_dot_r_next</div>
<div class="line">           &lt;&lt; <span class="stringliteral">&quot;, newResNorm = &quot;</span> &lt;&lt; newResNorm &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (newRelResNorm &lt;= convTol) {</div>
<div class="line">      <span class="keywordflow">return</span> numIters;</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> beta = r_dot_r_next / r_dot_r;</div>
<div class="line">    p.update(1.0, r, beta);  <span class="comment">// p := r + beta*p</span></div>
<div class="line">    r_dot_r = r_dot_r_next;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> numIters;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div>
<div class="line">  <span class="keyword">using </span>std::cout;</div>
<div class="line">  <span class="keyword">using </span>std::endl;</div>
<div class="line">  <span class="comment">// We&#39;re filling into Tpetra data structures now, so we have to</span></div>
<div class="line">  <span class="comment">// respect Tpetra&#39;s choices of local and global indices.</span></div>
<div class="line">  <span class="keyword">using </span>LO          = <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Map&lt;&gt;::local_ordinal_type</a>;</div>
<div class="line">  <span class="keyword">using </span>GO          = <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Map&lt;&gt;::global_ordinal_type</a>;</div>
<div class="line">  <span class="keyword">using </span>NT          = <a class="code hl_typedef" href="classTpetra_1_1Map.html#a29e003133a7ac66aa92439e07c455af4">Tpetra::Map&lt;&gt;::node_type</a>;</div>
<div class="line">  <span class="keyword">using </span>device_type = <span class="keyword">typename</span> NT::device_type;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classTpetra_1_1ScopeGuard.html">Tpetra::ScopeGuard</a> tpetraScope(&amp;argc, &amp;argv);</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">auto</span> comm          = <a class="code hl_function" href="namespaceTpetra.html#ab0f27babe7678e67ee420a36029ae10a">Tpetra::getDefaultComm</a>();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> myRank   = comm-&gt;getRank();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> numProcs = comm-&gt;getSize();</div>
<div class="line"> </div>
<div class="line">    LO numLclElements  = 10000;</div>
<div class="line">    <span class="keywordtype">int</span> numGblElements = numProcs * numLclElements;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We happened to choose a discretization with the same number of</span></div>
<div class="line">    <span class="comment">// nodes and degrees of freedom as elements.  That need not always</span></div>
<div class="line">    <span class="comment">// be the case.</span></div>
<div class="line">    LO numLclNodes = numLclElements;</div>
<div class="line">    LO numLclRows  = numLclNodes;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Describe the physical problem (heat equation with</span></div>
<div class="line">    <span class="comment">// nonhomogeneous Dirichlet boundary conditions) and its</span></div>
<div class="line">    <span class="comment">// discretization.</span></div>
<div class="line">    Kokkos::View&lt;double*, device_type&gt; temperature(<span class="stringliteral">&quot;temperature&quot;</span>, numLclNodes);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> diffusionCoeff = 1.0;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> x_left         = 0.0;  <span class="comment">// position of the left boundary</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> T_left         = 0.0;  <span class="comment">// temperature at the left boundary</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> x_right        = 1.0;  <span class="comment">// position of the right boundary</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> T_right        = 1.0;  <span class="comment">// temperature at the right boundary</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> dx             = (x_right - x_left) / numGblElements;</div>
<div class="line">    Kokkos::View&lt;double*, device_type&gt; forcingTerm(<span class="stringliteral">&quot;forcing term&quot;</span>, numLclNodes);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Set the forcing term.  We picked it so that we can know the exact</span></div>
<div class="line">    <span class="comment">// solution of the heat equation, namely</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// u(x) = -4.0 * (x - 0.5) * (x - 0.5) + 1.0 + (T_left - T_right)x.</span></div>
<div class="line">    Kokkos::parallel_for(</div>
<div class="line">        <span class="stringliteral">&quot;Set forcing term&quot;</span>, numLclNodes,</div>
<div class="line">        KOKKOS_LAMBDA(<span class="keyword">const</span> LO node) {</div>
<div class="line">          <span class="comment">// const double x = x_left + node * dx;</span></div>
<div class="line"> </div>
<div class="line">          forcingTerm(node) = -8.0;</div>
<div class="line">          <span class="comment">// We multiply dx*dx into the forcing term, so the matrix&#39;s</span></div>
<div class="line">          <span class="comment">// entries don&#39;t need to know it.</span></div>
<div class="line">          forcingTerm(node) *= dx * dx;</div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Do a reduction over local elements to count the total number of</span></div>
<div class="line">    <span class="comment">// (local) entries in the graph.  While doing so, count the number</span></div>
<div class="line">    <span class="comment">// of (local) entries in each row, using Kokkos&#39; atomic updates.</span></div>
<div class="line">    <span class="comment">// We may use LO for the number of entries in each row, since it</span></div>
<div class="line">    <span class="comment">// may not exceed the number of columns in the local matrix.</span></div>
<div class="line">    Kokkos::View&lt;LO*, device_type&gt; rowCounts(<span class="stringliteral">&quot;row counts&quot;</span>, numLclRows);</div>
<div class="line">    <span class="keywordtype">size_t</span> numLclEntries = 0;</div>
<div class="line">    Kokkos::parallel_reduce(</div>
<div class="line">        <span class="stringliteral">&quot;Count graph&quot;</span>, numLclElements,</div>
<div class="line">        KOKKOS_LAMBDA(<span class="keyword">const</span> LO elt, <span class="keywordtype">size_t</span>&amp; curNumLclEntries) {</div>
<div class="line">          <span class="keyword">const</span> LO lclRows = elt;</div>
<div class="line"> </div>
<div class="line">          <span class="comment">// Always add a diagonal matrix entry.</span></div>
<div class="line">          Kokkos::atomic_fetch_add(&amp;rowCounts(lclRows), LO(1));</div>
<div class="line">          curNumLclEntries++;</div>
<div class="line"> </div>
<div class="line">          <span class="comment">// Each neighboring MPI process contributes an entry to the</span></div>
<div class="line">          <span class="comment">// current row.  In a more realistic code, we might handle</span></div>
<div class="line">          <span class="comment">// this either through a global assembly process (requiring</span></div>
<div class="line">          <span class="comment">// MPI communication), or through ghosting a layer of elements</span></div>
<div class="line">          <span class="comment">// (no MPI communication).</span></div>
<div class="line"> </div>
<div class="line">          <span class="comment">// MPI process to the left sends us an entry</span></div>
<div class="line">          <span class="keywordflow">if</span> (myRank &gt; 0 &amp;&amp; lclRows == 0) {</div>
<div class="line">            Kokkos::atomic_fetch_add(&amp;rowCounts(lclRows), LO(1));</div>
<div class="line">            curNumLclEntries++;</div>
<div class="line">          }</div>
<div class="line">          <span class="comment">// MPI process to the right sends us an entry</span></div>
<div class="line">          <span class="keywordflow">if</span> (myRank + 1 &lt; numProcs &amp;&amp; lclRows + 1 == numLclRows) {</div>
<div class="line">            Kokkos::atomic_fetch_add(&amp;rowCounts(lclRows), LO(1));</div>
<div class="line">            curNumLclEntries++;</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line">          <span class="comment">// Contribute a matrix entry to the previous row.</span></div>
<div class="line">          <span class="keywordflow">if</span> (lclRows &gt; 0) {</div>
<div class="line">            Kokkos::atomic_fetch_add(&amp;rowCounts(lclRows - 1), LO(1));</div>
<div class="line">            curNumLclEntries++;</div>
<div class="line">          }</div>
<div class="line">          <span class="comment">// Contribute a matrix entry to the next row.</span></div>
<div class="line">          <span class="keywordflow">if</span> (lclRows + 1 &lt; numLclRows) {</div>
<div class="line">            Kokkos::atomic_fetch_add(&amp;rowCounts(lclRows + 1), LO(1));</div>
<div class="line">            curNumLclEntries++;</div>
<div class="line">          }</div>
<div class="line">        },</div>
<div class="line">        numLclEntries <span class="comment">/* reduction result */</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// mfh 20 Aug 2017: We can&#39;t just use a Kokkos::View&lt;size_t*&gt; for</span></div>
<div class="line">    <span class="comment">// the row offsets, because Tpetra::CrsMatrix reserves the right</span></div>
<div class="line">    <span class="comment">// to use a different row offset type for different execution /</span></div>
<div class="line">    <span class="comment">// memory spaces.  Instead, we first deduce the row offset type,</span></div>
<div class="line">    <span class="comment">// then construct a View of it.  (Note that a row offset needs to</span></div>
<div class="line">    <span class="comment">// have a type that can contain the sum of the row counts.)</span></div>
<div class="line">    <span class="keyword">using </span>row_offset_type =</div>
<div class="line">        <a class="code hl_class" href="classTpetra_1_1CrsMatrix.html">Tpetra::CrsMatrix&lt;double&gt;::local_matrix_device_type::row_map_type::non_const_value_type</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Use a parallel scan (prefix sum) over the array of row counts, to</span></div>
<div class="line">    <span class="comment">// compute the array of row offsets for the sparse graph.</span></div>
<div class="line">    Kokkos::View&lt;row_offset_type*, device_type&gt; rowOffsets(<span class="stringliteral">&quot;row offsets&quot;</span>, numLclRows + 1);</div>
<div class="line">    Kokkos::parallel_scan(</div>
<div class="line">        <span class="stringliteral">&quot;Row offsets&quot;</span>, numLclRows + 1,</div>
<div class="line">        KOKKOS_LAMBDA(<span class="keyword">const</span> LO lclRows,</div>
<div class="line">                      row_offset_type&amp; update,</div>
<div class="line">                      <span class="keyword">const</span> <span class="keywordtype">bool</span> <span class="keyword">final</span>) {</div>
<div class="line">          <span class="keywordflow">if</span> (<span class="keyword">final</span>) {</div>
<div class="line">            <span class="comment">// Kokkos uses a multipass algorithm to implement scan.  Only</span></div>
<div class="line">            <span class="comment">// update the array on the final pass.  Updating the array</span></div>
<div class="line">            <span class="comment">// before changing &#39;update&#39; means that we do an exclusive</span></div>
<div class="line">            <span class="comment">// scan.  Update the array after for an inclusive scan.</span></div>
<div class="line">            rowOffsets[lclRows] = update;</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">if</span> (lclRows &lt; numLclRows) {</div>
<div class="line">            update += rowCounts(lclRows);</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Use the array of row counts to keep track of where to put each</span></div>
<div class="line">    <span class="comment">// new column index, when filling the graph.  Updating the entries</span></div>
<div class="line">    <span class="comment">// of rowCounts atomically lets us parallelize over elements</span></div>
<div class="line">    <span class="comment">// (which may touch multiple rows at a time -- esp. in 2-D or 3-D,</span></div>
<div class="line">    <span class="comment">// or with higher-order discretizations), rather than rows.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// We leave as an exercise to the reader how to use this array</span></div>
<div class="line">    <span class="comment">// without resetting its entries.</span></div>
<div class="line">    Kokkos::deep_copy(rowCounts, 0);</div>
<div class="line"> </div>
<div class="line">    Kokkos::View&lt;LO*, device_type&gt; colIndices(<span class="stringliteral">&quot;column indices&quot;</span>, numLclEntries);</div>
<div class="line">    Kokkos::View&lt;double*, device_type&gt; matrixValues(<span class="stringliteral">&quot;matrix values&quot;</span>, numLclEntries);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Iterate over elements in parallel to fill the graph, matrix,</span></div>
<div class="line">    <span class="comment">// and right-hand side (forcing term).  The latter gets the</span></div>
<div class="line">    <span class="comment">// boundary conditions (a trick for nonzero Dirichlet boundary</span></div>
<div class="line">    <span class="comment">// conditions).</span></div>
<div class="line">    Kokkos::parallel_for(</div>
<div class="line">        <span class="stringliteral">&quot;Assemble&quot;</span>, numLclElements,</div>
<div class="line">        KOKKOS_LAMBDA(<span class="keyword">const</span> LO elt) {</div>
<div class="line">          <span class="comment">// Push dx*dx into the forcing term.</span></div>
<div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> offCoeff = -diffusionCoeff / 2.0;</div>
<div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> midCoeff = diffusionCoeff;</div>
<div class="line">          <span class="comment">// In this discretization, every element corresponds to a</span></div>
<div class="line">          <span class="comment">// degree of freedom, and to a row of the matrix.  (Boundary</span></div>
<div class="line">          <span class="comment">// conditions are Dirichlet, so they don&#39;t count as degrees of</span></div>
<div class="line">          <span class="comment">// freedom.)</span></div>
<div class="line">          <span class="keyword">const</span> <span class="keywordtype">int</span> lclRows = elt;</div>
<div class="line"> </div>
<div class="line">          <span class="comment">// Always add a diagonal matrix entry.</span></div>
<div class="line">          {</div>
<div class="line">            <span class="keyword">const</span> LO count =</div>
<div class="line">                Kokkos::atomic_fetch_add(&amp;rowCounts(lclRows), LO(1));</div>
<div class="line">            colIndices(rowOffsets(lclRows) + count) = lclRows;</div>
<div class="line">            Kokkos::atomic_fetch_add(&amp;matrixValues(rowOffsets(lclRows) + count), midCoeff);</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line">          <span class="comment">// Each neighboring MPI process contributes an entry to the</span></div>
<div class="line">          <span class="comment">// current row.  In a more realistic code, we might handle</span></div>
<div class="line">          <span class="comment">// this either through a global assembly process (requiring</span></div>
<div class="line">          <span class="comment">// MPI communication), or through ghosting a layer of elements</span></div>
<div class="line">          <span class="comment">// (no MPI communication).</span></div>
<div class="line"> </div>
<div class="line">          <span class="comment">// MPI process to the left sends us an entry</span></div>
<div class="line">          <span class="keywordflow">if</span> (myRank &gt; 0 &amp;&amp; lclRows == 0) {</div>
<div class="line">            <span class="keyword">const</span> LO count                          = Kokkos::atomic_fetch_add(&amp;rowCounts(lclRows), LO(1));</div>
<div class="line">            colIndices(rowOffsets(lclRows) + count) = numLclRows;</div>
<div class="line">            Kokkos::atomic_fetch_add(&amp;matrixValues(rowOffsets(lclRows) + count), offCoeff);</div>
<div class="line">          }</div>
<div class="line">          <span class="comment">// MPI process to the right sends us an entry</span></div>
<div class="line">          <span class="keywordflow">if</span> (myRank + 1 &lt; numProcs &amp;&amp; lclRows + 1 == numLclRows) {</div>
<div class="line">            <span class="keyword">const</span> LO count =</div>
<div class="line">                Kokkos::atomic_fetch_add(&amp;rowCounts(lclRows), LO(1));</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Give this entry the right local column index, depending</span></div>
<div class="line">            <span class="comment">// on whether the MPI process to the left has already sent</span></div>
<div class="line">            <span class="comment">// us an entry.</span></div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">int</span> colInd                        = (myRank &gt; 0) ? numLclRows + 1 : numLclRows;</div>
<div class="line">            colIndices(rowOffsets(lclRows) + count) = colInd;</div>
<div class="line">            Kokkos::atomic_fetch_add(&amp;matrixValues(rowOffsets(lclRows) + count), offCoeff);</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line">          <span class="comment">// Contribute a matrix entry to the previous row.</span></div>
<div class="line">          <span class="keywordflow">if</span> (lclRows &gt; 0) {</div>
<div class="line">            <span class="keyword">const</span> LO count                              = Kokkos::atomic_fetch_add(&amp;rowCounts(lclRows - 1), LO(1));</div>
<div class="line">            colIndices(rowOffsets(lclRows - 1) + count) = lclRows;</div>
<div class="line">            Kokkos::atomic_fetch_add(&amp;matrixValues(rowOffsets(lclRows - 1) + count), offCoeff);</div>
<div class="line">          }</div>
<div class="line">          <span class="comment">// Contribute a matrix entry to the next row.</span></div>
<div class="line">          <span class="keywordflow">if</span> (lclRows + 1 &lt; numLclRows) {</div>
<div class="line">            <span class="keyword">const</span> LO count                              = Kokkos::atomic_fetch_add(&amp;rowCounts(lclRows + 1), LO(1));</div>
<div class="line">            colIndices(rowOffsets(lclRows + 1) + count) = lclRows;</div>
<div class="line">            Kokkos::atomic_fetch_add(&amp;matrixValues(rowOffsets(lclRows + 1) + count), offCoeff);</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Construct Tpetra objects</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keyword">using </span>Teuchos::RCP;</div>
<div class="line">    <span class="keyword">using </span>Teuchos::rcp;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> GO indexBase = 0;</div>
<div class="line">    RCP&lt;const Tpetra::Map&lt;&gt; &gt; rowMap =</div>
<div class="line">        rcp(<span class="keyword">new</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Map&lt;&gt;</a>(numGblElements, numLclElements, indexBase, comm));</div>
<div class="line"> </div>
<div class="line">    LO num_col_inds = numLclElements;</div>
<div class="line">    <span class="keywordflow">if</span> (myRank &gt; 0) {</div>
<div class="line">      num_col_inds++;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (myRank + 1 &lt; numProcs) {</div>
<div class="line">      num_col_inds++;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Soon, it will be acceptable to use a device View here.  The</span></div>
<div class="line">    <span class="comment">// issues are that Teuchos::RCP isn&#39;t thread safe, and the Kokkos</span></div>
<div class="line">    <span class="comment">// version of Tpetra::Map isn&#39;t quite ready yet.  We will change</span></div>
<div class="line">    <span class="comment">// the latter soon.</span></div>
<div class="line">    Kokkos::View&lt;GO*, Kokkos::HostSpace&gt; colInds(<span class="stringliteral">&quot;Column Map&quot;</span>, num_col_inds);</div>
<div class="line">    <span class="keywordflow">for</span> (LO k = 0; k &lt; numLclElements; ++k) {</div>
<div class="line">      colInds(k) = rowMap-&gt;getGlobalElement(k);</div>
<div class="line">    }</div>
<div class="line">    LO k = numLclElements;</div>
<div class="line">    <span class="keywordflow">if</span> (myRank &gt; 0) {</div>
<div class="line">      <span class="comment">// Contribution from left process.</span></div>
<div class="line">      colInds(k++) = rowMap-&gt;getGlobalElement(0) - 1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (myRank + 1 &lt; numProcs) {</div>
<div class="line">      <span class="comment">// Contribution from right process.</span></div>
<div class="line">      colInds(k++) = rowMap-&gt;getGlobalElement(numLclElements - 1) + 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Flag to tell Tpetra::Map to compute the global number of</span></div>
<div class="line">    <span class="comment">// indices in the Map.</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::global_size_t</a> INV =</div>
<div class="line">        Teuchos::OrdinalTraits&lt;Tpetra::global_size_t&gt;::invalid();</div>
<div class="line">    RCP&lt;const Tpetra::Map&lt;&gt; &gt; colMap =</div>
<div class="line">        rcp(<span class="keyword">new</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Map&lt;&gt;</a>(INV, colInds.data(), colInds.extent(0), indexBase, comm));</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="Tpetra__Import__Util2_8hpp.html#afa6ddc7a853dc700b00ae11be6598ce6">Tpetra::Import_Util::sortCrsEntries</a>(rowOffsets, colIndices, matrixValues);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::CrsMatrix&lt;double&gt;</a> A(rowMap, colMap, rowOffsets,</div>
<div class="line">                                colIndices, matrixValues);</div>
<div class="line">    A.fillComplete();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Hack to deal with the fact that Tpetra::Vector needs a</span></div>
<div class="line">    <span class="comment">// DualView&lt;double**&gt; for now, rather than a View&lt;double*&gt;.</span></div>
<div class="line">    Kokkos::DualView&lt;double**, Kokkos::LayoutLeft, device_type&gt; b_lcl(<span class="stringliteral">&quot;b&quot;</span>, numLclRows, 1);</div>
<div class="line">    b_lcl.modify_device();</div>
<div class="line">    Kokkos::deep_copy(Kokkos::subview(b_lcl.view_device(), Kokkos::ALL(), 0), forcingTerm);</div>
<div class="line">    <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Vector&lt;&gt;</a> b(A.getRangeMap(), b_lcl);</div>
<div class="line"> </div>
<div class="line">    Kokkos::DualView&lt;double**, Kokkos::LayoutLeft, device_type&gt; x_lcl(<span class="stringliteral">&quot;b&quot;</span>, numLclRows, 1);</div>
<div class="line">    x_lcl.modify_device();</div>
<div class="line">    Kokkos::deep_copy(Kokkos::subview(x_lcl.view_device(), Kokkos::ALL(), 0), temperature);</div>
<div class="line">    <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Vector&lt;&gt;</a> x(A.getDomainMap(), x_lcl);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> numIters = solve(x, A, b, dx);  <span class="comment">// solve the linear system</span></div>
<div class="line">    <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;Linear system Ax=b took &quot;</span> &lt;&lt; numIters &lt;&lt; <span class="stringliteral">&quot; iteration(s) to solve&quot;</span> &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Hack to deal with the fact that Tpetra::Vector needs a</span></div>
<div class="line">    <span class="comment">// DualView&lt;double**&gt; for now, rather than a View&lt;double*&gt;.  This</span></div>
<div class="line">    <span class="comment">// means that we have to make a deep copy back into the</span></div>
<div class="line">    <span class="comment">// &#39;temperature&#39; output array.</span></div>
<div class="line">    x_lcl.sync_device();</div>
<div class="line">    Kokkos::deep_copy(temperature, Kokkos::subview(b_lcl.view_device(), Kokkos::ALL(), 0));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Correct the solution for the nonhomogenous Dirichlet boundary</span></div>
<div class="line">    <span class="comment">// conditions.</span></div>
<div class="line">    Kokkos::parallel_for(</div>
<div class="line">        <span class="stringliteral">&quot;Boundary conditions&quot;</span>, numLclNodes,</div>
<div class="line">        KOKKOS_LAMBDA(<span class="keyword">const</span> LO node) {</div>
<div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> x_cur = x_left + node * dx;</div>
<div class="line">          temperature(node) += (T_left - T_right) * x_cur;</div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Compare the computed solution against the known exact solution:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// u(x) = -4.0 * (x - 0.5) * (x - 0.5) + 1.0 + (T_left - T_right)x.</span></div>
<div class="line">    <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Vector&lt;&gt;</a> x_exact(x, Teuchos::Copy);</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> device_type::execution_space execution_space;</div>
<div class="line">    <span class="keyword">typedef</span> Kokkos::RangePolicy&lt;execution_space, LO&gt; policy_type;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> x_exact_lcl = x_exact.getLocalViewDevice(Tpetra::Access::ReadWrite);</div>
<div class="line"> </div>
<div class="line">    Kokkos::parallel_for(</div>
<div class="line">        <span class="stringliteral">&quot;Compare solutions&quot;</span>,</div>
<div class="line">        policy_type(0, numLclNodes),</div>
<div class="line">        KOKKOS_LAMBDA(<span class="keyword">const</span> LO&amp; node) {</div>
<div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> x_cur = x_left + node * dx;</div>
<div class="line">          x_exact_lcl(node, 0) -= exactSolution(x_cur, T_left, T_right);</div>
<div class="line">        });</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> absErrNorm = x_exact.norm2();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> relErrNorm = b.norm2() / absErrNorm;</div>
<div class="line">    <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;Relative error norm: &quot;</span> &lt;&lt; relErrNorm &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;End Result: TEST PASSED&quot;</span> &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="aTpetra__Core_8hpp_html"><div class="ttname"><a href="Tpetra__Core_8hpp.html">Tpetra_Core.hpp</a></div><div class="ttdoc">Functions for initializing and finalizing Tpetra.</div></div>
<div class="ttc" id="aTpetra__Import__Util2_8hpp_html"><div class="ttname"><a href="Tpetra__Import__Util2_8hpp.html">Tpetra_Import_Util2.hpp</a></div><div class="ttdoc">Utility functions for packing and unpacking sparse matrix entries.</div></div>
<div class="ttc" id="aTpetra__Import__Util2_8hpp_html_afa6ddc7a853dc700b00ae11be6598ce6"><div class="ttname"><a href="Tpetra__Import__Util2_8hpp.html#afa6ddc7a853dc700b00ae11be6598ce6">Tpetra::Import_Util::sortCrsEntries</a></div><div class="ttdeci">void sortCrsEntries(const Teuchos::ArrayView&lt; size_t &gt; &amp;CRS_rowptr, const Teuchos::ArrayView&lt; Ordinal &gt; &amp;CRS_colind, const Teuchos::ArrayView&lt; Scalar &gt; &amp;CRS_vals)</div><div class="ttdoc">Sort the entries of the (raw CSR) matrix by column index within each row.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__Import__Util2_8hpp_source.html#l00432">Tpetra_Import_Util2.hpp:432</a></div></div>
<div class="ttc" id="aclassTpetra_1_1CrsMatrixStruct_html"><div class="ttname"><a href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::CrsMatrixStruct</a></div><div class="ttdoc">Struct that holds views of the contents of a CrsMatrix.</div><div class="ttdef"><b>Definition</b> <a href="TpetraExt__MMHelpers__decl_8hpp_source.html#l00036">TpetraExt_MMHelpers_decl.hpp:36</a></div></div>
<div class="ttc" id="aclassTpetra_1_1CrsMatrix_html"><div class="ttname"><a href="classTpetra_1_1CrsMatrix.html">Tpetra::CrsMatrix</a></div><div class="ttdoc">Sparse matrix that presents a row-oriented interface that lets users read or modify entries.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__CrsMatrix__decl_8hpp_source.html#l00397">Tpetra_CrsMatrix_decl.hpp:399</a></div></div>
<div class="ttc" id="aclassTpetra_1_1Map_html_a29e003133a7ac66aa92439e07c455af4"><div class="ttname"><a href="classTpetra_1_1Map.html#a29e003133a7ac66aa92439e07c455af4">Tpetra::Map::node_type</a></div><div class="ttdeci">Node node_type</div><div class="ttdoc">Legacy typedef that will go away at some point.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__Map__decl_8hpp_source.html#l00222">Tpetra_Map_decl.hpp:222</a></div></div>
<div class="ttc" id="aclassTpetra_1_1ScopeGuard_html"><div class="ttname"><a href="classTpetra_1_1ScopeGuard.html">Tpetra::ScopeGuard</a></div><div class="ttdoc">Scope guard whose destructor automatically calls Tpetra::finalize for you.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__Core_8hpp_source.html#l00188">Tpetra_Core.hpp:188</a></div></div>
<div class="ttc" id="anamespaceTpetra_html_ab0f27babe7678e67ee420a36029ae10a"><div class="ttname"><a href="namespaceTpetra.html#ab0f27babe7678e67ee420a36029ae10a">Tpetra::getDefaultComm</a></div><div class="ttdeci">Teuchos::RCP&lt; const Teuchos::Comm&lt; int &gt; &gt; getDefaultComm()</div><div class="ttdoc">Get Tpetra's default communicator.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__Core_8cpp_source.html#l00170">Tpetra_Core.cpp:170</a></div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
