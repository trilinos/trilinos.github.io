<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tpetra parallel linear algebra: Tpetra Lesson 01: Initialization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tpetra parallel linear algebra<span id="projectnumber">&#160;Version of the Day</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Tpetra Lesson 01: Initialization</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>"Hello world!" initialization.</p>
<h1><a class="anchor" id="Tpetra_Lesson01_Topics"></a>
Lesson topics</h1>
<p>The <a class="el" href="namespace_tpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> package provides next-generation distributed sparse linear algebra. It includes sparse matrices, vectors, and other linear algebra objects, along with computational kernels. This lesson shows the MPI (or non-MPI) initialization you need to do in order to start using <a class="el" href="namespace_tpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a>. The initialization procedure differs slightly, depending on whether you are writing a code from scratch, or introducing <a class="el" href="namespace_tpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> into an existing code base. We will give example codes and discussion for the following three use cases: </p><ol>
<li>
A code which only uses MPI through Trilinos  </li>
<li>
A code which uses MPI on its own as well as through Trilinos  </li>
<li>
A code which does not use MPI  </li>
</ol>
<h1><a class="anchor" id="Tpetra_Lesson01_MpiOnlyThroughTrilinos"></a>
Initialization for a code that only uses MPI through Trilinos</h1>
<p>This section explains how to set up the distributed-memory parallel environment for using <a class="el" href="namespace_tpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a>, in a code which only uses MPI through Trilinos. If you want to introduce <a class="el" href="namespace_tpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> into an existing MPI application, please see the next section. This example works whether or not Trilinos was built with MPI support.</p>
<p><a class="el" href="namespace_tpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> was written for distributed-memory parallel programming. It uses <a href="http://en.wikipedia.org/wiki/Message_Passing_Interface">MPI</a> (the Message Passing Interface) for this. However, <a class="el" href="namespace_tpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> will work correctly whether or not you have built Trilinos with MPI support. It does so by interacting with MPI through an interface called Teuchos::Comm. (If you are familiar with Epetra, this interface is analogous to Epetra_Comm.) If MPI is enabled, then this wraps an MPI_Comm. Otherwise, this is a "serial communicator" with one process, analogous to MPI_COMM_SELF.</p>
<p><a class="el" href="namespace_tpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> also provides an MPI initialization interface, <a class="el" href="class_tpetra_1_1_scope_guard.html" title="Scope guard whose destructor automatically calls Tpetra::finalize for you.">Tpetra::ScopeGuard</a>. If you built Trilinos with MPI enabled, but have not yet initialized MPI, ScopeGuard's constructor calls MPI_Init for you, and its destructor calls MPI_Finalize for you. The following code example shows how to initialize MPI (if available) and get a Teuchos::Comm corresponding to MPI_COMM_WORLD. The example works whether or not Trilinos was build with MPI support. If you prefer a C-style initialization and finalization interface, you may use <a class="el" href="namespace_tpetra.html#a16d03623c0a0da2088c779f062b9f452" title="Initialize Tpetra.">Tpetra::initialize</a> and <a class="el" href="namespace_tpetra.html#a985ee1373c57c11f6d94fe3011eb0f88" title="Finalize Tpetra.">Tpetra::finalize</a> instead.</p>
<div class="fragment"><div class="line"><span class="comment">// @HEADER</span></div>
<div class="line"><span class="comment">// *****************************************************************************</span></div>
<div class="line"><span class="comment">//          Tpetra: Templated Linear Algebra Services Package</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Copyright 2008 NTESS and the Tpetra contributors.</span></div>
<div class="line"><span class="comment">// SPDX-License-Identifier: BSD-3-Clause</span></div>
<div class="line"><span class="comment">// *****************************************************************************</span></div>
<div class="line"><span class="comment">// @HEADER</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// This example includes MPI initialization, getting a Teuchos::Comm</span></div>
<div class="line"><span class="comment">// communicator, and printing out Tpetra version information.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_tpetra___core_8hpp.html">Tpetra_Core.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Tpetra_Version.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Do something with the given communicator.  In this case, we just</span></div>
<div class="line"><span class="comment">// print Tpetra&#39;s version to stdout on Process 0.</span></div>
<div class="line"><span class="keywordtype">void</span> exampleRoutine(<span class="keyword">const</span> Teuchos::RCP&lt;<span class="keyword">const</span> Teuchos::Comm&lt;int&gt; &gt;&amp; comm) {</div>
<div class="line">  <span class="keywordflow">if</span> (comm-&gt;getRank() == 0) {</div>
<div class="line">    <span class="comment">// On (MPI) Process 0, print out the Tpetra software version.</span></div>
<div class="line">    std::cout &lt;&lt; Tpetra::version() &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div>
<div class="line">  <span class="comment">// These &quot;using&quot; declarations make the code more concise, in that</span></div>
<div class="line">  <span class="comment">// you don&#39;t have to write the namespace along with the class or</span></div>
<div class="line">  <span class="comment">// object name.  This is especially helpful with commonly used</span></div>
<div class="line">  <span class="comment">// things like std::endl.</span></div>
<div class="line">  <span class="keyword">using </span>std::cout;</div>
<div class="line">  <span class="keyword">using </span>std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Start up MPI, if using MPI.  Trilinos doesn&#39;t have to be built</span></div>
<div class="line">  <span class="comment">// with MPI; it&#39;s called a &quot;serial&quot; build if you build without MPI.</span></div>
<div class="line">  <span class="comment">// Tpetra::ScopeGuard hides this implementation detail.</span></div>
<div class="line">  <a class="code hl_class" href="class_tpetra_1_1_scope_guard.html">Tpetra::ScopeGuard</a> tpetraScope(&amp;argc, &amp;argv);</div>
<div class="line"> </div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Never let Tpetra objects persist after either MPI_Finalize or</span></div>
<div class="line">    <span class="comment">// Kokkos::finalize has been called.  This is because the objects&#39;</span></div>
<div class="line">    <span class="comment">// destructors may need to call MPI or Kokkos functions.  In</span></div>
<div class="line">    <span class="comment">// particular, never create Tpetra objects at main scope.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Get a pointer to the communicator object representing</span></div>
<div class="line">    <span class="comment">// MPI_COMM_WORLD.  The function knows whether or not we built with</span></div>
<div class="line">    <span class="comment">// MPI support.  If we didn&#39;t build with MPI, we&#39;ll get a</span></div>
<div class="line">    <span class="comment">// &quot;communicator&quot; with size 1, whose only process has rank 0.</span></div>
<div class="line">    Teuchos::RCP&lt;const Teuchos::Comm&lt;int&gt; &gt; comm = <a class="code hl_function" href="namespace_tpetra.html#ab0f27babe7678e67ee420a36029ae10a">Tpetra::getDefaultComm</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Get my process&#39; rank, and the total number of processes.</span></div>
<div class="line">    <span class="comment">// Equivalent to MPI_Comm_rank resp. MPI_Comm_size.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> myRank   = comm-&gt;getRank();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> numProcs = comm-&gt;getSize();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;Total number of processes: &quot;</span> &lt;&lt; numProcs &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Do something with the new communicator.</span></div>
<div class="line">    exampleRoutine(comm);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This tells the Trilinos test framework that the test passed.</span></div>
<div class="line">    <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;End Result: TEST PASSED&quot;</span> &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// ScopeGuard&#39;s destructor calls MPI_Finalize, if its constructor</span></div>
<div class="line">    <span class="comment">// called MPI_Init.  Likewise, it calls Kokkos::finalize, if its</span></div>
<div class="line">    <span class="comment">// constructor called Kokkos::initialize.</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// You don&#39;t have to do anything here!  Just return from main().</span></div>
<div class="line">  <span class="comment">// Isn&#39;t that helpful?</span></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="a_tpetra___core_8hpp_html"><div class="ttname"><a href="_tpetra___core_8hpp.html">Tpetra_Core.hpp</a></div><div class="ttdoc">Functions for initializing and finalizing Tpetra.</div></div>
<div class="ttc" id="aclass_tpetra_1_1_scope_guard_html"><div class="ttname"><a href="class_tpetra_1_1_scope_guard.html">Tpetra::ScopeGuard</a></div><div class="ttdoc">Scope guard whose destructor automatically calls Tpetra::finalize for you.</div><div class="ttdef"><b>Definition</b> <a href="_tpetra___core_8hpp_source.html#l00188">Tpetra_Core.hpp:188</a></div></div>
<div class="ttc" id="anamespace_tpetra_html_ab0f27babe7678e67ee420a36029ae10a"><div class="ttname"><a href="namespace_tpetra.html#ab0f27babe7678e67ee420a36029ae10a">Tpetra::getDefaultComm</a></div><div class="ttdeci">Teuchos::RCP&lt; const Teuchos::Comm&lt; int &gt; &gt; getDefaultComm()</div><div class="ttdoc">Get Tpetra's default communicator.</div><div class="ttdef"><b>Definition</b> <a href="_tpetra___core_8cpp_source.html#l00170">Tpetra_Core.cpp:170</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="Tpetra_Lesson01_ExistingMpiCode"></a>
Initialization for an existing MPI code</h1>
<p><a class="el" href="namespace_tpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> also works fine in an existing MPI code. For this example, we assume that your code initializes MPI on its own by calling MPI_Init, and calls MPI_Finalize at the end. It also must get an MPI_Comm (an MPI communicator) somewhere, either by using a predefined communicator such as MPI_COMM_WORLD, or by creating a new one.</p>
<div class="fragment"><div class="line"><span class="comment">// @HEADER</span></div>
<div class="line"><span class="comment">// *****************************************************************************</span></div>
<div class="line"><span class="comment">//          Tpetra: Templated Linear Algebra Services Package</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Copyright 2008 NTESS and the Tpetra contributors.</span></div>
<div class="line"><span class="comment">// SPDX-License-Identifier: BSD-3-Clause</span></div>
<div class="line"><span class="comment">// *****************************************************************************</span></div>
<div class="line"><span class="comment">// @HEADER</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// This example shows how to wrap the MPI_Comm (MPI communicator) that</span></div>
<div class="line"><span class="comment">// you are using, so that Tpetra can use it as well.  it includes MPI</span></div>
<div class="line"><span class="comment">// initialization, getting a Teuchos::Comm communicator, and printing</span></div>
<div class="line"><span class="comment">// out Tpetra version information.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Your code is an existing MPI code, so it presumably includes mpi.h directly.</span></div>
<div class="line"><span class="preprocessor">#include &lt;mpi.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;Teuchos_DefaultMpiComm.hpp&gt;</span>  <span class="comment">// wrapper for MPI_Comm</span></div>
<div class="line"><span class="preprocessor">#include &lt;Tpetra_Version.hpp&gt;</span>          <span class="comment">// Tpetra version string</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// ... Your other include files go here ...</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Do something with the given communicator.  In this case, we just</span></div>
<div class="line"><span class="comment">// print Tpetra&#39;s version to stdout on Process 0 in the given</span></div>
<div class="line"><span class="comment">// communicator.</span></div>
<div class="line"><span class="keywordtype">void</span> exampleRoutine(<span class="keyword">const</span> Teuchos::RCP&lt;<span class="keyword">const</span> Teuchos::Comm&lt;int&gt; &gt;&amp; comm) {</div>
<div class="line">  <span class="keywordflow">if</span> (comm-&gt;getRank() == 0) {</div>
<div class="line">    <span class="comment">// On (MPI) Process 0, print out the Tpetra software version.</span></div>
<div class="line">    std::cout &lt;&lt; Tpetra::version() &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div>
<div class="line">  <span class="comment">// These &quot;using&quot; declarations make the code more concise, in that</span></div>
<div class="line">  <span class="comment">// you don&#39;t have to write the namespace along with the class or</span></div>
<div class="line">  <span class="comment">// object name.  This is especially helpful with commonly used</span></div>
<div class="line">  <span class="comment">// things like std::endl or Teuchos::RCP.</span></div>
<div class="line">  <span class="keyword">using </span>std::cout;</div>
<div class="line">  <span class="keyword">using </span>std::endl;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::Comm;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::MpiComm;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::RCP;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::rcp;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// We assume that your code calls MPI_Init.  It&#39;s bad form</span></div>
<div class="line">  <span class="comment">// to ignore the error codes returned by MPI functions, but</span></div>
<div class="line">  <span class="comment">// we do so here for brevity.</span></div>
<div class="line">  (void)MPI_Init(&amp;argc, &amp;argv);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// This code takes the place of whatever you do to get an MPI_Comm.</span></div>
<div class="line">  MPI_Comm yourComm = MPI_COMM_WORLD;</div>
<div class="line"> </div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Never create Tpetra objects at main scope.  Their destructors</span></div>
<div class="line">    <span class="comment">// must be called before MPI_Finalize and Kokkos::finalize are</span></div>
<div class="line">    <span class="comment">// called.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// If your code plans to use MPI on its own, as well as through</span></div>
<div class="line">    <span class="comment">// Trilinos, consider giving Trilinos a copy of your MPI_Comm</span></div>
<div class="line">    <span class="comment">// (created via MPI_Comm_dup) rather than your MPI_Comm directly.</span></div>
<div class="line">    <span class="comment">// Trilinos may in the future duplicate the MPI_Comm</span></div>
<div class="line">    <span class="comment">// automatically, but it does not currently do this.  Duplicating</span></div>
<div class="line">    <span class="comment">// the MPI_Comm is not necessary, but may make it easier for you</span></div>
<div class="line">    <span class="comment">// to overlap asynchronous communication operations performed by</span></div>
<div class="line">    <span class="comment">// Trilinos with those performed by your code.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Wrap the MPI_Comm.  If you wrap it in this way, you are telling</span></div>
<div class="line">    <span class="comment">// Trilinos that you are responsible for calling MPI_Comm_free on</span></div>
<div class="line">    <span class="comment">// your MPI_Comm after use, if necessary.  (It&#39;s not necessary for</span></div>
<div class="line">    <span class="comment">// MPI_COMM_WORLD.)  There is a way to tell Trilinos to call</span></div>
<div class="line">    <span class="comment">// MPI_Comm_free itself; we don&#39;t show it here.  (It involves</span></div>
<div class="line">    <span class="comment">// passing the result of Teuchos::opaqueWrapper to MpiComm&#39;s</span></div>
<div class="line">    <span class="comment">// constructor.)</span></div>
<div class="line"> </div>
<div class="line">    RCP&lt;const Comm&lt;int&gt; &gt; comm(<span class="keyword">new</span> MpiComm&lt;int&gt;(yourComm));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Get my process&#39; rank, and the total number of processes.</span></div>
<div class="line">    <span class="comment">// Equivalent to MPI_Comm_rank resp. MPI_Comm_size.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> myRank   = comm-&gt;getRank();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> numProcs = comm-&gt;getSize();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;Total number of processes: &quot;</span> &lt;&lt; numProcs &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Do something with the new communicator.</span></div>
<div class="line">    exampleRoutine(comm);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This tells the Trilinos test framework that the test passed.</span></div>
<div class="line">    <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;End Result: TEST PASSED&quot;</span> &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If you need to call MPI_Comm_free on your MPI_Comm, now would be</span></div>
<div class="line">  <span class="comment">// the time to do so, before calling MPI_Finalize.  You may also</span></div>
<div class="line">  <span class="comment">// automate this process; ask the tutorial presenter for more</span></div>
<div class="line">  <span class="comment">// information.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Since you called MPI_Init, you are responsible for calling</span></div>
<div class="line">  <span class="comment">// MPI_Finalize.</span></div>
<div class="line">  (void)MPI_Finalize();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="Tpetra_Lesson01_ExistingNonMpiCode"></a>
Initialization for an existing non-MPI code</h1>
<p>The first code example in this lesson uses <a class="el" href="class_tpetra_1_1_scope_guard.html" title="Scope guard whose destructor automatically calls Tpetra::finalize for you.">Tpetra::ScopeGuard</a> to initialize MPI. Despite the name, in a non-MPI build of Trilinos, it does nothing. Thus, if you built Trilinos with MPI disabled, you should feel free to use <a class="el" href="class_tpetra_1_1_scope_guard.html" title="Scope guard whose destructor automatically calls Tpetra::finalize for you.">Tpetra::ScopeGuard</a> in your main() function. However, if you are using a build of Trilinos that has MPI enabled, but you don't want to use multiple MPI processes in your application, you may use the three-argument version of <a class="el" href="class_tpetra_1_1_scope_guard.html" title="Scope guard whose destructor automatically calls Tpetra::finalize for you.">Tpetra::ScopeGuard</a>'s constructor, that takes an MPI_Comm argument. Just pass in MPI_COMM_SELF to force <a class="el" href="namespace_tpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> not to use multiple processes. The following example illustrates this.</p>
<div class="fragment"><div class="line"><span class="comment">// @HEADER</span></div>
<div class="line"><span class="comment">// *****************************************************************************</span></div>
<div class="line"><span class="comment">//          Tpetra: Templated Linear Algebra Services Package</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Copyright 2008 NTESS and the Tpetra contributors.</span></div>
<div class="line"><span class="comment">// SPDX-License-Identifier: BSD-3-Clause</span></div>
<div class="line"><span class="comment">// *****************************************************************************</span></div>
<div class="line"><span class="comment">// @HEADER</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... Your other include files go here ...</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_tpetra___core_8hpp.html">Tpetra_Core.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Tpetra_Version.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Do something with the given communicator.  In this case, we just</span></div>
<div class="line"><span class="comment">// print Tpetra&#39;s version to stdout on Process 0.</span></div>
<div class="line"><span class="keywordtype">void</span> exampleRoutine(<span class="keyword">const</span> Teuchos::RCP&lt;<span class="keyword">const</span> Teuchos::Comm&lt;int&gt; &gt;&amp; comm) {</div>
<div class="line">  <span class="keywordflow">if</span> (comm-&gt;getRank() == 0) {</div>
<div class="line">    <span class="comment">// On Process 0, print out the Tpetra software version.</span></div>
<div class="line">    std::cout &lt;&lt; Tpetra::version() &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div>
<div class="line">  <span class="keyword">using </span>std::cout;</div>
<div class="line">  <span class="keyword">using </span>std::endl;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::Comm;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::RCP;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::rcp;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Tpetra&#39;s default communicator will use a 1-process comm.</span></div>
<div class="line"><span class="preprocessor">#ifdef HAVE_TPETRA_MPI</span></div>
<div class="line">  <a class="code hl_class" href="class_tpetra_1_1_scope_guard.html">Tpetra::ScopeGuard</a> tpetraScope(&amp;argc, &amp;argv, MPI_COMM_SELF);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <span class="comment">// Not building with MPI, so default comm won&#39;t use MPI.</span></div>
<div class="line">  <a class="code hl_class" href="class_tpetra_1_1_scope_guard.html">Tpetra::ScopeGuard</a> tpetraScope(&amp;argc, &amp;argv);</div>
<div class="line"><span class="preprocessor">#endif  </span><span class="comment">// HAVE_TPETRA_MPI</span></div>
<div class="line">  {</div>
<div class="line">    RCP&lt;const Comm&lt;int&gt; &gt; comm = <a class="code hl_function" href="namespace_tpetra.html#ab0f27babe7678e67ee420a36029ae10a">Tpetra::getDefaultComm</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// With a single-process communicator, the rank is always 0, and</span></div>
<div class="line">    <span class="comment">// the number of processes is always 1.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> myRank   = comm-&gt;getRank();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> numProcs = comm-&gt;getSize();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;Total number of processes: &quot;</span> &lt;&lt; numProcs &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Test the two assertions in the previous comment.</span></div>
<div class="line">    <span class="comment">// TEUCHOS_TEST_FOR_EXCEPTION is a macro defined in the Teuchos</span></div>
<div class="line">    <span class="comment">// package that takes three arguments: a bool expression, an</span></div>
<div class="line">    <span class="comment">// exception to throw if the expression evaluates to true, and a</span></div>
<div class="line">    <span class="comment">// message (interpreted as if it follows a &quot;&lt;&lt;&quot; after an</span></div>
<div class="line">    <span class="comment">// std::ostream) to include in the exception.  The macro includes</span></div>
<div class="line">    <span class="comment">// useful line number and file information in the exception</span></div>
<div class="line">    <span class="comment">// message, as well as a place where you can set a breakpoint in a</span></div>
<div class="line">    <span class="comment">// debugger right before the exception is thrown.</span></div>
<div class="line"> </div>
<div class="line">    TEUCHOS_TEST_FOR_EXCEPTION(myRank != 0, std::logic_error,</div>
<div class="line">                               <span class="stringliteral">&quot;This is a single-MPI-process example, but the calling process&#39; &quot;</span></div>
<div class="line">                               <span class="stringliteral">&quot;rank is &quot;</span></div>
<div class="line">                                   &lt;&lt; myRank &lt;&lt; <span class="stringliteral">&quot; != 0.  Please report this bug.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    TEUCHOS_TEST_FOR_EXCEPTION(numProcs != 1, std::logic_error,</div>
<div class="line">                               <span class="stringliteral">&quot;This is a single-MPI-process example, but the number of &quot;</span></div>
<div class="line">                               <span class="stringliteral">&quot;processes in the Teuchos::Comm is &quot;</span></div>
<div class="line">                                   &lt;&lt; numProcs &lt;&lt; <span class="stringliteral">&quot; != 1.  &quot;</span></div>
<div class="line">                                                  <span class="stringliteral">&quot;Please report this bug.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Do something with the new communicator.</span></div>
<div class="line">    exampleRoutine(comm);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This tells the Trilinos test framework that the test passed.</span></div>
<div class="line">    <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;End Result: TEST PASSED&quot;</span> &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="Tpetra_Lesson01_Other"></a>
Things we didn't explain above</h1>
<h2><a class="anchor" id="Tpetra_Lesson01_Other_RCP"></a>
What are RCP and rcp?</h2>
<p>RCP stands for "reference-counted pointer." It lives in the Teuchos package of Trilinos, and is Trilinos' version of std::shared_ptr or boost::shared_ptr. (There are both historical and technical reasons why we use our own class instead of one of those.) For more details, please refer to the <a href="http://www.cs.sandia.gov/~rabartl/TeuchosMemoryManagementSAND.pdf">complete reference</a> for the Teuchos memory management classes.</p>
<p>In brief: RCP lets you have the benefits of pointers (the lightweight sharing of data) without the headaches and risks (managing ownership and deallocation). It behaves like a pointer in terms of syntax, but handles deallocation for you. RCP is templated on the type of object to which it points. For example, <code>RCP&lt;T&gt; x</code> works very much like <code>T* x</code> (a pointer to a <code>T</code>), and <code>RCP&lt;const T&gt; y</code> works like <code>const T* y</code> (that is, a pointer to a <code>const T</code>). The dereference (<code>*</code>) and method call (<code>-&gt;</code>) operators work just like they do with regular pointers. For example,</p>
<div class="fragment"><div class="line"><span class="comment">// Pointer to nonconst T.</span></div>
<div class="line">RCP&lt;T&gt; x_ptr = ...;</div>
<div class="line"><span class="comment">// Unary operator* returns a reference, not a copy.</span></div>
<div class="line">T&amp; x_ref = *x_ptr;</div>
<div class="line">x_ptr-&gt;nonconstInstanceMethod ();</div>
<div class="line">x_ptr-&gt;constInstanceMethod ();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Pointer to const T.</span></div>
<div class="line">RCP&lt;const T&gt; y_ptr = ...;</div>
<div class="line"><span class="keyword">const</span> T&amp; y_ref = *y_ptr;</div>
<div class="line"><span class="comment">// You may only call const instance methods with a const pointer.</span></div>
<div class="line">y_ptr-&gt;constInstanceMethod ();</div>
</div><!-- fragment --><p>The "reference-counted" part of RCP means that it automatically handles deallocation, if appropriate. Copying the RCP increments the reference count; allowing it to fall out of scope or assigning Teuchos::null to it decrements the reference count. When the reference count reaches zero, the deallocation function is called. By default, it calls <code>delete</code>, but you can control this behavior. Reference counting allows you to share pointers between different parts of your code, without needing to worry about what part of the code deallocates the object, or when it gets deallocated.</p>
<p>The Teuchos::rcp function is a "nonmember constructor" template function that returns a newly created RCP of something. Using this function to create an RCP saves some typing, and also may improve exception safety.</p>
<h2><a class="anchor" id="Tpetra_Lesson01_Other_Comm"></a>
Teuchos::Comm, Teuchos::MpiComm, and Teuchos::SerialComm</h2>
<p>Teuchos::Comm is Trilinos' interface to distributed-memory parallel communication. It lives in the Teuchos package of Trilinos. Comm is an abstract base class. The Teuchos::MpiComm and Teuchos::SerialComm classes implement this interface. As the name indicates, MpiComm implements Comm by using MPI calls. SerialComm implements Comm without MPI, as a "communicator" with only one process. (This is more or less equivalent to MPI_COMM_SELF, except without actually using MPI.) All of these classes are templated on the integer type used for MPI function calls. Currently, this is always <code>int</code>, so you should always use <code>int</code> as the template parameter.</p>
<p>Since Comm is an abstract base class, you must handle it by pointer or reference. The idiomatic way to create and handle a Comm is by RCP, as an <code>RCP&lt;const Comm&lt;int&gt; &gt;</code>. This expression should be considered Trilinos' version of the <code>MPI_Comm</code> opaque handle. Thus, </p><div class="fragment"><div class="line">RCP&lt;const Comm&lt;int&gt; &gt; comm = rcp (<span class="keyword">new</span> MpiComm&lt;int&gt; (MPI_COMM_WORLD));</div>
</div><!-- fragment --><p> is "Trilinos-speak" for this: </p><div class="fragment"><div class="line">MPI_Comm comm = MPI_COMM_WORLD;</div>
</div><!-- fragment --><p>The normal way to use Comm is to call the nonmember functions in the Teuchos_CommHelpers.hpp header file. We won't cover this in the lesson today. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
