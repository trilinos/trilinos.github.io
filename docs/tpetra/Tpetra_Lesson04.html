<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tpetra parallel linear algebra: Tpetra Lesson 04: Sparse matrix fill</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tpetra parallel linear algebra<span id="projectnumber">&#160;Version of the Day</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Tpetra Lesson 04: Sparse matrix fill</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Different ways to add entries to <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> sparse matrix.</p>
<h1><a class="anchor" id="Tpetra_Lesson04_Topics"></a>
Lesson topics</h1>
<p>This lesson explains how to add entries to a <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> sparse matrix (<a class="el" href="classTpetra_1_1CrsMatrix.html" title="Sparse matrix that presents a row-oriented interface that lets users read or modify entries.">Tpetra::CrsMatrix</a>). It explains how you can choose any of various ways to add entries to the matrix. Some are more flexible but less efficient, and others are more efficient but less flexible. In general, knowing the sparse matrix structure in advance will reduce both peak memory usage and total run time.</p>
<p>This lesson does not currently include code examples. The section <a class="el" href="Tpetra_Lesson04.html#Tpetra_Lesson04_Exercise">Exercise</a> at the end suggests modifying the example <a class="el" href="Tpetra_Lesson03.html">Tpetra Lesson 03: Power method</a> in order to learn about the different ways to add or change the entries of a sparse matrix.</p>
<h1><a class="anchor" id="Tpetra_Lesson04_Fill"></a>
Filling a sparse matrix</h1>
<p>We call adding entries to a sparse matrix <em>filling</em> it, and call the general procedure "sparse matrix fill" or just <em>fill</em>. Often people have finite element assembly in mind when they use this expression, but fill here means adding entries for any reason. For example, you might want to </p><ul>
<li>
solve an optimization problem with a set of linear constraints, so you would add one row to the sparse matrix for each constraint; or  </li>
<li>
represent a weighted graph as a sparse matrix, so that each row of the matrix represents a vertex's adjacency list and corresponding edge weights.  </li>
</ul>
<p>Also, by extension, "fill" might refer to modifying existing entries of a sparse matrix.</p>
<h1><a class="anchor" id="Tpetra_Lesson04_Rowwise"></a>
Rowwise access, not rowwise distribution</h1>
<p>CrsMatrix inherits from the RowMatrix interface; it "is a" RowMatrix. Some people have the misconception that "RowMatrix" (and therefore CrsMatrix) refers to a rowwise distribution of the sparse matrix over parallel processes. It does not. CrsMatrix supports an arbitrary "two-dimensional" distribution of rows and columns over processes. The term instead refers to rowwise access to the data. That is, the methods in this interface and in CrsMatrix let you add or access entries on each process by row.</p>
<p>This distinction matters because two or more processes might share entries in a row. Asking for "all the entries in a row" on a particular process only accesses the entries owned by that process, which is not necessarily all the entries in a row.</p>
<p>Whether adding entries or modifying existing ones, you may always do so for any number of entries in the row, such that their columns are owned by the calling process. You should always modify as many entries with one method call as possible, in order to amortize function call and data access overhead.</p>
<h1><a class="anchor" id="Tpetra_Lesson04_Phases"></a>
Phases of fill</h1>
<p>A sparse matrix may be in any of three different states: </p><ol>
<li>
Post construction, before first call to <code>fillComplete()</code>  </li>
<li>
<code>fillComplete()</code> has been called after construction or <code>resumeFill()</code>  </li>
<li>
<code>resumeFill()</code> has been called  </li>
</ol>
<p>In States 1 and 3, you are allowed to set or modify values in the matrix. If the matrix was not created with a constant graph (see below), and if there is room in the row (see "static profile" discussion below), you are allowed to insert entries into the matrix.</p>
<p>We call a matrix in State 2 "fill complete." In State 2, you are <em>not</em> allowed to modify the matrix <em>at all</em>. (This is different than Epetra_CrsMatrix, which allows modifications to the values (but not the structure) of a fill complete matrix.)</p>
<p>Calling <code>fillComplete()</code> does a lot of work. In general, it requires distributed-memory communication as well as local rearrangement of data. The intent is that you should exploit this work for as long as possible before calling <code>resumeFill()</code>. You can do so by performing multiple sparse matrix-vector multiplies or triangular solves.</p>
<h1><a class="anchor" id="Tpetra_Lesson04_Tradeoffs"></a>
Trade-offs between flexibility and performance</h1>
<p>In all the examples below, we assume the following "preamble" of code: </p><div class="fragment"><div class="line"><span class="keyword">using </span>Teuchos::RCP;</div>
<div class="line"><span class="keyword">using </span>Teuchos::rcp;</div>
<div class="line"><span class="comment">// Your scalar type; the type of sparse matrix entries. e.g., double.</span></div>
<div class="line"><span class="keyword">typedef</span> ST ...; </div>
<div class="line"><span class="comment">// Your local ordinal type; the signed integer type </span></div>
<div class="line"><span class="comment">// used to store local sparse matrix indices.  e.g., int.</span></div>
<div class="line"><span class="keyword">typedef</span> LO ...; </div>
<div class="line"><span class="comment">// Your global ordinal type; the signed integer type </span></div>
<div class="line"><span class="comment">// used to index the matrix globally, over all processes.</span></div>
<div class="line"><span class="comment">// e.g., int, long, ptrdif_t, int64_t, ...</span></div>
<div class="line"><span class="keyword">typedef</span> GO ...; </div>
<div class="line"><span class="comment">// The Node type.  e.g., Kokkos::DefaultNode::DefaultNodeType, </span></div>
<div class="line"><span class="comment">// defined in KokkosCompat_DefaultNode.hpp.</span></div>
<div class="line"><span class="keyword">typedef</span> NT ...; </div>
</div><!-- fragment --><h1><a class="anchor" id="Tpetra_Lesson04_Tradeoffs_dyn_hint"></a>
Allocation with a size hint</h1>
<p>CrsMatrix lets you make trade-offs between flexibility and performance. All of these trade-offs revolve around how much you know about the structure of the sparse matrix &ndash; that is, its graph &ndash; in advance. In the most general case, all you know is which process owns which row &ndash; the row Map. </p><div class="fragment"><div class="line">RCP&lt;const Map&lt;LO, GO, NT&gt; &gt; rowMap = ...; <span class="comment">// whatever row Map you want</span></div>
<div class="line">RCP&lt;CrsMatrix&lt;ST, LO, GO, NT&gt; &gt; A = rcp (<span class="keyword">new</span> CrsMatrix&lt;ST, LO, GO, NT&gt; (rowMap ,sizehint));</div>
</div><!-- fragment --><p> This code snippet says that you want to create a sparse matrix with the given row distribution with a certain approximate number of entries per row. <br  />
 It also says that you intend each process to own all the entries in a given row. If you want to allow a more general "2-D" distribution, you must also tell the constructor which process owns which columns of the matrix. You do so by supplying a "column Map": </p><div class="fragment"><div class="line">RCP&lt;const Map&lt;LO, GO, NT&gt; &gt; rowMap = ...; <span class="comment">// whatever row Map you want</span></div>
<div class="line">RCP&lt;const Map&lt;LO, GO, NT&gt; &gt; colMap = ...; <span class="comment">// whatever column Map you want</span></div>
<div class="line">RCP&lt;CrsMatrix&lt;ST, LO, GO, NT&gt; &gt; A = rcp (<span class="keyword">new</span> CrsMatrix&lt;ST, LO, GO, NT&gt; (rowMap, colMap, sizehint));</div>
</div><!-- fragment --><p> All the examples that follow allow you to supply a column Map if you which, so we omit this for brevity.</p>
<p>CrsMatrix lets you make trade-offs between flexibility and performance. All of these trade-offs revolve around how much you know about the structure of the sparse matrix &ndash; that is, its graph &ndash; in advance. In the most general case, all you know is which process owns which row &ndash; the row Map &mdash; and an approximate number of nonzeros per row. You may do so either with a single number, which is an expected upper bound on the number of entries in any one row, or with an upper bound for each row of the matrix. The typical use case is a single upper bound, which we illustrate below. </p><div class="fragment"><div class="line">RCP&lt;const Map&lt;LO, GO, NT&gt; &gt; rowMap = ...; <span class="comment">// whatever row Map you want</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> maxEntriesPerRow = 3;</div>
<div class="line">RCP&lt;CrsMatrix&lt;ST, LO, GO, NT&gt; &gt; A = </div>
<div class="line">  rcp (<span class="keyword">new</span> CrsMatrix&lt;ST, LO, GO, NT&gt; (rowMap, maxEntriesPerRow));</div>
</div><!-- fragment --><p> Giving an upper bound on the number of entries per row allows the matrix to preallocate space for each row, which is especially critical on architectures where memory allocation is relatively expensive (e.g. GPUs).</p>
<h1><a class="anchor" id="Tpetra_Lesson04_Tradeoffs_const_graph"></a>
Constant graph</h1>
<p>The most efficient but least flexible fill method is to create the CrsMatrix with a constant graph. That is, you create a CrsGraph separately, fill it, call its <code>fillComplete()</code> method, then pass the graph to the CrsMatrix constructor. This completely constrains the structure of the CrsMatrix. You may only set or modify values in the matrix, not the structure. (This means you may not call <code>insertGlobalValues()</code> or <code>insertLocalValues()</code>, only the <code>replace*Values()</code>, <code>sumInto*Values</code>, <code>scale()</code>, and <code>setAllToScalar()</code> methods.</p>
<div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_class" href="classTpetra_1_1CrsGraph.html">Tpetra::CrsGraph</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Note that the CrsMatrix constructor takes a &quot;const&quot; graph,</span></div>
<div class="line"><span class="comment">// meaning that the CrsMatrix is not allowed to change the</span></div>
<div class="line"><span class="comment">// graph.  You shouldn&#39;t either.  This is why we use an</span></div>
<div class="line"><span class="comment">// RCP&lt;const CrsGraph&gt; (&quot;pointer to const graph&quot;) below.</span></div>
<div class="line"><span class="comment">// The graph must be fill complete.</span></div>
<div class="line">RCP&lt;const CrsGraph&lt;LO, GO, NT&gt; &gt; graph = ...; </div>
<div class="line"> </div>
<div class="line"><span class="comment">// The graph comes with the row and column Maps already built in.</span></div>
<div class="line">RCP&lt;CrsMatrix&lt;ST, LO, GO, NT&gt; &gt; A = rcp (<span class="keyword">new</span> CrsMatrix&lt;ST, LO, GO, NT&gt; (graph));</div>
<div class="ttc" id="aclassTpetra_1_1CrsGraph_html"><div class="ttname"><a href="classTpetra_1_1CrsGraph.html">Tpetra::CrsGraph</a></div><div class="ttdoc">A distributed graph accessed by rows (adjacency lists) and stored sparsely.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__CrsGraph__decl_8hpp_source.html#l00190">Tpetra_CrsGraph_decl.hpp:195</a></div></div>
</div><!-- fragment --><p> Filling the CrsGraph works much like filling a CrsMatrix, except that you only specify structure, not values. Furthermore, the same size hint applies to CrsGraph.</p>
<h1><a class="anchor" id="Tpetra_Lesson04_local_vs_global"></a>
Local vs. global indices</h1>
<p>Please see <a class="el" href="Tpetra_Lesson02.html">Tpetra Lesson 02: Map and Vector</a> for a detailed explanation of global and local indices.</p>
<p>In the sparse matrix's final state, it represents column indices as local indices. This is faster for operations like sparse matrix-vector multiply. It saves storage as well, especially if <code>sizeof(LocalOrdinal) &lt; sizeof(GlobalOrdinal)</code>. However, accessing or inserting entries by local index is only allowed under certain conditions. In particular, the matrix must have a column Map, which tells it how to convert between global and local indices for the column indices of the matrix. If you didn't create the matrix with a precomputed column Map (either in its constructor, or in the constant graph), it has to compute the column Map on its own. It does so in <code>fillComplete()</code>.</p>
<p>If the matrix doesn't have a column Map yet, you must use global indices, since local indices don't exist yet. However, if you can use local indices, you should. For global indices, the matrix must go to the Map to look up the corresponding local index for every global index. Local indices only require an array access.</p>
<p>Remember that if column indices are local, then they are counted with respect to the column Map. Local row and column indices may not necessarily be the same. For example, the matrix entry at position <code>(i_local, i_local)</code>, where the first <code>i_local</code> is the local row index and the second <code>i_local</code> the local column index, may not necessarily be a diagonal entry of the matrix. However, the matrix entry at global position <code>(i_global, i_global)</code> is always a diagonal entry of the matrix.</p>
<h1><a class="anchor" id="Tpetra_Lesson04_Exercise"></a>
Exercise</h1>
<p>Start with the <a class="el" href="Tpetra_Lesson03.html">Tpetra Lesson 03: Power method</a> example, which uses global indices. Try all of the different fill techniques described in this lesson. If you like, you may also try cyclic boundary conditions instead of Dirichlet boundary conditions in the 1-D Poisson discretization. (This makes the number of entries per row the same for all rows.) </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 9 2025 21:01:02 for Tpetra parallel linear algebra by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
