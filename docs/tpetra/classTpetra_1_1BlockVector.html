<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tpetra parallel linear algebra: Tpetra::BlockVector&lt; Scalar, LO, GO, Node &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tpetra parallel linear algebra<span id="projectnumber">&#160;Version of the Day</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceTpetra.html">Tpetra</a></li><li class="navelem"><a class="el" href="classTpetra_1_1BlockVector.html">BlockVector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classTpetra_1_1BlockVector-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Tpetra::BlockVector&lt; Scalar, LO, GO, Node &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Vector</a> for multiple degrees of freedom per mesh point.  
 <a href="classTpetra_1_1BlockVector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html">Tpetra_BlockVector_decl.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Tpetra::BlockVector&lt; Scalar, LO, GO, Node &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classTpetra_1_1BlockVector__inherit__graph.gif" border="0" usemap="#aTpetra_1_1BlockVector_3_01Scalar_00_01LO_00_01GO_00_01Node_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aTpetra_1_1BlockVector_3_01Scalar_00_01LO_00_01GO_00_01Node_01_4_inherit__map" id="aTpetra_1_1BlockVector_3_01Scalar_00_01LO_00_01GO_00_01Node_01_4_inherit__map">
<area shape="rect" title="Vector for multiple degrees of freedom per mesh point." alt="" coords="1076,5,1263,45"/>
<area shape="rect" href="classTpetra_1_1BlockMultiVector.html" title="MultiVector for multiple degrees of freedom per mesh point." alt="" coords="840,5,1027,45"/>
<area shape="poly" title=" " alt="" coords="1041,23,1076,23,1076,28,1041,28"/>
<area shape="rect" href="classTpetra_1_1DistObject.html" title=" " alt="" coords="604,5,791,45"/>
<area shape="poly" title=" " alt="" coords="805,23,840,23,840,28,805,28"/>
<area shape="rect" href="classTpetra_1_1SrcDistObject.html" title="Abstract base class for objects that can be the source of an Import or Export operation." alt="" coords="5,21,165,46"/>
<area shape="poly" title=" " alt="" coords="179,26,215,24,397,15,580,16,604,17,603,22,580,21,397,21,215,29,179,31"/>
<area shape="rect" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution." alt="" coords="215,38,387,93"/>
<area shape="poly" title=" " alt="" coords="180,45,215,50,214,55,179,50"/>
<area shape="poly" title=" " alt="" coords="400,53,604,32,604,37,401,58"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Typedefs to facilitate template metaprogramming.</div></td></tr>
<tr class="memitem:a03f3b33e4f6aa99083b01f80ff360472" id="r_a03f3b33e4f6aa99083b01f80ff360472"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typedef</a> base_type::scalar_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#a03f3b33e4f6aa99083b01f80ff360472">scalar_type</a></td></tr>
<tr class="memdesc:a03f3b33e4f6aa99083b01f80ff360472"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of entries in the vector.  <br /></td></tr>
<tr class="separator:a03f3b33e4f6aa99083b01f80ff360472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29f4a163627d422d7c35deff10f95a5" id="r_ab29f4a163627d422d7c35deff10f95a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typedef</a> base_type::impl_scalar_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#ab29f4a163627d422d7c35deff10f95a5">impl_scalar_type</a></td></tr>
<tr class="memdesc:ab29f4a163627d422d7c35deff10f95a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation type of entries in the vector.  <br /></td></tr>
<tr class="separator:ab29f4a163627d422d7c35deff10f95a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b721b89e75eec2e42b80c8fb7d14947" id="r_a2b721b89e75eec2e42b80c8fb7d14947"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typedef</a> base_type::local_ordinal_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#a2b721b89e75eec2e42b80c8fb7d14947">local_ordinal_type</a></td></tr>
<tr class="memdesc:a2b721b89e75eec2e42b80c8fb7d14947"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of local indices.  <br /></td></tr>
<tr class="separator:a2b721b89e75eec2e42b80c8fb7d14947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e12e7df15f8361035a4b8328dd082d" id="r_af7e12e7df15f8361035a4b8328dd082d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typedef</a> base_type::global_ordinal_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#af7e12e7df15f8361035a4b8328dd082d">global_ordinal_type</a></td></tr>
<tr class="memdesc:af7e12e7df15f8361035a4b8328dd082d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of global indices.  <br /></td></tr>
<tr class="separator:af7e12e7df15f8361035a4b8328dd082d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc3e97c88345ba1df1a0704eae81fa5" id="r_a4fc3e97c88345ba1df1a0704eae81fa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typedef</a> base_type::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#a4fc3e97c88345ba1df1a0704eae81fa5">node_type</a></td></tr>
<tr class="memdesc:a4fc3e97c88345ba1df1a0704eae81fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Kokkos Node type.  <br /></td></tr>
<tr class="separator:a4fc3e97c88345ba1df1a0704eae81fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb1b2ab6ec5095f0b0293128d89a514" id="r_acfb1b2ab6ec5095f0b0293128d89a514"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typedef</a> Node::device_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#acfb1b2ab6ec5095f0b0293128d89a514">device_type</a></td></tr>
<tr class="memdesc:acfb1b2ab6ec5095f0b0293128d89a514"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Kokkos Device type.  <br /></td></tr>
<tr class="separator:acfb1b2ab6ec5095f0b0293128d89a514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4502b2eff5b736e714a37137f29a88ee" id="r_a4502b2eff5b736e714a37137f29a88ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typedef</a> <a class="el" href="classTpetra_1_1Map.html">Tpetra::Map</a>&lt; LO, GO, Node &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a></td></tr>
<tr class="memdesc:a4502b2eff5b736e714a37137f29a88ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialization of <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Tpetra::Map</a> that this class uses.  <br /></td></tr>
<tr class="separator:a4502b2eff5b736e714a37137f29a88ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362d442d5d154af1031b11170971a9df" id="r_a362d442d5d154af1031b11170971a9df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typedef</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#a362d442d5d154af1031b11170971a9df">mv_type</a></td></tr>
<tr class="memdesc:a362d442d5d154af1031b11170971a9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialization of <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">Tpetra::MultiVector</a> that this class uses.  <br /></td></tr>
<tr class="separator:a362d442d5d154af1031b11170971a9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73aaa521ab4dc2c734b0f14df57e366c" id="r_a73aaa521ab4dc2c734b0f14df57e366c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typedef</a> <a class="el" href="classTpetra_1_1Vector.html">Tpetra::Vector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#a73aaa521ab4dc2c734b0f14df57e366c">vec_type</a></td></tr>
<tr class="memdesc:a73aaa521ab4dc2c734b0f14df57e366c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialization of <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Tpetra::Vector</a> that this class uses.  <br /></td></tr>
<tr class="separator:a73aaa521ab4dc2c734b0f14df57e366c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2009c78127483c9546907e453aa406b7" id="r_a2009c78127483c9546907e453aa406b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typedef</a> base_type::little_vec_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#a2009c78127483c9546907e453aa406b7">little_vec_type</a></td></tr>
<tr class="memdesc:a2009c78127483c9546907e453aa406b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Block view" of all degrees of freedom at a mesh point.  <br /></td></tr>
<tr class="separator:a2009c78127483c9546907e453aa406b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976ed6ccb69cb6f398a185dabb5217e4" id="r_a976ed6ccb69cb6f398a185dabb5217e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typedef</a> base_type::const_little_vec_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#a976ed6ccb69cb6f398a185dabb5217e4">const_little_vec_type</a></td></tr>
<tr class="memdesc:a976ed6ccb69cb6f398a185dabb5217e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Const block view" of all degrees of freedom at a mesh point.  <br /></td></tr>
<tr class="separator:a976ed6ccb69cb6f398a185dabb5217e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Typedefs to facilitate template metaprogramming.</div></td></tr>
<tr class="memitem:a921098a19077b2db2ca3875e518970db" id="r_a921098a19077b2db2ca3875e518970db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> = <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1DistObject.html#a66edb1059ed7db04325605df64fe64c5">dist_object_type::buffer_device_type</a></td></tr>
<tr class="memdesc:a921098a19077b2db2ca3875e518970db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kokkos::Device specialization used for communication buffers.  <br /></td></tr>
<tr class="separator:a921098a19077b2db2ca3875e518970db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Typedefs</div></td></tr>
<tr class="memitem:a87c43585393cbe182ab96e31389e90fa" id="r_a87c43585393cbe182ab96e31389e90fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a87c43585393cbe182ab96e31389e90fa">execution_space</a> = <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> device_type::execution_space</td></tr>
<tr class="memdesc:a87c43585393cbe182ab96e31389e90fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Kokkos execution space.  <br /></td></tr>
<tr class="separator:a87c43585393cbe182ab96e31389e90fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a97c978bc34011a66288db198c03af359" id="r_a97c978bc34011a66288db198c03af359"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#a97c978bc34011a66288db198c03af359">BlockVector</a> ()</td></tr>
<tr class="memdesc:a97c978bc34011a66288db198c03af359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a97c978bc34011a66288db198c03af359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123d01f3ee00b6b3cec2194d2e5cfbfd" id="r_a123d01f3ee00b6b3cec2194d2e5cfbfd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#a123d01f3ee00b6b3cec2194d2e5cfbfd">BlockVector</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html">BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;)=<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">default</a></td></tr>
<tr class="memdesc:a123d01f3ee00b6b3cec2194d2e5cfbfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor (shallow copy).  <br /></td></tr>
<tr class="separator:a123d01f3ee00b6b3cec2194d2e5cfbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a58440e5370074719a7faf8b2c7dbb" id="r_ac5a58440e5370074719a7faf8b2c7dbb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#ac5a58440e5370074719a7faf8b2c7dbb">BlockVector</a> (<a class="el" href="classTpetra_1_1BlockVector.html">BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;&amp;)=<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">default</a></td></tr>
<tr class="memdesc:ac5a58440e5370074719a7faf8b2c7dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor (shallow move).  <br /></td></tr>
<tr class="separator:ac5a58440e5370074719a7faf8b2c7dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cbdbbef8dcc71a0e0d16b0fcd8f6f2" id="r_a71cbdbbef8dcc71a0e0d16b0fcd8f6f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1BlockVector.html">BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#a71cbdbbef8dcc71a0e0d16b0fcd8f6f2">operator=</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html">BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;)=<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">default</a></td></tr>
<tr class="memdesc:a71cbdbbef8dcc71a0e0d16b0fcd8f6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assigment (shallow copy).  <br /></td></tr>
<tr class="separator:a71cbdbbef8dcc71a0e0d16b0fcd8f6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a441a45e39366667a34cfa23a8c1045" id="r_a0a441a45e39366667a34cfa23a8c1045"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1BlockVector.html">BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#a0a441a45e39366667a34cfa23a8c1045">operator=</a> (<a class="el" href="classTpetra_1_1BlockVector.html">BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;&amp;)=<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">default</a></td></tr>
<tr class="memdesc:a0a441a45e39366667a34cfa23a8c1045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assigment (shallow move).  <br /></td></tr>
<tr class="separator:a0a441a45e39366667a34cfa23a8c1045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928a021197044be1de47d054ba1bac5a" id="r_a928a021197044be1de47d054ba1bac5a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#a928a021197044be1de47d054ba1bac5a">BlockVector</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html">BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">in</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::DataAccess <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">copyOrView</a>)</td></tr>
<tr class="memdesc:a928a021197044be1de47d054ba1bac5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Copy constructor" with option to deep copy.  <br /></td></tr>
<tr class="separator:a928a021197044be1de47d054ba1bac5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba08a0a983e84abc51b370426814e81d" id="r_aba08a0a983e84abc51b370426814e81d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#aba08a0a983e84abc51b370426814e81d">BlockVector</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">meshMap</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">blockSize</a>)</td></tr>
<tr class="memdesc:aba08a0a983e84abc51b370426814e81d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that takes a mesh <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> and a block size.  <br /></td></tr>
<tr class="separator:aba08a0a983e84abc51b370426814e81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18bf8ea97f942855d5b9d67b6ee864eb" id="r_a18bf8ea97f942855d5b9d67b6ee864eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#a18bf8ea97f942855d5b9d67b6ee864eb">BlockVector</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">meshMap</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">pointMap</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">blockSize</a>)</td></tr>
<tr class="memdesc:a18bf8ea97f942855d5b9d67b6ee864eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that takes a mesh <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>, a point <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>, and a block size.  <br /></td></tr>
<tr class="separator:a18bf8ea97f942855d5b9d67b6ee864eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4ba6e425c74c0a4f17a60a84b24ad5" id="r_a5b4ba6e425c74c0a4f17a60a84b24ad5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#a5b4ba6e425c74c0a4f17a60a84b24ad5">BlockVector</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a362d442d5d154af1031b11170971a9df">mv_type</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">X_mv</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">meshMap</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">blockSize</a>)</td></tr>
<tr class="memdesc:a5b4ba6e425c74c0a4f17a60a84b24ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">View an existing <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Vector</a> or <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>.  <br /></td></tr>
<tr class="separator:a5b4ba6e425c74c0a4f17a60a84b24ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90edebd73a467a8cf034c0bd7e3c6184" id="r_a90edebd73a467a8cf034c0bd7e3c6184"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#a90edebd73a467a8cf034c0bd7e3c6184">BlockVector</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a73aaa521ab4dc2c734b0f14df57e366c">vec_type</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">X_vec</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">meshMap</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">blockSize</a>)</td></tr>
<tr class="memdesc:a90edebd73a467a8cf034c0bd7e3c6184"><td class="mdescLeft">&#160;</td><td class="mdescRight">View an existing <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Vector</a>.  <br /></td></tr>
<tr class="separator:a90edebd73a467a8cf034c0bd7e3c6184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d44c9bc1e07e8b1bf6e376846d45fde" id="r_a4d44c9bc1e07e8b1bf6e376846d45fde"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#a4d44c9bc1e07e8b1bf6e376846d45fde">BlockVector</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html">BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">X</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">newMeshMap</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">newPointMap</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">offset</a>=0)</td></tr>
<tr class="memdesc:a4d44c9bc1e07e8b1bf6e376846d45fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">View an existing <a class="el" href="classTpetra_1_1BlockVector.html" title="Vector for multiple degrees of freedom per mesh point.">BlockVector</a> using a different mesh <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>, supplying the corresponding point <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>.  <br /></td></tr>
<tr class="separator:a4d44c9bc1e07e8b1bf6e376846d45fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d3561a244f861a581cb95052457ef6" id="r_a86d3561a244f861a581cb95052457ef6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#a86d3561a244f861a581cb95052457ef6">BlockVector</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html">BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">X</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">newMeshMap</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">offset</a>=0)</td></tr>
<tr class="memdesc:a86d3561a244f861a581cb95052457ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">View an existing <a class="el" href="classTpetra_1_1BlockVector.html" title="Vector for multiple degrees of freedom per mesh point.">BlockVector</a> using a different mesh <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>; compute the new point <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>.  <br /></td></tr>
<tr class="separator:a86d3561a244f861a581cb95052457ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to Maps, the block size, and a Vector view.</div></td></tr>
<tr class="memitem:a9d262edfcdb20fcc6d3b24015f139864" id="r_a9d262edfcdb20fcc6d3b24015f139864"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1BlockVector.html#a73aaa521ab4dc2c734b0f14df57e366c">vec_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#a9d262edfcdb20fcc6d3b24015f139864">getVectorView</a> ()</td></tr>
<tr class="memdesc:a9d262edfcdb20fcc6d3b24015f139864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Tpetra::Vector</a> that views this <a class="el" href="classTpetra_1_1BlockVector.html" title="Vector for multiple degrees of freedom per mesh point.">BlockVector</a>'s data.  <br /></td></tr>
<tr class="separator:a9d262edfcdb20fcc6d3b24015f139864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Fine-grained data access</div></td></tr>
<tr class="memitem:abe14ce0b7ad9da9b519555a7d20da3f0" id="r_abe14ce0b7ad9da9b519555a7d20da3f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#abe14ce0b7ad9da9b519555a7d20da3f0">replaceLocalValues</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">localRowIndex</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">vals</a>[])</td></tr>
<tr class="memdesc:abe14ce0b7ad9da9b519555a7d20da3f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all values at the given mesh point, using a local index.  <br /></td></tr>
<tr class="separator:abe14ce0b7ad9da9b519555a7d20da3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8494264fff86f447c22e4afd38ba9231" id="r_a8494264fff86f447c22e4afd38ba9231"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#a8494264fff86f447c22e4afd38ba9231">replaceGlobalValues</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> GO <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">globalRowIndex</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">vals</a>[])</td></tr>
<tr class="memdesc:a8494264fff86f447c22e4afd38ba9231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all values at the given mesh point, using a global index.  <br /></td></tr>
<tr class="separator:a8494264fff86f447c22e4afd38ba9231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c197c3684b5365ec7bf12b16c1e72ce" id="r_a9c197c3684b5365ec7bf12b16c1e72ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#a9c197c3684b5365ec7bf12b16c1e72ce">sumIntoLocalValues</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">localRowIndex</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">vals</a>[])</td></tr>
<tr class="memdesc:a9c197c3684b5365ec7bf12b16c1e72ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum into all values at the given mesh point, using a local index.  <br /></td></tr>
<tr class="separator:a9c197c3684b5365ec7bf12b16c1e72ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf3a3e711079d6d8f3753f5175d4e4c" id="r_a6bf3a3e711079d6d8f3753f5175d4e4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#a6bf3a3e711079d6d8f3753f5175d4e4c">sumIntoGlobalValues</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> GO <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">globalRowIndex</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">vals</a>[])</td></tr>
<tr class="memdesc:a6bf3a3e711079d6d8f3753f5175d4e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum into all values at the given mesh point, using a global index.  <br /></td></tr>
<tr class="separator:a6bf3a3e711079d6d8f3753f5175d4e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02efcd17ed84c25685f36d7efbf54b3e" id="r_a02efcd17ed84c25685f36d7efbf54b3e"><td class="memItemLeft" align="right" valign="top">const_little_host_vec_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockVector.html#a02efcd17ed84c25685f36d7efbf54b3e">getLocalBlockHost</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">localRowIndex</a>, Access::ReadOnlyStruct) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a02efcd17ed84c25685f36d7efbf54b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a view of the degrees of freedom at the given mesh point, using a local index.  <br /></td></tr>
<tr class="separator:a02efcd17ed84c25685f36d7efbf54b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Coarse-grained operations</div></td></tr>
<tr class="memitem:a028794981fd49adcea2e08e09a91ad35" id="r_a028794981fd49adcea2e08e09a91ad35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#a028794981fd49adcea2e08e09a91ad35">putScalar</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">val</a>)</td></tr>
<tr class="memdesc:a028794981fd49adcea2e08e09a91ad35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill all entries with the given value <code>val</code>.  <br /></td></tr>
<tr class="separator:a028794981fd49adcea2e08e09a91ad35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb56c1f0f259ec405d035999a6806b7a" id="r_abb56c1f0f259ec405d035999a6806b7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#abb56c1f0f259ec405d035999a6806b7a">scale</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">val</a>)</td></tr>
<tr class="memdesc:abb56c1f0f259ec405d035999a6806b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply all entries in place by the given value <code>val</code>.  <br /></td></tr>
<tr class="separator:abb56c1f0f259ec405d035999a6806b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598f61c29431518392a8aa0d353b2948" id="r_a598f61c29431518392a8aa0d353b2948"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#a598f61c29431518392a8aa0d353b2948">update</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">alpha</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">X</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">beta</a>)</td></tr>
<tr class="memdesc:a598f61c29431518392a8aa0d353b2948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update: <code>this = beta*this + alpha*X</code>.  <br /></td></tr>
<tr class="separator:a598f61c29431518392a8aa0d353b2948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1253543f32f38be28efa5dcd30811eab" id="r_a1253543f32f38be28efa5dcd30811eab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#a1253543f32f38be28efa5dcd30811eab">blockWiseMultiply</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">alpha</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::View&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#ab29f4a163627d422d7c35deff10f95a5">impl_scalar_type</a> ***, <a class="el" href="classTpetra_1_1BlockVector.html#acfb1b2ab6ec5095f0b0293128d89a514">device_type</a>, Kokkos::MemoryUnmanaged &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">D</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">X</a>)</td></tr>
<tr class="memdesc:a1253543f32f38be28efa5dcd30811eab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>*this := alpha * D * X</code>, where D is a block diagonal matrix.  <br /></td></tr>
<tr class="separator:a1253543f32f38be28efa5dcd30811eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323dd6fa9758b30950c1bf37a7a7488f" id="r_a323dd6fa9758b30950c1bf37a7a7488f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#a323dd6fa9758b30950c1bf37a7a7488f">blockJacobiUpdate</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">alpha</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::View&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#ab29f4a163627d422d7c35deff10f95a5">impl_scalar_type</a> ***, <a class="el" href="classTpetra_1_1BlockVector.html#acfb1b2ab6ec5095f0b0293128d89a514">device_type</a>, Kokkos::MemoryUnmanaged &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">D</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">X</a>, <a class="el" href="classTpetra_1_1BlockMultiVector.html">BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Z</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">beta</a>)</td></tr>
<tr class="memdesc:a323dd6fa9758b30950c1bf37a7a7488f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block Jacobi update <picture><source srcset="form_7_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$Y = \beta * Y + \alpha D (X - Z)$" src="form_7.png" width="136" height="14"/></picture>.  <br /></td></tr>
<tr class="separator:a323dd6fa9758b30950c1bf37a7a7488f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a582c41c3cd80e3e102376cf480fb2f" id="r_a1a582c41c3cd80e3e102376cf480fb2f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">TargetMemorySpace</a> &gt; </td></tr>
<tr class="memitem:a1a582c41c3cd80e3e102376cf480fb2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#a1a582c41c3cd80e3e102376cf480fb2f">need_sync</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a1a582c41c3cd80e3e102376cf480fb2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this object needs synchronization to the given memory space.  <br /></td></tr>
<tr class="separator:a1a582c41c3cd80e3e102376cf480fb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157d5fdfe37972f6685251900cd15b97" id="r_a157d5fdfe37972f6685251900cd15b97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#a157d5fdfe37972f6685251900cd15b97">need_sync_host</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a157d5fdfe37972f6685251900cd15b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this object needs synchronization to the host.  <br /></td></tr>
<tr class="separator:a157d5fdfe37972f6685251900cd15b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5aba5182202d23907454f4d9d9dcaad" id="r_ad5aba5182202d23907454f4d9d9dcaad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#ad5aba5182202d23907454f4d9d9dcaad">need_sync_device</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:ad5aba5182202d23907454f4d9d9dcaad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this object needs synchronization to the device.  <br /></td></tr>
<tr class="separator:ad5aba5182202d23907454f4d9d9dcaad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Fine-grained data access</div></td></tr>
<tr class="memitem:a8cf24c0f15b9eb358ac4b9f57fc8194d" id="r_a8cf24c0f15b9eb358ac4b9f57fc8194d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#a8cf24c0f15b9eb358ac4b9f57fc8194d">replaceLocalValues</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">localRowIndex</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">colIndex</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">vals</a>[])</td></tr>
<tr class="memdesc:a8cf24c0f15b9eb358ac4b9f57fc8194d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all values at the given mesh point, using local row and column indices.  <br /></td></tr>
<tr class="separator:a8cf24c0f15b9eb358ac4b9f57fc8194d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade05bfc9d18496bc20161b4491436e99" id="r_ade05bfc9d18496bc20161b4491436e99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#ade05bfc9d18496bc20161b4491436e99">replaceGlobalValues</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> GO <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">globalRowIndex</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">colIndex</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">vals</a>[])</td></tr>
<tr class="memdesc:ade05bfc9d18496bc20161b4491436e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all values at the given mesh point, using a global index.  <br /></td></tr>
<tr class="separator:ade05bfc9d18496bc20161b4491436e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c3cd4540b728c0ac3ff6f3bcea939e" id="r_a16c3cd4540b728c0ac3ff6f3bcea939e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#a16c3cd4540b728c0ac3ff6f3bcea939e">sumIntoLocalValues</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">localRowIndex</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">colIndex</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">vals</a>[])</td></tr>
<tr class="memdesc:a16c3cd4540b728c0ac3ff6f3bcea939e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum into all values at the given mesh point, using a local index.  <br /></td></tr>
<tr class="separator:a16c3cd4540b728c0ac3ff6f3bcea939e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654737881bbaf3611d8612a34c6e40dd" id="r_a654737881bbaf3611d8612a34c6e40dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#a654737881bbaf3611d8612a34c6e40dd">sumIntoGlobalValues</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> GO <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">globalRowIndex</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">colIndex</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">vals</a>[])</td></tr>
<tr class="memdesc:a654737881bbaf3611d8612a34c6e40dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum into all values at the given mesh point, using a global index.  <br /></td></tr>
<tr class="separator:a654737881bbaf3611d8612a34c6e40dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547175181014da27dc0e03a880acbbb4" id="r_a547175181014da27dc0e03a880acbbb4"><td class="memItemLeft" align="right" valign="top">little_host_vec_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#a547175181014da27dc0e03a880acbbb4">getLocalBlockHost</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">localRowIndex</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">colIndex</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Access::OverwriteAllStruct)</td></tr>
<tr class="memdesc:a547175181014da27dc0e03a880acbbb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a local block on host, with the intent to overwrite all blocks in the <a class="el" href="classTpetra_1_1BlockMultiVector.html" title="MultiVector for multiple degrees of freedom per mesh point.">BlockMultiVector</a> before accessing the data on device. If you intend to modify only some blocks on host, use Access::ReadWrite instead (otherwise, previous changes on device may be lost)  <br /></td></tr>
<tr class="separator:a547175181014da27dc0e03a880acbbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public methods for redistributing data</div></td></tr>
<tr class="memitem:a2e2cce34ee9698060f87e1fad3695a2d" id="r_a2e2cce34ee9698060f87e1fad3695a2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a2e2cce34ee9698060f87e1fad3695a2d">doImport</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">source</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Import.html">Import</a>&lt; LO, GO, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">importer</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">CM</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">restrictedMode</a>=<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">false</a>)</td></tr>
<tr class="memdesc:a2e2cce34ee9698060f87e1fad3695a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> data into this object using an <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> object ("forward mode").  <br /></td></tr>
<tr class="separator:a2e2cce34ee9698060f87e1fad3695a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbd89e8cf8df8d477f2c541db4d3215" id="r_a0cbd89e8cf8df8d477f2c541db4d3215"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a0cbd89e8cf8df8d477f2c541db4d3215">doImport</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">source</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Export.html">Export</a>&lt; LO, GO, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">exporter</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">CM</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">restrictedMode</a>=<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">false</a>)</td></tr>
<tr class="memdesc:a0cbd89e8cf8df8d477f2c541db4d3215"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> data into this object using an <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> object ("reverse mode").  <br /></td></tr>
<tr class="separator:a0cbd89e8cf8df8d477f2c541db4d3215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2623c99b47ce9d88692abdc094d8be6" id="r_ad2623c99b47ce9d88692abdc094d8be6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#ad2623c99b47ce9d88692abdc094d8be6">doExport</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">source</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Export.html">Export</a>&lt; LO, GO, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">exporter</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">CM</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">restrictedMode</a>=<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">false</a>)</td></tr>
<tr class="memdesc:ad2623c99b47ce9d88692abdc094d8be6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> data into this object using an <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> object ("forward mode").  <br /></td></tr>
<tr class="separator:ad2623c99b47ce9d88692abdc094d8be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b766629940d0400aa98e113b4e5ef3c" id="r_a5b766629940d0400aa98e113b4e5ef3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a5b766629940d0400aa98e113b4e5ef3c">doExport</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">source</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Import.html">Import</a>&lt; LO, GO, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">importer</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">CM</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">restrictedMode</a>=<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">false</a>)</td></tr>
<tr class="memdesc:a5b766629940d0400aa98e113b4e5ef3c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> data into this object using an <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> object ("reverse mode").  <br /></td></tr>
<tr class="separator:a5b766629940d0400aa98e113b4e5ef3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ad53419477919faf1acdcfc4d65daa" id="r_a47ad53419477919faf1acdcfc4d65daa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a47ad53419477919faf1acdcfc4d65daa">transferArrived</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a47ad53419477919faf1acdcfc4d65daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the data from an import/export operation has arrived, and is ready for the unpack and combine step.  <br /></td></tr>
<tr class="separator:a47ad53419477919faf1acdcfc4d65daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Attribute accessor methods</div></td></tr>
<tr class="memitem:afc178c45d66d8232f27b1e79fc0e1535" id="r_afc178c45d66d8232f27b1e79fc0e1535"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#afc178c45d66d8232f27b1e79fc0e1535">isDistributed</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:afc178c45d66d8232f27b1e79fc0e1535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this is a globally distributed object.  <br /></td></tr>
<tr class="separator:afc178c45d66d8232f27b1e79fc0e1535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef545d3737b47c030e0e6a3e7d8b1e7" id="r_adef545d3737b47c030e0e6a3e7d8b1e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#adef545d3737b47c030e0e6a3e7d8b1e7">getMap</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:adef545d3737b47c030e0e6a3e7d8b1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> describing the parallel distribution of this object.  <br /></td></tr>
<tr class="separator:adef545d3737b47c030e0e6a3e7d8b1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">I/O methods</div></td></tr>
<tr class="memitem:a8f39be1272b2b218c6b734d30fdb7956" id="r_a8f39be1272b2b218c6b734d30fdb7956"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a8f39be1272b2b218c6b734d30fdb7956">print</a> (std::ostream &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">os</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a8f39be1272b2b218c6b734d30fdb7956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print this object to the given output stream.  <br /></td></tr>
<tr class="separator:a8f39be1272b2b218c6b734d30fdb7956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implementation of Teuchos::Describable</div></td></tr>
<tr class="memitem:adeca5fe82d6ff5af11d1fcb78753c1ef" id="r_adeca5fe82d6ff5af11d1fcb78753c1ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#adeca5fe82d6ff5af11d1fcb78753c1ef">description</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:adeca5fe82d6ff5af11d1fcb78753c1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">One-line descriptiion of this object.  <br /></td></tr>
<tr class="separator:adeca5fe82d6ff5af11d1fcb78753c1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ae001a87e9a244a334891d33de8fc7" id="r_a05ae001a87e9a244a334891d33de8fc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a05ae001a87e9a244a334891d33de8fc7">describe</a> (Teuchos::FancyOStream &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">out</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::EVerbosityLevel <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">verbLevel</a>=Teuchos::Describable::verbLevel_default) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a05ae001a87e9a244a334891d33de8fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a descriptiion of this object to the given output stream.  <br /></td></tr>
<tr class="separator:a05ae001a87e9a244a334891d33de8fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Access to Maps, the block size, and a MultiVector view.</h2></td></tr>
<tr class="memitem:a7a77cb04963c6993696f53976b1557e5" id="r_a7a77cb04963c6993696f53976b1557e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#a7a77cb04963c6993696f53976b1557e5">getPointMap</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a7a77cb04963c6993696f53976b1557e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get this <a class="el" href="classTpetra_1_1BlockMultiVector.html" title="MultiVector for multiple degrees of freedom per mesh point.">BlockMultiVector</a>'s (previously computed) point <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>.  <br /></td></tr>
<tr class="separator:a7a77cb04963c6993696f53976b1557e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d93cbe2fb39fabb12fd283ee3e0a49" id="r_ad3d93cbe2fb39fabb12fd283ee3e0a49"><td class="memItemLeft" align="right" valign="top">LO&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#ad3d93cbe2fb39fabb12fd283ee3e0a49">getBlockSize</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:ad3d93cbe2fb39fabb12fd283ee3e0a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of degrees of freedom per mesh point.  <br /></td></tr>
<tr class="separator:ad3d93cbe2fb39fabb12fd283ee3e0a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fbb09c25de6da9fc4935a8e08bcfca" id="r_a93fbb09c25de6da9fc4935a8e08bcfca"><td class="memItemLeft" align="right" valign="top">LO&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#a93fbb09c25de6da9fc4935a8e08bcfca">getNumVectors</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a93fbb09c25de6da9fc4935a8e08bcfca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of columns (vectors) in the <a class="el" href="classTpetra_1_1BlockMultiVector.html" title="MultiVector for multiple degrees of freedom per mesh point.">BlockMultiVector</a>.  <br /></td></tr>
<tr class="separator:a93fbb09c25de6da9fc4935a8e08bcfca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f4ed666e210725e9d93d93a01e5e38" id="r_a09f4ed666e210725e9d93d93a01e5e38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a362d442d5d154af1031b11170971a9df">mv_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#a09f4ed666e210725e9d93d93a01e5e38">getMultiVectorView</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a09f4ed666e210725e9d93d93a01e5e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">Tpetra::MultiVector</a> that views this <a class="el" href="classTpetra_1_1BlockMultiVector.html" title="MultiVector for multiple degrees of freedom per mesh point.">BlockMultiVector</a>'s data.  <br /></td></tr>
<tr class="separator:a09f4ed666e210725e9d93d93a01e5e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919acd412412e81ffb3c242a1ba388c2" id="r_a919acd412412e81ffb3c242a1ba388c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">static</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#a919acd412412e81ffb3c242a1ba388c2">makePointMap</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">meshMap</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">blockSize</a>)</td></tr>
<tr class="memdesc:a919acd412412e81ffb3c242a1ba388c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return the point <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> corresponding to the given mesh <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> and block size.  <br /></td></tr>
<tr class="separator:a919acd412412e81ffb3c242a1ba388c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca238134ffd65fb487aa970ce0d773a" id="r_a1ca238134ffd65fb487aa970ce0d773a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">static</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#a1ca238134ffd65fb487aa970ce0d773a">makePointMapRCP</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">meshMap</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">blockSize</a>)</td></tr>
<tr class="memdesc:a1ca238134ffd65fb487aa970ce0d773a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return an owning RCP to the point <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> corresponding to the given mesh <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> and block size.  <br /></td></tr>
<tr class="separator:a1ca238134ffd65fb487aa970ce0d773a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Methods for use only by experts</h2></td></tr>
<tr class="memitem:aead0431a5e0fcdcb0b2147f8351b7792" id="r_aead0431a5e0fcdcb0b2147f8351b7792"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#aead0431a5e0fcdcb0b2147f8351b7792">removeEmptyProcessesInPlace</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">newMap</a>)</td></tr>
<tr class="memdesc:aead0431a5e0fcdcb0b2147f8351b7792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove processes which contain no entries in this object's <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>.  <br /></td></tr>
<tr class="separator:aead0431a5e0fcdcb0b2147f8351b7792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad126b78ec8e6971e3e219629691c95c8" id="r_ad126b78ec8e6971e3e219629691c95c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#ad126b78ec8e6971e3e219629691c95c8">constantNumberOfPackets</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:ad126b78ec8e6971e3e219629691c95c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the implementation's instance promises always to have a constant number of packets per LID (local index), and if so, how many packets per LID there are.  <br /></td></tr>
<tr class="separator:ad126b78ec8e6971e3e219629691c95c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a9a5fd0df1dda55188a340e6b5a2e7" id="r_a82a9a5fd0df1dda55188a340e6b5a2e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a82a9a5fd0df1dda55188a340e6b5a2e7">doTransfer</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;src, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Details_1_1Transfer.html">::Tpetra::Details::Transfer</a>&lt; <a class="el" href="classTpetra_1_1BlockVector.html#a2b721b89e75eec2e42b80c8fb7d14947">local_ordinal_type</a>, <a class="el" href="classTpetra_1_1BlockVector.html#af7e12e7df15f8361035a4b8328dd082d">global_ordinal_type</a>, <a class="el" href="classTpetra_1_1BlockVector.html#a4fc3e97c88345ba1df1a0704eae81fa5">node_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">transfer</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">char</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">modeString</a>[], <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1DistObject.html#ac1ff98c164c772986e2a5db411a311ab">ReverseOption</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">revOp</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">CM</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">restrictedMode</a>)</td></tr>
<tr class="memdesc:a82a9a5fd0df1dda55188a340e6b5a2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redistribute data across (MPI) processes.  <br /></td></tr>
<tr class="separator:a82a9a5fd0df1dda55188a340e6b5a2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20429024546804acef2060050d1b22f8" id="r_a20429024546804acef2060050d1b22f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a20429024546804acef2060050d1b22f8">reallocArraysForNumPacketsPerLid</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">numExportLIDs</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">numImportLIDs</a>)</td></tr>
<tr class="memdesc:a20429024546804acef2060050d1b22f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate numExportPacketsPerLID_ and/or numImportPacketsPerLID_, if necessary.  <br /></td></tr>
<tr class="separator:a20429024546804acef2060050d1b22f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a2256ab638b7f329b752535553f480" id="r_a30a2256ab638b7f329b752535553f480"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a30a2256ab638b7f329b752535553f480">beginTransfer</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;src, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Details_1_1Transfer.html">::Tpetra::Details::Transfer</a>&lt; <a class="el" href="classTpetra_1_1BlockVector.html#a2b721b89e75eec2e42b80c8fb7d14947">local_ordinal_type</a>, <a class="el" href="classTpetra_1_1BlockVector.html#af7e12e7df15f8361035a4b8328dd082d">global_ordinal_type</a>, <a class="el" href="classTpetra_1_1BlockVector.html#a4fc3e97c88345ba1df1a0704eae81fa5">node_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">transfer</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">char</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">modeString</a>[], <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1DistObject.html#ac1ff98c164c772986e2a5db411a311ab">ReverseOption</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">revOp</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">CM</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">restrictedMode</a>)</td></tr>
<tr class="memdesc:a30a2256ab638b7f329b752535553f480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation detail of doTransfer.  <br /></td></tr>
<tr class="separator:a30a2256ab638b7f329b752535553f480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ff98c164c772986e2a5db411a311ab" id="r_ac1ff98c164c772986e2a5db411a311ab"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#ac1ff98c164c772986e2a5db411a311ab">ReverseOption</a> </td></tr>
<tr class="memdesc:ac1ff98c164c772986e2a5db411a311ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the data transfer should be performed in forward or reverse mode.  <a href="classTpetra_1_1DistObject.html#ac1ff98c164c772986e2a5db411a311ab">More...</a><br /></td></tr>
<tr class="separator:ac1ff98c164c772986e2a5db411a311ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142f6b49db9d7bc4cb94e8488f89309c" id="r_a142f6b49db9d7bc4cb94e8488f89309c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a142f6b49db9d7bc4cb94e8488f89309c">buffer_memory_space</a> = ::Tpetra::Details::DefaultTypes::comm_buffer_memory_space&lt; <a class="el" href="classTpetra_1_1BlockVector.html#acfb1b2ab6ec5095f0b0293128d89a514">device_type</a> &gt;</td></tr>
<tr class="memdesc:a142f6b49db9d7bc4cb94e8488f89309c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kokkos memory space for communication buffers.  <br /></td></tr>
<tr class="separator:a142f6b49db9d7bc4cb94e8488f89309c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Implementation of Tpetra::DistObject.</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The methods here implement <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">Tpetra::DistObject</a>. They let <a class="el" href="classTpetra_1_1BlockMultiVector.html" title="MultiVector for multiple degrees of freedom per mesh point.">BlockMultiVector</a> participate in <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> and <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> operations. Users don't have to worry about these methods. </p>
</td></tr>
<tr class="memitem:a2b1ee94e60143c3dea8a7041c17cbcd5" id="r_a2b1ee94e60143c3dea8a7041c17cbcd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#a2b1ee94e60143c3dea8a7041c17cbcd5">meshMap_</a></td></tr>
<tr class="memdesc:a2b1ee94e60143c3dea8a7041c17cbcd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mesh <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> given to constructor.  <br /></td></tr>
<tr class="separator:a2b1ee94e60143c3dea8a7041c17cbcd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe41a8231bf0769f4724d1f7f9b6dc58" id="r_afe41a8231bf0769f4724d1f7f9b6dc58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1BlockVector.html#a362d442d5d154af1031b11170971a9df">mv_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#afe41a8231bf0769f4724d1f7f9b6dc58">mv_</a></td></tr>
<tr class="memdesc:afe41a8231bf0769f4724d1f7f9b6dc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">Tpetra::MultiVector</a> used to represent the data.  <br /></td></tr>
<tr class="separator:afe41a8231bf0769f4724d1f7f9b6dc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008b29f4b5afe674c58ff46a5c8ca0b7" id="r_a008b29f4b5afe674c58ff46a5c8ca0b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#a008b29f4b5afe674c58ff46a5c8ca0b7">checkSizes</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">Tpetra::SrcDistObject</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">source</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">override</a></td></tr>
<tr class="memdesc:a008b29f4b5afe674c58ff46a5c8ca0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the source and target (<em>this</em>) objects for compatibility.  <br /></td></tr>
<tr class="separator:a008b29f4b5afe674c58ff46a5c8ca0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac66b029f330696c2c0e9d5ae999d0ca" id="r_aac66b029f330696c2c0e9d5ae999d0ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#aac66b029f330696c2c0e9d5ae999d0ca">copyAndPermute</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">source</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> numSameIDs, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a2b721b89e75eec2e42b80c8fb7d14947">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">permuteToLIDs</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a2b721b89e75eec2e42b80c8fb7d14947">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">permuteFromLIDs</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">CM</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">override</a></td></tr>
<tr class="separator:aac66b029f330696c2c0e9d5ae999d0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ee2f568f2d24bbf1b10d6b3db65043" id="r_ab1ee2f568f2d24bbf1b10d6b3db65043"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#ab1ee2f568f2d24bbf1b10d6b3db65043">packAndPrepare</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">source</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a2b721b89e75eec2e42b80c8fb7d14947">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">exportLIDs</a>, Kokkos::DualView&lt; packet_type *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; &amp;exports, Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">numPacketsPerLID</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">constantNumPackets</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">override</a></td></tr>
<tr class="separator:ab1ee2f568f2d24bbf1b10d6b3db65043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf10ddd3bae75a3fa36d0d99fcaa245e" id="r_acf10ddd3bae75a3fa36d0d99fcaa245e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#acf10ddd3bae75a3fa36d0d99fcaa245e">unpackAndCombine</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a2b721b89e75eec2e42b80c8fb7d14947">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">importLIDs</a>, Kokkos::DualView&lt; packet_type *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; imports, Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">numPacketsPerLID</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">constantNumPackets</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">combineMode</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">override</a></td></tr>
<tr class="separator:acf10ddd3bae75a3fa36d0d99fcaa245e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89a38befd2575fc02a5cfe09181ca02" id="r_ab89a38befd2575fc02a5cfe09181ca02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#ab89a38befd2575fc02a5cfe09181ca02">getStrideX</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:ab89a38befd2575fc02a5cfe09181ca02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stride between consecutive local entries in the same column.  <br /></td></tr>
<tr class="separator:ab89a38befd2575fc02a5cfe09181ca02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7f05ce972bc3ef2017cd2fc9c6382e" id="r_ade7f05ce972bc3ef2017cd2fc9c6382e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#ade7f05ce972bc3ef2017cd2fc9c6382e">getStrideY</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:ade7f05ce972bc3ef2017cd2fc9c6382e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stride between consecutive local entries in the same row.  <br /></td></tr>
<tr class="separator:ade7f05ce972bc3ef2017cd2fc9c6382e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1fe21a288215100555aa30c730ee529" id="r_ae1fe21a288215100555aa30c730ee529"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1BlockMultiVector.html#ae1fe21a288215100555aa30c730ee529">isValidLocalMeshIndex</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">meshLocalIndex</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:ae1fe21a288215100555aa30c730ee529"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if and only if <code>meshLocalIndex</code> is a valid local index in the mesh <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>.  <br /></td></tr>
<tr class="separator:ae1fe21a288215100555aa30c730ee529"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Methods implemented by subclasses and used by doTransfer().</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The <a class="el" href="classTpetra_1_1DistObject.html#a82a9a5fd0df1dda55188a340e6b5a2e7" title="Redistribute data across (MPI) processes.">doTransfer()</a> method uses the subclass' implementations of these methods to implement data transfer. Subclasses of <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> must implement these methods. This is an instance of the <a href="http://en.wikipedia.org/wiki/Template_method_pattern">Template Method Pattern</a>. ("Template" here doesn't mean "C++
template"; it means "pattern with holes that are filled in by
the subclass' method implementations.") </p>
</td></tr>
<tr class="memitem:abd8bf976983da5f805c0d7975dfe45dc" id="r_abd8bf976983da5f805c0d7975dfe45dc"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#abd8bf976983da5f805c0d7975dfe45dc">map_</a></td></tr>
<tr class="memdesc:abd8bf976983da5f805c0d7975dfe45dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> over which this object is distributed.  <br /></td></tr>
<tr class="separator:abd8bf976983da5f805c0d7975dfe45dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e625c329325c60064dc133de40aed3b" id="r_a1e625c329325c60064dc133de40aed3b"><td class="memItemLeft" align="right" valign="top">Kokkos::DualView&lt; packet_type *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a1e625c329325c60064dc133de40aed3b">imports_</a></td></tr>
<tr class="memdesc:a1e625c329325c60064dc133de40aed3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer into which packed data are imported (received from other processes).  <br /></td></tr>
<tr class="separator:a1e625c329325c60064dc133de40aed3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1711cc6d0ea3921bd58fa27ba4a4dff8" id="r_a1711cc6d0ea3921bd58fa27ba4a4dff8"><td class="memItemLeft" align="right" valign="top">Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a1711cc6d0ea3921bd58fa27ba4a4dff8">numImportPacketsPerLID_</a></td></tr>
<tr class="memdesc:a1711cc6d0ea3921bd58fa27ba4a4dff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of packets to receive for each receive operation.  <br /></td></tr>
<tr class="separator:a1711cc6d0ea3921bd58fa27ba4a4dff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5ef8b469cce85d13924f7e65318e06" id="r_a1a5ef8b469cce85d13924f7e65318e06"><td class="memItemLeft" align="right" valign="top">Kokkos::DualView&lt; packet_type *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a1a5ef8b469cce85d13924f7e65318e06">exports_</a></td></tr>
<tr class="memdesc:a1a5ef8b469cce85d13924f7e65318e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer from which packed data are exported (sent to other processes).  <br /></td></tr>
<tr class="separator:a1a5ef8b469cce85d13924f7e65318e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b397a38b1966ac9833d8990e3cae211" id="r_a9b397a38b1966ac9833d8990e3cae211"><td class="memItemLeft" align="right" valign="top">Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a9b397a38b1966ac9833d8990e3cae211">numExportPacketsPerLID_</a></td></tr>
<tr class="memdesc:a9b397a38b1966ac9833d8990e3cae211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of packets to send for each send operation.  <br /></td></tr>
<tr class="separator:a9b397a38b1966ac9833d8990e3cae211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc82b9b77aec9c2eae61417374895ab5" id="r_abc82b9b77aec9c2eae61417374895ab5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#abc82b9b77aec9c2eae61417374895ab5">copyAndPermute</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">source</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> numSameIDs, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a2b721b89e75eec2e42b80c8fb7d14947">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">permuteToLIDs</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a2b721b89e75eec2e42b80c8fb7d14947">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">permuteFromLIDs</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">CM</a>)</td></tr>
<tr class="memdesc:abc82b9b77aec9c2eae61417374895ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform copies and permutations that are local to the calling (MPI) process.  <br /></td></tr>
<tr class="separator:abc82b9b77aec9c2eae61417374895ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454c858836519e8d35e7a3bc928327ed" id="r_a454c858836519e8d35e7a3bc928327ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a454c858836519e8d35e7a3bc928327ed">copyAndPermute</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">source</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> numSameIDs, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a2b721b89e75eec2e42b80c8fb7d14947">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">permuteToLIDs</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a2b721b89e75eec2e42b80c8fb7d14947">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">permuteFromLIDs</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">CM</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1DistObject.html#a87c43585393cbe182ab96e31389e90fa">execution_space</a> &amp;space)</td></tr>
<tr class="memdesc:a454c858836519e8d35e7a3bc928327ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as copyAndPermute, but do operations in <code>space</code>.  <br /></td></tr>
<tr class="separator:a454c858836519e8d35e7a3bc928327ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484241212e4d1ca7c2669a6729b57801" id="r_a484241212e4d1ca7c2669a6729b57801"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a484241212e4d1ca7c2669a6729b57801">packAndPrepare</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">source</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a2b721b89e75eec2e42b80c8fb7d14947">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">exportLIDs</a>, Kokkos::DualView&lt; packet_type *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; &amp;exports, Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">numPacketsPerLID</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">constantNumPackets</a>)</td></tr>
<tr class="memdesc:a484241212e4d1ca7c2669a6729b57801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack data and metadata for communication (sends).  <br /></td></tr>
<tr class="separator:a484241212e4d1ca7c2669a6729b57801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fead8f57b7d0157e507847f3f04f1e" id="r_af3fead8f57b7d0157e507847f3f04f1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#af3fead8f57b7d0157e507847f3f04f1e">packAndPrepare</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">source</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a2b721b89e75eec2e42b80c8fb7d14947">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">exportLIDs</a>, Kokkos::DualView&lt; packet_type *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; &amp;exports, Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">numPacketsPerLID</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">constantNumPackets</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1DistObject.html#a87c43585393cbe182ab96e31389e90fa">execution_space</a> &amp;space)</td></tr>
<tr class="memdesc:af3fead8f57b7d0157e507847f3f04f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as packAndPrepare, but in an execution space instance.  <br /></td></tr>
<tr class="separator:af3fead8f57b7d0157e507847f3f04f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb9c5a5d2e5532768bb494a583d2ab0" id="r_a9cb9c5a5d2e5532768bb494a583d2ab0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a9cb9c5a5d2e5532768bb494a583d2ab0">unpackAndCombine</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a2b721b89e75eec2e42b80c8fb7d14947">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">importLIDs</a>, Kokkos::DualView&lt; packet_type *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; imports, Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">numPacketsPerLID</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">constantNumPackets</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">combineMode</a>)</td></tr>
<tr class="memdesc:a9cb9c5a5d2e5532768bb494a583d2ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any unpacking and combining after communication.  <br /></td></tr>
<tr class="separator:a9cb9c5a5d2e5532768bb494a583d2ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065de0c79a89661fe820856212ad776f" id="r_a065de0c79a89661fe820856212ad776f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a065de0c79a89661fe820856212ad776f">reallocImportsIfNeeded</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">newSize</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> verbose, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> std::string *<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">prefix</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">remoteLIDsContiguous</a>=<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">false</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">CM</a>=<a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094ba8311a4172e79c1f3a25a4ffc2e637b28">INSERT</a>)</td></tr>
<tr class="memdesc:a065de0c79a89661fe820856212ad776f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate imports_ if needed.  <br /></td></tr>
<tr class="separator:a065de0c79a89661fe820856212ad776f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node&gt;<br />
class Tpetra::BlockVector&lt; Scalar, LO, GO, Node &gt;</div><p><a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Vector</a> for multiple degrees of freedom per mesh point. </p>
<dl class="section author"><dt>Author</dt><dd>Mark Hoemmen</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The type of each entry of the block vector. (You can use real-valued or complex-valued types here, unlike in Epetra, where the scalar type is always <code>double</code>.) </td></tr>
    <tr><td class="paramname">LO</td><td>The type of local indices. See the documentation of the first template parameter of <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> for requirements. </td></tr>
    <tr><td class="paramname">GO</td><td>The type of global indices. See the documentation of the second template parameter of <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> for requirements. </td></tr>
    <tr><td class="paramname">Node</td><td>The Kokkos Node type. See the documentation of the third template parameter of <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> for requirements.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="classTpetra_1_1BlockVector.html" title="Vector for multiple degrees of freedom per mesh point.">BlockVector</a> is like <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">Tpetra::MultiVector</a>, but its interface supports multiple degrees of freedom per mesh point. You can specify a mesh point by its local or global index, and read or write the values at that point. Every mesh point must have the same number of degrees of freedom. We call the number of degrees of freedom per mesh point the <em>block size</em>.</p>
<p><a class="el" href="classTpetra_1_1BlockVector.html" title="Vector for multiple degrees of freedom per mesh point.">BlockVector</a> is a special case of <a class="el" href="classTpetra_1_1BlockMultiVector.html" title="MultiVector for multiple degrees of freedom per mesh point.">BlockMultiVector</a>, for "multivectors" that are not "multi." That is, a <a class="el" href="classTpetra_1_1BlockVector.html" title="Vector for multiple degrees of freedom per mesh point.">BlockVector</a> has a single vector (column). Please refer to the documentation of <a class="el" href="classTpetra_1_1BlockMultiVector.html" title="MultiVector for multiple degrees of freedom per mesh point.">BlockMultiVector</a> for details. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html#l00048">48</a> of file <a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html">Tpetra_BlockVector_decl.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a03f3b33e4f6aa99083b01f80ff360472" name="a03f3b33e4f6aa99083b01f80ff360472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f3b33e4f6aa99083b01f80ff360472">&#9670;&#160;</a></span>scalar_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typedef</a> base_type::scalar_type <a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::scalar_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of entries in the vector. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html#l00058">58</a> of file <a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html">Tpetra_BlockVector_decl.hpp</a>.</p>

</div>
</div>
<a id="ab29f4a163627d422d7c35deff10f95a5" name="ab29f4a163627d422d7c35deff10f95a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab29f4a163627d422d7c35deff10f95a5">&#9670;&#160;</a></span>impl_scalar_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typedef</a> base_type::impl_scalar_type <a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::impl_scalar_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The implementation type of entries in the vector. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html#l00060">60</a> of file <a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html">Tpetra_BlockVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a2b721b89e75eec2e42b80c8fb7d14947" name="a2b721b89e75eec2e42b80c8fb7d14947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b721b89e75eec2e42b80c8fb7d14947">&#9670;&#160;</a></span>local_ordinal_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typedef</a> base_type::local_ordinal_type <a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::local_ordinal_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of local indices. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html#l00062">62</a> of file <a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html">Tpetra_BlockVector_decl.hpp</a>.</p>

</div>
</div>
<a id="af7e12e7df15f8361035a4b8328dd082d" name="af7e12e7df15f8361035a4b8328dd082d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e12e7df15f8361035a4b8328dd082d">&#9670;&#160;</a></span>global_ordinal_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typedef</a> base_type::global_ordinal_type <a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::global_ordinal_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of global indices. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html#l00064">64</a> of file <a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html">Tpetra_BlockVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a4fc3e97c88345ba1df1a0704eae81fa5" name="a4fc3e97c88345ba1df1a0704eae81fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc3e97c88345ba1df1a0704eae81fa5">&#9670;&#160;</a></span>node_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typedef</a> base_type::node_type <a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::node_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Kokkos Node type. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html#l00066">66</a> of file <a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html">Tpetra_BlockVector_decl.hpp</a>.</p>

</div>
</div>
<a id="acfb1b2ab6ec5095f0b0293128d89a514" name="acfb1b2ab6ec5095f0b0293128d89a514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb1b2ab6ec5095f0b0293128d89a514">&#9670;&#160;</a></span>device_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typedef</a> Node::device_type <a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::device_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Kokkos Device type. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html#l00068">68</a> of file <a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html">Tpetra_BlockVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a4502b2eff5b736e714a37137f29a88ee" name="a4502b2eff5b736e714a37137f29a88ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4502b2eff5b736e714a37137f29a88ee">&#9670;&#160;</a></span>map_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typedef</a> <a class="el" href="classTpetra_1_1Map.html">Tpetra::Map</a>&lt;LO, GO, Node&gt; <a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::map_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The specialization of <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Tpetra::Map</a> that this class uses. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html#l00071">71</a> of file <a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html">Tpetra_BlockVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a362d442d5d154af1031b11170971a9df" name="a362d442d5d154af1031b11170971a9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a362d442d5d154af1031b11170971a9df">&#9670;&#160;</a></span>mv_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typedef</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node&gt; <a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::mv_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The specialization of <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">Tpetra::MultiVector</a> that this class uses. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html#l00073">73</a> of file <a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html">Tpetra_BlockVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a73aaa521ab4dc2c734b0f14df57e366c" name="a73aaa521ab4dc2c734b0f14df57e366c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73aaa521ab4dc2c734b0f14df57e366c">&#9670;&#160;</a></span>vec_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typedef</a> <a class="el" href="classTpetra_1_1Vector.html">Tpetra::Vector</a>&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node&gt; <a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::vec_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The specialization of <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Tpetra::Vector</a> that this class uses. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html#l00075">75</a> of file <a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html">Tpetra_BlockVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a2009c78127483c9546907e453aa406b7" name="a2009c78127483c9546907e453aa406b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2009c78127483c9546907e453aa406b7">&#9670;&#160;</a></span>little_vec_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typedef</a> base_type::little_vec_type <a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::little_vec_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Block view" of all degrees of freedom at a mesh point. </p>
<p>A "block view" lets you address all degrees of freedom at a mesh point. You don't have to use this class to access the degrees of freedom. If you do choose to use this class, it implements operator()(LO i), so you can access and modify its entries.</p>
<p>The preferred way to refer to the little_vec_type and const_little_vec_type types, is to get them from the typedefs below. This is because different specializations of <a class="el" href="classTpetra_1_1BlockVector.html" title="Vector for multiple degrees of freedom per mesh point.">BlockVector</a> reserve the right to use different types to implement little_vec_type or const_little_vec_type. This gives us a porting strategy to move from "classic" <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> to the Kokkos refactor version. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html#l00092">92</a> of file <a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html">Tpetra_BlockVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a976ed6ccb69cb6f398a185dabb5217e4" name="a976ed6ccb69cb6f398a185dabb5217e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976ed6ccb69cb6f398a185dabb5217e4">&#9670;&#160;</a></span>const_little_vec_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typedef</a> base_type::const_little_vec_type <a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::const_little_vec_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Const block view" of all degrees of freedom at a mesh point. </p>
<p>This is just like little_vec_type, except that you can't modify its entries. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html#l00101">101</a> of file <a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html">Tpetra_BlockVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a921098a19077b2db2ca3875e518970db" name="a921098a19077b2db2ca3875e518970db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a921098a19077b2db2ca3875e518970db">&#9670;&#160;</a></span>buffer_device_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::buffer_device_type =  <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1DistObject.html#a66edb1059ed7db04325605df64fe64c5">dist_object_type::buffer_device_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kokkos::Device specialization used for communication buffers. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__decl_8hpp_source.html#l00143">143</a> of file <a class="el" href="Tpetra__BlockMultiVector__decl_8hpp_source.html">Tpetra_BlockMultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a87c43585393cbe182ab96e31389e90fa" name="a87c43585393cbe182ab96e31389e90fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c43585393cbe182ab96e31389e90fa">&#9670;&#160;</a></span>execution_space</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::execution_space =  <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> device_type::execution_space</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Kokkos execution space. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html#l00310">310</a> of file <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html">Tpetra_DistObject_decl.hpp</a>.</p>

</div>
</div>
<a id="a142f6b49db9d7bc4cb94e8488f89309c" name="a142f6b49db9d7bc4cb94e8488f89309c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142f6b49db9d7bc4cb94e8488f89309c">&#9670;&#160;</a></span>buffer_memory_space</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::buffer_memory_space</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kokkos memory space for communication buffers. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html#l00719">719</a> of file <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html">Tpetra_DistObject_decl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ac1ff98c164c772986e2a5db411a311ab" name="ac1ff98c164c772986e2a5db411a311ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ff98c164c772986e2a5db411a311ab">&#9670;&#160;</a></span>ReverseOption</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">enum</a> <a class="el" href="classTpetra_1_1DistObject.html#ac1ff98c164c772986e2a5db411a311ab">Tpetra::DistObject::ReverseOption</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the data transfer should be performed in forward or reverse mode. </p>
<p>"Reverse mode" means calling <a class="el" href="classTpetra_1_1DistObject.html#ad2623c99b47ce9d88692abdc094d8be6" title="Export data into this object using an Export object (&quot;forward mode&quot;).">doExport()</a> with an <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> object, or calling <a class="el" href="classTpetra_1_1DistObject.html#a2e2cce34ee9698060f87e1fad3695a2d" title="Import data into this object using an Import object (&quot;forward mode&quot;).">doImport()</a> with an <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> object. "Forward mode" means calling <a class="el" href="classTpetra_1_1DistObject.html#ad2623c99b47ce9d88692abdc094d8be6" title="Export data into this object using an Export object (&quot;forward mode&quot;).">doExport()</a> with an <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> object, or calling <a class="el" href="classTpetra_1_1DistObject.html#a2e2cce34ee9698060f87e1fad3695a2d" title="Import data into this object using an Import object (&quot;forward mode&quot;).">doImport()</a> with an <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> object. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html#l00649">649</a> of file <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html">Tpetra_DistObject_decl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a97c978bc34011a66288db198c03af359" name="a97c978bc34011a66288db198c03af359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c978bc34011a66288db198c03af359">&#9670;&#160;</a></span>BlockVector() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::BlockVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Creates an empty <a class="el" href="classTpetra_1_1BlockVector.html" title="Vector for multiple degrees of freedom per mesh point.">BlockVector</a>. An empty <a class="el" href="classTpetra_1_1BlockVector.html" title="Vector for multiple degrees of freedom per mesh point.">BlockVector</a> has zero rows, and block size zero. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html#l00016">16</a> of file <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html">Tpetra_BlockVector_def.hpp</a>.</p>

</div>
</div>
<a id="a123d01f3ee00b6b3cec2194d2e5cfbfd" name="a123d01f3ee00b6b3cec2194d2e5cfbfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123d01f3ee00b6b3cec2194d2e5cfbfd">&#9670;&#160;</a></span>BlockVector() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::BlockVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html">BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor (shallow copy). </p>

</div>
</div>
<a id="ac5a58440e5370074719a7faf8b2c7dbb" name="ac5a58440e5370074719a7faf8b2c7dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a58440e5370074719a7faf8b2c7dbb">&#9670;&#160;</a></span>BlockVector() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::BlockVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1BlockVector.html">BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor (shallow move). </p>

</div>
</div>
<a id="a928a021197044be1de47d054ba1bac5a" name="a928a021197044be1de47d054ba1bac5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928a021197044be1de47d054ba1bac5a">&#9670;&#160;</a></span>BlockVector() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::BlockVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html">BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::DataAccess&#160;</td>
          <td class="paramname"><em>copyOrView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Copy constructor" with option to deep copy. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html#l00021">21</a> of file <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html">Tpetra_BlockVector_def.hpp</a>.</p>

</div>
</div>
<a id="aba08a0a983e84abc51b370426814e81d" name="aba08a0a983e84abc51b370426814e81d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba08a0a983e84abc51b370426814e81d">&#9670;&#160;</a></span>BlockVector() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::BlockVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a> &amp;&#160;</td>
          <td class="paramname"><em>meshMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO&#160;</td>
          <td class="paramname"><em>blockSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor that takes a mesh <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> and a block size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshMap</td><td>[in] <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> that describes the distribution of mesh points (rather than the distribution of unknowns for those mesh points).</td></tr>
    <tr><td class="paramname">blockSize</td><td>[in] The number of degrees of freedom per mesh point. We assume that this is the same for all mesh points in the above <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>mesh <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a></em> describes the distribution of mesh points. Its corresponding <em>point <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a></em> describes the distribution of degrees of freedom corresponding to those mesh points. If you have already computed the point <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> corresponding to the above mesh <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>, then it is more efficient to call the three-argument constructor below, that takes both the mesh <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> and the point <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>.</p>
<p>There are two ways to get the point <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> corresponding to a given mesh <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> and block size. You may either call the class method <a class="el" href="classTpetra_1_1BlockMultiVector.html#a919acd412412e81ffb3c242a1ba388c2" title="Create and return the point Map corresponding to the given mesh Map and block size.">makePointMap()</a> (inherited from the parent class <a class="el" href="classTpetra_1_1BlockMultiVector.html" title="MultiVector for multiple degrees of freedom per mesh point.">BlockMultiVector</a>), or you may call this two-argument constructor, and then call <a class="el" href="classTpetra_1_1BlockMultiVector.html#a7a77cb04963c6993696f53976b1557e5" title="Get this BlockMultiVector&#39;s (previously computed) point Map.">getPointMap()</a>.</p>
<p>The point <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> enables reinterpretation of a <a class="el" href="classTpetra_1_1BlockVector.html" title="Vector for multiple degrees of freedom per mesh point.">BlockVector</a> as a standard <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Tpetra::Vector</a>, or as a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">Tpetra::MultiVector</a> with one column. This lets users solve linear systems with Trilinos' solvers and preconditioners, that expect vectors as <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">Tpetra::MultiVector</a> or <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Tpetra::Vector</a> instances. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html#l00027">27</a> of file <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html">Tpetra_BlockVector_def.hpp</a>.</p>

</div>
</div>
<a id="a18bf8ea97f942855d5b9d67b6ee864eb" name="a18bf8ea97f942855d5b9d67b6ee864eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18bf8ea97f942855d5b9d67b6ee864eb">&#9670;&#160;</a></span>BlockVector() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::BlockVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a> &amp;&#160;</td>
          <td class="paramname"><em>meshMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a> &amp;&#160;</td>
          <td class="paramname"><em>pointMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO&#160;</td>
          <td class="paramname"><em>blockSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor that takes a mesh <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>, a point <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>, and a block size. </p>
<p>See the documentation of the two-argument constructor above. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html#l00032">32</a> of file <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html">Tpetra_BlockVector_def.hpp</a>.</p>

</div>
</div>
<a id="a5b4ba6e425c74c0a4f17a60a84b24ad5" name="a5b4ba6e425c74c0a4f17a60a84b24ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4ba6e425c74c0a4f17a60a84b24ad5">&#9670;&#160;</a></span>BlockVector() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::BlockVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a362d442d5d154af1031b11170971a9df">mv_type</a> &amp;&#160;</td>
          <td class="paramname"><em>X_mv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a> &amp;&#160;</td>
          <td class="paramname"><em>meshMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO&#160;</td>
          <td class="paramname"><em>blockSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>View an existing <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Vector</a> or <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X_mv</td><td>[in/out] The <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Vector</a> or <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> to view. It MUST have view semantics; otherwise this constructor throws. Its <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> must be the same (in the sense of isSameAs) as the point <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> corresponding to the given mesh <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> and block size. If this is a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>, it must have only one column.</td></tr>
    <tr><td class="paramname">meshMap</td><td>[in] The mesh <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> to use for interpreting the given <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> or <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Vector</a> (in place) as a <a class="el" href="classTpetra_1_1BlockVector.html" title="Vector for multiple degrees of freedom per mesh point.">BlockVector</a>.</td></tr>
    <tr><td class="paramname">blockSize</td><td>[in] The number of degrees of freedom per mesh point. We assume that this is the same for all mesh points. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html#l00039">39</a> of file <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html">Tpetra_BlockVector_def.hpp</a>.</p>

</div>
</div>
<a id="a90edebd73a467a8cf034c0bd7e3c6184" name="a90edebd73a467a8cf034c0bd7e3c6184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90edebd73a467a8cf034c0bd7e3c6184">&#9670;&#160;</a></span>BlockVector() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::BlockVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a73aaa521ab4dc2c734b0f14df57e366c">vec_type</a> &amp;&#160;</td>
          <td class="paramname"><em>X_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a> &amp;&#160;</td>
          <td class="paramname"><em>meshMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO&#160;</td>
          <td class="paramname"><em>blockSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>View an existing <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X_vec</td><td>[in/out] The <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Vector</a> view. It MUST have view semantics; otherwise this constructor throws. Its <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> must be the same (in the sense of isSameAs) as the point <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> corresponding to the given mesh <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> and block size.</td></tr>
    <tr><td class="paramname">meshMap</td><td>[in] The mesh <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> to use for interpreting the given <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Vector</a> (in place) as a <a class="el" href="classTpetra_1_1BlockVector.html" title="Vector for multiple degrees of freedom per mesh point.">BlockVector</a>.</td></tr>
    <tr><td class="paramname">blockSize</td><td>[in] The number of degrees of freedom per mesh point. We assume that this is the same for all mesh points. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html#l00051">51</a> of file <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html">Tpetra_BlockVector_def.hpp</a>.</p>

</div>
</div>
<a id="a4d44c9bc1e07e8b1bf6e376846d45fde" name="a4d44c9bc1e07e8b1bf6e376846d45fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d44c9bc1e07e8b1bf6e376846d45fde">&#9670;&#160;</a></span>BlockVector() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::BlockVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html">BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a> &amp;&#160;</td>
          <td class="paramname"><em>newMeshMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a> &amp;&#160;</td>
          <td class="paramname"><em>newPointMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>View an existing <a class="el" href="classTpetra_1_1BlockVector.html" title="Vector for multiple degrees of freedom per mesh point.">BlockVector</a> using a different mesh <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>, supplying the corresponding point <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>. </p>
<p>This method corresponds to <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s "offset view" constructor. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html#l00058">58</a> of file <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html">Tpetra_BlockVector_def.hpp</a>.</p>

</div>
</div>
<a id="a86d3561a244f861a581cb95052457ef6" name="a86d3561a244f861a581cb95052457ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d3561a244f861a581cb95052457ef6">&#9670;&#160;</a></span>BlockVector() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::BlockVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html">BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a> &amp;&#160;</td>
          <td class="paramname"><em>newMeshMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>View an existing <a class="el" href="classTpetra_1_1BlockVector.html" title="Vector for multiple degrees of freedom per mesh point.">BlockVector</a> using a different mesh <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>; compute the new point <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>. </p>
<p>This method corresponds to <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s "offset view" constructor. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html#l00066">66</a> of file <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html">Tpetra_BlockVector_def.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a71cbdbbef8dcc71a0e0d16b0fcd8f6f2" name="a71cbdbbef8dcc71a0e0d16b0fcd8f6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71cbdbbef8dcc71a0e0d16b0fcd8f6f2">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1BlockVector.html">BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp; <a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html">BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assigment (shallow copy). </p>

</div>
</div>
<a id="a0a441a45e39366667a34cfa23a8c1045" name="a0a441a45e39366667a34cfa23a8c1045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a441a45e39366667a34cfa23a8c1045">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1BlockVector.html">BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp; <a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1BlockVector.html">BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assigment (shallow move). </p>

</div>
</div>
<a id="a9d262edfcdb20fcc6d3b24015f139864" name="a9d262edfcdb20fcc6d3b24015f139864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d262edfcdb20fcc6d3b24015f139864">&#9670;&#160;</a></span>getVectorView()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1BlockVector.html">BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;<a class="el" href="classTpetra_1_1BlockVector.html#a73aaa521ab4dc2c734b0f14df57e366c">::vec_type</a> <a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::getVectorView </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Tpetra::Vector</a> that views this <a class="el" href="classTpetra_1_1BlockVector.html" title="Vector for multiple degrees of freedom per mesh point.">BlockVector</a>'s data. </p>
<p>This is how you can give a <a class="el" href="classTpetra_1_1BlockVector.html" title="Vector for multiple degrees of freedom per mesh point.">BlockVector</a> to Trilinos' solvers and preconditioners. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html#l00074">74</a> of file <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html">Tpetra_BlockVector_def.hpp</a>.</p>

</div>
</div>
<a id="abe14ce0b7ad9da9b519555a7d20da3f0" name="abe14ce0b7ad9da9b519555a7d20da3f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe14ce0b7ad9da9b519555a7d20da3f0">&#9670;&#160;</a></span>replaceLocalValues() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::replaceLocalValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO&#160;</td>
          <td class="paramname"><em>localRowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>vals</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all values at the given mesh point, using a local index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">localRowIndex</td><td>[in] Local index of the mesh point. </td></tr>
    <tr><td class="paramname">vals</td><td>[in] Input values with which to replace whatever existing values are at the mesh point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, else false. This method will <em>not</em> succeed if the given local index of the mesh point is invalid on the calling process.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method, the other "replace" and "sumInto" methods, and the view methods, are marked const. This is because they do not change pointers. They do, of course, change the values in the <a class="el" href="classTpetra_1_1BlockVector.html" title="Vector for multiple degrees of freedom per mesh point.">BlockVector</a>, but that does not require marking the methods as nonconst. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html#l00080">80</a> of file <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html">Tpetra_BlockVector_def.hpp</a>.</p>

</div>
</div>
<a id="a8494264fff86f447c22e4afd38ba9231" name="a8494264fff86f447c22e4afd38ba9231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8494264fff86f447c22e4afd38ba9231">&#9670;&#160;</a></span>replaceGlobalValues() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::replaceGlobalValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> GO&#160;</td>
          <td class="paramname"><em>globalRowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>vals</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all values at the given mesh point, using a global index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">globalRowIndex</td><td>[in] Global index of the mesh point. </td></tr>
    <tr><td class="paramname">vals</td><td>[in] Input values with which to sum into whatever existing values are at the mesh point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, else false. This method will <em>not</em> succeed if the given global index of the mesh point is invalid on the calling process. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html#l00086">86</a> of file <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html">Tpetra_BlockVector_def.hpp</a>.</p>

</div>
</div>
<a id="a9c197c3684b5365ec7bf12b16c1e72ce" name="a9c197c3684b5365ec7bf12b16c1e72ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c197c3684b5365ec7bf12b16c1e72ce">&#9670;&#160;</a></span>sumIntoLocalValues() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::sumIntoLocalValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO&#160;</td>
          <td class="paramname"><em>localRowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>vals</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum into all values at the given mesh point, using a local index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">localRowIndex</td><td>[in] Local index of the mesh point. </td></tr>
    <tr><td class="paramname">vals</td><td>[in] Input values with which to replace whatever existing values are at the mesh point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, else false. This method will <em>not</em> succeed if the given local index of the mesh point is invalid on the calling process. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html#l00092">92</a> of file <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html">Tpetra_BlockVector_def.hpp</a>.</p>

</div>
</div>
<a id="a6bf3a3e711079d6d8f3753f5175d4e4c" name="a6bf3a3e711079d6d8f3753f5175d4e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf3a3e711079d6d8f3753f5175d4e4c">&#9670;&#160;</a></span>sumIntoGlobalValues() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::sumIntoGlobalValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> GO&#160;</td>
          <td class="paramname"><em>globalRowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>vals</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum into all values at the given mesh point, using a global index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">globalRowIndex</td><td>[in] Global index of the mesh point. </td></tr>
    <tr><td class="paramname">vals</td><td>[in] Input values with which to replace whatever existing values are at the mesh point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, else false. This method will <em>not</em> succeed if the given global index of the mesh point is invalid on the calling process. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html#l00098">98</a> of file <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html">Tpetra_BlockVector_def.hpp</a>.</p>

</div>
</div>
<a id="a02efcd17ed84c25685f36d7efbf54b3e" name="a02efcd17ed84c25685f36d7efbf54b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02efcd17ed84c25685f36d7efbf54b3e">&#9670;&#160;</a></span>getLocalBlockHost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1BlockVector.html">BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::const_little_host_vec_type <a class="el" href="classTpetra_1_1BlockVector.html">Tpetra::BlockVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::getLocalBlockHost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO&#160;</td>
          <td class="paramname"><em>localRowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Access::ReadOnlyStruct&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a view of the degrees of freedom at the given mesh point, using a local index. </p>
<p>The preferred way to refer to little_vec_type is to get it from <a class="el" href="classTpetra_1_1BlockVector.html" title="Vector for multiple degrees of freedom per mesh point.">BlockVector</a>'s typedef. This is because different specializations of <a class="el" href="classTpetra_1_1BlockVector.html" title="Vector for multiple degrees of freedom per mesh point.">BlockVector</a> reserve the right to use different types to implement little_vec_type. This gives us a porting strategy to move from "classic" <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> to the Kokkos refactor version. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html#l00105">105</a> of file <a class="el" href="Tpetra__BlockVector__def_8hpp_source.html">Tpetra_BlockVector_def.hpp</a>.</p>

</div>
</div>
<a id="a919acd412412e81ffb3c242a1ba388c2" name="a919acd412412e81ffb3c242a1ba388c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a919acd412412e81ffb3c242a1ba388c2">&#9670;&#160;</a></span>makePointMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1BlockMultiVector.html">BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;<a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">::map_type</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::makePointMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html#ab49f0237771b35d2b59a78e2987dbf57">map_type</a> &amp;&#160;</td>
          <td class="paramname"><em>meshMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO&#160;</td>
          <td class="paramname"><em>blockSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create and return the point <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> corresponding to the given mesh <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> and block size. </p>
<p>This is a class ("static") method so that you can make and reuse a point <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> for creating different <a class="el" href="classTpetra_1_1BlockMultiVector.html" title="MultiVector for multiple degrees of freedom per mesh point.">BlockMultiVector</a> instances, using the more efficient four-argument constructor. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html#l00174">174</a> of file <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html">Tpetra_BlockMultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a1ca238134ffd65fb487aa970ce0d773a" name="a1ca238134ffd65fb487aa970ce0d773a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca238134ffd65fb487aa970ce0d773a">&#9670;&#160;</a></span>makePointMapRCP()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;<a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">::map_type</a> &gt; <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::makePointMapRCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html#ab49f0237771b35d2b59a78e2987dbf57">map_type</a> &amp;&#160;</td>
          <td class="paramname"><em>meshMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO&#160;</td>
          <td class="paramname"><em>blockSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create and return an owning RCP to the point <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> corresponding to the given mesh <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> and block size. </p>
<p>This is a class ("static") method so that you can make and reuse a point <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> for creating different <a class="el" href="classTpetra_1_1BlockMultiVector.html" title="MultiVector for multiple degrees of freedom per mesh point.">BlockMultiVector</a> instances, using the more efficient four-argument constructor. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html#l00216">216</a> of file <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html">Tpetra_BlockMultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a7a77cb04963c6993696f53976b1557e5" name="a7a77cb04963c6993696f53976b1557e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a77cb04963c6993696f53976b1557e5">&#9670;&#160;</a></span>getPointMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::getPointMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get this <a class="el" href="classTpetra_1_1BlockMultiVector.html" title="MultiVector for multiple degrees of freedom per mesh point.">BlockMultiVector</a>'s (previously computed) point <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>. </p>
<p>It is always valid to call this method. A <a class="el" href="classTpetra_1_1BlockMultiVector.html" title="MultiVector for multiple degrees of freedom per mesh point.">BlockMultiVector</a> always has a point <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>. We do not compute the point <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> lazily. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__decl_8hpp_source.html#l00307">307</a> of file <a class="el" href="Tpetra__BlockMultiVector__decl_8hpp_source.html">Tpetra_BlockMultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="ad3d93cbe2fb39fabb12fd283ee3e0a49" name="ad3d93cbe2fb39fabb12fd283ee3e0a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d93cbe2fb39fabb12fd283ee3e0a49">&#9670;&#160;</a></span>getBlockSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LO <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::getBlockSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of degrees of freedom per mesh point. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__decl_8hpp_source.html#l00312">312</a> of file <a class="el" href="Tpetra__BlockMultiVector__decl_8hpp_source.html">Tpetra_BlockMultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a93fbb09c25de6da9fc4935a8e08bcfca" name="a93fbb09c25de6da9fc4935a8e08bcfca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93fbb09c25de6da9fc4935a8e08bcfca">&#9670;&#160;</a></span>getNumVectors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LO <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::getNumVectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of columns (vectors) in the <a class="el" href="classTpetra_1_1BlockMultiVector.html" title="MultiVector for multiple degrees of freedom per mesh point.">BlockMultiVector</a>. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__decl_8hpp_source.html#l00317">317</a> of file <a class="el" href="Tpetra__BlockMultiVector__decl_8hpp_source.html">Tpetra_BlockMultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a09f4ed666e210725e9d93d93a01e5e38" name="a09f4ed666e210725e9d93d93a01e5e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f4ed666e210725e9d93d93a01e5e38">&#9670;&#160;</a></span>getMultiVectorView()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;<a class="el" href="classTpetra_1_1BlockVector.html#a362d442d5d154af1031b11170971a9df">::mv_type</a> &amp; <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::getMultiVectorView </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">Tpetra::MultiVector</a> that views this <a class="el" href="classTpetra_1_1BlockMultiVector.html" title="MultiVector for multiple degrees of freedom per mesh point.">BlockMultiVector</a>'s data. </p>
<p>This is how you can give a <a class="el" href="classTpetra_1_1BlockMultiVector.html" title="MultiVector for multiple degrees of freedom per mesh point.">BlockMultiVector</a> to Trilinos' solvers and preconditioners. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html#l00022">22</a> of file <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html">Tpetra_BlockMultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a028794981fd49adcea2e08e09a91ad35" name="a028794981fd49adcea2e08e09a91ad35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028794981fd49adcea2e08e09a91ad35">&#9670;&#160;</a></span>putScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::putScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill all entries with the given value <code>val</code>. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html#l00477">477</a> of file <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html">Tpetra_BlockMultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="abb56c1f0f259ec405d035999a6806b7a" name="abb56c1f0f259ec405d035999a6806b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb56c1f0f259ec405d035999a6806b7a">&#9670;&#160;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply all entries in place by the given value <code>val</code>. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html#l00483">483</a> of file <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html">Tpetra_BlockMultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a598f61c29431518392a8aa0d353b2948" name="a598f61c29431518392a8aa0d353b2948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598f61c29431518392a8aa0d353b2948">&#9670;&#160;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update: <code>this = beta*this + alpha*X</code>. </p>
<p>Update this <a class="el" href="classTpetra_1_1BlockMultiVector.html" title="MultiVector for multiple degrees of freedom per mesh point.">BlockMultiVector</a> with scaled values of X. If beta is zero, overwrite <code>*this</code> unconditionally, even if it contains NaN entries. It is legal for the input X to alias this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html#l00489">489</a> of file <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html">Tpetra_BlockMultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a1253543f32f38be28efa5dcd30811eab" name="a1253543f32f38be28efa5dcd30811eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1253543f32f38be28efa5dcd30811eab">&#9670;&#160;</a></span>blockWiseMultiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::blockWiseMultiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::View&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html#a60510e225e9b41857156871e690c2dbc">impl_scalar_type</a> ***, <a class="el" href="classTpetra_1_1BlockMultiVector.html#ab5d9e30f8a9e6d69c769e85a98eb31b5">device_type</a>, Kokkos::MemoryUnmanaged &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>*this := alpha * D * X</code>, where D is a block diagonal matrix. </p>
<p>Compute <code>*this := alpha * D * X</code>, where D is a block diagonal matrix, stored as a 3-D Kokkos::View. This method is the block analog of <a class="el" href="classTpetra_1_1MultiVector.html#a95fae4b1f2891d8438b7fb692a85b3bd" title="Multiply a Vector A elementwise by a MultiVector B.">Tpetra::MultiVector::elementWiseMultiply</a>, and is likewise useful for implementing (block) Jacobi.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>[in] Coefficient by which to scale the result. We treat alpha = 0 as a special case, following the BLAS rules. That is, if alpha = 0, this method does <code>this-&gt;putScalar(0)</code>. </td></tr>
    <tr><td class="paramname">D</td><td>[in] Block diagonal, as a 3-D Kokkos::View. The leftmost index indicates which block, the middle index the row within a block, and the rightmost index the column within a block. </td></tr>
    <tr><td class="paramname">pivots</td><td>[in] Pivots (from LU factorization of the blocks) </td></tr>
    <tr><td class="paramname">X</td><td>[in] Input Block(Multi)<a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Vector</a>; may alias <code>*this</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>D is really the inverse of some <a class="el" href="classTpetra_1_1BlockCrsMatrix.html" title="Sparse matrix whose entries are small dense square blocks, all of the same dimensions.">BlockCrsMatrix</a>'s block diagonal. You may compute the inverse of each block however you like. One way is to use GETRF, then GETRI. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html#l00688">688</a> of file <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html">Tpetra_BlockMultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a323dd6fa9758b30950c1bf37a7a7488f" name="a323dd6fa9758b30950c1bf37a7a7488f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323dd6fa9758b30950c1bf37a7a7488f">&#9670;&#160;</a></span>blockJacobiUpdate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::blockJacobiUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::View&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html#a60510e225e9b41857156871e690c2dbc">impl_scalar_type</a> ***, <a class="el" href="classTpetra_1_1BlockMultiVector.html#ab5d9e30f8a9e6d69c769e85a98eb31b5">device_type</a>, Kokkos::MemoryUnmanaged &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1BlockMultiVector.html">BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Block Jacobi update <picture><source srcset="form_7_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$Y = \beta * Y + \alpha D (X - Z)$" src="form_7.png" width="136" height="14"/></picture>. </p>
<p>This method computes the block Jacobi update <picture><source srcset="form_7_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$Y = \beta * Y + \alpha D (X - Z)$" src="form_7.png" width="136" height="14"/></picture>, where Y is <code>*this&lt;\tt&gt;, D the (explicitly stored) inverse block diagonal of a <a class="el" href="classTpetra_1_1BlockCrsMatrix.html" title="Sparse matrix whose entries are small dense square blocks, all of the same dimensions.">BlockCrsMatrix</a> A, and <picture><source srcset="form_8_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$Z = A*Y$" src="form_8.png" width="56" height="10"/></picture>. The method may use Z as scratch space.</code></p>
<p><code>Folks who optimize sparse matrix-vector multiply kernels tend not to write special-purpose kernels like this one. Thus, this kernel consolidates all the other code that block Jacobi needs, while exploiting the existing sparse matrix-vector multiply kernel in <a class="el" href="classTpetra_1_1BlockCrsMatrix.html" title="Sparse matrix whose entries are small dense square blocks, all of the same dimensions.">BlockCrsMatrix</a>. That consolidation minimizes thread-parallel kernel launch overhead.</code></p>
<p><code></p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>[in] Coefficient of the "block scaled" term. We treat alpha = 0 as a special case, following the BLAS rules. That is, if alpha = 0, this method does Y = beta * Y. </td></tr>
    <tr><td class="paramname">D</td><td>[in] Block diagonal, as a 3-D Kokkos::View. The leftmost index indicates which block, the middle index the row within a block, and the rightmost index the column within a block. </td></tr>
    <tr><td class="paramname">X</td><td>[in] The first of two block (multi)vectors whose difference is "block scaled" </td></tr>
    <tr><td class="paramname">Z</td><td>[in/out] On input: The second of two block (multi)vectors whose difference is "block scaled." This method may use Z as scratch space. </td></tr>
    <tr><td class="paramname">beta</td><td>[in] Coefficient of Y. We treat beta = 0 as a special case, following the BLAS rules. That is, if beta = 0, the initial contents of Y are ignored. </td></tr>
  </table>
  </dd>
</dl>
<p></code></p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html#l00717">717</a> of file <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html">Tpetra_BlockMultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a1a582c41c3cd80e3e102376cf480fb2f" name="a1a582c41c3cd80e3e102376cf480fb2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a582c41c3cd80e3e102376cf480fb2f">&#9670;&#160;</a></span>need_sync()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">TargetMemorySpace</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::need_sync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether this object needs synchronization to the given memory space. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__decl_8hpp_source.html#l00417">417</a> of file <a class="el" href="Tpetra__BlockMultiVector__decl_8hpp_source.html">Tpetra_BlockMultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a157d5fdfe37972f6685251900cd15b97" name="a157d5fdfe37972f6685251900cd15b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a157d5fdfe37972f6685251900cd15b97">&#9670;&#160;</a></span>need_sync_host()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::need_sync_host </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether this object needs synchronization to the host. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__decl_8hpp_source.html#l00422">422</a> of file <a class="el" href="Tpetra__BlockMultiVector__decl_8hpp_source.html">Tpetra_BlockMultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="ad5aba5182202d23907454f4d9d9dcaad" name="ad5aba5182202d23907454f4d9d9dcaad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5aba5182202d23907454f4d9d9dcaad">&#9670;&#160;</a></span>need_sync_device()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::need_sync_device </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether this object needs synchronization to the device. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__decl_8hpp_source.html#l00427">427</a> of file <a class="el" href="Tpetra__BlockMultiVector__decl_8hpp_source.html">Tpetra_BlockMultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a8cf24c0f15b9eb358ac4b9f57fc8194d" name="a8cf24c0f15b9eb358ac4b9f57fc8194d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf24c0f15b9eb358ac4b9f57fc8194d">&#9670;&#160;</a></span>replaceLocalValues() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::replaceLocalValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO&#160;</td>
          <td class="paramname"><em>localRowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO&#160;</td>
          <td class="paramname"><em>colIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>vals</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace all values at the given mesh point, using local row and column indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">localRowIndex</td><td>[in] Local index of the mesh point. </td></tr>
    <tr><td class="paramname">colIndex</td><td>[in] Column (vector) to modify. </td></tr>
    <tr><td class="paramname">vals</td><td>[in] Input values with which to replace whatever existing values are at the mesh point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, else false. This method will <em>not</em> succeed if the given local index of the mesh point is invalid on the calling process.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method, the other "replace" and "sumInto" methods, and the view methods, are marked const. This is because they do not change pointers. They do, of course, change the values in the <a class="el" href="classTpetra_1_1BlockMultiVector.html" title="MultiVector for multiple degrees of freedom per mesh point.">BlockMultiVector</a>, but that does not require marking the methods as nonconst. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html#l00270">270</a> of file <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html">Tpetra_BlockMultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="ade05bfc9d18496bc20161b4491436e99" name="ade05bfc9d18496bc20161b4491436e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade05bfc9d18496bc20161b4491436e99">&#9670;&#160;</a></span>replaceGlobalValues() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::replaceGlobalValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> GO&#160;</td>
          <td class="paramname"><em>globalRowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO&#160;</td>
          <td class="paramname"><em>colIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>vals</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace all values at the given mesh point, using a global index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">globalRowIndex</td><td>[in] Global index of the mesh point. </td></tr>
    <tr><td class="paramname">colIndex</td><td>[in] Column (vector) to modify. </td></tr>
    <tr><td class="paramname">vals</td><td>[in] Input values with which to sum into whatever existing values are at the mesh point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, else false. This method will <em>not</em> succeed if the given global index of the mesh point is invalid on the calling process. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html#l00283">283</a> of file <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html">Tpetra_BlockMultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a16c3cd4540b728c0ac3ff6f3bcea939e" name="a16c3cd4540b728c0ac3ff6f3bcea939e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c3cd4540b728c0ac3ff6f3bcea939e">&#9670;&#160;</a></span>sumIntoLocalValues() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::sumIntoLocalValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO&#160;</td>
          <td class="paramname"><em>localRowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO&#160;</td>
          <td class="paramname"><em>colIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>vals</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sum into all values at the given mesh point, using a local index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">localRowIndex</td><td>[in] Local index of the mesh point. </td></tr>
    <tr><td class="paramname">colIndex</td><td>[in] Column (vector) to modify. </td></tr>
    <tr><td class="paramname">vals</td><td>[in] Input values with which to replace whatever existing values are at the mesh point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, else false. This method will <em>not</em> succeed if the given local index of the mesh point is invalid on the calling process. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html#l00308">308</a> of file <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html">Tpetra_BlockMultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a654737881bbaf3611d8612a34c6e40dd" name="a654737881bbaf3611d8612a34c6e40dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654737881bbaf3611d8612a34c6e40dd">&#9670;&#160;</a></span>sumIntoGlobalValues() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::sumIntoGlobalValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> GO&#160;</td>
          <td class="paramname"><em>globalRowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO&#160;</td>
          <td class="paramname"><em>colIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>vals</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sum into all values at the given mesh point, using a global index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">globalRowIndex</td><td>[in] Global index of the mesh point. </td></tr>
    <tr><td class="paramname">colIndex</td><td>[in] Column (vector) to modify. </td></tr>
    <tr><td class="paramname">vals</td><td>[in] Input values with which to replace whatever existing values are at the mesh point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, else false. This method will <em>not</em> succeed if the given global index of the mesh point is invalid on the calling process. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html#l00321">321</a> of file <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html">Tpetra_BlockMultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a547175181014da27dc0e03a880acbbb4" name="a547175181014da27dc0e03a880acbbb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a547175181014da27dc0e03a880acbbb4">&#9670;&#160;</a></span>getLocalBlockHost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1BlockMultiVector.html">BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::little_host_vec_type <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::getLocalBlockHost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO&#160;</td>
          <td class="paramname"><em>localRowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO&#160;</td>
          <td class="paramname"><em>colIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Access::OverwriteAllStruct&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a local block on host, with the intent to overwrite all blocks in the <a class="el" href="classTpetra_1_1BlockMultiVector.html" title="MultiVector for multiple degrees of freedom per mesh point.">BlockMultiVector</a> before accessing the data on device. If you intend to modify only some blocks on host, use Access::ReadWrite instead (otherwise, previous changes on device may be lost) </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html#l00354">354</a> of file <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html">Tpetra_BlockMultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a008b29f4b5afe674c58ff46a5c8ca0b7" name="a008b29f4b5afe674c58ff46a5c8ca0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008b29f4b5afe674c58ff46a5c8ca0b7">&#9670;&#160;</a></span>checkSizes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::checkSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">Tpetra::SrcDistObject</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the source and target (<em>this</em>) objects for compatibility. </p>
<dl class="section return"><dt>Returns</dt><dd>True if they are compatible, else false. </dd></dl>

<p>Implements <a class="el" href="classTpetra_1_1DistObject.html#a84bb8e0004dd8a4ae1b2cce20187ee50">Tpetra::DistObject&lt; Scalar, LO, GO, Node &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html#l00417">417</a> of file <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html">Tpetra_BlockMultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="aac66b029f330696c2c0e9d5ae999d0ca" name="aac66b029f330696c2c0e9d5ae999d0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac66b029f330696c2c0e9d5ae999d0ca">&#9670;&#160;</a></span>copyAndPermute() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::copyAndPermute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a>&#160;</td>
          <td class="paramname"><em>numSameIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html#abdb5bf693fecbdadb80ba6e9f2891106">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permuteToLIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html#abdb5bf693fecbdadb80ba6e9f2891106">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permuteFromLIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a>&#160;</td>
          <td class="paramname"><em>CM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>&lt; <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> copyAndPermute has multiple overloads &ndash; use copyAndPermutes for anything we don't override </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html#l00423">423</a> of file <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html">Tpetra_BlockMultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="abc82b9b77aec9c2eae61417374895ab5" name="abc82b9b77aec9c2eae61417374895ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc82b9b77aec9c2eae61417374895ab5">&#9670;&#160;</a></span>copyAndPermute() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::copyAndPermute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a>&#160;</td>
          <td class="paramname"><em>numSameIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1DistObject.html#a6704de48b06419ddaa09161663702858">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1DistObject.html#a66edb1059ed7db04325605df64fe64c5">buffer_device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permuteToLIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1DistObject.html#a6704de48b06419ddaa09161663702858">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1DistObject.html#a66edb1059ed7db04325605df64fe64c5">buffer_device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permuteFromLIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a>&#160;</td>
          <td class="paramname"><em>CM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform copies and permutations that are local to the calling (MPI) process. </p>
<p>Subclasses <em>must</em> reimplement this function. Its default implementation does nothing. Note that the &lt;t&gt;target object of the <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> or <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a>, namely <code>*this</code>, packs the <em>source</em> object's data.</p>
<dl class="section pre"><dt>Precondition</dt><dd>permuteToLIDs and permuteFromLIDs are sync'd to both host and device. That is, <code>permuteToLIDs.need_sync_host()</code>, <code>permuteToLIDs.need_sync_device()</code>, <code>permuteFromLIDs.need_sync_host()</code>, and <code>permuteFromLIDs.need_sync_device()</code> are all false.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>[in] On entry, the source object of the <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> or <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> operation. </td></tr>
    <tr><td class="paramname">numSameIDs</td><td>[in] The number of elements that are the same on the source and target objects. These elements live on the same process in both the source and target objects. </td></tr>
    <tr><td class="paramname">permuteToLIDs</td><td>[in] List of the elements that are permuted. They are listed by their local index (LID) in the destination object. </td></tr>
    <tr><td class="paramname">permuteFromLIDs</td><td>[in] List of the elements that are permuted. They are listed by their local index (LID) in the source object. </td></tr>
    <tr><td class="paramname">CM</td><td>[in] CombineMode to be used during copyAndPermute; may or may not be used by the particular object being called; behavior with respect to CombineMode may differ by object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00827">827</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="a454c858836519e8d35e7a3bc928327ed" name="a454c858836519e8d35e7a3bc928327ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454c858836519e8d35e7a3bc928327ed">&#9670;&#160;</a></span>copyAndPermute() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::copyAndPermute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a>&#160;</td>
          <td class="paramname"><em>numSameIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1DistObject.html#a6704de48b06419ddaa09161663702858">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1DistObject.html#a66edb1059ed7db04325605df64fe64c5">buffer_device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permuteToLIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1DistObject.html#a6704de48b06419ddaa09161663702858">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1DistObject.html#a66edb1059ed7db04325605df64fe64c5">buffer_device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permuteFromLIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a>&#160;</td>
          <td class="paramname"><em>CM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1DistObject.html#a87c43585393cbe182ab96e31389e90fa">execution_space</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as copyAndPermute, but do operations in <code>space</code>. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00837">837</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="ab1ee2f568f2d24bbf1b10d6b3db65043" name="ab1ee2f568f2d24bbf1b10d6b3db65043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ee2f568f2d24bbf1b10d6b3db65043">&#9670;&#160;</a></span>packAndPrepare() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::packAndPrepare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html#abdb5bf693fecbdadb80ba6e9f2891106">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>exportLIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kokkos::DualView&lt; packet_type *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>exports</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt;&#160;</td>
          <td class="paramname"><em>numPacketsPerLID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>constantNumPackets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>&lt; <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> overloads packAndPrepare. Explicitly use <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a>'s packAndPrepare for anything we don't override </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html#l00437">437</a> of file <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html">Tpetra_BlockMultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a484241212e4d1ca7c2669a6729b57801" name="a484241212e4d1ca7c2669a6729b57801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484241212e4d1ca7c2669a6729b57801">&#9670;&#160;</a></span>packAndPrepare() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::packAndPrepare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1DistObject.html#a6704de48b06419ddaa09161663702858">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1DistObject.html#a66edb1059ed7db04325605df64fe64c5">buffer_device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>exportLIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1DistObject.html#a79749ff4d4160e4c97116d564f66af92">packet_type</a> *, <a class="el" href="classTpetra_1_1DistObject.html#a66edb1059ed7db04325605df64fe64c5">buffer_device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>exports</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> *, <a class="el" href="classTpetra_1_1DistObject.html#a66edb1059ed7db04325605df64fe64c5">buffer_device_type</a> &gt;&#160;</td>
          <td class="paramname"><em>numPacketsPerLID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>constantNumPackets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack data and metadata for communication (sends). </p>
<p>Subclasses <em>must</em> reimplement this function. Its default implementation does nothing. Note that the &lt;t&gt;target object of the <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> or <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a>, namely <code>*this</code>, packs the <em>source</em> object's data.</p>
<dl class="section pre"><dt>Precondition</dt><dd>exportLIDs is sync'd to both host and device. That is, <code>exportLIDs.need_sync_host ()</code> and <code>exportLIDs.need_sync_device()</code> are both false.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>[in] Source object for the redistribution.</td></tr>
    <tr><td class="paramname">exportLIDs</td><td>[in] List of the entries (as local IDs in the source object) that <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> will send to other processes.</td></tr>
    <tr><td class="paramname">exports</td><td>[out] On exit, the packed data to send. Implementations must reallocate this as needed (prefer reusing the existing allocation if possible), and may modify and/or sync this wherever they like.</td></tr>
    <tr><td class="paramname">numPacketsPerLID</td><td>[out] On exit, the implementation of this method must do one of two things: either set <code>numPacketsPerLID[i]</code> to the number of packets to be packed for <code>exportLIDs[i]</code> and set <code>constantNumPackets</code> to zero, or set <code>constantNumPackets</code> to a nonzero value. If the latter, the implementation must not modify the entries of <code>numPacketsPerLID</code>. If the former, the implementation may sync <code>numPacketsPerLID</code> this wherever it likes, either to host or to device. The allocation belongs to <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a>, not to subclasses; don't be tempted to change this to pass by reference.</td></tr>
    <tr><td class="paramname">constantNumPackets</td><td>[out] On exit, 0 if the number of packets per LID could differ, else (if nonzero) the number of packets per LID (which must be constant). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00881">881</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="af3fead8f57b7d0157e507847f3f04f1e" name="af3fead8f57b7d0157e507847f3f04f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fead8f57b7d0157e507847f3f04f1e">&#9670;&#160;</a></span>packAndPrepare() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::packAndPrepare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1DistObject.html#a6704de48b06419ddaa09161663702858">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1DistObject.html#a66edb1059ed7db04325605df64fe64c5">buffer_device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>exportLIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1DistObject.html#a79749ff4d4160e4c97116d564f66af92">packet_type</a> *, <a class="el" href="classTpetra_1_1DistObject.html#a66edb1059ed7db04325605df64fe64c5">buffer_device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>exports</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> *, <a class="el" href="classTpetra_1_1DistObject.html#a66edb1059ed7db04325605df64fe64c5">buffer_device_type</a> &gt;&#160;</td>
          <td class="paramname"><em>numPacketsPerLID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>constantNumPackets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1DistObject.html#a87c43585393cbe182ab96e31389e90fa">execution_space</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as packAndPrepare, but in an execution space instance. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00894">894</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="acf10ddd3bae75a3fa36d0d99fcaa245e" name="acf10ddd3bae75a3fa36d0d99fcaa245e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf10ddd3bae75a3fa36d0d99fcaa245e">&#9670;&#160;</a></span>unpackAndCombine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::unpackAndCombine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html#abdb5bf693fecbdadb80ba6e9f2891106">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>importLIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kokkos::DualView&lt; packet_type *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt;&#160;</td>
          <td class="paramname"><em>imports</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> *, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a> &gt;&#160;</td>
          <td class="paramname"><em>numPacketsPerLID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a>&#160;</td>
          <td class="paramname"><em>constantNumPackets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a>&#160;</td>
          <td class="paramname"><em>combineMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>&lt; <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> has overloaded unpackAndCombine, use the <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a>'s implementation for anything we don't override. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html#l00453">453</a> of file <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html">Tpetra_BlockMultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a9cb9c5a5d2e5532768bb494a583d2ab0" name="a9cb9c5a5d2e5532768bb494a583d2ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb9c5a5d2e5532768bb494a583d2ab0">&#9670;&#160;</a></span>unpackAndCombine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::unpackAndCombine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1DistObject.html#a6704de48b06419ddaa09161663702858">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1DistObject.html#a66edb1059ed7db04325605df64fe64c5">buffer_device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>importLIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1DistObject.html#a79749ff4d4160e4c97116d564f66af92">packet_type</a> *, <a class="el" href="classTpetra_1_1DistObject.html#a66edb1059ed7db04325605df64fe64c5">buffer_device_type</a> &gt;&#160;</td>
          <td class="paramname"><em>imports</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> *, <a class="el" href="classTpetra_1_1DistObject.html#a66edb1059ed7db04325605df64fe64c5">buffer_device_type</a> &gt;&#160;</td>
          <td class="paramname"><em>numPacketsPerLID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a>&#160;</td>
          <td class="paramname"><em>constantNumPackets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a>&#160;</td>
          <td class="paramname"><em>combineMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform any unpacking and combining after communication. </p>
<p>Subclasses <em>must</em> reimplement this function. Its default implementation does nothing. Note that the &lt;t&gt;target object of the <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> or <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a>, namely <code>*this</code>, unpacks the received data into itself, possibly modifying its entries.</p>
<dl class="section pre"><dt>Precondition</dt><dd>importLIDs is sync'd to both host and device. That is, <code>importLIDs.need_sync_host ()</code> and <code>importLIDs.need_sync_device()</code> are both false.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">importLIDs</td><td>[in] List of the entries (as LIDs in the destination object) we received from other processes.</td></tr>
    <tr><td class="paramname">imports</td><td>[in/out] On input: Buffer of received data to unpack. <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> promises nothing about where this is sync'd. Implementations may sync this wherever they like, either to host or to device. The allocation belongs to <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a>, not to subclasses; don't be tempted to change this to pass by reference.</td></tr>
    <tr><td class="paramname">numPacketsPerLID</td><td>[in/out] On input: If <code>constantNumPackets</code> is zero, then <code>numPacketsPerLID[i]</code> contains the number of packets imported for importLIDs[i]. <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> promises nothing about where this is sync'd. Implementations may sync this wherever they like, either to host or to device. The allocation belongs to <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a>, not to subclasses; don't be tempted to change this to pass by reference.</td></tr>
    <tr><td class="paramname">constantNumPackets</td><td>[in] If nonzero, then the number of packets per LID is the same for all entries ("constant") and <code>constantNumPackets</code> is that number. If zero, then <code>numPacketsPerLID[i]</code> is the number of packets to unpack for LID <code>importLIDs[i]</code>.</td></tr>
    <tr><td class="paramname">combineMode</td><td>[in] The CombineMode to use when combining the imported entries with existing entries. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00945">945</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="ab89a38befd2575fc02a5cfe09181ca02" name="ab89a38befd2575fc02a5cfe09181ca02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89a38befd2575fc02a5cfe09181ca02">&#9670;&#160;</a></span>getStrideX()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::getStrideX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stride between consecutive local entries in the same column. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__decl_8hpp_source.html#l00569">569</a> of file <a class="el" href="Tpetra__BlockMultiVector__decl_8hpp_source.html">Tpetra_BlockMultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="ade7f05ce972bc3ef2017cd2fc9c6382e" name="ade7f05ce972bc3ef2017cd2fc9c6382e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7f05ce972bc3ef2017cd2fc9c6382e">&#9670;&#160;</a></span>getStrideY()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::getStrideY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stride between consecutive local entries in the same row. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__decl_8hpp_source.html#l00574">574</a> of file <a class="el" href="Tpetra__BlockMultiVector__decl_8hpp_source.html">Tpetra_BlockMultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="ae1fe21a288215100555aa30c730ee529" name="ae1fe21a288215100555aa30c730ee529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1fe21a288215100555aa30c730ee529">&#9670;&#160;</a></span>isValidLocalMeshIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::isValidLocalMeshIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> LO&#160;</td>
          <td class="paramname"><em>meshLocalIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if and only if <code>meshLocalIndex</code> is a valid local index in the mesh <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html#l00470">470</a> of file <a class="el" href="Tpetra__BlockMultiVector__def_8hpp_source.html">Tpetra_BlockMultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a2e2cce34ee9698060f87e1fad3695a2d" name="a2e2cce34ee9698060f87e1fad3695a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2cce34ee9698060f87e1fad3695a2d">&#9670;&#160;</a></span>doImport() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::doImport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Import.html">Import</a>&lt; LO , GO , Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>importer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a>&#160;</td>
          <td class="paramname"><em>CM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td>
          <td class="paramname"><em>restrictedMode</em> = <code><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> data into this object using an <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> object ("forward mode"). </p>
<p>The input <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> is always the source of the data redistribution operation, and the <code>*this</code> object is always the target.</p>
<p>If you don't know the difference between forward and reverse mode, then you probably want forward mode. Use this method with your precomputed <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> object if you want to do an <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a>, else use <a class="el" href="classTpetra_1_1DistObject.html#ad2623c99b47ce9d88692abdc094d8be6" title="Export data into this object using an Export object (&quot;forward mode&quot;).">doExport()</a> with a precomputed <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> object.</p>
<p>"Restricted Mode" does two things: </p><ol>
<li>
Skips copyAndPermute  </li>
<li>
Allows the "target" <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> of the transfer to be a subset of the <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> of <code>*this</code>, in a "locallyFitted" sense.  </li>
</ol>
<p>This cannot be used if (2) is not true, OR there are permutes. The "source" maps still need to match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>[in] The "source" object for redistribution. </td></tr>
    <tr><td class="paramname">importer</td><td>[in] Precomputed data redistribution plan. Its source <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> must be the same as the input <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a>'s <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>, and its target <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> must be the same as <code>this-&gt;<a class="el" href="classTpetra_1_1DistObject.html#adef545d3737b47c030e0e6a3e7d8b1e7" title="The Map describing the parallel distribution of this object.">getMap()</a></code>. </td></tr>
    <tr><td class="paramname">CM</td><td>[in] How to combine incoming data with the same global index. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00379">379</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="a0cbd89e8cf8df8d477f2c541db4d3215" name="a0cbd89e8cf8df8d477f2c541db4d3215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cbd89e8cf8df8d477f2c541db4d3215">&#9670;&#160;</a></span>doImport() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::doImport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Export.html">Export</a>&lt; LO , GO , Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>exporter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a>&#160;</td>
          <td class="paramname"><em>CM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td>
          <td class="paramname"><em>restrictedMode</em> = <code><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> data into this object using an <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> object ("reverse mode"). </p>
<p>The input <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> is always the source of the data redistribution operation, and the <code>*this</code> object is always the target.</p>
<p>If you don't know the difference between forward and reverse mode, then you probably want forward mode. Use the version of <a class="el" href="classTpetra_1_1DistObject.html#a2e2cce34ee9698060f87e1fad3695a2d" title="Import data into this object using an Import object (&quot;forward mode&quot;).">doImport()</a> that takes a precomputed <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> object in that case.</p>
<p>"Restricted Mode" does two things: </p><ol>
<li>
Skips copyAndPermute  </li>
<li>
Allows the "target" <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> of the transfer to be a subset of the <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> of <code>*this</code>, in a "locallyFitted" sense.  </li>
</ol>
<p>This cannot be used if (2) is not true, OR there are permutes. The "source" maps still need to match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>[in] The "source" object for redistribution. </td></tr>
    <tr><td class="paramname">exporter</td><td>[in] Precomputed data redistribution plan. Its <em>target</em> <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> must be the same as the input <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a>'s <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>, and its <em>source</em> <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> must be the same as <code>this-&gt;<a class="el" href="classTpetra_1_1DistObject.html#adef545d3737b47c030e0e6a3e7d8b1e7" title="The Map describing the parallel distribution of this object.">getMap()</a></code>. (Note the difference from forward mode.) </td></tr>
    <tr><td class="paramname">CM</td><td>[in] How to combine incoming data with the same global index. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00446">446</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="ad2623c99b47ce9d88692abdc094d8be6" name="ad2623c99b47ce9d88692abdc094d8be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2623c99b47ce9d88692abdc094d8be6">&#9670;&#160;</a></span>doExport() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::doExport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Export.html">Export</a>&lt; LO , GO , Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>exporter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a>&#160;</td>
          <td class="paramname"><em>CM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td>
          <td class="paramname"><em>restrictedMode</em> = <code><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> data into this object using an <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> object ("forward mode"). </p>
<p>The input <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> is always the source of the data redistribution operation, and the <code>*this</code> object is always the target.</p>
<p>If you don't know the difference between forward and reverse mode, then you probably want forward mode. Use this method with your precomputed <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> object if you want to do an <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a>, else use <a class="el" href="classTpetra_1_1DistObject.html#a2e2cce34ee9698060f87e1fad3695a2d" title="Import data into this object using an Import object (&quot;forward mode&quot;).">doImport()</a> with a precomputed <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> object.</p>
<p>"Restricted Mode" does two things: </p><ol>
<li>
Skips copyAndPermute  </li>
<li>
Allows the "target" <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> of the transfer to be a subset of the <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> of <code>*this</code>, in a "locallyFitted" sense.  </li>
</ol>
<p>This cannot be used if (2) is not true, OR there are permutes. The "source" maps still need to match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>[in] The "source" object for redistribution. </td></tr>
    <tr><td class="paramname">exporter</td><td>[in] Precomputed data redistribution plan. Its source <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> must be the same as the input <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a>'s <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>, and its target <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> must be the same as <code>this-&gt;<a class="el" href="classTpetra_1_1DistObject.html#adef545d3737b47c030e0e6a3e7d8b1e7" title="The Map describing the parallel distribution of this object.">getMap()</a></code>. </td></tr>
    <tr><td class="paramname">CM</td><td>[in] How to combine incoming data with the same global index. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00412">412</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="a5b766629940d0400aa98e113b4e5ef3c" name="a5b766629940d0400aa98e113b4e5ef3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b766629940d0400aa98e113b4e5ef3c">&#9670;&#160;</a></span>doExport() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::doExport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Import.html">Import</a>&lt; LO , GO , Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>importer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a>&#160;</td>
          <td class="paramname"><em>CM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td>
          <td class="paramname"><em>restrictedMode</em> = <code><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> data into this object using an <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> object ("reverse mode"). </p>
<p>The input <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> is always the source of the data redistribution operation, and the <code>*this</code> object is always the target.</p>
<p>If you don't know the difference between forward and reverse mode, then you probably want forward mode. Use the version of <a class="el" href="classTpetra_1_1DistObject.html#ad2623c99b47ce9d88692abdc094d8be6" title="Export data into this object using an Export object (&quot;forward mode&quot;).">doExport()</a> that takes a precomputed <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> object in that case.</p>
<p>"Restricted Mode" does two things: </p><ol>
<li>
Skips copyAndPermute  </li>
<li>
Allows the "target" <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> of the transfer to be a subset of the <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> of <code>*this</code>, in a "locallyFitted" sense.  </li>
</ol>
<p>This cannot be used if (2) is not true, OR there are permutes. The "source" maps still need to match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>[in] The "source" object for redistribution. </td></tr>
    <tr><td class="paramname">importer</td><td>[in] Precomputed data redistribution plan. Its <em>target</em> <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> must be the same as the input <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a>'s <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>, and its <em>source</em> <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> must be the same as <code>this-&gt;<a class="el" href="classTpetra_1_1DistObject.html#adef545d3737b47c030e0e6a3e7d8b1e7" title="The Map describing the parallel distribution of this object.">getMap()</a></code>. (Note the difference from forward mode.) </td></tr>
    <tr><td class="paramname">CM</td><td>[in] How to combine incoming data with the same global index. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00480">480</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="a47ad53419477919faf1acdcfc4d65daa" name="a47ad53419477919faf1acdcfc4d65daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ad53419477919faf1acdcfc4d65daa">&#9670;&#160;</a></span>transferArrived()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::transferArrived </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the data from an import/export operation has arrived, and is ready for the unpack and combine step. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00535">535</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="afc178c45d66d8232f27b1e79fc0e1535" name="afc178c45d66d8232f27b1e79fc0e1535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc178c45d66d8232f27b1e79fc0e1535">&#9670;&#160;</a></span>isDistributed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::isDistributed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether this is a globally distributed object. </p>
<p>For a definition of "globally distributed" (and its opposite, "locally replicated"), see the documentation of <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>'s <a class="el" href="classTpetra_1_1DistObject.html#afc178c45d66d8232f27b1e79fc0e1535" title="Whether this is a globally distributed object.">isDistributed()</a> method. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00546">546</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="adef545d3737b47c030e0e6a3e7d8b1e7" name="adef545d3737b47c030e0e6a3e7d8b1e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef545d3737b47c030e0e6a3e7d8b1e7">&#9670;&#160;</a></span>getMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a> &gt; <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::getMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> describing the parallel distribution of this object. </p>
<p>Note that some <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> objects might be distributed using multiple <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> objects. For example, <a class="el" href="classTpetra_1_1CrsMatrix.html" title="Sparse matrix that presents a row-oriented interface that lets users read or modify entries.">CrsMatrix</a> has both a row <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> and a column <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>. It is up to the subclass to decide which <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> to use when invoking the <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> constructor. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html#l00554">554</a> of file <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html">Tpetra_DistObject_decl.hpp</a>.</p>

</div>
</div>
<a id="a8f39be1272b2b218c6b734d30fdb7956" name="a8f39be1272b2b218c6b734d30fdb7956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f39be1272b2b218c6b734d30fdb7956">&#9670;&#160;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print this object to the given output stream. </p>
<p>We generally assume that all MPI processes can print to the given stream. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00564">564</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="adeca5fe82d6ff5af11d1fcb78753c1ef" name="adeca5fe82d6ff5af11d1fcb78753c1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeca5fe82d6ff5af11d1fcb78753c1ef">&#9670;&#160;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>One-line descriptiion of this object. </p>
<p>We declare this method virtual so that subclasses of <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> may override it. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00574">574</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="a05ae001a87e9a244a334891d33de8fc7" name="a05ae001a87e9a244a334891d33de8fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ae001a87e9a244a334891d33de8fc7">&#9670;&#160;</a></span>describe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::describe </td>
          <td>(</td>
          <td class="paramtype">Teuchos::FancyOStream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::EVerbosityLevel&#160;</td>
          <td class="paramname"><em>verbLevel</em> = <code>Teuchos::Describable::verbLevel_default</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a descriptiion of this object to the given output stream. </p>
<p>We declare this method virtual so that subclasses of Distobject may override it. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00581">581</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="aead0431a5e0fcdcb0b2147f8351b7792" name="aead0431a5e0fcdcb0b2147f8351b7792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead0431a5e0fcdcb0b2147f8351b7792">&#9670;&#160;</a></span>removeEmptyProcessesInPlace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::removeEmptyProcessesInPlace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1DistObject.html#a68d6fd7d67100f1b886af5fb2636efed">map_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove processes which contain no entries in this object's <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method is ONLY for use by experts. We highly recommend using the nonmember function of the same name defined in this file.</dd>
<dd>
We make NO promises of backwards compatibility. This method may change or disappear at any time.</dd></dl>
<p>On input, this object is distributed over the <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> returned by <a class="el" href="classTpetra_1_1DistObject.html#adef545d3737b47c030e0e6a3e7d8b1e7" title="The Map describing the parallel distribution of this object.">getMap()</a> (the "original Map," with its communicator, the "original communicator"). The input <code>newMap</code> of this method <em>must</em> be the same as the result of calling <code><a class="el" href="classTpetra_1_1DistObject.html#adef545d3737b47c030e0e6a3e7d8b1e7" title="The Map describing the parallel distribution of this object.">getMap()</a>-&gt;removeEmptyProcesses()</code>. On processes in the original communicator which contain zero entries ("excluded processes," as opposed to "included processes"), the input <code>newMap</code> must be <code>Teuchos::null</code> (which is what <code><a class="el" href="classTpetra_1_1DistObject.html#adef545d3737b47c030e0e6a3e7d8b1e7" title="The Map describing the parallel distribution of this object.">getMap()</a>-&gt;removeEmptyProcesses()</code> returns anyway).</p>
<p>On included processes, reassign this object's <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> (that would be returned by <a class="el" href="classTpetra_1_1DistObject.html#adef545d3737b47c030e0e6a3e7d8b1e7" title="The Map describing the parallel distribution of this object.">getMap()</a>) to the input <code>newMap</code>, and do any work that needs to be done to restore correct semantics. On excluded processes, free any data that needs freeing, and do any other work that needs to be done to restore correct semantics.</p>
<p>This method has collective semantics over the original communicator. On exit, the only method of this object which is safe to call on excluded processes is the destructor. This implies that subclasses' destructors must not contain communication operations.</p>
<dl class="section return"><dt>Returns</dt><dd>The object's new <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>. Its communicator is a new communicator, distinct from the old <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>'s communicator, which contains a subset of the processes in the old communicator.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The name differs from <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>'s method removeEmptyProcesses(), in order to emphasize that the operation on <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> happens in place, modifying the input, whereas the operation removeEmptyProcess() on <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> does not modify the input.</dd>
<dd>
To implementers of <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> subclasses: The default implementation of this class throws std::logic_error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00636">636</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="ad126b78ec8e6971e3e219629691c95c8" name="ad126b78ec8e6971e3e219629691c95c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad126b78ec8e6971e3e219629691c95c8">&#9670;&#160;</a></span>constantNumberOfPackets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::constantNumberOfPackets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the implementation's instance promises always to have a constant number of packets per LID (local index), and if so, how many packets per LID there are. </p>
<p>If this method returns zero, the instance says that it might possibly have a different number of packets for each LID (local index) to send or receive. If it returns nonzero, the instance promises that the number of packets is the same for all LIDs, and that the return value is this number of packets per LID.</p>
<p>The default implementation of this method returns zero. This does not affect the behavior of <a class="el" href="classTpetra_1_1DistObject.html#a82a9a5fd0df1dda55188a340e6b5a2e7" title="Redistribute data across (MPI) processes.">doTransfer()</a> in any way. If a nondefault implementation returns nonzero, <a class="el" href="classTpetra_1_1DistObject.html#a82a9a5fd0df1dda55188a340e6b5a2e7" title="Redistribute data across (MPI) processes.">doTransfer()</a> will use this information to avoid unnecessary allocation and / or resizing of arrays. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00670">670</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="a82a9a5fd0df1dda55188a340e6b5a2e7" name="a82a9a5fd0df1dda55188a340e6b5a2e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a9a5fd0df1dda55188a340e6b5a2e7">&#9670;&#160;</a></span>doTransfer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::doTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Details_1_1Transfer.html">::Tpetra::Details::Transfer</a>&lt; <a class="el" href="classTpetra_1_1DistObject.html#a6704de48b06419ddaa09161663702858">local_ordinal_type</a>, <a class="el" href="classTpetra_1_1DistObject.html#a929719b0e24ee6bc9a2c9a58aa155250">global_ordinal_type</a>, <a class="el" href="classTpetra_1_1DistObject.html#acd680979e0f221fb01fd28676da4e79d">node_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">char</a>&#160;</td>
          <td class="paramname"><em>modeString</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1DistObject.html#ac1ff98c164c772986e2a5db411a311ab">ReverseOption</a>&#160;</td>
          <td class="paramname"><em>revOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a>&#160;</td>
          <td class="paramname"><em>CM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td>
          <td class="paramname"><em>restrictedMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redistribute data across (MPI) processes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>[in] The source object, to redistribute into the target object, which is <code>*this</code> object.</td></tr>
    <tr><td class="paramname">transfer</td><td>[in] The <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> or <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> object representing the communication pattern. (<a class="el" href="classTpetra_1_1Details_1_1Transfer.html" title="Common base class of Import and Export.">Details::Transfer</a> is the common base class of these two objects.)</td></tr>
    <tr><td class="paramname">modeString</td><td>[in] Human-readable string, for verbose debugging output and error output, explaining what function called this method. Example: "doImport (forward)", "doExport (reverse)".</td></tr>
    <tr><td class="paramname">revOp</td><td>[in] Whether to do a forward or reverse mode redistribution.</td></tr>
    <tr><td class="paramname">CM</td><td>[in] The combine mode that describes how to combine values that map to the same global ID on the same process. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00692">692</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="a20429024546804acef2060050d1b22f8" name="a20429024546804acef2060050d1b22f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20429024546804acef2060050d1b22f8">&#9670;&#160;</a></span>reallocArraysForNumPacketsPerLid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::reallocArraysForNumPacketsPerLid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a>&#160;</td>
          <td class="paramname"><em>numExportLIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a>&#160;</td>
          <td class="paramname"><em>numImportLIDs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reallocate numExportPacketsPerLID_ and/or numImportPacketsPerLID_, if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numExportLIDs</td><td>[in] Number of entries in the exportLIDs input array argument of <a class="el" href="classTpetra_1_1DistObject.html#a82a9a5fd0df1dda55188a340e6b5a2e7" title="Redistribute data across (MPI) processes.">doTransfer()</a>.</td></tr>
    <tr><td class="paramname">numImportLIDs</td><td>[in] Number of entries in the remoteLIDs input array argument of <a class="el" href="classTpetra_1_1DistObject.html#a82a9a5fd0df1dda55188a340e6b5a2e7" title="Redistribute data across (MPI) processes.">doTransfer()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether we actually reallocated either of the arrays.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is an implementation detail of doTransferNew(). This needs to be protected, but that doesn't mean users should call this method. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00714">714</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="a30a2256ab638b7f329b752535553f480" name="a30a2256ab638b7f329b752535553f480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a2256ab638b7f329b752535553f480">&#9670;&#160;</a></span>beginTransfer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::beginTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Details_1_1Transfer.html">::Tpetra::Details::Transfer</a>&lt; <a class="el" href="classTpetra_1_1DistObject.html#a6704de48b06419ddaa09161663702858">local_ordinal_type</a>, <a class="el" href="classTpetra_1_1DistObject.html#a929719b0e24ee6bc9a2c9a58aa155250">global_ordinal_type</a>, <a class="el" href="classTpetra_1_1DistObject.html#acd680979e0f221fb01fd28676da4e79d">node_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">char</a>&#160;</td>
          <td class="paramname"><em>modeString</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1DistObject.html#ac1ff98c164c772986e2a5db411a311ab">ReverseOption</a>&#160;</td>
          <td class="paramname"><em>revOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a>&#160;</td>
          <td class="paramname"><em>CM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td>
          <td class="paramname"><em>restrictedMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation detail of doTransfer. </p>
<p>LID DualViews come from the Transfer object given to doTransfer. They are <em>always</em> sync'd on both host and device. Users must never attempt to modify or sync them. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00743">743</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="a065de0c79a89661fe820856212ad776f" name="a065de0c79a89661fe820856212ad776f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065de0c79a89661fe820856212ad776f">&#9670;&#160;</a></span>reallocImportsIfNeeded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::reallocImportsIfNeeded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a>&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> std::string *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td>
          <td class="paramname"><em>remoteLIDsContiguous</em> = <code><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a>&#160;</td>
          <td class="paramname"><em>CM</em> = <code>INSERT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reallocate imports_ if needed. </p>
<p>This unfortunately must be declared protected, for the same reason that imports_ is declared protected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>[in] New size of imports_. </td></tr>
    <tr><td class="paramname">verbose</td><td>[in] Whether to print verbose debugging output to stderr on every (MPI) process in the communicator. </td></tr>
    <tr><td class="paramname">prefix</td><td>[in] If <code>verbose</code> is <code>true</code>, then this is a nonnull prefix to print at the beginning of each line of verbose debugging output. Otherwise, not used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether we actually reallocated.</dd></dl>
<p>We don't need a "reallocExportsIfNeeded" method, because <code>exports_</code> always gets passed into <a class="el" href="classTpetra_1_1BlockMultiVector.html#ab1ee2f568f2d24bbf1b10d6b3db65043">packAndPrepare()</a> by nonconst reference. Thus, that method can resize the DualView without needing to call other <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> methods. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l01004">1004</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2b1ee94e60143c3dea8a7041c17cbcd5" name="a2b1ee94e60143c3dea8a7041c17cbcd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1ee94e60143c3dea8a7041c17cbcd5">&#9670;&#160;</a></span>meshMap_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::meshMap_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mesh <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> given to constructor. </p>
<p>This is stored by value, not as a Teuchos::RCP, because the latter is not thread-safe. I would like GID-&gt;LID lookups to be thread-safe. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__decl_8hpp_source.html#l00587">587</a> of file <a class="el" href="Tpetra__BlockMultiVector__decl_8hpp_source.html">Tpetra_BlockMultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="afe41a8231bf0769f4724d1f7f9b6dc58" name="afe41a8231bf0769f4724d1f7f9b6dc58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe41a8231bf0769f4724d1f7f9b6dc58">&#9670;&#160;</a></span>mv_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1BlockVector.html#a362d442d5d154af1031b11170971a9df">mv_type</a> <a class="el" href="classTpetra_1_1BlockMultiVector.html">Tpetra::BlockMultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, LO, GO, Node &gt;::mv_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">Tpetra::MultiVector</a> used to represent the data. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__BlockMultiVector__decl_8hpp_source.html#l00595">595</a> of file <a class="el" href="Tpetra__BlockMultiVector__decl_8hpp_source.html">Tpetra_BlockMultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="abd8bf976983da5f805c0d7975dfe45dc" name="abd8bf976983da5f805c0d7975dfe45dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8bf976983da5f805c0d7975dfe45dc">&#9670;&#160;</a></span>map_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1BlockVector.html#a4502b2eff5b736e714a37137f29a88ee">map_type</a>&gt; <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::map_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> over which this object is distributed. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html#l00970">970</a> of file <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html">Tpetra_DistObject_decl.hpp</a>.</p>

</div>
</div>
<a id="a1e625c329325c60064dc133de40aed3b" name="a1e625c329325c60064dc133de40aed3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e625c329325c60064dc133de40aed3b">&#9670;&#160;</a></span>imports_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::DualView&lt;packet_type*, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a>&gt; <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::imports_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Buffer into which packed data are imported (received from other processes). </p>
<p>Unfortunately, I had to declare these protected, because <a class="el" href="classTpetra_1_1CrsMatrix.html" title="Sparse matrix that presents a row-oriented interface that lets users read or modify entries.">CrsMatrix</a> uses them at one point. Please, nobody else use them. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html#l00983">983</a> of file <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html">Tpetra_DistObject_decl.hpp</a>.</p>

</div>
</div>
<a id="a1711cc6d0ea3921bd58fa27ba4a4dff8" name="a1711cc6d0ea3921bd58fa27ba4a4dff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1711cc6d0ea3921bd58fa27ba4a4dff8">&#9670;&#160;</a></span>numImportPacketsPerLID_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::DualView&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a>*, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a>&gt; <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::numImportPacketsPerLID_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of packets to receive for each receive operation. </p>
<p>This array is used in <a class="el" href="classTpetra_1_1Distributor.html#a0c2780485997436aa01b53c07908f629" title="Post the data for a forward plan, but do not execute the waits yet.">Distributor::doPosts()</a> (and doReversePosts()) when starting the ireceive operation.</p>
<p>This may be ignored in <a class="el" href="classTpetra_1_1DistObject.html#a82a9a5fd0df1dda55188a340e6b5a2e7" title="Redistribute data across (MPI) processes.">doTransfer()</a> if constantNumPackets is nonzero, indicating a constant number of packets per LID. (For example, <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> sets the constantNumPackets output argument of <a class="el" href="classTpetra_1_1BlockMultiVector.html#ab1ee2f568f2d24bbf1b10d6b3db65043">packAndPrepare()</a> to the number of columns in the multivector.)</p>
<p>Unfortunately, I had to declare this protected, because <a class="el" href="classTpetra_1_1CrsMatrix.html" title="Sparse matrix that presents a row-oriented interface that lets users read or modify entries.">CrsMatrix</a> uses it at one point. Please, nobody else use it. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html#l01023">1023</a> of file <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html">Tpetra_DistObject_decl.hpp</a>.</p>

</div>
</div>
<a id="a1a5ef8b469cce85d13924f7e65318e06" name="a1a5ef8b469cce85d13924f7e65318e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5ef8b469cce85d13924f7e65318e06">&#9670;&#160;</a></span>exports_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::DualView&lt;packet_type*, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a>&gt; <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::exports_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Buffer from which packed data are exported (sent to other processes). </p>
<p>Unfortunately, I had to declare this protected, because <a class="el" href="classTpetra_1_1CrsMatrix.html" title="Sparse matrix that presents a row-oriented interface that lets users read or modify entries.">CrsMatrix</a> uses it at one point. Please, nobody else use it. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html#l01030">1030</a> of file <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html">Tpetra_DistObject_decl.hpp</a>.</p>

</div>
</div>
<a id="a9b397a38b1966ac9833d8990e3cae211" name="a9b397a38b1966ac9833d8990e3cae211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b397a38b1966ac9833d8990e3cae211">&#9670;&#160;</a></span>numExportPacketsPerLID_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::DualView&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">size_t</a>*, <a class="el" href="classTpetra_1_1BlockMultiVector.html#a921098a19077b2db2ca3875e518970db">buffer_device_type</a>&gt; <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , LO , GO , Node &gt;::numExportPacketsPerLID_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of packets to send for each send operation. </p>
<p>This array is used in <a class="el" href="classTpetra_1_1Distributor.html#a0c2780485997436aa01b53c07908f629" title="Post the data for a forward plan, but do not execute the waits yet.">Distributor::doPosts()</a> (and doReversePosts()) for preparing for the send operation.</p>
<p>This may be ignored in <a class="el" href="classTpetra_1_1DistObject.html#a82a9a5fd0df1dda55188a340e6b5a2e7" title="Redistribute data across (MPI) processes.">doTransfer()</a> if constantNumPackets is nonzero, indicating a constant number of packets per LID. (For example, <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> sets the constantNumPackets output argument of <a class="el" href="classTpetra_1_1BlockMultiVector.html#ab1ee2f568f2d24bbf1b10d6b3db65043">packAndPrepare()</a> to the number of columns in the multivector.)</p>
<p>Unfortunately, I had to declare this protected, because <a class="el" href="classTpetra_1_1CrsMatrix.html" title="Sparse matrix that presents a row-oriented interface that lets users read or modify entries.">CrsMatrix</a> uses them at one point. Please, nobody else use it. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html#l01045">1045</a> of file <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html">Tpetra_DistObject_decl.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Tpetra__BlockVector__decl_8hpp_source.html">Tpetra_BlockVector_decl.hpp</a></li>
<li><a class="el" href="Tpetra__BlockVector__def_8hpp_source.html">Tpetra_BlockVector_def.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
