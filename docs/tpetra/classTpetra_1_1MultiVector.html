<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tpetra parallel linear algebra: Tpetra::MultiVector&lt; Scalar, LocalOrdinal, GlobalOrdinal, Node &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tpetra parallel linear algebra<span id="projectnumber">&#160;Version of the Day</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceTpetra.html">Tpetra</a></li><li class="navelem"><a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#related">Related Symbols</a> &#124;
<a href="classTpetra_1_1MultiVector-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Tpetra::MultiVector&lt; Scalar, LocalOrdinal, GlobalOrdinal, Node &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>One or more distributed dense vectors.  
 <a href="classTpetra_1_1MultiVector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Tpetra::MultiVector&lt; Scalar, LocalOrdinal, GlobalOrdinal, Node &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classTpetra_1_1MultiVector__inherit__graph.gif" border="0" usemap="#aTpetra_1_1MultiVector_3_01Scalar_00_01LocalOrdinal_00_01GlobalOrdinal_00_01Node_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aTpetra_1_1MultiVector_3_01Scalar_00_01LocalOrdinal_00_01GlobalOrdinal_00_01Node_01_4_inherit__map" id="aTpetra_1_1MultiVector_3_01Scalar_00_01LocalOrdinal_00_01GlobalOrdinal_00_01Node_01_4_inherit__map">
<area shape="rect" title="One or more distributed dense vectors." alt="" coords="809,41,981,96"/>
<area shape="rect" href="classTpetra_1_1Vector.html" title="A distributed dense vector." alt="" coords="1199,5,1407,60"/>
<area shape="poly" title=" " alt="" coords="995,57,1198,39,1199,44,995,63"/>
<area shape="rect" href="classTpetra_1_1MultiVector.html" title=" " alt="" coords="1209,85,1396,125"/>
<area shape="poly" title=" " alt="" coords="995,76,1006,77,1210,94,1209,100,1005,82,995,81"/>
<area shape="rect" href="classTpetra_1_1DistObject.html" title=" " alt="" coords="588,41,760,96"/>
<area shape="poly" title=" " alt="" coords="774,66,809,66,809,71,774,71"/>
<area shape="rect" href="classTpetra_1_1SrcDistObject.html" title="Abstract base class for objects that can be the source of an Import or Export operation." alt="" coords="5,60,165,85"/>
<area shape="poly" title=" " alt="" coords="179,65,215,63,389,54,466,52,564,55,588,57,588,62,564,61,466,58,389,59,215,69,179,70"/>
<area shape="rect" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution." alt="" coords="215,77,387,132"/>
<area shape="poly" title=" " alt="" coords="180,84,215,89,214,95,179,89"/>
<area shape="poly" title=" " alt="" coords="401,98,564,85,588,81,588,87,564,90,401,103"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Typedefs to facilitate template metaprogramming.</div></td></tr>
<tr class="memitem:a798f64a312664da3cc1e43738c4c0ec0" id="r_a798f64a312664da3cc1e43738c4c0ec0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a798f64a312664da3cc1e43738c4c0ec0">scalar_type</a> = <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a></td></tr>
<tr class="memdesc:a798f64a312664da3cc1e43738c4c0ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of each entry in the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>.  <br /></td></tr>
<tr class="separator:a798f64a312664da3cc1e43738c4c0ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6015995ea4c087f317aada3994fbd01" id="r_aa6015995ea4c087f317aada3994fbd01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> = <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> Kokkos::ArithTraits&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &gt;::val_type</td></tr>
<tr class="memdesc:aa6015995ea4c087f317aada3994fbd01"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used internally in place of <code>Scalar</code>.  <br /></td></tr>
<tr class="separator:aa6015995ea4c087f317aada3994fbd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13797b2505f2b68367b4d4413a2f98c" id="r_aa13797b2505f2b68367b4d4413a2f98c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> = <a class="el" href="classTpetra_1_1Map.html">Map</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;</td></tr>
<tr class="memdesc:aa13797b2505f2b68367b4d4413a2f98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> specialization used by this class.  <br /></td></tr>
<tr class="separator:aa13797b2505f2b68367b4d4413a2f98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e770e950420cc2a0b3018f1fe9315b" id="r_a23e770e950420cc2a0b3018f1fe9315b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a23e770e950420cc2a0b3018f1fe9315b">local_ordinal_type</a> = <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1Map.html#a777128f8251acb73e09af1a4689ed9f0">map_type::local_ordinal_type</a></td></tr>
<tr class="memdesc:a23e770e950420cc2a0b3018f1fe9315b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of local indices that this class uses.  <br /></td></tr>
<tr class="separator:a23e770e950420cc2a0b3018f1fe9315b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040b35e734b4162bba42c5a6d2f53d10" id="r_a040b35e734b4162bba42c5a6d2f53d10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a040b35e734b4162bba42c5a6d2f53d10">global_ordinal_type</a> = <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1Map.html#a37b210a895282f8575a3e48837a58aab">map_type::global_ordinal_type</a></td></tr>
<tr class="memdesc:a040b35e734b4162bba42c5a6d2f53d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of global indices that this class uses.  <br /></td></tr>
<tr class="separator:a040b35e734b4162bba42c5a6d2f53d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9114e22e58c9c70b153b341c4f6134d0" id="r_a9114e22e58c9c70b153b341c4f6134d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a9114e22e58c9c70b153b341c4f6134d0">device_type</a> = <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1Map.html#afc10fafadc443d72af3be25dfb944b51">map_type::device_type</a></td></tr>
<tr class="memdesc:a9114e22e58c9c70b153b341c4f6134d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class' preferred Kokkos device type.  <br /></td></tr>
<tr class="separator:a9114e22e58c9c70b153b341c4f6134d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2eafc5434402b790165efbf5418dae" id="r_a0e2eafc5434402b790165efbf5418dae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a0e2eafc5434402b790165efbf5418dae">node_type</a> = <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1Map.html#a29e003133a7ac66aa92439e07c455af4">map_type::node_type</a></td></tr>
<tr class="memdesc:a0e2eafc5434402b790165efbf5418dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legacy thing that you should not use any more.  <br /></td></tr>
<tr class="separator:a0e2eafc5434402b790165efbf5418dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5ff6294071bb6f75dd92fa8e9b1bda" id="r_a6b5ff6294071bb6f75dd92fa8e9b1bda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a6b5ff6294071bb6f75dd92fa8e9b1bda">dot_type</a> = <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> Kokkos::Details::InnerProductSpaceTraits&lt; <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &gt;::dot_type</td></tr>
<tr class="memdesc:a6b5ff6294071bb6f75dd92fa8e9b1bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of an inner ("dot") product result.  <br /></td></tr>
<tr class="separator:a6b5ff6294071bb6f75dd92fa8e9b1bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf0baff5a335005840b1ea926822abc" id="r_addf0baff5a335005840b1ea926822abc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#addf0baff5a335005840b1ea926822abc">mag_type</a> = <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> Kokkos::ArithTraits&lt; <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &gt;::mag_type</td></tr>
<tr class="memdesc:addf0baff5a335005840b1ea926822abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a norm result.  <br /></td></tr>
<tr class="separator:addf0baff5a335005840b1ea926822abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52fef102335f8ae2bf93fc45e390757" id="r_ab52fef102335f8ae2bf93fc45e390757"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ab52fef102335f8ae2bf93fc45e390757">execution_space</a> = <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> device_type::execution_space</td></tr>
<tr class="memdesc:ab52fef102335f8ae2bf93fc45e390757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the (new) Kokkos execution space.  <br /></td></tr>
<tr class="separator:ab52fef102335f8ae2bf93fc45e390757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9309c7680bb1030097ec3b8a912329" id="r_a8d9309c7680bb1030097ec3b8a912329"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a8d9309c7680bb1030097ec3b8a912329">dual_view_type</a> = Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> **, Kokkos::LayoutLeft, <a class="el" href="classTpetra_1_1MultiVector.html#a9114e22e58c9c70b153b341c4f6134d0">device_type</a> &gt;</td></tr>
<tr class="memdesc:a8d9309c7680bb1030097ec3b8a912329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kokkos::DualView specialization used by this class.  <br /></td></tr>
<tr class="separator:a8d9309c7680bb1030097ec3b8a912329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Typedefs</div></td></tr>
<tr class="memitem:a79749ff4d4160e4c97116d564f66af92" id="r_a79749ff4d4160e4c97116d564f66af92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a79749ff4d4160e4c97116d564f66af92">packet_type</a> = <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> ::Kokkos::ArithTraits&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &gt;::val_type</td></tr>
<tr class="memdesc:a79749ff4d4160e4c97116d564f66af92"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of each datum being sent or received in an <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> or <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a>.  <br /></td></tr>
<tr class="separator:a79749ff4d4160e4c97116d564f66af92"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Get a copy or view of a subset of rows and/or columns</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The following methods get either a (deep) copy or a view (shallow copy) of a subset of rows and/or columns of the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>. They return one of the following:</p>
<ul>
<li>
Another <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>  </li>
<li>
A Kokkos::View or Kokkos::DualView  </li>
<li>
A Teuchos::ArrayRCP (see the Teuchos Memory Management Classes)  </li>
</ul>
<p>We prefer use of Kokkos classes to Teuchos Memory Management Classes. In particular, Teuchos::ArrayRCP reference counts are not thread safe, while Kokkos::View (and Kokkos::DualView) reference counts are thread safe.</p>
<p>Not all of these methods are valid for a particular <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>. For instance, calling a method that accesses a view of the data in a 1-D format (i.e., get1dView) requires that the target <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> have constant stride.</p>
<p>This category of methods also includes sync(), modify(), and <a class="el" href="classTpetra_1_1MultiVector.html#a59fada0463f4c64162d20e47951f5711" title="Return a view of the local data on a specific device, with the given access mode. The return type is ...">getLocalView()</a>, which help <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> implement DualView semantics. </p>
</div></td></tr>
<tr class="memitem:a69c7c2057bde6ba15c123cb3b9fad83f" id="r_a69c7c2057bde6ba15c123cb3b9fad83f"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a69c7c2057bde6ba15c123cb3b9fad83f">subCopy</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::Range1D &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">colRng</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a69c7c2057bde6ba15c123cb3b9fad83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> with copies of selected columns.  <br /></td></tr>
<tr class="separator:a69c7c2057bde6ba15c123cb3b9fad83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4288a7b4894118c533c2c74e6823f2" id="r_adb4288a7b4894118c533c2c74e6823f2"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#adb4288a7b4894118c533c2c74e6823f2">subCopy</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">cols</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:adb4288a7b4894118c533c2c74e6823f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> with copies of selected columns.  <br /></td></tr>
<tr class="separator:adb4288a7b4894118c533c2c74e6823f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285e244524edddafccde2d67bd2ccff5" id="r_a285e244524edddafccde2d67bd2ccff5"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a285e244524edddafccde2d67bd2ccff5">subView</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::Range1D &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">colRng</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a285e244524edddafccde2d67bd2ccff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> with const views of selected columns.  <br /></td></tr>
<tr class="separator:a285e244524edddafccde2d67bd2ccff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1815cb70d294852d0a0db73d4238bf26" id="r_a1815cb70d294852d0a0db73d4238bf26"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a1815cb70d294852d0a0db73d4238bf26">subView</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">cols</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a1815cb70d294852d0a0db73d4238bf26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> with const views of selected columns.  <br /></td></tr>
<tr class="separator:a1815cb70d294852d0a0db73d4238bf26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfae85bbbad08e633ce9ca5f7fa3957" id="r_accfae85bbbad08e633ce9ca5f7fa3957"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#accfae85bbbad08e633ce9ca5f7fa3957">subViewNonConst</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::Range1D &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">colRng</a>)</td></tr>
<tr class="memdesc:accfae85bbbad08e633ce9ca5f7fa3957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> with views of selected columns.  <br /></td></tr>
<tr class="separator:accfae85bbbad08e633ce9ca5f7fa3957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cd6e8fa9fd0c7e83155ae99c9ca240" id="r_ae7cd6e8fa9fd0c7e83155ae99c9ca240"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ae7cd6e8fa9fd0c7e83155ae99c9ca240">subViewNonConst</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">cols</a>)</td></tr>
<tr class="memdesc:ae7cd6e8fa9fd0c7e83155ae99c9ca240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> with views of selected columns.  <br /></td></tr>
<tr class="separator:ae7cd6e8fa9fd0c7e83155ae99c9ca240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3206f47461023595ff7719a8b2d9af49" id="r_a3206f47461023595ff7719a8b2d9af49"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a3206f47461023595ff7719a8b2d9af49">offsetView</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">subMap</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">offset</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a3206f47461023595ff7719a8b2d9af49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const view of a subset of rows.  <br /></td></tr>
<tr class="separator:a3206f47461023595ff7719a8b2d9af49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8144625014f563392bba7b338e42f80" id="r_ae8144625014f563392bba7b338e42f80"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ae8144625014f563392bba7b338e42f80">offsetViewNonConst</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">subMap</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">offset</a>)</td></tr>
<tr class="memdesc:ae8144625014f563392bba7b338e42f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a nonconst view of a subset of rows.  <br /></td></tr>
<tr class="separator:ae8144625014f563392bba7b338e42f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70768f09fa210af4fe087bdd06594607" id="r_a70768f09fa210af4fe087bdd06594607"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Vector.html">Vector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a70768f09fa210af4fe087bdd06594607">getVector</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">j</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a70768f09fa210af4fe087bdd06594607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Vector</a> which is a const view of column j.  <br /></td></tr>
<tr class="separator:a70768f09fa210af4fe087bdd06594607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d5485e8a14af1b04cecc529eadcab1" id="r_a40d5485e8a14af1b04cecc529eadcab1"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1Vector.html">Vector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a40d5485e8a14af1b04cecc529eadcab1">getVectorNonConst</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">j</a>)</td></tr>
<tr class="memdesc:a40d5485e8a14af1b04cecc529eadcab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Vector</a> which is a nonconst view of column j.  <br /></td></tr>
<tr class="separator:a40d5485e8a14af1b04cecc529eadcab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c24ad7a31e1108e679cd5ba1449eb55" id="r_a6c24ad7a31e1108e679cd5ba1449eb55"><td class="memItemLeft" align="right" valign="top">Teuchos::ArrayRCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a6c24ad7a31e1108e679cd5ba1449eb55">getData</a> (size_t <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">j</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a6c24ad7a31e1108e679cd5ba1449eb55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const view of the local values in a particular vector of this multivector.  <br /></td></tr>
<tr class="separator:a6c24ad7a31e1108e679cd5ba1449eb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1f43d53048705b89b37af8097253c7" id="r_add1f43d53048705b89b37af8097253c7"><td class="memItemLeft" align="right" valign="top">Teuchos::ArrayRCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#add1f43d53048705b89b37af8097253c7">getDataNonConst</a> (size_t <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">j</a>)</td></tr>
<tr class="memdesc:add1f43d53048705b89b37af8097253c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">View of the local values in a particular vector of this multivector.  <br /></td></tr>
<tr class="separator:add1f43d53048705b89b37af8097253c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086e98c453c86b9ef132d6bc242d6204" id="r_a086e98c453c86b9ef132d6bc242d6204"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a086e98c453c86b9ef132d6bc242d6204">get1dCopy</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">A</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LDA</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a086e98c453c86b9ef132d6bc242d6204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the given array with a copy of this multivector's local values.  <br /></td></tr>
<tr class="separator:a086e98c453c86b9ef132d6bc242d6204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc320a72fd71c4f6332c802fbbcf6ff" id="r_abdc320a72fd71c4f6332c802fbbcf6ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#abdc320a72fd71c4f6332c802fbbcf6ff">get2dCopy</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &gt; &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">ArrayOfPtrs</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:abdc320a72fd71c4f6332c802fbbcf6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the given array with a copy of this multivector's local values.  <br /></td></tr>
<tr class="separator:abdc320a72fd71c4f6332c802fbbcf6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecf3d07f3a10ec697787680f0107136" id="r_a7ecf3d07f3a10ec697787680f0107136"><td class="memItemLeft" align="right" valign="top">Teuchos::ArrayRCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a7ecf3d07f3a10ec697787680f0107136">get1dView</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a7ecf3d07f3a10ec697787680f0107136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const persisting (1-D) view of this multivector's local values.  <br /></td></tr>
<tr class="separator:a7ecf3d07f3a10ec697787680f0107136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c6180faec99ce71621ba69fa26ba57" id="r_af0c6180faec99ce71621ba69fa26ba57"><td class="memItemLeft" align="right" valign="top">Teuchos::ArrayRCP&lt; Teuchos::ArrayRCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#af0c6180faec99ce71621ba69fa26ba57">get2dView</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:af0c6180faec99ce71621ba69fa26ba57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return const persisting pointers to values.  <br /></td></tr>
<tr class="separator:af0c6180faec99ce71621ba69fa26ba57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a36ce29f5a84fae0178ff4da3c4ef13" id="r_a3a36ce29f5a84fae0178ff4da3c4ef13"><td class="memItemLeft" align="right" valign="top">Teuchos::ArrayRCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a3a36ce29f5a84fae0178ff4da3c4ef13">get1dViewNonConst</a> ()</td></tr>
<tr class="memdesc:a3a36ce29f5a84fae0178ff4da3c4ef13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nonconst persisting (1-D) view of this multivector's local values.  <br /></td></tr>
<tr class="separator:a3a36ce29f5a84fae0178ff4da3c4ef13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d2421887580f245b8314ad7b32c4cb" id="r_ae2d2421887580f245b8314ad7b32c4cb"><td class="memItemLeft" align="right" valign="top">Teuchos::ArrayRCP&lt; Teuchos::ArrayRCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ae2d2421887580f245b8314ad7b32c4cb">get2dViewNonConst</a> ()</td></tr>
<tr class="memdesc:ae2d2421887580f245b8314ad7b32c4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return non-const persisting pointers to values.  <br /></td></tr>
<tr class="separator:ae2d2421887580f245b8314ad7b32c4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50eeed74463db067da67bf827ec1d00" id="r_ac50eeed74463db067da67bf827ec1d00"><td class="memItemLeft" align="right" valign="top">dual_view_type::t_host::const_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ac50eeed74463db067da67bf827ec1d00">getLocalViewHost</a> (Access::ReadOnlyStruct) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:ac50eeed74463db067da67bf827ec1d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only, up-to-date view of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s local data on host. This requires that there are no live device-space views.  <br /></td></tr>
<tr class="separator:ac50eeed74463db067da67bf827ec1d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cf09ddbb773a570003aeb7fe738adc" id="r_a80cf09ddbb773a570003aeb7fe738adc"><td class="memItemLeft" align="right" valign="top">dual_view_type::t_host&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a80cf09ddbb773a570003aeb7fe738adc">getLocalViewHost</a> (Access::ReadWriteStruct)</td></tr>
<tr class="memdesc:a80cf09ddbb773a570003aeb7fe738adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mutable, up-to-date view of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s local data on host. This requires that there are no live device-space views.  <br /></td></tr>
<tr class="separator:a80cf09ddbb773a570003aeb7fe738adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4444f2cfb79073feca098bf9b44963" id="r_aea4444f2cfb79073feca098bf9b44963"><td class="memItemLeft" align="right" valign="top">dual_view_type::t_host&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#aea4444f2cfb79073feca098bf9b44963">getLocalViewHost</a> (Access::OverwriteAllStruct)</td></tr>
<tr class="memdesc:aea4444f2cfb79073feca098bf9b44963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mutable view of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s local data on host, assuming all existing data will be overwritten. This requires that there are no live device-space views.  <br /></td></tr>
<tr class="separator:aea4444f2cfb79073feca098bf9b44963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4eade004018814a8fff9964abf747e6" id="r_ab4eade004018814a8fff9964abf747e6"><td class="memItemLeft" align="right" valign="top">dual_view_type::t_dev::const_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ab4eade004018814a8fff9964abf747e6">getLocalViewDevice</a> (Access::ReadOnlyStruct) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:ab4eade004018814a8fff9964abf747e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only, up-to-date view of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s local data on device. This requires that there are no live host-space views.  <br /></td></tr>
<tr class="separator:ab4eade004018814a8fff9964abf747e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3224f32298782bc3e10c441b048af7e5" id="r_a3224f32298782bc3e10c441b048af7e5"><td class="memItemLeft" align="right" valign="top">dual_view_type::t_dev&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a3224f32298782bc3e10c441b048af7e5">getLocalViewDevice</a> (Access::ReadWriteStruct)</td></tr>
<tr class="memdesc:a3224f32298782bc3e10c441b048af7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mutable, up-to-date view of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s local data on device. This requires that there are no live host-space views.  <br /></td></tr>
<tr class="separator:a3224f32298782bc3e10c441b048af7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e13fc7838c50960acd1305add495bf" id="r_ac3e13fc7838c50960acd1305add495bf"><td class="memItemLeft" align="right" valign="top">dual_view_type::t_dev&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ac3e13fc7838c50960acd1305add495bf">getLocalViewDevice</a> (Access::OverwriteAllStruct)</td></tr>
<tr class="memdesc:ac3e13fc7838c50960acd1305add495bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mutable view of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s local data on device, assuming all existing data will be overwritten. This requires that there are no live host-space views.  <br /></td></tr>
<tr class="separator:ac3e13fc7838c50960acd1305add495bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa829c0be76771be20a543c01410bd347" id="r_aa829c0be76771be20a543c01410bd347"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1Details_1_1WrappedDualView.html">wrapped_dual_view_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#aa829c0be76771be20a543c01410bd347">getWrappedDualView</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:aa829c0be76771be20a543c01410bd347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the wrapped dual view holding this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s local data.  <br /></td></tr>
<tr class="separator:aa829c0be76771be20a543c01410bd347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f1be5a0c6dfdcd21f41e7d028b0c28" id="r_a79f1be5a0c6dfdcd21f41e7d028b0c28"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">TargetDeviceType</a> &gt; </td></tr>
<tr class="memitem:a79f1be5a0c6dfdcd21f41e7d028b0c28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a79f1be5a0c6dfdcd21f41e7d028b0c28">need_sync</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a79f1be5a0c6dfdcd21f41e7d028b0c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> needs synchronization to the given space.  <br /></td></tr>
<tr class="separator:a79f1be5a0c6dfdcd21f41e7d028b0c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d350c242f5c7132475c42334a76734a" id="r_a6d350c242f5c7132475c42334a76734a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a6d350c242f5c7132475c42334a76734a">need_sync_host</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a6d350c242f5c7132475c42334a76734a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> needs synchronization to the host.  <br /></td></tr>
<tr class="separator:a6d350c242f5c7132475c42334a76734a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9346ae5c04153b94aae8660ecbf8d4" id="r_a4a9346ae5c04153b94aae8660ecbf8d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a4a9346ae5c04153b94aae8660ecbf8d4">need_sync_device</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a4a9346ae5c04153b94aae8660ecbf8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> needs synchronization to the device.  <br /></td></tr>
<tr class="separator:a4a9346ae5c04153b94aae8660ecbf8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fada0463f4c64162d20e47951f5711" id="r_a59fada0463f4c64162d20e47951f5711"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">TargetDeviceType</a> &gt; </td></tr>
<tr class="memitem:a59fada0463f4c64162d20e47951f5711"><td class="memTemplItemLeft" align="right" valign="top">std::remove_reference&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">decltype</a>(std::declval&lt; <a class="el" href="classTpetra_1_1MultiVector.html#a8d9309c7680bb1030097ec3b8a912329">dual_view_type</a> &gt;().<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">templateview</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">TargetDeviceType</a> &gt;())&gt;::type::const_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a59fada0463f4c64162d20e47951f5711">getLocalView</a> (Access::ReadOnlyStruct <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">s</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a59fada0463f4c64162d20e47951f5711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a view of the local data on a specific device, with the given access mode. The return type is either dual_view_type::t_dev, dual_view_type::t_host, or the const_type of one of those.  <br /></td></tr>
<tr class="separator:a59fada0463f4c64162d20e47951f5711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mathematical methods</div></td></tr>
<tr class="memitem:a2c2254963f2d922af64de1ec3c60a6fd" id="r_a2c2254963f2d922af64de1ec3c60a6fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a2c2254963f2d922af64de1ec3c60a6fd">dot</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">A</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1MultiVector.html#a6b5ff6294071bb6f75dd92fa8e9b1bda">dot_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">dots</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a2c2254963f2d922af64de1ec3c60a6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product of each corresponding pair of vectors (columns) in A and B.  <br /></td></tr>
<tr class="separator:a2c2254963f2d922af64de1ec3c60a6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15cc575eac0e0b6b8083418b6590ffd7" id="r_a15cc575eac0e0b6b8083418b6590ffd7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </td></tr>
<tr class="memitem:a15cc575eac0e0b6b8083418b6590ffd7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!(std::is_same&lt; <a class="el" href="classTpetra_1_1MultiVector.html#a6b5ff6294071bb6f75dd92fa8e9b1bda">dot_type</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt;::value), <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a15cc575eac0e0b6b8083418b6590ffd7">dot</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">A</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">dots</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a15cc575eac0e0b6b8083418b6590ffd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product of each corresponding pair of vectors (columns) in A and B.  <br /></td></tr>
<tr class="separator:a15cc575eac0e0b6b8083418b6590ffd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae717f93742231d57d6dbe3f6a6adab30" id="r_ae717f93742231d57d6dbe3f6a6adab30"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </td></tr>
<tr class="memitem:ae717f93742231d57d6dbe3f6a6adab30"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!(std::is_same&lt; <a class="el" href="classTpetra_1_1MultiVector.html#a6b5ff6294071bb6f75dd92fa8e9b1bda">dot_type</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt;::value), <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ae717f93742231d57d6dbe3f6a6adab30">dot</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">A</a>, std::vector&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">dots</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:ae717f93742231d57d6dbe3f6a6adab30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the above <a class="el" href="classTpetra_1_1MultiVector.html#a2c2254963f2d922af64de1ec3c60a6fd" title="Compute the dot product of each corresponding pair of vectors (columns) in A and B.">dot()</a> overload, but for std::vector output.  <br /></td></tr>
<tr class="separator:ae717f93742231d57d6dbe3f6a6adab30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf868fa8bf3932f07fafe542d32d6b58" id="r_abf868fa8bf3932f07fafe542d32d6b58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#abf868fa8bf3932f07fafe542d32d6b58">dot</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">A</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::View&lt; <a class="el" href="classTpetra_1_1MultiVector.html#a6b5ff6294071bb6f75dd92fa8e9b1bda">dot_type</a> *, Kokkos::HostSpace &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">norms</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:abf868fa8bf3932f07fafe542d32d6b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product of each corresponding pair of vectors (columns) in A and B, storing the result in a device View.  <br /></td></tr>
<tr class="separator:abf868fa8bf3932f07fafe542d32d6b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51ffee027fd32a78ef2fc3c352724b1" id="r_aa51ffee027fd32a78ef2fc3c352724b1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </td></tr>
<tr class="memitem:aa51ffee027fd32a78ef2fc3c352724b1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!(std::is_same&lt; <a class="el" href="classTpetra_1_1MultiVector.html#a6b5ff6294071bb6f75dd92fa8e9b1bda">dot_type</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt;::value), <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#aa51ffee027fd32a78ef2fc3c352724b1">dot</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">A</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::View&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a9114e22e58c9c70b153b341c4f6134d0">device_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">dots</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:aa51ffee027fd32a78ef2fc3c352724b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product of each corresponding pair of vectors (columns) in A and B, storing the result in a device view.  <br /></td></tr>
<tr class="separator:aa51ffee027fd32a78ef2fc3c352724b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a727e92f3f190a3e3b72fa8753f295" id="r_ab8a727e92f3f190a3e3b72fa8753f295"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ab8a727e92f3f190a3e3b72fa8753f295">abs</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">A</a>)</td></tr>
<tr class="memdesc:ab8a727e92f3f190a3e3b72fa8753f295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put element-wise absolute values of input Multi-vector in target: A = abs(this)  <br /></td></tr>
<tr class="separator:ab8a727e92f3f190a3e3b72fa8753f295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a5d7ce085a6d8a87a1a7d6e034d838" id="r_a04a5d7ce085a6d8a87a1a7d6e034d838"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a04a5d7ce085a6d8a87a1a7d6e034d838">reciprocal</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">A</a>)</td></tr>
<tr class="memdesc:a04a5d7ce085a6d8a87a1a7d6e034d838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put element-wise reciprocal values of input Multi-vector in target, this(i,j) = 1/A(i,j).  <br /></td></tr>
<tr class="separator:a04a5d7ce085a6d8a87a1a7d6e034d838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27deea3362cbd12f3e5a104fdb5fd1e1" id="r_a27deea3362cbd12f3e5a104fdb5fd1e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a27deea3362cbd12f3e5a104fdb5fd1e1">scale</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">alpha</a>)</td></tr>
<tr class="memdesc:a27deea3362cbd12f3e5a104fdb5fd1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale in place: <code>this = alpha*this</code>.  <br /></td></tr>
<tr class="separator:a27deea3362cbd12f3e5a104fdb5fd1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4f290a9c9f05fb6a71b1c01525257d" id="r_abd4f290a9c9f05fb6a71b1c01525257d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#abd4f290a9c9f05fb6a71b1c01525257d">scale</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">alpha</a>)</td></tr>
<tr class="memdesc:abd4f290a9c9f05fb6a71b1c01525257d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale each column in place: <code>this[j] = alpha[j]*this[j]</code>.  <br /></td></tr>
<tr class="separator:abd4f290a9c9f05fb6a71b1c01525257d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3871c5ec4a299430090a5e2e0772148" id="r_ab3871c5ec4a299430090a5e2e0772148"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ab3871c5ec4a299430090a5e2e0772148">scale</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::View&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a9114e22e58c9c70b153b341c4f6134d0">device_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">alpha</a>)</td></tr>
<tr class="memdesc:ab3871c5ec4a299430090a5e2e0772148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale each column in place: <code>this[j] = alpha[j]*this[j]</code>.  <br /></td></tr>
<tr class="separator:ab3871c5ec4a299430090a5e2e0772148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a25c55341d6edd28badabdf30e2b40" id="r_a10a25c55341d6edd28badabdf30e2b40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a10a25c55341d6edd28badabdf30e2b40">scale</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">alpha</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">A</a>)</td></tr>
<tr class="memdesc:a10a25c55341d6edd28badabdf30e2b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale in place: <code>this = alpha * A</code>.  <br /></td></tr>
<tr class="separator:a10a25c55341d6edd28badabdf30e2b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4a653bb1937cfd5a3b6316b0de04ae" id="r_afd4a653bb1937cfd5a3b6316b0de04ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#afd4a653bb1937cfd5a3b6316b0de04ae">update</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">alpha</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">A</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">beta</a>)</td></tr>
<tr class="memdesc:afd4a653bb1937cfd5a3b6316b0de04ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update: <code>this = beta*this + alpha*A</code>.  <br /></td></tr>
<tr class="separator:afd4a653bb1937cfd5a3b6316b0de04ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3b8b03f52cc005b2bd1ad5d57f7cfd" id="r_afb3b8b03f52cc005b2bd1ad5d57f7cfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#afb3b8b03f52cc005b2bd1ad5d57f7cfd">update</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">alpha</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">A</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">beta</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">B</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">gamma</a>)</td></tr>
<tr class="memdesc:afb3b8b03f52cc005b2bd1ad5d57f7cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update: <code>this = gamma*this + alpha*A + beta*B</code>.  <br /></td></tr>
<tr class="separator:afb3b8b03f52cc005b2bd1ad5d57f7cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb74a8ac29991816b7cd502c90e5b026" id="r_abb74a8ac29991816b7cd502c90e5b026"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#abb74a8ac29991816b7cd502c90e5b026">norm1</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::View&lt; <a class="el" href="classTpetra_1_1MultiVector.html#addf0baff5a335005840b1ea926822abc">mag_type</a> *, Kokkos::HostSpace &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">norms</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:abb74a8ac29991816b7cd502c90e5b026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the one-norm of each vector (column), storing the result in a host view.  <br /></td></tr>
<tr class="separator:abb74a8ac29991816b7cd502c90e5b026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a83b678327409a28a5bd8d5667bc085" id="r_a7a83b678327409a28a5bd8d5667bc085"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </td></tr>
<tr class="memitem:a7a83b678327409a28a5bd8d5667bc085"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!(std::is_same&lt; <a class="el" href="classTpetra_1_1MultiVector.html#addf0baff5a335005840b1ea926822abc">mag_type</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt;::value), <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a7a83b678327409a28a5bd8d5667bc085">norm1</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::View&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a9114e22e58c9c70b153b341c4f6134d0">device_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">norms</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a7a83b678327409a28a5bd8d5667bc085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the one-norm of each vector (column), storing the result in a device view.  <br /></td></tr>
<tr class="separator:a7a83b678327409a28a5bd8d5667bc085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac36c424e851e82981da13751922e650" id="r_aac36c424e851e82981da13751922e650"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#aac36c424e851e82981da13751922e650">norm1</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1MultiVector.html#addf0baff5a335005840b1ea926822abc">mag_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">norms</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:aac36c424e851e82981da13751922e650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the one-norm of each vector (column).  <br /></td></tr>
<tr class="separator:aac36c424e851e82981da13751922e650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19de9de7345466edb2a50e38db47e0ef" id="r_a19de9de7345466edb2a50e38db47e0ef"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </td></tr>
<tr class="memitem:a19de9de7345466edb2a50e38db47e0ef"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!(std::is_same&lt; <a class="el" href="classTpetra_1_1MultiVector.html#addf0baff5a335005840b1ea926822abc">mag_type</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt;::value), <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a19de9de7345466edb2a50e38db47e0ef">norm1</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">norms</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a19de9de7345466edb2a50e38db47e0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the one-norm of each vector (column).  <br /></td></tr>
<tr class="separator:a19de9de7345466edb2a50e38db47e0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8df7eea260ede50cd9b77727030e87" id="r_a7a8df7eea260ede50cd9b77727030e87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a7a8df7eea260ede50cd9b77727030e87">norm2</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::View&lt; <a class="el" href="classTpetra_1_1MultiVector.html#addf0baff5a335005840b1ea926822abc">mag_type</a> *, Kokkos::HostSpace &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">norms</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a7a8df7eea260ede50cd9b77727030e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the two-norm of each vector (column), storing the result in a host View.  <br /></td></tr>
<tr class="separator:a7a8df7eea260ede50cd9b77727030e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2501c02d8481f89d2477d537b04fc3" id="r_a1b2501c02d8481f89d2477d537b04fc3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </td></tr>
<tr class="memitem:a1b2501c02d8481f89d2477d537b04fc3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!(std::is_same&lt; <a class="el" href="classTpetra_1_1MultiVector.html#addf0baff5a335005840b1ea926822abc">mag_type</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt;::value), <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a1b2501c02d8481f89d2477d537b04fc3">norm2</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::View&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a9114e22e58c9c70b153b341c4f6134d0">device_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">norms</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a1b2501c02d8481f89d2477d537b04fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the two-norm of each vector (column), storing the result in a device view.  <br /></td></tr>
<tr class="separator:a1b2501c02d8481f89d2477d537b04fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a87aacbc87c6ee12645132582bdede" id="r_ab5a87aacbc87c6ee12645132582bdede"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ab5a87aacbc87c6ee12645132582bdede">norm2</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1MultiVector.html#addf0baff5a335005840b1ea926822abc">mag_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">norms</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:ab5a87aacbc87c6ee12645132582bdede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the two-norm of each vector (column).  <br /></td></tr>
<tr class="separator:ab5a87aacbc87c6ee12645132582bdede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96728d41266a0503836e43141a6df19a" id="r_a96728d41266a0503836e43141a6df19a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </td></tr>
<tr class="memitem:a96728d41266a0503836e43141a6df19a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!(std::is_same&lt; <a class="el" href="classTpetra_1_1MultiVector.html#addf0baff5a335005840b1ea926822abc">mag_type</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt;::value), <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a96728d41266a0503836e43141a6df19a">norm2</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">norms</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a96728d41266a0503836e43141a6df19a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the two-norm of each vector (column).  <br /></td></tr>
<tr class="separator:a96728d41266a0503836e43141a6df19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0677b2f6d6474b2097791af511ae7fb8" id="r_a0677b2f6d6474b2097791af511ae7fb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a0677b2f6d6474b2097791af511ae7fb8">normInf</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::View&lt; <a class="el" href="classTpetra_1_1MultiVector.html#addf0baff5a335005840b1ea926822abc">mag_type</a> *, Kokkos::HostSpace &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">norms</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a0677b2f6d6474b2097791af511ae7fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the infinity-norm of each vector (column), storing the result in a host View.  <br /></td></tr>
<tr class="separator:a0677b2f6d6474b2097791af511ae7fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c61eb2e9bdc9a2bcce962f6fe718f3" id="r_a48c61eb2e9bdc9a2bcce962f6fe718f3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </td></tr>
<tr class="memitem:a48c61eb2e9bdc9a2bcce962f6fe718f3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!(std::is_same&lt; <a class="el" href="classTpetra_1_1MultiVector.html#addf0baff5a335005840b1ea926822abc">mag_type</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt;::value), <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a48c61eb2e9bdc9a2bcce962f6fe718f3">normInf</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::View&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a9114e22e58c9c70b153b341c4f6134d0">device_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">norms</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a48c61eb2e9bdc9a2bcce962f6fe718f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the infinity-norm of each vector (column), storing the result in a device view.  <br /></td></tr>
<tr class="separator:a48c61eb2e9bdc9a2bcce962f6fe718f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b1b0e2a7b6952de61f73714ee8ae6d" id="r_ac1b1b0e2a7b6952de61f73714ee8ae6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ac1b1b0e2a7b6952de61f73714ee8ae6d">normInf</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1MultiVector.html#addf0baff5a335005840b1ea926822abc">mag_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">norms</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:ac1b1b0e2a7b6952de61f73714ee8ae6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the infinity-norm of each vector (column), storing the result in a Teuchos::ArrayView.  <br /></td></tr>
<tr class="separator:ac1b1b0e2a7b6952de61f73714ee8ae6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2a8de67c7bc4c5ed1bc6cca64acdb9" id="r_a3e2a8de67c7bc4c5ed1bc6cca64acdb9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </td></tr>
<tr class="memitem:a3e2a8de67c7bc4c5ed1bc6cca64acdb9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!(std::is_same&lt; <a class="el" href="classTpetra_1_1MultiVector.html#addf0baff5a335005840b1ea926822abc">mag_type</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt;::value), <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a3e2a8de67c7bc4c5ed1bc6cca64acdb9">normInf</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">norms</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a3e2a8de67c7bc4c5ed1bc6cca64acdb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the infinity-norm of each vector (column), storing the result in a Teuchos::ArrayView.  <br /></td></tr>
<tr class="separator:a3e2a8de67c7bc4c5ed1bc6cca64acdb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419c96003b0060abc7791226f75f16b2" id="r_a419c96003b0060abc7791226f75f16b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a419c96003b0060abc7791226f75f16b2">meanValue</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">means</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a419c96003b0060abc7791226f75f16b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute mean (average) value of each column.  <br /></td></tr>
<tr class="separator:a419c96003b0060abc7791226f75f16b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473b4545e66e12eba553d04c060d201c" id="r_a473b4545e66e12eba553d04c060d201c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a473b4545e66e12eba553d04c060d201c">multiply</a> (Teuchos::ETransp <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">transA</a>, Teuchos::ETransp <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">transB</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">alpha</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">A</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">B</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">beta</a>)</td></tr>
<tr class="memdesc:a473b4545e66e12eba553d04c060d201c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix-matrix multiplication: <code>this = beta*this + alpha*op(A)*op(B)</code>.  <br /></td></tr>
<tr class="separator:a473b4545e66e12eba553d04c060d201c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95fae4b1f2891d8438b7fb692a85b3bd" id="r_a95fae4b1f2891d8438b7fb692a85b3bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a95fae4b1f2891d8438b7fb692a85b3bd">elementWiseMultiply</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">scalarAB</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Vector.html">Vector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">A</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">B</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">scalarThis</a>)</td></tr>
<tr class="memdesc:a95fae4b1f2891d8438b7fb692a85b3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Vector</a> A elementwise by a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> B.  <br /></td></tr>
<tr class="separator:a95fae4b1f2891d8438b7fb692a85b3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Attribute access functions</div></td></tr>
<tr class="memitem:a99612db6ea6a62d73eee3a0563e5e561" id="r_a99612db6ea6a62d73eee3a0563e5e561"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a99612db6ea6a62d73eee3a0563e5e561">getNumVectors</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a99612db6ea6a62d73eee3a0563e5e561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of columns in the multivector.  <br /></td></tr>
<tr class="separator:a99612db6ea6a62d73eee3a0563e5e561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdc127576764db9045ce5f1258e39d8" id="r_a5cdc127576764db9045ce5f1258e39d8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a5cdc127576764db9045ce5f1258e39d8">getLocalLength</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a5cdc127576764db9045ce5f1258e39d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local number of rows on the calling process.  <br /></td></tr>
<tr class="separator:a5cdc127576764db9045ce5f1258e39d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e008db43eebb57980f9e91d3062f113" id="r_a7e008db43eebb57980f9e91d3062f113"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceTpetra.html#a9bf6069ab0d0c54962569526f3cc9cf5">global_size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a7e008db43eebb57980f9e91d3062f113">getGlobalLength</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a7e008db43eebb57980f9e91d3062f113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global number of rows in the multivector.  <br /></td></tr>
<tr class="separator:a7e008db43eebb57980f9e91d3062f113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad03fc5b0a480d51837c88d922680f2" id="r_a0ad03fc5b0a480d51837c88d922680f2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a0ad03fc5b0a480d51837c88d922680f2">getStride</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a0ad03fc5b0a480d51837c88d922680f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stride between columns in the multivector.  <br /></td></tr>
<tr class="separator:a0ad03fc5b0a480d51837c88d922680f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add82b0581b87c0b43deb07113054172c" id="r_add82b0581b87c0b43deb07113054172c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#add82b0581b87c0b43deb07113054172c">isConstantStride</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:add82b0581b87c0b43deb07113054172c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this multivector has constant stride between columns.  <br /></td></tr>
<tr class="separator:add82b0581b87c0b43deb07113054172c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3479ff3024192bdc4eac0ee73e05939" id="r_ac3479ff3024192bdc4eac0ee73e05939"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ac3479ff3024192bdc4eac0ee73e05939">aliases</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">other</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:ac3479ff3024192bdc4eac0ee73e05939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this multivector's memory might alias other. This is conservative: if either this or other is not constant stride, then it simply checks whether the contiguous memory allocations overlap. It doesn't check whether the sets of columns overlap. This is a symmetric relation: X.aliases(Y) == Y.aliases(X).  <br /></td></tr>
<tr class="separator:ac3479ff3024192bdc4eac0ee73e05939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public methods for redistributing data</div></td></tr>
<tr class="memitem:a2e2cce34ee9698060f87e1fad3695a2d" id="r_a2e2cce34ee9698060f87e1fad3695a2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a2e2cce34ee9698060f87e1fad3695a2d">doImport</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">source</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Import.html">Import</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">importer</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">CM</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">restrictedMode</a>=<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">false</a>)</td></tr>
<tr class="memdesc:a2e2cce34ee9698060f87e1fad3695a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> data into this object using an <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> object ("forward mode").  <br /></td></tr>
<tr class="separator:a2e2cce34ee9698060f87e1fad3695a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbd89e8cf8df8d477f2c541db4d3215" id="r_a0cbd89e8cf8df8d477f2c541db4d3215"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a0cbd89e8cf8df8d477f2c541db4d3215">doImport</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">source</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Export.html">Export</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">exporter</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">CM</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">restrictedMode</a>=<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">false</a>)</td></tr>
<tr class="memdesc:a0cbd89e8cf8df8d477f2c541db4d3215"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> data into this object using an <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> object ("reverse mode").  <br /></td></tr>
<tr class="separator:a0cbd89e8cf8df8d477f2c541db4d3215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2623c99b47ce9d88692abdc094d8be6" id="r_ad2623c99b47ce9d88692abdc094d8be6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#ad2623c99b47ce9d88692abdc094d8be6">doExport</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">source</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Export.html">Export</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">exporter</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">CM</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">restrictedMode</a>=<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">false</a>)</td></tr>
<tr class="memdesc:ad2623c99b47ce9d88692abdc094d8be6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> data into this object using an <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> object ("forward mode").  <br /></td></tr>
<tr class="separator:ad2623c99b47ce9d88692abdc094d8be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b766629940d0400aa98e113b4e5ef3c" id="r_a5b766629940d0400aa98e113b4e5ef3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a5b766629940d0400aa98e113b4e5ef3c">doExport</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">source</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Import.html">Import</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">importer</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">CM</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">restrictedMode</a>=<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">false</a>)</td></tr>
<tr class="memdesc:a5b766629940d0400aa98e113b4e5ef3c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> data into this object using an <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> object ("reverse mode").  <br /></td></tr>
<tr class="separator:a5b766629940d0400aa98e113b4e5ef3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ad53419477919faf1acdcfc4d65daa" id="r_a47ad53419477919faf1acdcfc4d65daa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a47ad53419477919faf1acdcfc4d65daa">transferArrived</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a47ad53419477919faf1acdcfc4d65daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the data from an import/export operation has arrived, and is ready for the unpack and combine step.  <br /></td></tr>
<tr class="separator:a47ad53419477919faf1acdcfc4d65daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Attribute accessor methods</div></td></tr>
<tr class="memitem:afc178c45d66d8232f27b1e79fc0e1535" id="r_afc178c45d66d8232f27b1e79fc0e1535"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#afc178c45d66d8232f27b1e79fc0e1535">isDistributed</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:afc178c45d66d8232f27b1e79fc0e1535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this is a globally distributed object.  <br /></td></tr>
<tr class="separator:afc178c45d66d8232f27b1e79fc0e1535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef545d3737b47c030e0e6a3e7d8b1e7" id="r_adef545d3737b47c030e0e6a3e7d8b1e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#adef545d3737b47c030e0e6a3e7d8b1e7">getMap</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:adef545d3737b47c030e0e6a3e7d8b1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> describing the parallel distribution of this object.  <br /></td></tr>
<tr class="separator:adef545d3737b47c030e0e6a3e7d8b1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">I/O methods</div></td></tr>
<tr class="memitem:a8f39be1272b2b218c6b734d30fdb7956" id="r_a8f39be1272b2b218c6b734d30fdb7956"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a8f39be1272b2b218c6b734d30fdb7956">print</a> (std::ostream &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">os</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a8f39be1272b2b218c6b734d30fdb7956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print this object to the given output stream.  <br /></td></tr>
<tr class="separator:a8f39be1272b2b218c6b734d30fdb7956"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Misc. implementation details</div></td></tr>
<tr class="memitem:a45f2b3b19e6cdb176c8ac84525f4a00a" id="r_a45f2b3b19e6cdb176c8ac84525f4a00a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a45f2b3b19e6cdb176c8ac84525f4a00a">descriptionImpl</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> std::string &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">className</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a45f2b3b19e6cdb176c8ac84525f4a00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="classTpetra_1_1MultiVector.html#ae717adfdc48e6a2c30369645e7de9b5e" title="A simple one-line description of this object.">description()</a> for this class, and its subclass <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Vector</a>.  <br /></td></tr>
<tr class="separator:a45f2b3b19e6cdb176c8ac84525f4a00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8b4ae57b5af420079d548b2aa9cf52" id="r_aea8b4ae57b5af420079d548b2aa9cf52"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#aea8b4ae57b5af420079d548b2aa9cf52">localDescribeToString</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::EVerbosityLevel <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">vl</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:aea8b4ae57b5af420079d548b2aa9cf52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the calling process' verbose <a class="el" href="classTpetra_1_1MultiVector.html#abc13bb2361c48fdcf08d13ebeb351109" title="Print the object with the given verbosity level to a FancyOStream.">describe()</a> information to the returned string.  <br /></td></tr>
<tr class="separator:aea8b4ae57b5af420079d548b2aa9cf52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d374c0f351e73e77837bed5b315e8e5" id="r_a2d374c0f351e73e77837bed5b315e8e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a2d374c0f351e73e77837bed5b315e8e5">describeImpl</a> (Teuchos::FancyOStream &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">out</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> std::string &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">className</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::EVerbosityLevel <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">verbLevel</a>=Teuchos::Describable::verbLevel_default) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a2d374c0f351e73e77837bed5b315e8e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="classTpetra_1_1MultiVector.html#abc13bb2361c48fdcf08d13ebeb351109" title="Print the object with the given verbosity level to a FancyOStream.">describe()</a> for this class, and its subclass <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Vector</a>.  <br /></td></tr>
<tr class="separator:a2d374c0f351e73e77837bed5b315e8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839e4f7803ea583d4114cfabd2a35391" id="r_a839e4f7803ea583d4114cfabd2a35391"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </td></tr>
<tr class="memitem:a839e4f7803ea583d4114cfabd2a35391"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::ArrayRCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a839e4f7803ea583d4114cfabd2a35391">getSubArrayRCP</a> (Teuchos::ArrayRCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">arr</a>, size_t <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">j</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:a839e4f7803ea583d4114cfabd2a35391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persisting view of j-th column in the given ArrayRCP.  <br /></td></tr>
<tr class="separator:a839e4f7803ea583d4114cfabd2a35391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef58658ae67afa6851887ca31f258650" id="r_aef58658ae67afa6851887ca31f258650"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#aef58658ae67afa6851887ca31f258650">getOrigNumLocalRows</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:aef58658ae67afa6851887ca31f258650"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Original" number of rows in the (local) data.  <br /></td></tr>
<tr class="separator:aef58658ae67afa6851887ca31f258650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13baf73b3f0da799e89d06e026dee2f" id="r_ae13baf73b3f0da799e89d06e026dee2f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ae13baf73b3f0da799e89d06e026dee2f">getOrigNumLocalCols</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:ae13baf73b3f0da799e89d06e026dee2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Original" number of columns in the (local) data.  <br /></td></tr>
<tr class="separator:ae13baf73b3f0da799e89d06e026dee2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:a252cfba1878494ff99d2454d92a9823b" id="r_a252cfba1878494ff99d2454d92a9823b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">DS</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">DL</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">DG</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">DN</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">SS</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">SL</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">SG</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">SN</a> &gt; </td></tr>
<tr class="memitem:a252cfba1878494ff99d2454d92a9823b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a252cfba1878494ff99d2454d92a9823b">deep_copy</a> (<a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">DS</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">DL</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">DG</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">DN</a> &gt; &amp;dst, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">SS</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">SL</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">SG</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">SN</a> &gt; &amp;src)</td></tr>
<tr class="memdesc:a252cfba1878494ff99d2454d92a9823b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> <code>src</code> into <code>dst</code>.  <br /></td></tr>
<tr class="separator:a252cfba1878494ff99d2454d92a9823b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4d99be4ef954d973258b629d7281ac" id="r_a0d4d99be4ef954d973258b629d7281ac"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> ST , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">NT</a> &gt; </td></tr>
<tr class="memitem:a0d4d99be4ef954d973258b629d7281ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; ST, LO, GO, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">NT</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a0d4d99be4ef954d973258b629d7281ac">createCopy</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; ST, LO, GO, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">NT</a> &gt; &amp;src)</td></tr>
<tr class="memdesc:a0d4d99be4ef954d973258b629d7281ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a deep copy of the given <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>.  <br /></td></tr>
<tr class="separator:a0d4d99be4ef954d973258b629d7281ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Overridden from Teuchos::Describable</h2></td></tr>
<tr class="memitem:a4bec5291531c0ba59fd7131da27a5c4d" id="r_a4bec5291531c0ba59fd7131da27a5c4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1Details_1_1WrappedDualView.html">wrapped_dual_view_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a4bec5291531c0ba59fd7131da27a5c4d">view_</a></td></tr>
<tr class="memdesc:a4bec5291531c0ba59fd7131da27a5c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Kokkos::DualView containing the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s data.  <br /></td></tr>
<tr class="separator:a4bec5291531c0ba59fd7131da27a5c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada106f56880af8830af09b11cd4057c5" id="r_ada106f56880af8830af09b11cd4057c5"><td class="memItemLeft" align="right" valign="top">Teuchos::Array&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ada106f56880af8830af09b11cd4057c5">whichVectors_</a></td></tr>
<tr class="memdesc:ada106f56880af8830af09b11cd4057c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indices of columns this multivector is viewing.  <br /></td></tr>
<tr class="separator:ada106f56880af8830af09b11cd4057c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae717adfdc48e6a2c30369645e7de9b5e" id="r_ae717adfdc48e6a2c30369645e7de9b5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ae717adfdc48e6a2c30369645e7de9b5e">description</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">override</a></td></tr>
<tr class="memdesc:ae717adfdc48e6a2c30369645e7de9b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple one-line description of this object.  <br /></td></tr>
<tr class="separator:ae717adfdc48e6a2c30369645e7de9b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc13bb2361c48fdcf08d13ebeb351109" id="r_abc13bb2361c48fdcf08d13ebeb351109"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#abc13bb2361c48fdcf08d13ebeb351109">describe</a> (Teuchos::FancyOStream &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">out</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::EVerbosityLevel <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">verbLevel</a>=Teuchos::Describable::verbLevel_default) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">override</a></td></tr>
<tr class="memdesc:abc13bb2361c48fdcf08d13ebeb351109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the object with the given verbosity level to a FancyOStream.  <br /></td></tr>
<tr class="separator:abc13bb2361c48fdcf08d13ebeb351109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d3fc9e6b5759024a8ce7a525b694fc" id="r_a39d3fc9e6b5759024a8ce7a525b694fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a39d3fc9e6b5759024a8ce7a525b694fc">removeEmptyProcessesInPlace</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">newMap</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">override</a></td></tr>
<tr class="memdesc:a39d3fc9e6b5759024a8ce7a525b694fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove processes owning zero rows from the <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> and their communicator.  <br /></td></tr>
<tr class="separator:a39d3fc9e6b5759024a8ce7a525b694fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970e8a82654c257ecc8333f71ac3538e" id="r_a970e8a82654c257ecc8333f71ac3538e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a970e8a82654c257ecc8333f71ac3538e">setCopyOrView</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::DataAccess <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">copyOrView</a>)</td></tr>
<tr class="memdesc:a970e8a82654c257ecc8333f71ac3538e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether this has copy (copyOrView = Teuchos::Copy) or view (copyOrView = Teuchos::View) semantics.  <br /></td></tr>
<tr class="separator:a970e8a82654c257ecc8333f71ac3538e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada1c2ec10f3f23a5fa7b819a7eb5e4f" id="r_aada1c2ec10f3f23a5fa7b819a7eb5e4f"><td class="memItemLeft" align="right" valign="top">Teuchos::DataAccess&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#aada1c2ec10f3f23a5fa7b819a7eb5e4f">getCopyOrView</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:aada1c2ec10f3f23a5fa7b819a7eb5e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether this has copy (copyOrView = Teuchos::Copy) or view (copyOrView = Teuchos::View) semantics.  <br /></td></tr>
<tr class="separator:aada1c2ec10f3f23a5fa7b819a7eb5e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db220925b8597ba88461d52d7f944ac" id="r_a3db220925b8597ba88461d52d7f944ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a3db220925b8597ba88461d52d7f944ac">assign</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;src)</td></tr>
<tr class="memdesc:a3db220925b8597ba88461d52d7f944ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of <code>src</code> into <code>*this</code> (deep copy).  <br /></td></tr>
<tr class="separator:a3db220925b8597ba88461d52d7f944ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b7885b3f166ca65607b6e0d397edf4" id="r_ab0b7885b3f166ca65607b6e0d397edf4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </td></tr>
<tr class="memitem:ab0b7885b3f166ca65607b6e0d397edf4"><td class="memTemplItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ab0b7885b3f166ca65607b6e0d397edf4">convert</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="memdesc:ab0b7885b3f166ca65607b6e0d397edf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return another <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> with the same entries, but converted to a different Scalar type <code>T</code>.  <br /></td></tr>
<tr class="separator:ab0b7885b3f166ca65607b6e0d397edf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4e380b566a64d2492c0794a82de034" id="r_aef4e380b566a64d2492c0794a82de034"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#aef4e380b566a64d2492c0794a82de034">isSameSize</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">vec</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a></td></tr>
<tr class="separator:aef4e380b566a64d2492c0794a82de034"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Implementation of Tpetra::DistObject</h2></td></tr>
<tr class="memitem:a6576557039b8bae3b2cc06aeefd8c8d7" id="r_a6576557039b8bae3b2cc06aeefd8c8d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a> = <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1DistObject.html">DistObject</a>&lt; <a class="el" href="classTpetra_1_1MultiVector.html#a798f64a312664da3cc1e43738c4c0ec0">scalar_type</a>, <a class="el" href="classTpetra_1_1MultiVector.html#a23e770e950420cc2a0b3018f1fe9315b">local_ordinal_type</a>, <a class="el" href="classTpetra_1_1MultiVector.html#a040b35e734b4162bba42c5a6d2f53d10">global_ordinal_type</a>, <a class="el" href="classTpetra_1_1MultiVector.html#a0e2eafc5434402b790165efbf5418dae">node_type</a> &gt;::buffer_device_type</td></tr>
<tr class="memdesc:a6576557039b8bae3b2cc06aeefd8c8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kokkos::Device specialization for communication buffers.  <br /></td></tr>
<tr class="separator:a6576557039b8bae3b2cc06aeefd8c8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8f31277205023e77e52140be7bf7fd" id="r_a1e8f31277205023e77e52140be7bf7fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a1e8f31277205023e77e52140be7bf7fd">checkSizes</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">sourceObj</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">override</a></td></tr>
<tr class="memdesc:a1e8f31277205023e77e52140be7bf7fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether data redistribution between <code>sourceObj</code> and this object is legal.  <br /></td></tr>
<tr class="separator:a1e8f31277205023e77e52140be7bf7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6261b3d552d1d03f76b69912e55ea81" id="r_aa6261b3d552d1d03f76b69912e55ea81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#aa6261b3d552d1d03f76b69912e55ea81">constantNumberOfPackets</a> () <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">override</a></td></tr>
<tr class="memdesc:aa6261b3d552d1d03f76b69912e55ea81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of packets to send per LID.  <br /></td></tr>
<tr class="separator:aa6261b3d552d1d03f76b69912e55ea81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d198cf6e6d5507e0c142ae020de954" id="r_a74d198cf6e6d5507e0c142ae020de954"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a74d198cf6e6d5507e0c142ae020de954">copyAndPermute</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">sourceObj</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t numSameIDs, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#a23e770e950420cc2a0b3018f1fe9315b">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">permuteToLIDs</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#a23e770e950420cc2a0b3018f1fe9315b">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">permuteFromLIDs</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">CM</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#ab52fef102335f8ae2bf93fc45e390757">execution_space</a> &amp;space) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">override</a></td></tr>
<tr class="memdesc:a74d198cf6e6d5507e0c142ae020de954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as copyAndPermute, but do operations in <code>space</code>.  <br /></td></tr>
<tr class="separator:a74d198cf6e6d5507e0c142ae020de954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c7be23350a211e8e44538ecb36eb75" id="r_a56c7be23350a211e8e44538ecb36eb75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a56c7be23350a211e8e44538ecb36eb75">copyAndPermute</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">sourceObj</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t numSameIDs, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#a23e770e950420cc2a0b3018f1fe9315b">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">permuteToLIDs</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#a23e770e950420cc2a0b3018f1fe9315b">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">permuteFromLIDs</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">CM</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">override</a></td></tr>
<tr class="memdesc:a56c7be23350a211e8e44538ecb36eb75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform copies and permutations that are local to the calling (MPI) process.  <br /></td></tr>
<tr class="separator:a56c7be23350a211e8e44538ecb36eb75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188c72d11d6aaffbb62621d5ef9fb3e7" id="r_a188c72d11d6aaffbb62621d5ef9fb3e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a188c72d11d6aaffbb62621d5ef9fb3e7">reallocImportsIfNeeded</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">newSize</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> verbose, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> std::string *<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">prefix</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> areRemoteLIDsContiguous=<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">false</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">CM</a>=<a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094ba8311a4172e79c1f3a25a4ffc2e637b28">INSERT</a>) <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">override</a></td></tr>
<tr class="memdesc:a188c72d11d6aaffbb62621d5ef9fb3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate imports_ if needed.  <br /></td></tr>
<tr class="separator:a188c72d11d6aaffbb62621d5ef9fb3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Methods for use only by experts</h2></td></tr>
<tr class="memitem:ac1ff98c164c772986e2a5db411a311ab" id="r_ac1ff98c164c772986e2a5db411a311ab"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#ac1ff98c164c772986e2a5db411a311ab">ReverseOption</a> </td></tr>
<tr class="memdesc:ac1ff98c164c772986e2a5db411a311ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the data transfer should be performed in forward or reverse mode.  <a href="classTpetra_1_1DistObject.html#ac1ff98c164c772986e2a5db411a311ab">More...</a><br /></td></tr>
<tr class="separator:ac1ff98c164c772986e2a5db411a311ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142f6b49db9d7bc4cb94e8488f89309c" id="r_a142f6b49db9d7bc4cb94e8488f89309c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a142f6b49db9d7bc4cb94e8488f89309c">buffer_memory_space</a> = ::Tpetra::Details::DefaultTypes::comm_buffer_memory_space&lt; <a class="el" href="classTpetra_1_1MultiVector.html#a9114e22e58c9c70b153b341c4f6134d0">device_type</a> &gt;</td></tr>
<tr class="memdesc:a142f6b49db9d7bc4cb94e8488f89309c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kokkos memory space for communication buffers.  <br /></td></tr>
<tr class="separator:a142f6b49db9d7bc4cb94e8488f89309c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead0431a5e0fcdcb0b2147f8351b7792" id="r_aead0431a5e0fcdcb0b2147f8351b7792"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#aead0431a5e0fcdcb0b2147f8351b7792">removeEmptyProcessesInPlace</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">newMap</a>)</td></tr>
<tr class="memdesc:aead0431a5e0fcdcb0b2147f8351b7792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove processes which contain no entries in this object's <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>.  <br /></td></tr>
<tr class="separator:aead0431a5e0fcdcb0b2147f8351b7792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01545040824d209ef6f686de7d3b842" id="r_ad01545040824d209ef6f686de7d3b842"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Details::DistributorActor &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#ad01545040824d209ef6f686de7d3b842">getActor</a> ()</td></tr>
<tr class="memdesc:ad01545040824d209ef6f686de7d3b842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the DistributorActor.  <br /></td></tr>
<tr class="separator:ad01545040824d209ef6f686de7d3b842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a9a5fd0df1dda55188a340e6b5a2e7" id="r_a82a9a5fd0df1dda55188a340e6b5a2e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a82a9a5fd0df1dda55188a340e6b5a2e7">doTransfer</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;src, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Details_1_1Transfer.html">::Tpetra::Details::Transfer</a>&lt; <a class="el" href="classTpetra_1_1MultiVector.html#a23e770e950420cc2a0b3018f1fe9315b">local_ordinal_type</a>, <a class="el" href="classTpetra_1_1MultiVector.html#a040b35e734b4162bba42c5a6d2f53d10">global_ordinal_type</a>, <a class="el" href="classTpetra_1_1MultiVector.html#a0e2eafc5434402b790165efbf5418dae">node_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">transfer</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">char</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">modeString</a>[], <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1DistObject.html#ac1ff98c164c772986e2a5db411a311ab">ReverseOption</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">revOp</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">CM</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">restrictedMode</a>)</td></tr>
<tr class="memdesc:a82a9a5fd0df1dda55188a340e6b5a2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redistribute data across (MPI) processes.  <br /></td></tr>
<tr class="separator:a82a9a5fd0df1dda55188a340e6b5a2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20429024546804acef2060050d1b22f8" id="r_a20429024546804acef2060050d1b22f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a20429024546804acef2060050d1b22f8">reallocArraysForNumPacketsPerLid</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">numExportLIDs</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">numImportLIDs</a>)</td></tr>
<tr class="memdesc:a20429024546804acef2060050d1b22f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate numExportPacketsPerLID_ and/or numImportPacketsPerLID_, if necessary.  <br /></td></tr>
<tr class="separator:a20429024546804acef2060050d1b22f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a2256ab638b7f329b752535553f480" id="r_a30a2256ab638b7f329b752535553f480"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a30a2256ab638b7f329b752535553f480">beginTransfer</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;src, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Details_1_1Transfer.html">::Tpetra::Details::Transfer</a>&lt; <a class="el" href="classTpetra_1_1MultiVector.html#a23e770e950420cc2a0b3018f1fe9315b">local_ordinal_type</a>, <a class="el" href="classTpetra_1_1MultiVector.html#a040b35e734b4162bba42c5a6d2f53d10">global_ordinal_type</a>, <a class="el" href="classTpetra_1_1MultiVector.html#a0e2eafc5434402b790165efbf5418dae">node_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">transfer</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">char</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">modeString</a>[], <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1DistObject.html#ac1ff98c164c772986e2a5db411a311ab">ReverseOption</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">revOp</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">CM</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">restrictedMode</a>)</td></tr>
<tr class="memdesc:a30a2256ab638b7f329b752535553f480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation detail of doTransfer.  <br /></td></tr>
<tr class="separator:a30a2256ab638b7f329b752535553f480"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Post-construction modification routines</h2></td></tr>
<tr class="memitem:af79a57ae7d7b00a821871824700dafeb" id="r_af79a57ae7d7b00a821871824700dafeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">static</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#af79a57ae7d7b00a821871824700dafeb">useAtomicUpdatesByDefault</a></td></tr>
<tr class="memdesc:af79a57ae7d7b00a821871824700dafeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether sumIntoLocalValue and sumIntoGlobalValue should use atomic updates by default.  <br /></td></tr>
<tr class="separator:af79a57ae7d7b00a821871824700dafeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d32396b1f980611f12c31994c200a25" id="r_a8d32396b1f980611f12c31994c200a25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a8d32396b1f980611f12c31994c200a25">replaceGlobalValue</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">gblRow</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t col, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &amp;value)</td></tr>
<tr class="memdesc:a8d32396b1f980611f12c31994c200a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace value in host memory, using global row index.  <br /></td></tr>
<tr class="separator:a8d32396b1f980611f12c31994c200a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293acae425ea5e8d83d6aa141756714b" id="r_a293acae425ea5e8d83d6aa141756714b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </td></tr>
<tr class="memitem:a293acae425ea5e8d83d6aa141756714b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_same&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a>, <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &gt;::value &amp;&amp;std::is_convertible&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a>, <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &gt;::value, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a293acae425ea5e8d83d6aa141756714b">replaceGlobalValue</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">globalRow</a>, size_t col, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &amp;value)</td></tr>
<tr class="memdesc:a293acae425ea5e8d83d6aa141756714b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the above replaceGlobalValue, but only enabled if T differs from impl_scalar_type.  <br /></td></tr>
<tr class="separator:a293acae425ea5e8d83d6aa141756714b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf793ee4674bffee54df32ecb94e8256" id="r_abf793ee4674bffee54df32ecb94e8256"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#abf793ee4674bffee54df32ecb94e8256">sumIntoGlobalValue</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">gblRow</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t col, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &amp;value, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> atomic=<a class="el" href="classTpetra_1_1MultiVector.html#af79a57ae7d7b00a821871824700dafeb">useAtomicUpdatesByDefault</a>)</td></tr>
<tr class="memdesc:abf793ee4674bffee54df32ecb94e8256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update (+=) a value in host memory, using global row index.  <br /></td></tr>
<tr class="separator:abf793ee4674bffee54df32ecb94e8256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607e5ccfa4c4ac98538ec1d5c2d8492e" id="r_a607e5ccfa4c4ac98538ec1d5c2d8492e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </td></tr>
<tr class="memitem:a607e5ccfa4c4ac98538ec1d5c2d8492e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_same&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a>, <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &gt;::value &amp;&amp;std::is_convertible&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a>, <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &gt;::value, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a607e5ccfa4c4ac98538ec1d5c2d8492e">sumIntoGlobalValue</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">gblRow</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t col, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">val</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> atomic=<a class="el" href="classTpetra_1_1MultiVector.html#af79a57ae7d7b00a821871824700dafeb">useAtomicUpdatesByDefault</a>)</td></tr>
<tr class="memdesc:a607e5ccfa4c4ac98538ec1d5c2d8492e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the above sumIntoGlobalValue, but only enabled if T differs from impl_scalar_type.  <br /></td></tr>
<tr class="separator:a607e5ccfa4c4ac98538ec1d5c2d8492e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522140b91b74f9fc1d2dbf0f5ef7edfb" id="r_a522140b91b74f9fc1d2dbf0f5ef7edfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a522140b91b74f9fc1d2dbf0f5ef7edfb">replaceLocalValue</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">lclRow</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t col, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &amp;value)</td></tr>
<tr class="memdesc:a522140b91b74f9fc1d2dbf0f5ef7edfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace value in host memory, using local (row) index.  <br /></td></tr>
<tr class="separator:a522140b91b74f9fc1d2dbf0f5ef7edfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bbfc6ffa48db404ac33745834f16ee" id="r_ae7bbfc6ffa48db404ac33745834f16ee"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </td></tr>
<tr class="memitem:ae7bbfc6ffa48db404ac33745834f16ee"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_same&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a>, <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &gt;::value &amp;&amp;std::is_convertible&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a>, <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &gt;::value, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ae7bbfc6ffa48db404ac33745834f16ee">replaceLocalValue</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">lclRow</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t col, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">val</a>)</td></tr>
<tr class="memdesc:ae7bbfc6ffa48db404ac33745834f16ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the above replaceLocalValue, but only enabled if T differs from impl_scalar_type.  <br /></td></tr>
<tr class="separator:ae7bbfc6ffa48db404ac33745834f16ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8faded8a81ded34bd1333aa75940712" id="r_aa8faded8a81ded34bd1333aa75940712"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#aa8faded8a81ded34bd1333aa75940712">sumIntoLocalValue</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">lclRow</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t col, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">val</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> atomic=<a class="el" href="classTpetra_1_1MultiVector.html#af79a57ae7d7b00a821871824700dafeb">useAtomicUpdatesByDefault</a>)</td></tr>
<tr class="memdesc:aa8faded8a81ded34bd1333aa75940712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update (+=) a value in host memory, using local row index.  <br /></td></tr>
<tr class="separator:aa8faded8a81ded34bd1333aa75940712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa570cfaa74d682c6a704dc34efcdb2" id="r_aeaa570cfaa74d682c6a704dc34efcdb2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </td></tr>
<tr class="memitem:aeaa570cfaa74d682c6a704dc34efcdb2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_same&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a>, <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &gt;::value &amp;&amp;std::is_convertible&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a>, <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &gt;::value, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#aeaa570cfaa74d682c6a704dc34efcdb2">sumIntoLocalValue</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">lclRow</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t col, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">val</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> atomic=<a class="el" href="classTpetra_1_1MultiVector.html#af79a57ae7d7b00a821871824700dafeb">useAtomicUpdatesByDefault</a>)</td></tr>
<tr class="memdesc:aeaa570cfaa74d682c6a704dc34efcdb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the above sumIntoLocalValue, but only enabled if T differs from impl_scalar_type.  <br /></td></tr>
<tr class="separator:aeaa570cfaa74d682c6a704dc34efcdb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbeb860634427bff7afc9c827ceedbc2" id="r_afbeb860634427bff7afc9c827ceedbc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#afbeb860634427bff7afc9c827ceedbc2">putScalar</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;value)</td></tr>
<tr class="memdesc:afbeb860634427bff7afc9c827ceedbc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all values in the multivector with the given value.  <br /></td></tr>
<tr class="separator:afbeb860634427bff7afc9c827ceedbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b41d28a50db2f5ffb68ad455fceb292" id="r_a5b41d28a50db2f5ffb68ad455fceb292"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </td></tr>
<tr class="memitem:a5b41d28a50db2f5ffb68ad455fceb292"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_same&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a>, <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &gt;::value &amp;&amp;std::is_convertible&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a>, <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &gt;::value, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a5b41d28a50db2f5ffb68ad455fceb292">putScalar</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &amp;value)</td></tr>
<tr class="memdesc:a5b41d28a50db2f5ffb68ad455fceb292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all values in the multivector with the given value.  <br /></td></tr>
<tr class="separator:a5b41d28a50db2f5ffb68ad455fceb292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f63bc12712ae0141b4794d19ecf35e0" id="r_a1f63bc12712ae0141b4794d19ecf35e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a1f63bc12712ae0141b4794d19ecf35e0">randomize</a> ()</td></tr>
<tr class="memdesc:a1f63bc12712ae0141b4794d19ecf35e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all values in the multivector to pseudorandom numbers.  <br /></td></tr>
<tr class="separator:a1f63bc12712ae0141b4794d19ecf35e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f53da7612d960a1d091e8181513c96" id="r_ae9f53da7612d960a1d091e8181513c96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ae9f53da7612d960a1d091e8181513c96">randomize</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;minVal, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;maxVal)</td></tr>
<tr class="memdesc:ae9f53da7612d960a1d091e8181513c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all values in the multivector to pseudorandom numbers in the given range.  <br /></td></tr>
<tr class="separator:ae9f53da7612d960a1d091e8181513c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9ebfa68d7ea8fc2e3d1be679f10c65" id="r_aad9ebfa68d7ea8fc2e3d1be679f10c65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#aad9ebfa68d7ea8fc2e3d1be679f10c65">replaceMap</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">map</a>)</td></tr>
<tr class="memdesc:aad9ebfa68d7ea8fc2e3d1be679f10c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the underlying <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> in place.  <br /></td></tr>
<tr class="separator:aad9ebfa68d7ea8fc2e3d1be679f10c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9294b6cfafd55cc6ab2c3677175f0d" id="r_a1c9294b6cfafd55cc6ab2c3677175f0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a1c9294b6cfafd55cc6ab2c3677175f0d">reduce</a> ()</td></tr>
<tr class="memdesc:a1c9294b6cfafd55cc6ab2c3677175f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum values of a locally replicated multivector across all processes.  <br /></td></tr>
<tr class="separator:a1c9294b6cfafd55cc6ab2c3677175f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Methods implemented by subclasses and used by doTransfer().</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The <a class="el" href="classTpetra_1_1DistObject.html#a82a9a5fd0df1dda55188a340e6b5a2e7" title="Redistribute data across (MPI) processes.">doTransfer()</a> method uses the subclass' implementations of these methods to implement data transfer. Subclasses of <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> must implement these methods. This is an instance of the <a href="http://en.wikipedia.org/wiki/Template_method_pattern">Template Method Pattern</a>. ("Template" here doesn't mean "C++
template"; it means "pattern with holes that are filled in by
the subclass' method implementations.") </p>
</td></tr>
<tr class="memitem:abd8bf976983da5f805c0d7975dfe45dc" id="r_abd8bf976983da5f805c0d7975dfe45dc"><td class="memItemLeft" align="right" valign="top">Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#abd8bf976983da5f805c0d7975dfe45dc">map_</a></td></tr>
<tr class="memdesc:abd8bf976983da5f805c0d7975dfe45dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> over which this object is distributed.  <br /></td></tr>
<tr class="separator:abd8bf976983da5f805c0d7975dfe45dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e625c329325c60064dc133de40aed3b" id="r_a1e625c329325c60064dc133de40aed3b"><td class="memItemLeft" align="right" valign="top">Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1DistObject.html#a79749ff4d4160e4c97116d564f66af92">packet_type</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a1e625c329325c60064dc133de40aed3b">imports_</a></td></tr>
<tr class="memdesc:a1e625c329325c60064dc133de40aed3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer into which packed data are imported (received from other processes).  <br /></td></tr>
<tr class="separator:a1e625c329325c60064dc133de40aed3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1711cc6d0ea3921bd58fa27ba4a4dff8" id="r_a1711cc6d0ea3921bd58fa27ba4a4dff8"><td class="memItemLeft" align="right" valign="top">Kokkos::DualView&lt; size_t *, <a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a1711cc6d0ea3921bd58fa27ba4a4dff8">numImportPacketsPerLID_</a></td></tr>
<tr class="memdesc:a1711cc6d0ea3921bd58fa27ba4a4dff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of packets to receive for each receive operation.  <br /></td></tr>
<tr class="separator:a1711cc6d0ea3921bd58fa27ba4a4dff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5ef8b469cce85d13924f7e65318e06" id="r_a1a5ef8b469cce85d13924f7e65318e06"><td class="memItemLeft" align="right" valign="top">Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1DistObject.html#a79749ff4d4160e4c97116d564f66af92">packet_type</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a1a5ef8b469cce85d13924f7e65318e06">exports_</a></td></tr>
<tr class="memdesc:a1a5ef8b469cce85d13924f7e65318e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer from which packed data are exported (sent to other processes).  <br /></td></tr>
<tr class="separator:a1a5ef8b469cce85d13924f7e65318e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b397a38b1966ac9833d8990e3cae211" id="r_a9b397a38b1966ac9833d8990e3cae211"><td class="memItemLeft" align="right" valign="top">Kokkos::DualView&lt; size_t *, <a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a9b397a38b1966ac9833d8990e3cae211">numExportPacketsPerLID_</a></td></tr>
<tr class="memdesc:a9b397a38b1966ac9833d8990e3cae211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of packets to send for each send operation.  <br /></td></tr>
<tr class="separator:a9b397a38b1966ac9833d8990e3cae211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484241212e4d1ca7c2669a6729b57801" id="r_a484241212e4d1ca7c2669a6729b57801"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a484241212e4d1ca7c2669a6729b57801">packAndPrepare</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">source</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#a23e770e950420cc2a0b3018f1fe9315b">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">exportLIDs</a>, Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1DistObject.html#a79749ff4d4160e4c97116d564f66af92">packet_type</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a> &gt; &amp;exports, Kokkos::DualView&lt; size_t *, <a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a> &gt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">numPacketsPerLID</a>, size_t &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">constantNumPackets</a>)</td></tr>
<tr class="memdesc:a484241212e4d1ca7c2669a6729b57801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack data and metadata for communication (sends).  <br /></td></tr>
<tr class="separator:a484241212e4d1ca7c2669a6729b57801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fead8f57b7d0157e507847f3f04f1e" id="r_af3fead8f57b7d0157e507847f3f04f1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#af3fead8f57b7d0157e507847f3f04f1e">packAndPrepare</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">source</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#a23e770e950420cc2a0b3018f1fe9315b">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">exportLIDs</a>, Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1DistObject.html#a79749ff4d4160e4c97116d564f66af92">packet_type</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a> &gt; &amp;exports, Kokkos::DualView&lt; size_t *, <a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a> &gt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">numPacketsPerLID</a>, size_t &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">constantNumPackets</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#ab52fef102335f8ae2bf93fc45e390757">execution_space</a> &amp;space)</td></tr>
<tr class="memdesc:af3fead8f57b7d0157e507847f3f04f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as packAndPrepare, but in an execution space instance.  <br /></td></tr>
<tr class="separator:af3fead8f57b7d0157e507847f3f04f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb9c5a5d2e5532768bb494a583d2ab0" id="r_a9cb9c5a5d2e5532768bb494a583d2ab0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1DistObject.html#a9cb9c5a5d2e5532768bb494a583d2ab0">unpackAndCombine</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#a23e770e950420cc2a0b3018f1fe9315b">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">importLIDs</a>, Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1DistObject.html#a79749ff4d4160e4c97116d564f66af92">packet_type</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a> &gt; imports, Kokkos::DualView&lt; size_t *, <a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a> &gt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">numPacketsPerLID</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">constantNumPackets</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">combineMode</a>)</td></tr>
<tr class="memdesc:a9cb9c5a5d2e5532768bb494a583d2ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any unpacking and combining after communication.  <br /></td></tr>
<tr class="separator:a9cb9c5a5d2e5532768bb494a583d2ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Constructors and destructor</h2></td></tr>
<tr class="memitem:ab4e67d703dea75848ed94bdf56fa7620" id="r_ab4e67d703dea75848ed94bdf56fa7620"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ab4e67d703dea75848ed94bdf56fa7620">MultiVector</a> ()</td></tr>
<tr class="memdesc:ab4e67d703dea75848ed94bdf56fa7620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor: makes a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> with no rows or columns.  <br /></td></tr>
<tr class="separator:ab4e67d703dea75848ed94bdf56fa7620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3a72f3637153c63da72a012443d01c" id="r_ada3a72f3637153c63da72a012443d01c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ada3a72f3637153c63da72a012443d01c">MultiVector</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">map</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">numVecs</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">zeroOut</a>=<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">true</a>)</td></tr>
<tr class="memdesc:ada3a72f3637153c63da72a012443d01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic constuctor.  <br /></td></tr>
<tr class="separator:ada3a72f3637153c63da72a012443d01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a22efe05d77f0250a0b3482a279156" id="r_a40a22efe05d77f0250a0b3482a279156"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a40a22efe05d77f0250a0b3482a279156">MultiVector</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">source</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::DataAccess <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">copyOrView</a>)</td></tr>
<tr class="memdesc:a40a22efe05d77f0250a0b3482a279156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor, with option to do deep or shallow copy.  <br /></td></tr>
<tr class="separator:a40a22efe05d77f0250a0b3482a279156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018becd4ced5b2a8167b8cbfbdafec9b" id="r_a018becd4ced5b2a8167b8cbfbdafec9b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a018becd4ced5b2a8167b8cbfbdafec9b">MultiVector</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">map</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">A</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LDA</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t NumVectors)</td></tr>
<tr class="memdesc:a018becd4ced5b2a8167b8cbfbdafec9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create multivector by copying two-dimensional array of local data.  <br /></td></tr>
<tr class="separator:a018becd4ced5b2a8167b8cbfbdafec9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e2bb80941ea92900cd8f7b134b508b" id="r_ab2e2bb80941ea92900cd8f7b134b508b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ab2e2bb80941ea92900cd8f7b134b508b">MultiVector</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">map</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &gt; &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">ArrayOfPtrs</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t NumVectors)</td></tr>
<tr class="memdesc:ab2e2bb80941ea92900cd8f7b134b508b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create multivector by copying array of views of local data.  <br /></td></tr>
<tr class="separator:ab2e2bb80941ea92900cd8f7b134b508b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab24761c9a427241410a185541ec73f" id="r_abab24761c9a427241410a185541ec73f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#abab24761c9a427241410a185541ec73f">MultiVector</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">map</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#a8d9309c7680bb1030097ec3b8a912329">dual_view_type</a> &amp;view)</td></tr>
<tr class="memdesc:abab24761c9a427241410a185541ec73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, that takes a Kokkos::DualView of the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s data, and returns a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> that views those data.  <br /></td></tr>
<tr class="separator:abab24761c9a427241410a185541ec73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a99287c74bffaa38039a1e638d2bc5" id="r_ae9a99287c74bffaa38039a1e638d2bc5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ae9a99287c74bffaa38039a1e638d2bc5">MultiVector</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">map</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> dual_view_type::t_dev &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">d_view</a>)</td></tr>
<tr class="memdesc:ae9a99287c74bffaa38039a1e638d2bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, that takes a Kokkos::View of the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s data (living in the Device's memory space), and returns a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> that views those data.  <br /></td></tr>
<tr class="separator:ae9a99287c74bffaa38039a1e638d2bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9390e19a0b02a01e8230dc36f151c2" id="r_ace9390e19a0b02a01e8230dc36f151c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ace9390e19a0b02a01e8230dc36f151c2">MultiVector</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">map</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#a8d9309c7680bb1030097ec3b8a912329">dual_view_type</a> &amp;view, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#a8d9309c7680bb1030097ec3b8a912329">dual_view_type</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">origView</a>)</td></tr>
<tr class="memdesc:ace9390e19a0b02a01e8230dc36f151c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert mode constructor, that takes a Kokkos::DualView of the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s data and the "original" Kokkos::DualView of the data, and returns a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> that views those data.  <br /></td></tr>
<tr class="separator:ace9390e19a0b02a01e8230dc36f151c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc101f32c978188d21cc9ba70342b4f" id="r_a7dc101f32c978188d21cc9ba70342b4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a7dc101f32c978188d21cc9ba70342b4f">MultiVector</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">map</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Details_1_1WrappedDualView.html">wrapped_dual_view_type</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">d_view</a>)</td></tr>
<tr class="memdesc:a7dc101f32c978188d21cc9ba70342b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert mode constructor, that takes a WrappedDualView of the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s data.  <br /></td></tr>
<tr class="separator:a7dc101f32c978188d21cc9ba70342b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289f4962ad72779f2b8021b11147b6a9" id="r_a289f4962ad72779f2b8021b11147b6a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a289f4962ad72779f2b8021b11147b6a9">MultiVector</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">map</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#a8d9309c7680bb1030097ec3b8a912329">dual_view_type</a> &amp;view, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">whichVectors</a>)</td></tr>
<tr class="memdesc:a289f4962ad72779f2b8021b11147b6a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert mode constructor for noncontiguous views.  <br /></td></tr>
<tr class="separator:a289f4962ad72779f2b8021b11147b6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddd590f663d0c9ef04435e6b604f5cb" id="r_a9ddd590f663d0c9ef04435e6b604f5cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a9ddd590f663d0c9ef04435e6b604f5cb">MultiVector</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">map</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Details_1_1WrappedDualView.html">wrapped_dual_view_type</a> &amp;view, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">whichVectors</a>)</td></tr>
<tr class="memdesc:a9ddd590f663d0c9ef04435e6b604f5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert mode constructor for noncontiguous views.  <br /></td></tr>
<tr class="separator:a9ddd590f663d0c9ef04435e6b604f5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d15ec2b93d4683ad348e86bc14bd79" id="r_ad4d15ec2b93d4683ad348e86bc14bd79"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ad4d15ec2b93d4683ad348e86bc14bd79">MultiVector</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">map</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#a8d9309c7680bb1030097ec3b8a912329">dual_view_type</a> &amp;view, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#a8d9309c7680bb1030097ec3b8a912329">dual_view_type</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">origView</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">whichVectors</a>)</td></tr>
<tr class="memdesc:ad4d15ec2b93d4683ad348e86bc14bd79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert mode constructor for noncontiguous views, with original view.  <br /></td></tr>
<tr class="separator:ad4d15ec2b93d4683ad348e86bc14bd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2084349ee48d9e497753c5fbf525c6d" id="r_ae2084349ee48d9e497753c5fbf525c6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ae2084349ee48d9e497753c5fbf525c6d">MultiVector</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">X</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">subMap</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#a23e770e950420cc2a0b3018f1fe9315b">local_ordinal_type</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">rowOffset</a>=0)</td></tr>
<tr class="memdesc:ae2084349ee48d9e497753c5fbf525c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Offset view" constructor; make a view of a contiguous subset of rows on each process.  <br /></td></tr>
<tr class="separator:ae2084349ee48d9e497753c5fbf525c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b235e894f9bf83dbb7f3ec8fdd7633" id="r_a51b235e894f9bf83dbb7f3ec8fdd7633"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a51b235e894f9bf83dbb7f3ec8fdd7633">MultiVector</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">X</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">subMap</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">offset</a>=0)</td></tr>
<tr class="memdesc:a51b235e894f9bf83dbb7f3ec8fdd7633"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Offset view" constructor, that takes the new <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> as a <code>const <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>&amp;</code> rather than by RCP.  <br /></td></tr>
<tr class="separator:a51b235e894f9bf83dbb7f3ec8fdd7633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03649f570d26b5df6e6242904c3f71e" id="r_af03649f570d26b5df6e6242904c3f71e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#af03649f570d26b5df6e6242904c3f71e">MultiVector</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;)=<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">default</a></td></tr>
<tr class="memdesc:af03649f570d26b5df6e6242904c3f71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor (shallow copy).  <br /></td></tr>
<tr class="separator:af03649f570d26b5df6e6242904c3f71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d1099df2114e7f1918c3e45b2b0bb3" id="r_ad2d1099df2114e7f1918c3e45b2b0bb3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#ad2d1099df2114e7f1918c3e45b2b0bb3">MultiVector</a> (<a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&amp;)=<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">default</a></td></tr>
<tr class="memdesc:ad2d1099df2114e7f1918c3e45b2b0bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor (shallow move).  <br /></td></tr>
<tr class="separator:ad2d1099df2114e7f1918c3e45b2b0bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe0cc17a36bf8b4c6f180ee51d20367" id="r_a3fe0cc17a36bf8b4c6f180ee51d20367"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a3fe0cc17a36bf8b4c6f180ee51d20367">operator=</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;)=<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">default</a></td></tr>
<tr class="memdesc:a3fe0cc17a36bf8b4c6f180ee51d20367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assigment (shallow copy).  <br /></td></tr>
<tr class="separator:a3fe0cc17a36bf8b4c6f180ee51d20367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047b4f55257524c1d514ec5d132b450c" id="r_a047b4f55257524c1d514ec5d132b450c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a047b4f55257524c1d514ec5d132b450c">operator=</a> (<a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&amp;)=<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">default</a></td></tr>
<tr class="memdesc:a047b4f55257524c1d514ec5d132b450c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assigment (shallow move).  <br /></td></tr>
<tr class="separator:a047b4f55257524c1d514ec5d132b450c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d75314d84dbe586fa3e82ef4e41231" id="r_af2d75314d84dbe586fa3e82ef4e41231"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#af2d75314d84dbe586fa3e82ef4e41231">~MultiVector</a> ()=<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">default</a></td></tr>
<tr class="memdesc:af2d75314d84dbe586fa3e82ef4e41231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor (virtual for memory safety of derived classes).  <br /></td></tr>
<tr class="separator:af2d75314d84dbe586fa3e82ef4e41231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb0954bc8e5ec686960ecdf213dee42" id="r_a5bb0954bc8e5ec686960ecdf213dee42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#a5bb0954bc8e5ec686960ecdf213dee42">swap</a> (<a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">mv</a>)</td></tr>
<tr class="memdesc:a5bb0954bc8e5ec686960ecdf213dee42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap contents of <code>mv</code> with contents of <code>*this</code>.  <br /></td></tr>
<tr class="separator:a5bb0954bc8e5ec686960ecdf213dee42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e8d020fa470b2ef382ef3bcef7b213" id="r_af4e8d020fa470b2ef382ef3bcef7b213"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTpetra_1_1MultiVector.html#af4e8d020fa470b2ef382ef3bcef7b213">MultiVector</a> (<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">X</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">j</a>)</td></tr>
<tr class="memdesc:af4e8d020fa470b2ef382ef3bcef7b213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-column subview constructor, for derived classes ONLY.  <br /></td></tr>
<tr class="separator:af4e8d020fa470b2ef382ef3bcef7b213"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node&gt;<br />
class Tpetra::MultiVector&lt; Scalar, LocalOrdinal, GlobalOrdinal, Node &gt;</div><p>One or more distributed dense vectors. </p>
<p>A "multivector" contains one or more dense vectors. All the vectors in a multivector have the same distribution of rows in parallel over the communicator used to create the multivector. Multivectors containing more than one vector are useful for algorithms that solve multiple linear systems at once, or that solve for a cluster of eigenvalues and their corresponding eigenvectors at once. These "block" algorithms often have accuracy or performance advantages over corresponding algorithms that solve for only one vector at a time. For example, working with multiple vectors at a time allows <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> to use faster BLAS 3 routines for local computations. It may also reduce the number of parallel reductions.</p>
<p>The <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Vector</a> class implements the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> interface, so if you only wish to work with a single vector at a time, you may simply use <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Vector</a> instead of <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>. However, if you are writing solvers or preconditioners, you would do better to write to the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> interface and always assume that each <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> contains more than one vector. This will make your solver or preconditioner more compatible with other Trilinos packages, and it will also let you exploit the performance optimizations mentioned above.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The type of each entry of the multivector. (You can use real-valued or complex-valued types here, unlike in Epetra, where the scalar type is always <code>double</code>.) </td></tr>
    <tr><td class="paramname">LocalOrdinal</td><td>The type of local indices. See the documentation of <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> for requirements. </td></tr>
    <tr><td class="paramname">GlobalOrdinal</td><td>The type of global indices. See the documentation of <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> for requirements. </td></tr>
    <tr><td class="paramname">Node</td><td>The Kokkos Node type.</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Kokkos_KR_MV_prereq"></a>
Prerequisites</h1>
<p>Before reading the rest of this documentation, it helps to know a little bit about Kokkos. In particular, you should know about execution spaces, memory spaces, and shallow copy semantics. You should also know something about the Teuchos memory management classes, in particular Teuchos::RCP, though it helps to know a bit about Teuchos::ArrayRCP and Teuchos::ArrayView as well. You may also want to know about the differences between BLAS 1, 2, and 3 operations, and learn a little bit about MPI (the Message Passing Interface for distributed-memory programming). You won't have to use MPI directly to use <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>, but it helps to be familiar with the general idea of distributed storage of data over a communicator.</p>
<h1><a class="anchor" id="Kokkos_KR_MV_view"></a>
A MultiVector is a view of data</h1>
<p>A <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> is a view of data. A <em>view</em> behaves like a pointer; it provides access to the original multivector's data without copying the data. This means that the copy constructor and assignment operator (<code>operator=</code>) do <em>shallow</em> copies. They do <em>not</em> copy the data; they just copy pointers and other "metadata." If you would like to copy a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> into an existing <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>, call the nonmember function deep_copy(). If you would like to create a new <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> which is a deep copy of an existing <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>, call the nonmember function <a class="el" href="classTpetra_1_1MultiVector.html#a0d4d99be4ef954d973258b629d7281ac" title="Return a deep copy of the given MultiVector.">createCopy()</a>, or use the two-argument copy constructor with Teuchos::Copy as the second argument.</p>
<p>Views have the additional property that they automatically handle deallocation. They use <em>reference counting</em> for this, much like how std::shared_ptr works. That means you do not have to worry about "freeing" a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> after it has been created. Furthermore, you may pass shallow copies around without needing to worry about which is the "master" view of the data. There is no "master" view of the data; when the last view falls out of scope, the data will be deallocated.</p>
<p>This is what the documentation means when it speaks of <em>view semantics</em>. The opposite of that is <em>copy</em> or <em>container</em> semantics, where the copy constructor and <code>operator=</code> do deep copies (of the data). We say that "std::vector has container semantics," and "MultiVector has view
semantics."</p>
<p><a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> also has "subview" methods that give results analogous to the Kokkos::subview() function. That is, they return a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> which views some subset of another <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s rows and columns. The subset of columns in a view need not be contiguous. For example, given a multivector X with 43 columns, it is possible to have a multivector Y which is a view of columns 1, 3, and 42 (zero-based indices) of X. We call such multivectors <em>noncontiguous</em>. They have the the property that <a class="el" href="classTpetra_1_1MultiVector.html#add82b0581b87c0b43deb07113054172c" title="Whether this multivector has constant stride between columns.">isConstantStride()</a> returns false.</p>
<p>Noncontiguous multivectors lose some performance advantages. For example, local computations may be slower, since <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> cannot use BLAS 3 routines (e.g., matrix-matrix multiply) on a noncontiguous multivectors without copying into temporary contiguous storage. For performance reasons, if you get a Kokkos::View of a noncontiguous <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s local data, it does <em>not</em> correspond to the columns that the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> views.</p>
<h1><a class="anchor" id="Kokkos_KR_MV_dual"></a>
DualView semantics</h1>
<p><a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> was designed to perform well on many different kinds of computers. Some computers have different <em>memory spaces</em>. For example, GPUs (Graphics Processing Units) by NVIDIA have "device memory" and "host memory." The GPU has faster access to device memory than host memory, but usually there is less device memory than host memory. Intel's "Knights Landing" architecture has two different memory spaces, also with different capacity and performance characteristics. Some architectures let the processor address memory in any space, possibly with a performance penalty. Others can only access data in certain spaces, and require a special system call to copy memory between spaces.</p>
<p>The Kokkos package provides abstractions for handling multiple memory spaces. In particular, Kokkos::DualView lets users "mirror" data that live in one space, with data in another space. It also lets users manually mark data in one space as modified (modify()), and synchronize (sync()) data from one space to another. The latter only actually copies if the data have been marked as modified. Users can access data in a particular space by calling view(). All three of these methods &ndash; modify(), sync(), and view() &ndash; are templated on the memory space. This is how users select the memory space on which they want the method to act.</p>
<p><a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> implements "DualView semantics." This means that it implements the above three operations: </p><ul>
<li>
modify(): Mark data in a memory space as modified (or about to be modified)  </li>
<li>
sync(): If data in the target memory space are least recently modified compared with the other space, copy data to the target memory space  </li>
<li>
<a class="el" href="classTpetra_1_1MultiVector.html#a59fada0463f4c64162d20e47951f5711" title="Return a view of the local data on a specific device, with the given access mode. The return type is ...">getLocalView()</a>: Return a Kokkos::View of the data in a given memory space  </li>
</ul>
<p>If your computer only has one memory space, as with conventional single-core or multicore processors, you don't have to worry about this. You can ignore the modify() and sync() methods in that case.</p>
<h1><a class="anchor" id="Kokkos_KR_MV_access"></a>
How to access the local data</h1>
<p>The <a class="el" href="classTpetra_1_1MultiVector.html#a59fada0463f4c64162d20e47951f5711" title="Return a view of the local data on a specific device, with the given access mode. The return type is ...">getLocalView()</a> method for getting a Kokkos::View is the main way to access a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s local data. If you want to read or write the actual values in a multivector, this is what you want. The resulting Kokkos::View behaves like a 2-D array. You can address it using an index pair (i,j), where i is the local row index, and j is the column index.</p>
<p><a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> also has methods that return an Teuchos::ArrayRCP&lt;Scalar&gt; ("1-D view"), or a Teuchos::ArrayRCP&lt;Teuchos::ArrayRCP&lt;Scalar&gt; &gt; ("2-D view"). These exist only for backwards compatibility, and also give access to the local data.</p>
<p>All of these views only view <em>local</em> data. This means that the corresponding rows of the multivector are owned by the calling (MPI) process. You may <em>not</em> use these methods to access <em>remote</em> data, that is, rows that do not belong to the calling process.</p>
<p><a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s public interface also has methods for modifying local data, like <a class="el" href="classTpetra_1_1MultiVector.html#aa8faded8a81ded34bd1333aa75940712" title="Update (+=) a value in host memory, using local row index.">sumIntoLocalValue()</a> and <a class="el" href="classTpetra_1_1MultiVector.html#a8d32396b1f980611f12c31994c200a25" title="Replace value in host memory, using global row index.">replaceGlobalValue()</a>. These methods act on host data <em>only</em>. To access or modify device data, you must get the Kokkos::View and work with it directly.</p>
<h1><a class="anchor" id="Kokkos_KR_MV_why"></a>
Why won't you give me a raw pointer?</h1>
<p><a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> was designed to allow different data representations underneath the same interface. This lets <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> run correctly and efficiently on many different kinds of hardware. These different kinds of hardware all have in common the following: </p><ul>
<li>
Data layout matters a lot for performance  </li>
<li>
The right layout for your data depends on the hardware  </li>
<li>
Data may be distributed over different memory spaces in hardware, and efficient code must respect this, whether or not the programming model presents the different memories as a single address space  </li>
<li>
Copying between different data layouts or memory spaces is expensive and should be avoided whenever possible  </li>
<li>
Optimal data layout may require control over initialization of storage  </li>
</ul>
<p>These conclusions have practical consequences for the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> interface. In particular, we have deliberately made it difficult for you to access data directly by raw pointer. This is because the underlying layout may not be what you expect. The memory might not even be accessible from the host CPU. Instead, we give access through a Kokkos::View, which behaves like a 2-D array. You can ask the Kokkos::View for a raw pointer by calling its <code>data()</code> method, but then you are responsible for understanding its layout in memory.</p>
<h1><a class="anchor" id="Kokkos_KR_MV_dist"></a>
Parallel distribution of data</h1>
<p>A <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s rows are distributed over processes in its (row) <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>'s communicator. A <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> is a <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a>; the <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> of the <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> tells which process in the communicator owns which rows. This means that you may use <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> and <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> operations to migrate between different distributions. Please refer to the documentation of <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>, <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a>, and <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> for more information.</p>
<p><a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> includes methods that perform parallel all-reduces. These include inner products and various kinds of norms. All of these methods have the same blocking semantics as <code>MPI_Allreduce</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Some computational methods, such as inner products and norms, may return incorrect results if the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> is overlapping (not one-to-one) but not locally replicated. That is, if some but not all rows are shared by more than one process in the communicator, then inner products and norms may be wrong. This behavior may change in future releases. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l00350">350</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a798f64a312664da3cc1e43738c4c0ec0" name="a798f64a312664da3cc1e43738c4c0ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798f64a312664da3cc1e43738c4c0ec0">&#9670;&#160;</a></span>scalar_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::scalar_type =  <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of each entry in the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l00356">356</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="aa6015995ea4c087f317aada3994fbd01" name="aa6015995ea4c087f317aada3994fbd01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6015995ea4c087f317aada3994fbd01">&#9670;&#160;</a></span>impl_scalar_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::impl_scalar_type =  <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> Kokkos::ArithTraits&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>&gt;::val_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type used internally in place of <code>Scalar</code>. </p>
<p>Some <code>Scalar</code> types might not work with Kokkos on all execution spaces, due to missing CUDA device macros or missing volatile overloads of some methods. The C++ standard type <code>std::complex&lt;T&gt;</code> has this problem. To fix this, we replace <code>std::complex&lt;T&gt;</code> values internally with the bitwise identical type <code>Kokkos::complex&lt;T&gt;</code>. The latter is the <code>impl_scalar_type</code> corresponding to <code>Scalar = std::complex&lt;T&gt;</code>.</p>
<p>Most users don't need to know about this. Just be aware that if you ask for a Kokkos::View or Kokkos::DualView of the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s data, its entries have type <code>impl_scalar_type</code>, not <code>scalar_type</code>. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l00372">372</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="aa13797b2505f2b68367b4d4413a2f98c" name="aa13797b2505f2b68367b4d4413a2f98c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13797b2505f2b68367b4d4413a2f98c">&#9670;&#160;</a></span>map_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::map_type =  <a class="el" href="classTpetra_1_1Map.html">Map</a>&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> specialization used by this class. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l00380">380</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a23e770e950420cc2a0b3018f1fe9315b" name="a23e770e950420cc2a0b3018f1fe9315b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e770e950420cc2a0b3018f1fe9315b">&#9670;&#160;</a></span>local_ordinal_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::local_ordinal_type =  <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1Map.html#a777128f8251acb73e09af1a4689ed9f0">map_type::local_ordinal_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of local indices that this class uses. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l00382">382</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a040b35e734b4162bba42c5a6d2f53d10" name="a040b35e734b4162bba42c5a6d2f53d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040b35e734b4162bba42c5a6d2f53d10">&#9670;&#160;</a></span>global_ordinal_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::global_ordinal_type =  <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1Map.html#a37b210a895282f8575a3e48837a58aab">map_type::global_ordinal_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of global indices that this class uses. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l00384">384</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a9114e22e58c9c70b153b341c4f6134d0" name="a9114e22e58c9c70b153b341c4f6134d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9114e22e58c9c70b153b341c4f6134d0">&#9670;&#160;</a></span>device_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::device_type =  <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1Map.html#afc10fafadc443d72af3be25dfb944b51">map_type::device_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This class' preferred Kokkos device type. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l00386">386</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a0e2eafc5434402b790165efbf5418dae" name="a0e2eafc5434402b790165efbf5418dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2eafc5434402b790165efbf5418dae">&#9670;&#160;</a></span>node_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::node_type =  <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1Map.html#a29e003133a7ac66aa92439e07c455af4">map_type::node_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Legacy thing that you should not use any more. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l00388">388</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a6b5ff6294071bb6f75dd92fa8e9b1bda" name="a6b5ff6294071bb6f75dd92fa8e9b1bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5ff6294071bb6f75dd92fa8e9b1bda">&#9670;&#160;</a></span>dot_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::dot_type =  <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> Kokkos::Details::InnerProductSpaceTraits&lt;<a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a>&gt;::dot_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of an inner ("dot") product result. </p>
<p>This is usually the same as <code>impl_scalar_type</code>, but may differ if <code>impl_scalar_type</code> is e.g., an uncertainty quantification type from the Stokhos package. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l00395">395</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="addf0baff5a335005840b1ea926822abc" name="addf0baff5a335005840b1ea926822abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf0baff5a335005840b1ea926822abc">&#9670;&#160;</a></span>mag_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::mag_type =  <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> Kokkos::ArithTraits&lt;<a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a>&gt;::mag_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of a norm result. </p>
<p>This is usually the same as the type of the magnitude (absolute value) of <code>impl_scalar_type</code>, but may differ if <code>impl_scalar_type</code> is e.g., an uncertainty quantification type from the Stokhos package. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l00407">407</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="ab52fef102335f8ae2bf93fc45e390757" name="ab52fef102335f8ae2bf93fc45e390757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab52fef102335f8ae2bf93fc45e390757">&#9670;&#160;</a></span>execution_space</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::execution_space =  <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> device_type::execution_space</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the (new) Kokkos execution space. </p>
<p>The execution space implements parallel operations, like parallel_for, parallel_reduce, and parallel_scan. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l00414">414</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a8d9309c7680bb1030097ec3b8a912329" name="a8d9309c7680bb1030097ec3b8a912329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9309c7680bb1030097ec3b8a912329">&#9670;&#160;</a></span>dual_view_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::dual_view_type =  Kokkos::DualView&lt;<a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a>**, Kokkos::LayoutLeft, <a class="el" href="classTpetra_1_1MultiVector.html#a9114e22e58c9c70b153b341c4f6134d0">device_type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kokkos::DualView specialization used by this class. </p>
<p>This is of interest to users who already have a Kokkos::DualView, and want the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> to view it. By "view" it, we mean that the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> doesn't copy the data in the DualView; it just hangs on to the pointer.</p>
<p>We take particular care to template the DualView on an execution space, rather than a memory space. This ensures that <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> will use exactly the specified execution space(s) and no others. This matters because View (and DualView) initialization is a parallel Kokkos kernel. If the View is templated on an execution space, Kokkos uses that execution space (and only that execution space) to initialize the View. This is what we want. If the View is templated on a <em>memory</em> space, Kokkos uses the memory space's default <em>execution</em> space to initialize. This is not necessarily what we want. For example, if building with OpenMP enabled, the default execution space for host memory is Kokkos::OpenMP, even if the user-specified DeviceType is Kokkos::Serial. That is why we go through the trouble of asking for the execution_space's execution space. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l00438">438</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a6576557039b8bae3b2cc06aeefd8c8d7" name="a6576557039b8bae3b2cc06aeefd8c8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6576557039b8bae3b2cc06aeefd8c8d7">&#9670;&#160;</a></span>buffer_device_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::buffer_device_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kokkos::Device specialization for communication buffers. </p>
<p>See #1088 for why this is not just <code>device_type::device_type</code>. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l02274">2274</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a79749ff4d4160e4c97116d564f66af92" name="a79749ff4d4160e4c97116d564f66af92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79749ff4d4160e4c97116d564f66af92">&#9670;&#160;</a></span>packet_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">using</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::packet_type =  <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> ::Kokkos::ArithTraits&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &gt;::val_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of each datum being sent or received in an <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> or <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a>. </p>
<p>Note that this type does not always correspond to the <code>Scalar</code> template parameter of subclasses. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html#l00298">298</a> of file <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html">Tpetra_DistObject_decl.hpp</a>.</p>

</div>
</div>
<a id="a142f6b49db9d7bc4cb94e8488f89309c" name="a142f6b49db9d7bc4cb94e8488f89309c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142f6b49db9d7bc4cb94e8488f89309c">&#9670;&#160;</a></span>buffer_memory_space</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::buffer_memory_space</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kokkos memory space for communication buffers. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html#l00722">722</a> of file <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html">Tpetra_DistObject_decl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ac1ff98c164c772986e2a5db411a311ab" name="ac1ff98c164c772986e2a5db411a311ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ff98c164c772986e2a5db411a311ab">&#9670;&#160;</a></span>ReverseOption</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">enum</a> <a class="el" href="classTpetra_1_1DistObject.html#ac1ff98c164c772986e2a5db411a311ab">Tpetra::DistObject::ReverseOption</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the data transfer should be performed in forward or reverse mode. </p>
<p>"Reverse mode" means calling <a class="el" href="classTpetra_1_1DistObject.html#ad2623c99b47ce9d88692abdc094d8be6" title="Export data into this object using an Export object (&quot;forward mode&quot;).">doExport()</a> with an <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> object, or calling <a class="el" href="classTpetra_1_1DistObject.html#a2e2cce34ee9698060f87e1fad3695a2d" title="Import data into this object using an Import object (&quot;forward mode&quot;).">doImport()</a> with an <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> object. "Forward mode" means calling <a class="el" href="classTpetra_1_1DistObject.html#ad2623c99b47ce9d88692abdc094d8be6" title="Export data into this object using an Export object (&quot;forward mode&quot;).">doExport()</a> with an <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> object, or calling <a class="el" href="classTpetra_1_1DistObject.html#a2e2cce34ee9698060f87e1fad3695a2d" title="Import data into this object using an Import object (&quot;forward mode&quot;).">doImport()</a> with an <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> object. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html#l00652">652</a> of file <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html">Tpetra_DistObject_decl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab4e67d703dea75848ed94bdf56fa7620" name="ab4e67d703dea75848ed94bdf56fa7620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e67d703dea75848ed94bdf56fa7620">&#9670;&#160;</a></span>MultiVector() <span class="overload">[1/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::MultiVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor: makes a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> with no rows or columns. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l00401">401</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="ada3a72f3637153c63da72a012443d01c" name="ada3a72f3637153c63da72a012443d01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3a72f3637153c63da72a012443d01c">&#9670;&#160;</a></span>MultiVector() <span class="overload">[2/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::MultiVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t&#160;</td>
          <td class="paramname"><em>numVecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td>
          <td class="paramname"><em>zeroOut</em> = <code><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Basic constuctor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>[in] <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> describing the distribution of rows. </td></tr>
    <tr><td class="paramname">numVecs</td><td>[in] Number of vectors (columns). </td></tr>
    <tr><td class="paramname">zeroOut</td><td>[in] Whether to initialize all the entries of the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> to zero. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l00406">406</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a40a22efe05d77f0250a0b3482a279156" name="a40a22efe05d77f0250a0b3482a279156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a22efe05d77f0250a0b3482a279156">&#9670;&#160;</a></span>MultiVector() <span class="overload">[3/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::MultiVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::DataAccess&#160;</td>
          <td class="paramname"><em>copyOrView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor, with option to do deep or shallow copy. </p>
<p>The current (so-called "Kokkos refactor," circa &gt;= 2014/5) version of <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a>, unlike the previous "classic" version, always has view semantics. Thus, copyOrView = Teuchos::View has no effect, and copyOrView = Teuchos::Copy does not mark this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> as having copy semantics. However, copyOrView = Teuchos::Copy will make the resulting <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> a deep copy of the input <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l00419">419</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a018becd4ced5b2a8167b8cbfbdafec9b" name="a018becd4ced5b2a8167b8cbfbdafec9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018becd4ced5b2a8167b8cbfbdafec9b">&#9670;&#160;</a></span>MultiVector() <span class="overload">[4/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::MultiVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t&#160;</td>
          <td class="paramname"><em>NumVectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create multivector by copying two-dimensional array of local data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>[in] The <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> describing the distribution of rows of the multivector. </td></tr>
    <tr><td class="paramname">view</td><td>[in] A view of column-major dense matrix data. The calling process will make a deep copy of this data. </td></tr>
    <tr><td class="paramname">LDA</td><td>[in] The leading dimension (a.k.a. "stride") of the column-major input data. </td></tr>
    <tr><td class="paramname">NumVectors</td><td>[in] The number of columns in the input data. This will be the number of vectors in the returned multivector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>LDA &gt;= A.size() </dd>
<dd>
NumVectors &gt; 0 </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classTpetra_1_1MultiVector.html#add82b0581b87c0b43deb07113054172c" title="Whether this multivector has constant stride between columns.">isConstantStride()</a> == true </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l00847">847</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="ab2e2bb80941ea92900cd8f7b134b508b" name="ab2e2bb80941ea92900cd8f7b134b508b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e2bb80941ea92900cd8f7b134b508b">&#9670;&#160;</a></span>MultiVector() <span class="overload">[5/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::MultiVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ArrayOfPtrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t&#160;</td>
          <td class="paramname"><em>NumVectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create multivector by copying array of views of local data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>[in] The <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> describing the distribution of rows of the multivector. </td></tr>
    <tr><td class="paramname">ArrayOfPtrs</td><td>[in/out] Array of views of each column's data. The calling process will make a deep copy of this data. </td></tr>
    <tr><td class="paramname">NumVectors</td><td>[in] The number of columns in the input data, and the number of elements in ArrayOfPtrs. This will be the number of vectors in the returned multivector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>NumVectors &gt; 0 </dd>
<dd>
NumVectors == ArrayOfPtrs.size() </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>constantStride() == true </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l00920">920</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="abab24761c9a427241410a185541ec73f" name="abab24761c9a427241410a185541ec73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab24761c9a427241410a185541ec73f">&#9670;&#160;</a></span>MultiVector() <span class="overload">[6/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::MultiVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#a8d9309c7680bb1030097ec3b8a912329">dual_view_type</a> &amp;&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor, that takes a Kokkos::DualView of the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s data, and returns a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> that views those data. </p>
<p>To "view those data" means that this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> and the input Kokkos::DualView point to the same data, just like two "raw" pointers (e.g., <code>double*</code>) can point to the same data. If you modify one, the other sees it (subject to the limitations of cache coherence).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>[in] <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> describing the distribution of rows. </td></tr>
    <tr><td class="paramname">view</td><td>[in] Kokkos::DualView of the data to view. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l00452">452</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="ae9a99287c74bffaa38039a1e638d2bc5" name="ae9a99287c74bffaa38039a1e638d2bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a99287c74bffaa38039a1e638d2bc5">&#9670;&#160;</a></span>MultiVector() <span class="overload">[7/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::MultiVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> dual_view_type::t_dev &amp;&#160;</td>
          <td class="paramname"><em>d_view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor, that takes a Kokkos::View of the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s data (living in the Device's memory space), and returns a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> that views those data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>[in] <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> describing the distribution of rows. </td></tr>
    <tr><td class="paramname">view</td><td>[in] Kokkos::View of the data to view.</td></tr>
  </table>
  </dd>
</dl>
<p>Q: What's the difference between this constructor (that takes a Kokkos::View), and the constructor above that takes a Kokkos::DualView?</p>
<p>A: Suppose that for the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s device type, there are actually two memory spaces (e.g., for Kokkos::Cuda with UVM off, assuming that this is allowed). In order for <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> to implement DualView semantics correctly, this constructor must allocate a Kokkos::View of host memory (or lazily allocate it on modify() or sync()).</p>
<p>Now suppose that you pass in the same Kokkos::View of device memory to two different <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> instances, X and Y. Each would allocate its own Kokkos::View of host memory. That means that X and Y would have different DualView instances, but their DualView instances would have the same device View.</p>
<p>Suppose that you do the following: </p><ol>
<li>
Modify X on host (calling modify() correctly)  </li>
<li>
Modify Y on host (calling modify() correctly)  </li>
<li>
Sync Y to device (calling sync() correctly)  </li>
<li>
Sync X to device (calling sync() correctly)  </li>
</ol>
<p>This would clobber Y's later changes on host, in favor of X's earlier changes on host. That could be very confusing. We allow this behavior because Kokkos::DualView allows it. That is, Kokkos::DualView also lets you get the device View, and hand it off to another Kokkos::DualView. It's confusing, but users need to know what they are doing if they start messing around with multiple memory spaces. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l00518">518</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="ace9390e19a0b02a01e8230dc36f151c2" name="ace9390e19a0b02a01e8230dc36f151c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9390e19a0b02a01e8230dc36f151c2">&#9670;&#160;</a></span>MultiVector() <span class="overload">[8/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::MultiVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#a8d9309c7680bb1030097ec3b8a912329">dual_view_type</a> &amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#a8d9309c7680bb1030097ec3b8a912329">dual_view_type</a> &amp;&#160;</td>
          <td class="paramname"><em>origView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expert mode constructor, that takes a Kokkos::DualView of the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s data and the "original" Kokkos::DualView of the data, and returns a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> that views those data. </p>
<dl class="section warning"><dt>Warning</dt><dd>This constructor is only for expert users. We make no promises about backwards compatibility for this interface. It may change or go away at any time. It is mainly useful for <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> developers and we do not expect it to be useful for anyone else.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>[in] <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> describing the distribution of rows. </td></tr>
    <tr><td class="paramname">view</td><td>[in] View of the data (shallow copy). </td></tr>
    <tr><td class="paramname">origView</td><td>[in] The original view of the data.</td></tr>
  </table>
  </dd>
</dl>
<p>The original view keeps the "original" dimensions. Doing so lets us safely construct a column <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> view of a (domain <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> view of a (column <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>)). The result of a Kokkos::subview does not remember the original dimensions of the view, and does not allow constructing a view with a superset of rows or columns, so we have to keep the original view. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l00560">560</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a7dc101f32c978188d21cc9ba70342b4f" name="a7dc101f32c978188d21cc9ba70342b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc101f32c978188d21cc9ba70342b4f">&#9670;&#160;</a></span>MultiVector() <span class="overload">[9/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::MultiVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Details_1_1WrappedDualView.html">wrapped_dual_view_type</a> &amp;&#160;</td>
          <td class="paramname"><em>d_view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expert mode constructor, that takes a WrappedDualView of the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s data. </p>
<dl class="section warning"><dt>Warning</dt><dd>This constructor is only for expert users. We make no promises about backwards compatibility for this interface. It may change or go away at any time. It is mainly useful for <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> developers and we do not expect it to be useful for anyone else. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l00485">485</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="af4e8d020fa470b2ef382ef3bcef7b213" name="af4e8d020fa470b2ef382ef3bcef7b213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e8d020fa470b2ef382ef3bcef7b213">&#9670;&#160;</a></span>MultiVector() <span class="overload">[10/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::MultiVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Single-column subview constructor, for derived classes ONLY. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>[in] Input <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> to view (in possibly nonconst fashion). </td></tr>
    <tr><td class="paramname">j</td><td>[in] The column of X to view. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03495">3495</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a289f4962ad72779f2b8021b11147b6a9" name="a289f4962ad72779f2b8021b11147b6a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289f4962ad72779f2b8021b11147b6a9">&#9670;&#160;</a></span>MultiVector() <span class="overload">[11/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::MultiVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#a8d9309c7680bb1030097ec3b8a912329">dual_view_type</a> &amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>whichVectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expert mode constructor for noncontiguous views. </p>
<dl class="section warning"><dt>Warning</dt><dd>This constructor is only for expert users. We make no promises about backwards compatibility for this interface. It may change or go away at any time. It is mainly useful for <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> developers and we do not expect it to be useful for anyone else.</dd></dl>
<p>This constructor takes a Kokkos::DualView for the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> to view, and a list of the columns to view, and returns a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> that views those data. The resulting <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> does <em>not</em> have constant stride, that is, <a class="el" href="classTpetra_1_1MultiVector.html#add82b0581b87c0b43deb07113054172c" title="Whether this multivector has constant stride between columns.">isConstantStride()</a> returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>[in] <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> describing the distribution of rows. </td></tr>
    <tr><td class="paramname">view</td><td>[in] Device view to the data (shallow copy). </td></tr>
    <tr><td class="paramname">whichVectors</td><td>[in] Which columns (vectors) to view. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l00599">599</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a9ddd590f663d0c9ef04435e6b604f5cb" name="a9ddd590f663d0c9ef04435e6b604f5cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ddd590f663d0c9ef04435e6b604f5cb">&#9670;&#160;</a></span>MultiVector() <span class="overload">[12/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::MultiVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Details_1_1WrappedDualView.html">wrapped_dual_view_type</a> &amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>whichVectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expert mode constructor for noncontiguous views. </p>
<dl class="section warning"><dt>Warning</dt><dd>This constructor is only for expert users. We make no promises about backwards compatibility for this interface. It may change or go away at any time. It is mainly useful for <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> developers and we do not expect it to be useful for anyone else.</dd></dl>
<p>This constructor takes a Kokkos::DualView for the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> to view, and a list of the columns to view, and returns a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> that views those data. The resulting <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> does <em>not</em> have constant stride, that is, <a class="el" href="classTpetra_1_1MultiVector.html#add82b0581b87c0b43deb07113054172c" title="Whether this multivector has constant stride between columns.">isConstantStride()</a> returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>[in] <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> describing the distribution of rows. </td></tr>
    <tr><td class="paramname">view</td><td>[in] WrappedDualView to the data (shallow copy). </td></tr>
    <tr><td class="paramname">whichVectors</td><td>[in] Which columns (vectors) to view. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l00679">679</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="ad4d15ec2b93d4683ad348e86bc14bd79" name="ad4d15ec2b93d4683ad348e86bc14bd79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d15ec2b93d4683ad348e86bc14bd79">&#9670;&#160;</a></span>MultiVector() <span class="overload">[13/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::MultiVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#a8d9309c7680bb1030097ec3b8a912329">dual_view_type</a> &amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#a8d9309c7680bb1030097ec3b8a912329">dual_view_type</a> &amp;&#160;</td>
          <td class="paramname"><em>origView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>whichVectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expert mode constructor for noncontiguous views, with original view. </p>
<dl class="section warning"><dt>Warning</dt><dd>This constructor is only for expert users. We make no promises about backwards compatibility for this interface. It may change or go away at any time. It is mainly useful for <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> developers and we do not expect it to be useful for anyone else.</dd></dl>
<p>This constructor takes a Kokkos::DualView for the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> to view, a view of the "original" data, and a list of the columns to view, and returns a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> that views those data. The resulting <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> does <em>not</em> have constant stride, that is, <a class="el" href="classTpetra_1_1MultiVector.html#add82b0581b87c0b43deb07113054172c" title="Whether this multivector has constant stride between columns.">isConstantStride()</a> returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>[in] <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> describing the distribution of rows. </td></tr>
    <tr><td class="paramname">view</td><td>[in] View of the data (shallow copy). </td></tr>
    <tr><td class="paramname">origView</td><td>[in] The original view of the data. </td></tr>
    <tr><td class="paramname">whichVectors</td><td>[in] Which columns (vectors) to view.</td></tr>
  </table>
  </dd>
</dl>
<p>The original view keeps the "original" dimensions. Doing so lets us safely construct a column <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> view of a (domain <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> view of a (column <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>)). The result of a Kokkos::subview does not remember the original dimensions of the view, and does not allow constructing a view with a superset of rows or columns, so we have to keep the original view. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l00759">759</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="ae2084349ee48d9e497753c5fbf525c6d" name="ae2084349ee48d9e497753c5fbf525c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2084349ee48d9e497753c5fbf525c6d">&#9670;&#160;</a></span>MultiVector() <span class="overload">[14/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::MultiVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#a23e770e950420cc2a0b3018f1fe9315b">local_ordinal_type</a>&#160;</td>
          <td class="paramname"><em>rowOffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Offset view" constructor; make a view of a contiguous subset of rows on each process. </p>
<p>Return a view of the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> <code>X</code>, which views a subset of the rows of <code>X</code>. Specify the subset by a subset <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s current row <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>, and an optional (local) offset. "View" means "alias": if the original (this) <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s data change, the view will see the changed data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>[in] The <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> to view. </td></tr>
    <tr><td class="paramname">subMap</td><td>[in] The row <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> for the new <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>. This must be a subset <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> of the input <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s row <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>. </td></tr>
    <tr><td class="paramname">offset</td><td>[in] The local row offset at which to start the view.</td></tr>
  </table>
  </dd>
</dl>
<p>Suppose that you have a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> X, and you want to view X, on all processes in X's (MPI) communicator, as split into two row blocks X1 and X2. One could express this in Matlab notation as X = [X1; X2], except that here, X1 and X2 are views into X, rather than copies of X's data. This method assumes that the <em>local</em> indices of X1 and X2 are each contiguous, and that the local indices of X2 follow those of X1. If that is not the case, you cannot use views to divide X into blocks like this; you must instead use the <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> or <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> functionality, which copies the relevant rows of X.</p>
<p>Here is how you would construct the views X1 and X2. </p><div class="fragment"><div class="line"><a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">MultiVector&lt;&gt;</a> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">X</a> (...); <span class="comment">// the input MultiVector</span></div>
<div class="line"><span class="comment">// ... fill X with data ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>Teuchos::RCP;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Map that on each process in X&#39;s communicator,</span></div>
<div class="line"><span class="comment">// contains the global indices of the rows of X1.</span></div>
<div class="line"><a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">RCP&lt;const Map&lt;&gt;</a>&gt; <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">map1</a> (<span class="keyword">new</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Map&lt;&gt;</a> (...));</div>
<div class="line"><span class="comment">// Map that on each process in X&#39;s communicator,</span></div>
<div class="line"><span class="comment">// contains the global indices of the rows of X2.</span></div>
<div class="line"><a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">RCP&lt;const Map&lt;&gt;</a>&gt; <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">map2</a> (<span class="keyword">new</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Map&lt;&gt;</a> (...));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the first view X1.  The second argument, the offset,</span></div>
<div class="line"><span class="comment">// is the index of the local row at which to start the view.</span></div>
<div class="line"><span class="comment">// X1 is the topmost block of X, so the offset is zero.</span></div>
<div class="line"><a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">MultiVector&lt;&gt;</a> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">X1</a> (<a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">X</a>, <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">map1</a>, 0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the second view X2.  X2 is directly below X1 in X,</span></div>
<div class="line"><span class="comment">// so the offset is the local number of rows in X1.  This is</span></div>
<div class="line"><span class="comment">// the same as the local number of entries in map1.</span></div>
<div class="line"><a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">MultiVector&lt;&gt;</a> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">X1</a> (<a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">X</a>, <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">map2</a>, <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">X1</a>.getLocalLength ());</div>
<div class="ttc" id="aclassTpetra_1_1CrsMatrixStruct_html"><div class="ttname"><a href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::CrsMatrixStruct</a></div><div class="ttdoc">Struct that holds views of the contents of a CrsMatrix.</div><div class="ttdef"><b>Definition</b> <a href="TpetraExt__MMHelpers__decl_8hpp_source.html#l00036">TpetraExt_MMHelpers_decl.hpp:36</a></div></div>
</div><!-- fragment --><p>It is legal, in the above example, for X1 or X2 to have zero local rows on any or all process(es). In that case, the corresponding <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> must have zero local entries on that / those process(es). In particular, if X2 has zero local rows on a process, then the corresponding offset on that process would be the number of local rows in X (and therefore in X1) on that process. This is the only case in which the sum of the local number of entries in <code>subMap</code> (in this case, zero) and the offset may equal the number of local entries in <code>*this</code>. </p>

</div>
</div>
<a id="a51b235e894f9bf83dbb7f3ec8fdd7633" name="a51b235e894f9bf83dbb7f3ec8fdd7633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b235e894f9bf83dbb7f3ec8fdd7633">&#9670;&#160;</a></span>MultiVector() <span class="overload">[15/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::MultiVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &amp;&#160;</td>
          <td class="paramname"><em>subMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Offset view" constructor, that takes the new <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> as a <code>const <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>&amp;</code> rather than by RCP. </p>
<p>This constructor exists for backwards compatibility. It invokes the input <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>'s copy constructor, which is a shallow copy. Maps are immutable anyway, so the copy is harmless. </p>

</div>
</div>
<a id="af03649f570d26b5df6e6242904c3f71e" name="af03649f570d26b5df6e6242904c3f71e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03649f570d26b5df6e6242904c3f71e">&#9670;&#160;</a></span>MultiVector() <span class="overload">[16/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::MultiVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor (shallow copy). </p>
<p><a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s copy constructor always does a shallow copy. Use the nonmember function <code><a class="el" href="namespaceTpetra.html#a0c2a95e65b2f6106b307f7f7a8551e71" title="Copy the contents of the MultiVector src into dst.">Tpetra::deep_copy</a></code> (see below) to deep-copy one existing <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> to another, and use the two-argument "copy constructor" (in this file, with <code>copyOrView=Teuchos::Copy</code>) to create a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> that is a deep copy of an existing <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>. </p>

</div>
</div>
<a id="ad2d1099df2114e7f1918c3e45b2b0bb3" name="ad2d1099df2114e7f1918c3e45b2b0bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d1099df2114e7f1918c3e45b2b0bb3">&#9670;&#160;</a></span>MultiVector() <span class="overload">[17/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::MultiVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor (shallow move). </p>

</div>
</div>
<a id="af2d75314d84dbe586fa3e82ef4e41231" name="af2d75314d84dbe586fa3e82ef4e41231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d75314d84dbe586fa3e82ef4e41231">&#9670;&#160;</a></span>~MultiVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::~<a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor (virtual for memory safety of derived classes). </p>
<dl class="section note"><dt>Note</dt><dd>To <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> developers: See the C++ Core Guidelines C.21 ("If you define or &lt;tt&gt;=delete&lt;/tt&gt; any default operation,
  define or &lt;tt&gt;=delete&lt;/tt&gt; them all"), in particular the AbstractBase example, for why this destructor declaration implies that we need the above four <code>=default</code> declarations for copy construction, move construction, copy assignment, and move assignment. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3fe0cc17a36bf8b4c6f180ee51d20367" name="a3fe0cc17a36bf8b4c6f180ee51d20367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe0cc17a36bf8b4c6f180ee51d20367">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp; <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assigment (shallow copy). </p>
<p><a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s copy constructor always does a shallow copy. Use the nonmember function <code><a class="el" href="namespaceTpetra.html#a0c2a95e65b2f6106b307f7f7a8551e71" title="Copy the contents of the MultiVector src into dst.">Tpetra::deep_copy</a></code> (see below) to deep-copy one existing <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> to another. </p>

</div>
</div>
<a id="a047b4f55257524c1d514ec5d132b450c" name="a047b4f55257524c1d514ec5d132b450c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047b4f55257524c1d514ec5d132b450c">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp; <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assigment (shallow move). </p>

</div>
</div>
<a id="a5bb0954bc8e5ec686960ecdf213dee42" name="a5bb0954bc8e5ec686960ecdf213dee42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb0954bc8e5ec686960ecdf213dee42">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; ST, LO, GO, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">NT</a> &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>mv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap contents of <code>mv</code> with contents of <code>*this</code>. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l04566">4566</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a8d32396b1f980611f12c31994c200a25" name="a8d32396b1f980611f12c31994c200a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d32396b1f980611f12c31994c200a25">&#9670;&#160;</a></span>replaceGlobalValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::replaceGlobalValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>&#160;</td>
          <td class="paramname"><em>gblRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace value in host memory, using global row index. </p>
<p>Replace the current value at row <code>gblRow</code> (a global index) and column <code>col</code> with the given value. The column index is zero based.</p>
<p>This method affects the host memory version of the data. If <code>device_type</code> is a Kokkos device that has two memory spaces, and you want to modify the non-host version of the data, you must access the device View directly by calling <a class="el" href="classTpetra_1_1MultiVector.html#a59fada0463f4c64162d20e47951f5711" title="Return a view of the local data on a specific device, with the given access mode. The return type is ...">getLocalView()</a>. Please see modify(), sync(), and the discussion of DualView semantics elsewhere in the documentation. This method calls sync_host() before modifying host data, and modify_host() afterwards.</p>
<p>This method does not have an "atomic" option like sumIntoGlobalValue. This is deliberate. Replacement is not commutative, unlike += (modulo rounding error). Concurrent calls to replaceGlobalValue on different threads that modify the same entry/ies have undefined results. (It's not just that one thread might win; it's that the value might get messed up.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gblRow</td><td>[in] Global row index of the entry to modify. This <em>must</em> be a valid global row index on the calling process with respect to the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>. </td></tr>
    <tr><td class="paramname">col</td><td>[in] Column index of the entry to modify. </td></tr>
    <tr><td class="paramname">value</td><td>[in] Incoming value to add to the entry. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l04191">4191</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a293acae425ea5e8d83d6aa141756714b" name="a293acae425ea5e8d83d6aa141756714b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293acae425ea5e8d83d6aa141756714b">&#9670;&#160;</a></span>replaceGlobalValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_same&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a>, <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &gt;::value &amp;&amp;std::is_convertible&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a>, <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &gt;::value, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::replaceGlobalValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>&#160;</td>
          <td class="paramname"><em>globalRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like the above replaceGlobalValue, but only enabled if T differs from impl_scalar_type. </p>
<p>This method only exists if its template parameter <code>T</code> and impl_scalar_type differ, and if it is syntactically possible to convert <code>T</code> to impl_scalar_type. This method is mainly useful for backwards compatibility, when the Scalar template parameter differs from impl_scalar_type. That is commonly only the case when Scalar is std::complex&lt;U&gt; for some type U.</p>
<p>This method affects the host memory version of the data. If <code>device_type</code> is a Kokkos device that has two memory spaces, and you want to modify the non-host version of the data, you must access the device View directly by calling <a class="el" href="classTpetra_1_1MultiVector.html#a59fada0463f4c64162d20e47951f5711" title="Return a view of the local data on a specific device, with the given access mode. The return type is ...">getLocalView()</a>. Please see modify(), sync(), and the discussion of DualView semantics elsewhere in the documentation. This method calls sync_host() before modifying host data, and modify_host() afterwards.</p>
<p>This method does not have an "atomic" option like sumIntoGlobalValue. This is deliberate. Replacement is not commutative, unlike += (modulo rounding error). Concurrent calls to replaceGlobalValue on different threads that modify the same entry/ies have undefined results. (It's not just that one thread might win; it's that the value might get messed up.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gblRow</td><td>[in] Global row index of the entry to modify. This <em>must</em> be a valid global row index on the calling process with respect to the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>. </td></tr>
    <tr><td class="paramname">col</td><td>[in] Column index of the entry to modify. </td></tr>
    <tr><td class="paramname">value</td><td>[in] Incoming value to add to the entry. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l00887">887</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="abf793ee4674bffee54df32ecb94e8256" name="abf793ee4674bffee54df32ecb94e8256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf793ee4674bffee54df32ecb94e8256">&#9670;&#160;</a></span>sumIntoGlobalValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::sumIntoGlobalValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>&#160;</td>
          <td class="paramname"><em>gblRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td>
          <td class="paramname"><em>atomic</em> = <code><a class="el" href="classTpetra_1_1MultiVector.html#af79a57ae7d7b00a821871824700dafeb">useAtomicUpdatesByDefault</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update (+=) a value in host memory, using global row index. </p>
<p>Add the given value to the existing value at row <code>gblRow</code> (a global index) and column <code>col</code>. The column index is zero based.</p>
<p>This method affects the host memory version of the data. If <code>device_type</code> is a Kokkos device that has two memory spaces, and you want to modify the non-host version of the data, you must access the device View directly by calling <a class="el" href="classTpetra_1_1MultiVector.html#a59fada0463f4c64162d20e47951f5711" title="Return a view of the local data on a specific device, with the given access mode. The return type is ...">getLocalView()</a>. Please see modify(), sync(), and the discussion of DualView semantics elsewhere in the documentation. This method calls sync_host() before modifying host data, and modify_host() afterwards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gblRow</td><td>[in] Global row index of the entry to modify. This <em>must</em> be a valid global row index on the calling process with respect to the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>. </td></tr>
    <tr><td class="paramname">col</td><td>[in] Column index of the entry to modify. </td></tr>
    <tr><td class="paramname">value</td><td>[in] Incoming value to add to the entry. </td></tr>
    <tr><td class="paramname">atomic</td><td>[in] Whether to use an atomic update. If this class' execution space is not Kokkos::Serial, then this is true by default, else it is false by default. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l04213">4213</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a607e5ccfa4c4ac98538ec1d5c2d8492e" name="a607e5ccfa4c4ac98538ec1d5c2d8492e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607e5ccfa4c4ac98538ec1d5c2d8492e">&#9670;&#160;</a></span>sumIntoGlobalValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_same&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a>, <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &gt;::value &amp;&amp;std::is_convertible&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a>, <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &gt;::value, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::sumIntoGlobalValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>&#160;</td>
          <td class="paramname"><em>gblRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td>
          <td class="paramname"><em>atomic</em> = <code><a class="el" href="classTpetra_1_1MultiVector.html#af79a57ae7d7b00a821871824700dafeb">useAtomicUpdatesByDefault</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like the above sumIntoGlobalValue, but only enabled if T differs from impl_scalar_type. </p>
<p>This method only exists if its template parameter <code>T</code> and impl_scalar_type differ, and if it is syntactically possible to convert <code>T</code> to impl_scalar_type. This method is mainly useful for backwards compatibility, when the Scalar template parameter differs from impl_scalar_type. That is commonly only the case when Scalar is std::complex&lt;U&gt; for some type U.</p>
<p>This method affects the host memory version of the data. If <code>device_type</code> is a Kokkos device that has two memory spaces, and you want to modify the non-host version of the data, you must access the device View directly by calling <a class="el" href="classTpetra_1_1MultiVector.html#a59fada0463f4c64162d20e47951f5711" title="Return a view of the local data on a specific device, with the given access mode. The return type is ...">getLocalView()</a>. Please see modify(), sync(), and the discussion of DualView semantics elsewhere in the documentation. This method calls sync_host() before modifying host data, and modify_host() afterwards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gblRow</td><td>[in] Global row index of the entry to modify. This <em>must</em> be a valid global row index on the calling process with respect to the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>. </td></tr>
    <tr><td class="paramname">col</td><td>[in] Column index of the entry to modify. </td></tr>
    <tr><td class="paramname">val</td><td>[in] Incoming value to add to the entry. </td></tr>
    <tr><td class="paramname">atomic</td><td>[in] Whether to use an atomic update. If this class' execution space is not Kokkos::Serial, then this is true by default, else it is false by default. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l00953">953</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a522140b91b74f9fc1d2dbf0f5ef7edfb" name="a522140b91b74f9fc1d2dbf0f5ef7edfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a522140b91b74f9fc1d2dbf0f5ef7edfb">&#9670;&#160;</a></span>replaceLocalValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::replaceLocalValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>&#160;</td>
          <td class="paramname"><em>lclRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace value in host memory, using local (row) index. </p>
<p>Replace the current value at row <code>lclRow</code> (a local index) and column <code>col</code> with the given value. The column index is zero based.</p>
<p>This method affects the host memory version of the data. If <code>device_type</code> is a Kokkos device that has two memory spaces, and you want to modify the non-host version of the data, you must access the device View directly by calling <a class="el" href="classTpetra_1_1MultiVector.html#a59fada0463f4c64162d20e47951f5711" title="Return a view of the local data on a specific device, with the given access mode. The return type is ...">getLocalView()</a>. Please see modify(), sync(), and the discussion of DualView semantics elsewhere in the documentation. This method calls sync_host() before modifying host data, and modify_host() afterwards.</p>
<p>This method does not have an "atomic" option like sumIntoLocalValue. This is deliberate. Replacement is not commutative, unlike += (modulo rounding error). Concurrent calls to replaceLocalValue on different threads that modify the same entry/ies have undefined results. (It's not just that one thread might win; it's that the value might get messed up.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lclRow</td><td>[in] Local row index of the entry to modify. Must be a valid local index in this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> on the calling process. </td></tr>
    <tr><td class="paramname">col</td><td>[in] Column index of the entry to modify. </td></tr>
    <tr><td class="paramname">value</td><td>[in] Incoming value to add to the entry. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l04131">4131</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="ae7bbfc6ffa48db404ac33745834f16ee" name="ae7bbfc6ffa48db404ac33745834f16ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7bbfc6ffa48db404ac33745834f16ee">&#9670;&#160;</a></span>replaceLocalValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_same&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a>, <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &gt;::value &amp;&amp;std::is_convertible&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a>, <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &gt;::value, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::replaceLocalValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>&#160;</td>
          <td class="paramname"><em>lclRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like the above replaceLocalValue, but only enabled if T differs from impl_scalar_type. </p>
<p>This method only exists if its template parameter <code>T</code> and impl_scalar_type differ, and if it is syntactically possible to convert <code>T</code> to impl_scalar_type. This method is mainly useful for backwards compatibility, when the Scalar template parameter differs from impl_scalar_type. That is commonly only the case when Scalar is std::complex&lt;U&gt; for some type U.</p>
<p>This method affects the host memory version of the data. If <code>device_type</code> is a Kokkos device that has two memory spaces, and you want to modify the non-host version of the data, you must access the device View directly by calling <a class="el" href="classTpetra_1_1MultiVector.html#a59fada0463f4c64162d20e47951f5711" title="Return a view of the local data on a specific device, with the given access mode. The return type is ...">getLocalView()</a>. Please see modify(), sync(), and the discussion of DualView semantics elsewhere in the documentation. This method calls sync_host() before modifying host data, and modify_host() afterwards.</p>
<p>This method does not have an "atomic" option like sumIntoLocalValue. This is deliberate. Replacement is not commutative, unlike += (modulo rounding error). Concurrent calls to replaceLocalValue on different threads that modify the same entry/ies have undefined results. (It's not just that one thread might win; it's that the value might get messed up.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lclRow</td><td>[in] Local row index of the entry to modify. Must be a valid local index in this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> on the calling process. </td></tr>
    <tr><td class="paramname">col</td><td>[in] Column index of the entry to modify. </td></tr>
    <tr><td class="paramname">val</td><td>[in] Incoming value to add to the entry. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l01029">1029</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="aa8faded8a81ded34bd1333aa75940712" name="aa8faded8a81ded34bd1333aa75940712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8faded8a81ded34bd1333aa75940712">&#9670;&#160;</a></span>sumIntoLocalValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::sumIntoLocalValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>&#160;</td>
          <td class="paramname"><em>lclRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td>
          <td class="paramname"><em>atomic</em> = <code><a class="el" href="classTpetra_1_1MultiVector.html#af79a57ae7d7b00a821871824700dafeb">useAtomicUpdatesByDefault</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update (+=) a value in host memory, using local row index. </p>
<p>Add the given value to the existing value at row <code>localRow</code> (a local index) and column <code>col</code>. The column index is zero based.</p>
<p>This method affects the host memory version of the data. If <code>device_type</code> is a Kokkos device that has two memory spaces, and you want to modify the non-host version of the data, you must access the device View directly by calling <a class="el" href="classTpetra_1_1MultiVector.html#a59fada0463f4c64162d20e47951f5711" title="Return a view of the local data on a specific device, with the given access mode. The return type is ...">getLocalView()</a>. Please see modify(), sync(), and the discussion of DualView semantics elsewhere in the documentation. This method calls sync_host() before modifying host data, and modify_host() afterwards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lclRow</td><td>[in] Local row index of the entry to modify. Must be a valid local index in this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> on the calling process. </td></tr>
    <tr><td class="paramname">col</td><td>[in] Column index of the entry to modify. </td></tr>
    <tr><td class="paramname">val</td><td>[in] Incoming value to add to the entry. </td></tr>
    <tr><td class="paramname">atomic</td><td>[in] Whether to use an atomic update. If this class' execution space is not Kokkos::Serial, then this is true by default, else it is false by default. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l04158">4158</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="aeaa570cfaa74d682c6a704dc34efcdb2" name="aeaa570cfaa74d682c6a704dc34efcdb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa570cfaa74d682c6a704dc34efcdb2">&#9670;&#160;</a></span>sumIntoLocalValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_same&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a>, <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &gt;::value &amp;&amp;std::is_convertible&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a>, <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &gt;::value, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::sumIntoLocalValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>&#160;</td>
          <td class="paramname"><em>lclRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td>
          <td class="paramname"><em>atomic</em> = <code><a class="el" href="classTpetra_1_1MultiVector.html#af79a57ae7d7b00a821871824700dafeb">useAtomicUpdatesByDefault</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like the above sumIntoLocalValue, but only enabled if T differs from impl_scalar_type. </p>
<p>This method only exists if its template parameter <code>T</code> and impl_scalar_type differ, and if it is syntactically possible to convert <code>T</code> to impl_scalar_type. This method is mainly useful for backwards compatibility, when the Scalar template parameter differs from impl_scalar_type. That is commonly only the case when Scalar is std::complex&lt;U&gt; for some type U.</p>
<p>This method affects the host memory version of the data. If <code>device_type</code> is a Kokkos device that has two memory spaces, and you want to modify the non-host version of the data, you must access the device View directly by calling <a class="el" href="classTpetra_1_1MultiVector.html#a59fada0463f4c64162d20e47951f5711" title="Return a view of the local data on a specific device, with the given access mode. The return type is ...">getLocalView()</a>. Please see modify(), sync(), and the discussion of DualView semantics elsewhere in the documentation. This method calls sync_host() before modifying host data, and modify_host() afterwards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lclRow</td><td>[in] Local row index of the entry to modify. </td></tr>
    <tr><td class="paramname">col</td><td>[in] Column index of the entry to modify. </td></tr>
    <tr><td class="paramname">val</td><td>[in] Incoming value to add to the entry. </td></tr>
    <tr><td class="paramname">atomic</td><td>[in] Whether to use an atomic update. If this class' execution space is not Kokkos::Serial, then this is true by default, else it is false by default. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l01093">1093</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="afbeb860634427bff7afc9c827ceedbc2" name="afbeb860634427bff7afc9c827ceedbc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbeb860634427bff7afc9c827ceedbc2">&#9670;&#160;</a></span>putScalar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::putScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all values in the multivector with the given value. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l02560">2560</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a5b41d28a50db2f5ffb68ad455fceb292" name="a5b41d28a50db2f5ffb68ad455fceb292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b41d28a50db2f5ffb68ad455fceb292">&#9670;&#160;</a></span>putScalar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_same&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a>, <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &gt;::value &amp;&amp;std::is_convertible&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a>, <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &gt;::value, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::putScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all values in the multivector with the given value. </p>
<p>This method only exists if its template parameter <code>T</code> and impl_scalar_type differ, and if it is syntactically possible to convert <code>T</code> to impl_scalar_type. This method is mainly useful for backwards compatibility, when the Scalar template parameter differs from impl_scalar_type. That is commonly only the case when Scalar is std::complex&lt;U&gt; for some type U. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l01113">1113</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a1f63bc12712ae0141b4794d19ecf35e0" name="a1f63bc12712ae0141b4794d19ecf35e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f63bc12712ae0141b4794d19ecf35e0">&#9670;&#160;</a></span>randomize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::randomize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all values in the multivector to pseudorandom numbers. </p>
<dl class="section note"><dt>Note</dt><dd>Do not expect repeatable results. </dd>
<dd>
Behavior of this method may or may not depend on external use of the C library routines srand() and rand(). In particular, setting the seed there may not affect it here. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method does <em>not</em> promise to use a distributed-memory parallel pseudorandom number generator. Corresponding values on different processes might be correlated. It also does not promise to use a high-quality pseudorandom number generator within each process. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l02513">2513</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="ae9f53da7612d960a1d091e8181513c96" name="ae9f53da7612d960a1d091e8181513c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f53da7612d960a1d091e8181513c96">&#9670;&#160;</a></span>randomize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::randomize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>minVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>maxVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all values in the multivector to pseudorandom numbers in the given range. </p>
<dl class="section note"><dt>Note</dt><dd>Do not expect repeatable results. </dd>
<dd>
Behavior of this method may or may not depend on external use of the C library routines srand() and rand(). In particular, setting the seed there may not affect it here. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method does <em>not</em> promise to use a distributed-memory parallel pseudorandom number generator. Corresponding values on different processes might be correlated. It also does not promise to use a high-quality pseudorandom number generator within each process. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l02531">2531</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="aad9ebfa68d7ea8fc2e3d1be679f10c65" name="aad9ebfa68d7ea8fc2e3d1be679f10c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9ebfa68d7ea8fc2e3d1be679f10c65">&#9670;&#160;</a></span>replaceMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::replaceMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the underlying <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> in place. </p>
<dl class="section warning"><dt>Warning</dt><dd>The normal use case of this method, with an input <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> that is compatible with the object's current <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> and has the same communicator, is safe. However, if the input <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> has a different communicator (with a different number of processes, in particular) than this object's current <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>, the semantics of this method are tricky. We recommend that only experts try the latter use case.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If the new <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>'s communicator is similar to the original <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>'s communicator, then the original <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> and new <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> must be compatible: <code>map-&gt;isCompatible (this-&gt;getMap ())</code>. "Similar" means that the communicators have the same number of processes, though these need not be in the same order (have the same assignments of ranks) or represent the same communication contexts. It means the same thing as the MPI_SIMILAR return value of MPI_COMM_COMPARE. See MPI 3.0 Standard, Section 6.4.1.</dd>
<dd>
If the new <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>'s communicator contains more processes than the original <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>'s communicator, then the projection of the original <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> onto the new communicator must be compatible with the new <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>.</dd>
<dd>
If the new <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>'s communicator contains fewer processes than the original <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>'s communicator, then the projection of the new <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> onto the original communicator must be compatible with the original <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>.</dd></dl>
<p>This method replaces this object's <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> with the given <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>. This relabels the rows of the multivector using the global IDs in the input <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>. Thus, it implicitly applies a permutation, without actually moving data. If the new <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>'s communicator has more processes than the original <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>'s communicator, it "projects" the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> onto the new <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> by filling in missing rows with zeros. If the new <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>'s communicator has fewer processes than the original <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>'s communicator, the method "forgets about" any rows that do not exist in the new <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>. (It mathematical terms, if one considers a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> as a function from one vector space to another, this operation <em>restricts</em> the range.)</p>
<p>This method must always be called collectively on the communicator with the largest number of processes: either this object's current communicator (<code>this-&gt;<a class="el" href="classTpetra_1_1DistObject.html#adef545d3737b47c030e0e6a3e7d8b1e7" title="The Map describing the parallel distribution of this object.">getMap()</a>-&gt;getComm()</code>), or the new <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>'s communicator (<code>map-&gt;getComm()</code>). If the new <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>'s communicator has fewer processes, then the new <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> must be null on processes excluded from the original communicator, and the current <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> must be nonnull on all processes. If the new <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> has more processes, then it must be nonnull on all those processes, and the original <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> must be null on those processes which are not in the new <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>'s communicator. (The latter case can only happen to a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> to which a <a class="el" href="classTpetra_1_1MultiVector.html#aad9ebfa68d7ea8fc2e3d1be679f10c65" title="Replace the underlying Map in place.">replaceMap()</a> operation has happened before.)</p>
<dl class="section warning"><dt>Warning</dt><dd>This method must always be called as a collective operation on all processes in the original communicator (<code>this-&gt;getMap ()-&gt;getComm ()</code>). We reserve the right to do checking in debug mode that requires this method to be called collectively in order not to deadlock.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method does <em>not</em> do data redistribution. If you need to move data around, use <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> or <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l02600">2600</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a1c9294b6cfafd55cc6ab2c3677175f0d" name="a1c9294b6cfafd55cc6ab2c3677175f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c9294b6cfafd55cc6ab2c3677175f0d">&#9670;&#160;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::reduce </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum values of a locally replicated multivector across all processes. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method may only be called for locally replicated MultiVectors.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classTpetra_1_1DistObject.html#afc178c45d66d8232f27b1e79fc0e1535" title="Whether this is a globally distributed object.">isDistributed()</a> == false </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l04099">4099</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a69c7c2057bde6ba15c123cb3b9fad83f" name="a69c7c2057bde6ba15c123cb3b9fad83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c7c2057bde6ba15c123cb3b9fad83f">&#9670;&#160;</a></span>subCopy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &gt; <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::subCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::Range1D &amp;&#160;</td>
          <td class="paramname"><em>colRng</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> with copies of selected columns. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03146">3146</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="adb4288a7b4894118c533c2c74e6823f2" name="adb4288a7b4894118c533c2c74e6823f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb4288a7b4894118c533c2c74e6823f2">&#9670;&#160;</a></span>subCopy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &gt; <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::subCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> with copies of selected columns. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03119">3119</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a285e244524edddafccde2d67bd2ccff5" name="a285e244524edddafccde2d67bd2ccff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285e244524edddafccde2d67bd2ccff5">&#9670;&#160;</a></span>subView() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &gt; <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::subView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::Range1D &amp;&#160;</td>
          <td class="paramname"><em>colRng</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a const <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> with const views of selected columns. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03375">3375</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a1815cb70d294852d0a0db73d4238bf26" name="a1815cb70d294852d0a0db73d4238bf26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1815cb70d294852d0a0db73d4238bf26">&#9670;&#160;</a></span>subView() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &gt; <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::subView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a const <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> with const views of selected columns. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03328">3328</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="accfae85bbbad08e633ce9ca5f7fa3957" name="accfae85bbbad08e633ce9ca5f7fa3957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfae85bbbad08e633ce9ca5f7fa3957">&#9670;&#160;</a></span>subViewNonConst() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &gt; <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::subViewNonConst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::Range1D &amp;&#160;</td>
          <td class="paramname"><em>colRng</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> with views of selected columns. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03488">3488</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="ae7cd6e8fa9fd0c7e83155ae99c9ca240" name="ae7cd6e8fa9fd0c7e83155ae99c9ca240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7cd6e8fa9fd0c7e83155ae99c9ca240">&#9670;&#160;</a></span>subViewNonConst() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &gt; <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::subViewNonConst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> with views of selected columns. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03480">3480</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a3206f47461023595ff7719a8b2d9af49" name="a3206f47461023595ff7719a8b2d9af49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3206f47461023595ff7719a8b2d9af49">&#9670;&#160;</a></span>offsetView()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &gt; <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::offsetView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a const view of a subset of rows. </p>
<p>Return a const (nonmodifiable) view of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> consisting of a subset of the rows, as specified by an offset and a subset <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s current row <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>. If you want X1 or X2 to be nonconst (modifiable) views, use <a class="el" href="classTpetra_1_1MultiVector.html#ae8144625014f563392bba7b338e42f80" title="Return a nonconst view of a subset of rows.">offsetViewNonConst()</a> with the same arguments. "View" means "alias": if the original (this) <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s data change, the view will see the changed data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subMap</td><td>[in] The row <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> for the new <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>. This must be a subset <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s row <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>. </td></tr>
    <tr><td class="paramname">offset</td><td>[in] The local row offset at which to start the view.</td></tr>
  </table>
  </dd>
</dl>
<p>Suppose that you have a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> X, and you want to view X, on all processes in X's (MPI) communicator, as split into two row blocks X1 and X2. One could express this in Matlab notation as X = [X1; X2], except that here, X1 and X2 are views into X, rather than copies of X's data. This method assumes that the <em>local</em> indices of X1 and X2 are each contiguous, and that the local indices of X2 follow those of X1. If that is not the case, you cannot use views to divide X into blocks like this; you must instead use the <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> or <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> functionality, which copies the relevant rows of X.</p>
<p>Here is how you would construct the views X1 and X2. </p><div class="fragment"><div class="line"><span class="keyword">using </span>Teuchos::RCP;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Map&lt;LO, GO, Node&gt;</a> <a class="code hl_typedef" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::MultiVector&lt;Scalar, LO, GO, Node&gt;</a> MV;</div>
<div class="line"> </div>
<div class="line">MV <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">X</a> (...); <span class="comment">// the input MultiVector</span></div>
<div class="line"><span class="comment">// ... fill X with data ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Map that on each process in X&#39;s communicator,</span></div>
<div class="line"><span class="comment">// contains the global indices of the rows of X1.</span></div>
<div class="line"><a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">RCP&lt;const map_type&gt;</a> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">map1</a> (<span class="keyword">new</span> <a class="code hl_class" href="classTpetra_1_1Map.html">map_type</a> (...));</div>
<div class="line"><span class="comment">// Map that on each process in X&#39;s communicator,</span></div>
<div class="line"><span class="comment">// contains the global indices of the rows of X2.</span></div>
<div class="line"><a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">RCP&lt;const map_type&gt;</a> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">map2</a> (<span class="keyword">new</span> <a class="code hl_class" href="classTpetra_1_1Map.html">map_type</a> (...));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the first view X1.  The second argument, the offset,</span></div>
<div class="line"><span class="comment">// is the index of the local row at which to start the view.</span></div>
<div class="line"><span class="comment">// X1 is the topmost block of X, so the offset is zero.</span></div>
<div class="line"><a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">RCP&lt;const MV&gt;</a> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">X1</a> = <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">X</a>.offsetView (<a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">map1</a>, 0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the second view X2.  X2 is directly below X1 in X,</span></div>
<div class="line"><span class="comment">// so the offset is the local number of rows in X1.  This is</span></div>
<div class="line"><span class="comment">// the same as the local number of entries in map1.</span></div>
<div class="line"><a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">RCP&lt;const MV&gt;</a> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">X2</a> = <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">X</a>.offsetView (<a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">map2</a>, <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">X1</a>-&gt;getLocalLength ());</div>
<div class="ttc" id="aclassTpetra_1_1Map_html"><div class="ttname"><a href="classTpetra_1_1Map.html">Tpetra::Map</a></div><div class="ttdoc">A parallel distribution of indices over processes.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__Map__decl_8hpp_source.html#l00197">Tpetra_Map_decl.hpp:197</a></div></div>
<div class="ttc" id="aclassTpetra_1_1MultiVector_html_aa13797b2505f2b68367b4d4413a2f98c"><div class="ttname"><a href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">Tpetra::MultiVector::map_type</a></div><div class="ttdeci">Map&lt; LocalOrdinal, GlobalOrdinal, Node &gt; map_type</div><div class="ttdoc">The type of the Map specialization used by this class.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__MultiVector__decl_8hpp_source.html#l00380">Tpetra_MultiVector_decl.hpp:380</a></div></div>
</div><!-- fragment --><p>It is legal, in the above example, for X1 or X2 to have zero local rows on any or all process(es). In that case, the corresponding <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> must have zero local entries on that / those process(es). In particular, if X2 has zero local rows on a process, then the corresponding offset on that process would be the number of local rows in X (and therefore in X1) on that process. This is the only case in which the sum of the local number of entries in <code>subMap</code> (in this case, zero) and the <code>offset</code> may equal the number of local entries in <code>*this</code>. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03310">3310</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="ae8144625014f563392bba7b338e42f80" name="ae8144625014f563392bba7b338e42f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8144625014f563392bba7b338e42f80">&#9670;&#160;</a></span>offsetViewNonConst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &gt; <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::offsetViewNonConst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a nonconst view of a subset of rows. </p>
<p>Return a nonconst (modifiable) view of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> consisting of a subset of the rows, as specified by an offset and a subset <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s current row <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>. If you want X1 or X2 to be const (nonmodifiable) views, use <a class="el" href="classTpetra_1_1MultiVector.html#a3206f47461023595ff7719a8b2d9af49" title="Return a const view of a subset of rows.">offsetView()</a> with the same arguments. "View" means "alias": if the original (this) <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s data change, the view will see the changed data, and if the view's data change, the original <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> will see the changed data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subMap</td><td>[in] The row <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> for the new <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>. This must be a subset <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s row <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>. </td></tr>
    <tr><td class="paramname">offset</td><td>[in] The local row offset at which to start the view.</td></tr>
  </table>
  </dd>
</dl>
<p>See the documentation of <a class="el" href="classTpetra_1_1MultiVector.html#a3206f47461023595ff7719a8b2d9af49" title="Return a const view of a subset of rows.">offsetView()</a> for a code example and an explanation of edge cases. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03319">3319</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a70768f09fa210af4fe087bdd06594607" name="a70768f09fa210af4fe087bdd06594607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70768f09fa210af4fe087bdd06594607">&#9670;&#160;</a></span>getVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Vector.html">Vector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &gt; <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::getVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Vector</a> which is a const view of column j. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03543">3543</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a40d5485e8a14af1b04cecc529eadcab1" name="a40d5485e8a14af1b04cecc529eadcab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40d5485e8a14af1b04cecc529eadcab1">&#9670;&#160;</a></span>getVectorNonConst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1Vector.html">Vector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &gt; <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::getVectorNonConst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Vector</a> which is a nonconst view of column j. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03551">3551</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a6c24ad7a31e1108e679cd5ba1449eb55" name="a6c24ad7a31e1108e679cd5ba1449eb55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c24ad7a31e1108e679cd5ba1449eb55">&#9670;&#160;</a></span>getData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::ArrayRCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &gt; <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::getData </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const view of the local values in a particular vector of this multivector. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03065">3065</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="add1f43d53048705b89b37af8097253c7" name="add1f43d53048705b89b37af8097253c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1f43d53048705b89b37af8097253c7">&#9670;&#160;</a></span>getDataNonConst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::ArrayRCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &gt; <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::getDataNonConst </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>View of the local values in a particular vector of this multivector. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03094">3094</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a086e98c453c86b9ef132d6bc242d6204" name="a086e98c453c86b9ef132d6bc242d6204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086e98c453c86b9ef132d6bc242d6204">&#9670;&#160;</a></span>get1dCopy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::get1dCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t&#160;</td>
          <td class="paramname"><em>LDA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the given array with a copy of this multivector's local values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>[out] View of the array to fill. We consider A as a matrix with column-major storage.</td></tr>
    <tr><td class="paramname">LDA</td><td>[in] Leading dimension of the matrix A. </td></tr>
  </table>
  </dd>
</dl>
<p>problematic example</p><ul>
<li>a host view is checked out by users ; this increase ref count on host view</li>
<li>when the view is const view, it does not raise modify_host() flag</li>
<li>when we use useHostVersion logic (this-&gt;<a class="el" href="classTpetra_1_1MultiVector.html#a4a9346ae5c04153b94aae8660ecbf8d4" title="Whether this MultiVector needs synchronization to the device.">need_sync_device()</a>) to figure out more recent version, the flag is false as the user checked out a const view</li>
<li>as a result, it attempts to use device view and it volate ref count rule</li>
<li>the other case of using device view is also problematic solution</li>
<li>any non const view is alive outside, we cannot give a copy</li>
<li>if a user takes a const view, we use the same host/device view not to violate ref count rule.</li>
</ul>
<p>there is non-const host or device view outside, we cannot give a copy as a user can change the local data and we do not know which one the user want as a copy</p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03558">3558</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="abdc320a72fd71c4f6332c802fbbcf6ff" name="abdc320a72fd71c4f6332c802fbbcf6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc320a72fd71c4f6332c802fbbcf6ff">&#9670;&#160;</a></span>get2dCopy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::get2dCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ArrayOfPtrs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the given array with a copy of this multivector's local values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ArrayOfPtrs</td><td>[out] Array of arrays, one for each column of the multivector. On output, we fill ArrayOfPtrs[j] with the data for column j of this multivector. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03633">3633</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a7ecf3d07f3a10ec697787680f0107136" name="a7ecf3d07f3a10ec697787680f0107136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecf3d07f3a10ec697787680f0107136">&#9670;&#160;</a></span>get1dView()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::ArrayRCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &gt; <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::get1dView </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const persisting (1-D) view of this multivector's local values. </p>
<p>This method assumes that the columns of the multivector are stored contiguously. If not, this method throws std::runtime_error. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03669">3669</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="af0c6180faec99ce71621ba69fa26ba57" name="af0c6180faec99ce71621ba69fa26ba57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c6180faec99ce71621ba69fa26ba57">&#9670;&#160;</a></span>get2dView()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::ArrayRCP&lt; Teuchos::ArrayRCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &gt; &gt; <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::get2dView </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return const persisting pointers to values. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03787">3787</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a3a36ce29f5a84fae0178ff4da3c4ef13" name="a3a36ce29f5a84fae0178ff4da3c4ef13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a36ce29f5a84fae0178ff4da3c4ef13">&#9670;&#160;</a></span>get1dViewNonConst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::ArrayRCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &gt; <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::get1dViewNonConst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nonconst persisting (1-D) view of this multivector's local values. </p>
<p>This method assumes that the columns of the multivector are stored contiguously. If not, this method throws std::runtime_error. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03693">3693</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="ae2d2421887580f245b8314ad7b32c4cb" name="ae2d2421887580f245b8314ad7b32c4cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d2421887580f245b8314ad7b32c4cb">&#9670;&#160;</a></span>get2dViewNonConst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::ArrayRCP&lt; Teuchos::ArrayRCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &gt; &gt; <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::get2dViewNonConst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return non-const persisting pointers to values. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03713">3713</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="ac50eeed74463db067da67bf827ec1d00" name="ac50eeed74463db067da67bf827ec1d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50eeed74463db067da67bf827ec1d00">&#9670;&#160;</a></span>getLocalViewHost() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::dual_view_type::t_host::const_type <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::getLocalViewHost </td>
          <td>(</td>
          <td class="paramtype">Access::ReadOnlyStruct&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a read-only, up-to-date view of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s local data on host. This requires that there are no live device-space views. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03738">3738</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a80cf09ddbb773a570003aeb7fe738adc" name="a80cf09ddbb773a570003aeb7fe738adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80cf09ddbb773a570003aeb7fe738adc">&#9670;&#160;</a></span>getLocalViewHost() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::dual_view_type::t_host <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::getLocalViewHost </td>
          <td>(</td>
          <td class="paramtype">Access::ReadWriteStruct&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mutable, up-to-date view of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s local data on host. This requires that there are no live device-space views. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03745">3745</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="aea4444f2cfb79073feca098bf9b44963" name="aea4444f2cfb79073feca098bf9b44963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea4444f2cfb79073feca098bf9b44963">&#9670;&#160;</a></span>getLocalViewHost() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::dual_view_type::t_host <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::getLocalViewHost </td>
          <td>(</td>
          <td class="paramtype">Access::OverwriteAllStruct&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mutable view of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s local data on host, assuming all existing data will be overwritten. This requires that there are no live device-space views. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03752">3752</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="ab4eade004018814a8fff9964abf747e6" name="ab4eade004018814a8fff9964abf747e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4eade004018814a8fff9964abf747e6">&#9670;&#160;</a></span>getLocalViewDevice() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::dual_view_type::t_dev::const_type <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::getLocalViewDevice </td>
          <td>(</td>
          <td class="paramtype">Access::ReadOnlyStruct&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a read-only, up-to-date view of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s local data on device. This requires that there are no live host-space views. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03759">3759</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a3224f32298782bc3e10c441b048af7e5" name="a3224f32298782bc3e10c441b048af7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3224f32298782bc3e10c441b048af7e5">&#9670;&#160;</a></span>getLocalViewDevice() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::dual_view_type::t_dev <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::getLocalViewDevice </td>
          <td>(</td>
          <td class="paramtype">Access::ReadWriteStruct&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mutable, up-to-date view of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s local data on device. This requires that there are no live host-space views. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03766">3766</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="ac3e13fc7838c50960acd1305add495bf" name="ac3e13fc7838c50960acd1305add495bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e13fc7838c50960acd1305add495bf">&#9670;&#160;</a></span>getLocalViewDevice() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::dual_view_type::t_dev <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::getLocalViewDevice </td>
          <td>(</td>
          <td class="paramtype">Access::OverwriteAllStruct&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mutable view of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s local data on device, assuming all existing data will be overwritten. This requires that there are no live host-space views. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03773">3773</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="aa829c0be76771be20a543c01410bd347" name="aa829c0be76771be20a543c01410bd347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa829c0be76771be20a543c01410bd347">&#9670;&#160;</a></span>getWrappedDualView()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::wrapped_dual_view_type <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::getWrappedDualView </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the wrapped dual view holding this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s local data. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method is ONLY for use by experts. We highly recommend accessing the local data by using the member functions getLocalViewHost and getLocalViewDevice. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03780">3780</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a79f1be5a0c6dfdcd21f41e7d028b0c28" name="a79f1be5a0c6dfdcd21f41e7d028b0c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f1be5a0c6dfdcd21f41e7d028b0c28">&#9670;&#160;</a></span>need_sync()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">TargetDeviceType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::need_sync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> needs synchronization to the given space. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l01447">1447</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a6d350c242f5c7132475c42334a76734a" name="a6d350c242f5c7132475c42334a76734a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d350c242f5c7132475c42334a76734a">&#9670;&#160;</a></span>need_sync_host()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::need_sync_host </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> needs synchronization to the host. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l04256">4256</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a4a9346ae5c04153b94aae8660ecbf8d4" name="a4a9346ae5c04153b94aae8660ecbf8d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9346ae5c04153b94aae8660ecbf8d4">&#9670;&#160;</a></span>need_sync_device()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::need_sync_device </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> needs synchronization to the device. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l04262">4262</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a59fada0463f4c64162d20e47951f5711" name="a59fada0463f4c64162d20e47951f5711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59fada0463f4c64162d20e47951f5711">&#9670;&#160;</a></span>getLocalView()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">TargetDeviceType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::remove_reference&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">decltype</a>(std::declval&lt; <a class="el" href="classTpetra_1_1MultiVector.html#a8d9309c7680bb1030097ec3b8a912329">dual_view_type</a> &gt;().<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">templateview</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">TargetDeviceType</a> &gt;())&gt;::type::const_type <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::getLocalView </td>
          <td>(</td>
          <td class="paramtype">Access::ReadOnlyStruct&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a view of the local data on a specific device, with the given access mode. The return type is either dual_view_type::t_dev, dual_view_type::t_host, or the const_type of one of those. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TargetDeviceType</td><td>The Kokkos Device type whose data to return.</td></tr>
  </table>
  </dd>
</dl>
<p>For example, suppose you create a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">Tpetra::MultiVector</a> for the Kokkos::Cuda device, like this: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> Tpetra::KokkosCompat::KokkosDeviceWrapperNode&lt;Kokkos::Cuda&gt; &gt; <a class="code hl_typedef" href="classTpetra_1_1MultiVector.html#a0e2eafc5434402b790165efbf5418dae">node_type</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Map&lt;int, int, node_type&gt;</a> <a class="code hl_typedef" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::MultiVector&lt;float, int, int, node_type&gt;</a> mv_type;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">RCP&lt;const map_type&gt;</a> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">map</a> = ...;</div>
<div class="line">mv_type <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">DV</a> (<a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">map</a>, 3);</div>
<div class="ttc" id="aclassTpetra_1_1MultiVector_html_a0e2eafc5434402b790165efbf5418dae"><div class="ttname"><a href="classTpetra_1_1MultiVector.html#a0e2eafc5434402b790165efbf5418dae">Tpetra::MultiVector::node_type</a></div><div class="ttdeci">typename map_type::node_type node_type</div><div class="ttdoc">Legacy thing that you should not use any more.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__MultiVector__decl_8hpp_source.html#l00388">Tpetra_MultiVector_decl.hpp:388</a></div></div>
</div><!-- fragment --><p> If you want to get the CUDA device Kokkos::View as read-write, do this: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> mv_type::dual_view_type <a class="code hl_typedef" href="classTpetra_1_1MultiVector.html#a8d9309c7680bb1030097ec3b8a912329">dual_view_type</a>;</div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> dual_view_type::t_dev device_view_type;</div>
<div class="line">device_view_type <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">cudaView</a> = <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">DV</a>.getLocalView&lt;Kokkos::Cuda&gt; (Access::ReadWrite);</div>
<div class="ttc" id="aclassTpetra_1_1MultiVector_html_a8d9309c7680bb1030097ec3b8a912329"><div class="ttname"><a href="classTpetra_1_1MultiVector.html#a8d9309c7680bb1030097ec3b8a912329">Tpetra::MultiVector::dual_view_type</a></div><div class="ttdeci">Kokkos::DualView&lt; impl_scalar_type **, Kokkos::LayoutLeft, device_type &gt; dual_view_type</div><div class="ttdoc">Kokkos::DualView specialization used by this class.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__MultiVector__decl_8hpp_source.html#l00438">Tpetra_MultiVector_decl.hpp:440</a></div></div>
</div><!-- fragment --><p> and if you want to get the host mirror of that View, do this: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> dual_view_type::host_mirror_space host_execution_space;</div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> dual_view_type::t_host host_view_type;</div>
<div class="line">host_view_type <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">hostView</a> = <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">DV</a>.getLocalView&lt;host_execution_space&gt; (Access::ReadWrite);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l01487">1487</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a2c2254963f2d922af64de1ec3c60a6fd" name="a2c2254963f2d922af64de1ec3c60a6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2254963f2d922af64de1ec3c60a6fd">&#9670;&#160;</a></span>dot() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::dot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1MultiVector.html#a6b5ff6294071bb6f75dd92fa8e9b1bda">dot_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the dot product of each corresponding pair of vectors (columns) in A and B. </p>
<p>The "dot product" is the standard Euclidean inner product. If the type of entries of the vectors (impl_scalar_type) is complex, then A is transposed, not <code>*this</code>. For example, if x and y each have one column, then <code>x.dot (y, dots)</code> computes <picture><source srcset="form_27_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$y^* x = \bar{y}^T x = \sum_i \bar{y}_i \cdot x_i$" src="form_27.png" width="125" height="15"/></picture>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*this</code> and A have the same number of columns (vectors). </dd>
<dd>
<code>dots</code> has at least as many entries as the number of columns in A.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>dots[j] == (this-&gt;getVector[j])-&gt;dot (* (A.getVector[j]))</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l02294">2294</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a15cc575eac0e0b6b8083418b6590ffd7" name="a15cc575eac0e0b6b8083418b6590ffd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15cc575eac0e0b6b8083418b6590ffd7">&#9670;&#160;</a></span>dot() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!(std::is_same&lt; <a class="el" href="classTpetra_1_1MultiVector.html#a6b5ff6294071bb6f75dd92fa8e9b1bda">dot_type</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt;::value), <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::dot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the dot product of each corresponding pair of vectors (columns) in A and B. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The output type of the dot products.</td></tr>
  </table>
  </dd>
</dl>
<p>This method only exists if dot_type and T are different types. For example, if impl_scalar_type and dot_type differ, then this method ensures backwards compatibility with the previous interface (that returned dot products as impl_scalar_type rather than as dot_type). The complicated <code>enable_if</code> expression just ensures that the method only exists if dot_type and T are different types; the method still returns <code>void</code>, as above. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l01537">1537</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="ae717f93742231d57d6dbe3f6a6adab30" name="ae717f93742231d57d6dbe3f6a6adab30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae717f93742231d57d6dbe3f6a6adab30">&#9670;&#160;</a></span>dot() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!(std::is_same&lt; <a class="el" href="classTpetra_1_1MultiVector.html#a6b5ff6294071bb6f75dd92fa8e9b1bda">dot_type</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt;::value), <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::dot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like the above <a class="el" href="classTpetra_1_1MultiVector.html#a2c2254963f2d922af64de1ec3c60a6fd" title="Compute the dot product of each corresponding pair of vectors (columns) in A and B.">dot()</a> overload, but for std::vector output. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l01551">1551</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="abf868fa8bf3932f07fafe542d32d6b58" name="abf868fa8bf3932f07fafe542d32d6b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf868fa8bf3932f07fafe542d32d6b58">&#9670;&#160;</a></span>dot() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::dot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::View&lt; <a class="el" href="classTpetra_1_1MultiVector.html#a6b5ff6294071bb6f75dd92fa8e9b1bda">dot_type</a> *, Kokkos::HostSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>norms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the dot product of each corresponding pair of vectors (columns) in A and B, storing the result in a device View. </p>
<p>The "dot product" is the standard Euclidean inner product. If the type of entries of the vectors (impl_scalar_type) is complex, then A is transposed, not <code>*this</code>. For example, if x and y each have one column, then <code>x.dot (y, dots)</code> computes <picture><source srcset="form_27_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$y^* x = \bar{y}^T x = \sum_i \bar{y}_i \cdot x_i$" src="form_27.png" width="125" height="15"/></picture>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>[in] <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> with which to dot <code>*this</code>. </td></tr>
    <tr><td class="paramname">dots</td><td>[out] Device View with <a class="el" href="classTpetra_1_1MultiVector.html#a99612db6ea6a62d73eee3a0563e5e561" title="Number of columns in the multivector.">getNumVectors()</a> entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>this-&gt;getNumVectors () == A.getNumVectors ()</code> </dd>
<dd>
<code>dots.extent (0) == A.getNumVectors ()</code></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>dots(j) == (this-&gt;getVector[j])-&gt;dot (* (A.getVector[j]))</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l02150">2150</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="aa51ffee027fd32a78ef2fc3c352724b1" name="aa51ffee027fd32a78ef2fc3c352724b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51ffee027fd32a78ef2fc3c352724b1">&#9670;&#160;</a></span>dot() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!(std::is_same&lt; <a class="el" href="classTpetra_1_1MultiVector.html#a6b5ff6294071bb6f75dd92fa8e9b1bda">dot_type</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt;::value), <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::dot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::View&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a9114e22e58c9c70b153b341c4f6134d0">device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the dot product of each corresponding pair of vectors (columns) in A and B, storing the result in a device view. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The output type of the dot products.</td></tr>
  </table>
  </dd>
</dl>
<p>This method only exists if dot_type and T are different types. For example, if Scalar and dot_type differ, then this method ensures backwards compatibility with the previous interface (that returned dot products as Scalar rather than as dot_type). The complicated <code>enable_if</code> expression just ensures that the method only exists if dot_type and T are different types; the method still returns <code>void</code>, as above. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l01609">1609</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="ab8a727e92f3f190a3e3b72fa8753f295" name="ab8a727e92f3f190a3e3b72fa8753f295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a727e92f3f190a3e3b72fa8753f295">&#9670;&#160;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put element-wise absolute values of input Multi-vector in target: A = abs(this) </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l02903">2903</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a04a5d7ce085a6d8a87a1a7d6e034d838" name="a04a5d7ce085a6d8a87a1a7d6e034d838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a5d7ce085a6d8a87a1a7d6e034d838">&#9670;&#160;</a></span>reciprocal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::reciprocal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put element-wise reciprocal values of input Multi-vector in target, this(i,j) = 1/A(i,j). </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l02865">2865</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a27deea3362cbd12f3e5a104fdb5fd1e1" name="a27deea3362cbd12f3e5a104fdb5fd1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27deea3362cbd12f3e5a104fdb5fd1e1">&#9670;&#160;</a></span>scale() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scale in place: <code>this = alpha*this</code>. </p>
<p>Replace this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> with alpha times this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>. This method will always multiply, even if alpha is zero. That means, for example, that if <code>*this</code> contains NaN entries before calling this method, the NaN entries will remain after this method finishes. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l02678">2678</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="abd4f290a9c9f05fb6a71b1c01525257d" name="abd4f290a9c9f05fb6a71b1c01525257d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4f290a9c9f05fb6a71b1c01525257d">&#9670;&#160;</a></span>scale() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scale each column in place: <code>this[j] = alpha[j]*this[j]</code>. </p>
<p>Replace each column j of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> with <code>alpha[j]</code> times the current column j of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>. This method will always multiply, even if all the entries of alpha are zero. That means, for example, that if <code>*this</code> contains NaN entries before calling this method, the NaN entries will remain after this method finishes. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l02729">2729</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="ab3871c5ec4a299430090a5e2e0772148" name="ab3871c5ec4a299430090a5e2e0772148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3871c5ec4a299430090a5e2e0772148">&#9670;&#160;</a></span>scale() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::View&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a9114e22e58c9c70b153b341c4f6134d0">device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scale each column in place: <code>this[j] = alpha[j]*this[j]</code>. </p>
<p>Replace each column j of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> with <code>alpha[j]</code> times the current column j of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>. This method will always multiply, even if all the entries of alpha are zero. That means, for example, that if <code>*this</code> contains NaN entries before calling this method, the NaN entries will remain after this method finishes. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l02753">2753</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a10a25c55341d6edd28badabdf30e2b40" name="a10a25c55341d6edd28badabdf30e2b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a25c55341d6edd28badabdf30e2b40">&#9670;&#160;</a></span>scale() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scale in place: <code>this = alpha * A</code>. </p>
<p>Replace this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> with scaled values of A. This method will always multiply, even if alpha is zero. That means, for example, that if <code>*this</code> contains NaN entries before calling this method, the NaN entries will remain after this method finishes. It is legal for the input A to alias this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l02821">2821</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="afd4a653bb1937cfd5a3b6316b0de04ae" name="afd4a653bb1937cfd5a3b6316b0de04ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4a653bb1937cfd5a3b6316b0de04ae">&#9670;&#160;</a></span>update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update: <code>this = beta*this + alpha*A</code>. </p>
<p>Update this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> with scaled values of A. If beta is zero, overwrite <code>*this</code> unconditionally, even if it contains NaN entries. It is legal for the input A to alias this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l02941">2941</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="afb3b8b03f52cc005b2bd1ad5d57f7cfd" name="afb3b8b03f52cc005b2bd1ad5d57f7cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3b8b03f52cc005b2bd1ad5d57f7cfd">&#9670;&#160;</a></span>update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>gamma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update: <code>this = gamma*this + alpha*A + beta*B</code>. </p>
<p>Update this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> with scaled values of A and B. If gamma is zero, overwrite <code>*this</code> unconditionally, even if it contains NaN entries. It is legal for the inputs A or B to alias this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l02992">2992</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="abb74a8ac29991816b7cd502c90e5b026" name="abb74a8ac29991816b7cd502c90e5b026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb74a8ac29991816b7cd502c90e5b026">&#9670;&#160;</a></span>norm1() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::norm1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::View&lt; <a class="el" href="classTpetra_1_1MultiVector.html#addf0baff5a335005840b1ea926822abc">mag_type</a> *, Kokkos::HostSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>norms</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the one-norm of each vector (column), storing the result in a host view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">norms</td><td>[out] Host View with <a class="el" href="classTpetra_1_1MultiVector.html#a99612db6ea6a62d73eee3a0563e5e561" title="Number of columns in the multivector.">getNumVectors()</a> entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>norms.extent (0) == this-&gt;getNumVectors ()</code> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>norms(j) == (this-&gt;getVector[j])-&gt;norm1 (* (A.getVector[j]))</code></dd></dl>
<p>The one-norm of a vector is the sum of the magnitudes of the vector's entries. On exit, norms(j) is the one-norm of column j of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l02371">2371</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a7a83b678327409a28a5bd8d5667bc085" name="a7a83b678327409a28a5bd8d5667bc085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a83b678327409a28a5bd8d5667bc085">&#9670;&#160;</a></span>norm1() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!(std::is_same&lt; <a class="el" href="classTpetra_1_1MultiVector.html#addf0baff5a335005840b1ea926822abc">mag_type</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt;::value), <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::norm1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::View&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a9114e22e58c9c70b153b341c4f6134d0">device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>norms</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the one-norm of each vector (column), storing the result in a device view. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The output type of the dot products.</td></tr>
  </table>
  </dd>
</dl>
<p>See the above <a class="el" href="classTpetra_1_1MultiVector.html#abb74a8ac29991816b7cd502c90e5b026" title="Compute the one-norm of each vector (column), storing the result in a host view.">norm1()</a> method for documentation.</p>
<p>This method only exists if mag_type and T are different types. For example, if Teuchos::ScalarTraits&lt;Scalar&gt;::magnitudeType and mag_type differ, then this method ensures backwards compatibility with the previous interface (that returned norms products as Teuchos::ScalarTraits&lt;Scalar&gt;::magnitudeType rather than as mag_type). The complicated <code>enable_if</code> expression just ensures that the method only exists if mag_type and T are different types; the method still returns <code>void</code>, as above. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l01742">1742</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="aac36c424e851e82981da13751922e650" name="aac36c424e851e82981da13751922e650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac36c424e851e82981da13751922e650">&#9670;&#160;</a></span>norm1() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::norm1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1MultiVector.html#addf0baff5a335005840b1ea926822abc">mag_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>norms</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the one-norm of each vector (column). </p>
<p>See the uppermost <a class="el" href="classTpetra_1_1MultiVector.html#abb74a8ac29991816b7cd502c90e5b026" title="Compute the one-norm of each vector (column), storing the result in a host view.">norm1()</a> method above for documentation. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l02358">2358</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a19de9de7345466edb2a50e38db47e0ef" name="a19de9de7345466edb2a50e38db47e0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19de9de7345466edb2a50e38db47e0ef">&#9670;&#160;</a></span>norm1() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!(std::is_same&lt; <a class="el" href="classTpetra_1_1MultiVector.html#addf0baff5a335005840b1ea926822abc">mag_type</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt;::value), <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::norm1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>norms</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the one-norm of each vector (column). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The output type of the norms.</td></tr>
  </table>
  </dd>
</dl>
<p>See the uppermost <a class="el" href="classTpetra_1_1MultiVector.html#abb74a8ac29991816b7cd502c90e5b026" title="Compute the one-norm of each vector (column), storing the result in a host view.">norm1()</a> method above for documentation.</p>
<p>This method only exists if mag_type and T are different types. For example, if Teuchos::ScalarTraits&lt;Scalar&gt;::magnitudeType and mag_type differ, then this method ensures backwards compatibility with the previous interface (that returned norms as Teuchos::ScalarTraits&lt;Scalar&gt;::magnitudeType rather than as mag_type). The complicated <code>enable_if</code> expression just ensures that the method only exists if mag_type and T are different types; the method still returns <code>void</code>, as above. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l01777">1777</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a7a8df7eea260ede50cd9b77727030e87" name="a7a8df7eea260ede50cd9b77727030e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8df7eea260ede50cd9b77727030e87">&#9670;&#160;</a></span>norm2() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::norm2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::View&lt; <a class="el" href="classTpetra_1_1MultiVector.html#addf0baff5a335005840b1ea926822abc">mag_type</a> *, Kokkos::HostSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>norms</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the two-norm of each vector (column), storing the result in a host View. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">norms</td><td>[out] Host View with <a class="el" href="classTpetra_1_1MultiVector.html#a99612db6ea6a62d73eee3a0563e5e561" title="Number of columns in the multivector.">getNumVectors()</a> entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>norms.extent (0) == this-&gt;getNumVectors ()</code> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>norms(j) == (this-&gt;getVector[j])-&gt;dot (* (A.getVector[j]))</code></dd></dl>
<p>The two-norm of a vector is the standard Euclidean norm, the square root of the sum of squares of the magnitudes of the vector's entries. On exit, norms(k) is the two-norm of column k of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l02351">2351</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a1b2501c02d8481f89d2477d537b04fc3" name="a1b2501c02d8481f89d2477d537b04fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2501c02d8481f89d2477d537b04fc3">&#9670;&#160;</a></span>norm2() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!(std::is_same&lt; <a class="el" href="classTpetra_1_1MultiVector.html#addf0baff5a335005840b1ea926822abc">mag_type</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt;::value), <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::norm2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::View&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a9114e22e58c9c70b153b341c4f6134d0">device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>norms</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the two-norm of each vector (column), storing the result in a device view. </p>
<p>See the above <a class="el" href="classTpetra_1_1MultiVector.html#a7a8df7eea260ede50cd9b77727030e87" title="Compute the two-norm of each vector (column), storing the result in a host View.">norm2()</a> method for documentation.</p>
<p>This method only exists if mag_type and T are different types. For example, if Teuchos::ScalarTraits&lt;Scalar&gt;::magnitudeType and mag_type differ, then this method ensures backwards compatibility with the previous interface (that returned norms as Teuchos::ScalarTraits&lt;Scalar&gt;::magnitudeType rather than as mag_type). The complicated <code>enable_if</code> expression just ensures that the method only exists if mag_type and T are different types; the method still returns <code>void</code>, as above. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l01832">1832</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="ab5a87aacbc87c6ee12645132582bdede" name="ab5a87aacbc87c6ee12645132582bdede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a87aacbc87c6ee12645132582bdede">&#9670;&#160;</a></span>norm2() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::norm2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1MultiVector.html#addf0baff5a335005840b1ea926822abc">mag_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>norms</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the two-norm of each vector (column). </p>
<p>See the uppermost <a class="el" href="classTpetra_1_1MultiVector.html#a7a8df7eea260ede50cd9b77727030e87" title="Compute the two-norm of each vector (column), storing the result in a host View.">norm2()</a> method above for documentation. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l02338">2338</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a96728d41266a0503836e43141a6df19a" name="a96728d41266a0503836e43141a6df19a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96728d41266a0503836e43141a6df19a">&#9670;&#160;</a></span>norm2() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!(std::is_same&lt; <a class="el" href="classTpetra_1_1MultiVector.html#addf0baff5a335005840b1ea926822abc">mag_type</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt;::value), <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::norm2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>norms</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the two-norm of each vector (column). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The output type of the norms.</td></tr>
  </table>
  </dd>
</dl>
<p>See the uppermost <a class="el" href="classTpetra_1_1MultiVector.html#a7a8df7eea260ede50cd9b77727030e87" title="Compute the two-norm of each vector (column), storing the result in a host View.">norm2()</a> method above for documentation.</p>
<p>This method only exists if mag_type and T are different types. For example, if Teuchos::ScalarTraits&lt;Scalar&gt;::magnitudeType and mag_type differ, then this method ensures backwards compatibility with the previous interface (that returned norms products as Teuchos::ScalarTraits&lt;Scalar&gt;::magnitudeType rather than as mag_type). The complicated <code>enable_if</code> expression just ensures that the method only exists if mag_type and T are different types; the method still returns <code>void</code>, as above. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l01867">1867</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a0677b2f6d6474b2097791af511ae7fb8" name="a0677b2f6d6474b2097791af511ae7fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0677b2f6d6474b2097791af511ae7fb8">&#9670;&#160;</a></span>normInf() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::normInf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::View&lt; <a class="el" href="classTpetra_1_1MultiVector.html#addf0baff5a335005840b1ea926822abc">mag_type</a> *, Kokkos::HostSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>norms</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the infinity-norm of each vector (column), storing the result in a host View. </p>
<p>The infinity-norm of a vector is the maximum of the magnitudes of the vector's entries. On exit, norms(j) is the infinity-norm of column j of this <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l02391">2391</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a48c61eb2e9bdc9a2bcce962f6fe718f3" name="a48c61eb2e9bdc9a2bcce962f6fe718f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c61eb2e9bdc9a2bcce962f6fe718f3">&#9670;&#160;</a></span>normInf() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!(std::is_same&lt; <a class="el" href="classTpetra_1_1MultiVector.html#addf0baff5a335005840b1ea926822abc">mag_type</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt;::value), <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::normInf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::View&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a9114e22e58c9c70b153b341c4f6134d0">device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>norms</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the infinity-norm of each vector (column), storing the result in a device view. </p>
<p>See the above <a class="el" href="classTpetra_1_1MultiVector.html#a0677b2f6d6474b2097791af511ae7fb8" title="Compute the infinity-norm of each vector (column), storing the result in a host View.">normInf()</a> method for documentation.</p>
<p>This method only exists if mag_type and T are different types. For example, if Teuchos::ScalarTraits&lt;Scalar&gt;::magnitudeType and mag_type differ, then this method ensures backwards compatibility with the previous interface (that returned norms as Teuchos::ScalarTraits&lt;Scalar&gt;::magnitudeType rather than as mag_type). The complicated <code>enable_if</code> expression just ensures that the method only exists if mag_type and T are different types; the method still returns <code>void</code>, as above. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l01915">1915</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="ac1b1b0e2a7b6952de61f73714ee8ae6d" name="ac1b1b0e2a7b6952de61f73714ee8ae6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b1b0e2a7b6952de61f73714ee8ae6d">&#9670;&#160;</a></span>normInf() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::normInf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1MultiVector.html#addf0baff5a335005840b1ea926822abc">mag_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>norms</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the infinity-norm of each vector (column), storing the result in a Teuchos::ArrayView. </p>
<p>See the uppermost <a class="el" href="classTpetra_1_1MultiVector.html#a0677b2f6d6474b2097791af511ae7fb8" title="Compute the infinity-norm of each vector (column), storing the result in a host View.">normInf()</a> method above for documentation. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l02378">2378</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a3e2a8de67c7bc4c5ed1bc6cca64acdb9" name="a3e2a8de67c7bc4c5ed1bc6cca64acdb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2a8de67c7bc4c5ed1bc6cca64acdb9">&#9670;&#160;</a></span>normInf() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">typename</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!(std::is_same&lt; <a class="el" href="classTpetra_1_1MultiVector.html#addf0baff5a335005840b1ea926822abc">mag_type</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt;::value), <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> &gt;::type <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::normInf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>norms</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the infinity-norm of each vector (column), storing the result in a Teuchos::ArrayView. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The output type of the norms.</td></tr>
  </table>
  </dd>
</dl>
<p>See the uppermost <a class="el" href="classTpetra_1_1MultiVector.html#a0677b2f6d6474b2097791af511ae7fb8" title="Compute the infinity-norm of each vector (column), storing the result in a host View.">normInf()</a> method above for documentation.</p>
<p>This method only exists if mag_type and T are different types. For example, if Teuchos::ScalarTraits&lt;Scalar&gt;::magnitudeType and mag_type differ, then this method ensures backwards compatibility with the previous interface (that returned norms products as Teuchos::ScalarTraits&lt;Scalar&gt;::magnitudeType rather than as mag_type). The complicated <code>enable_if</code> expression just ensures that the method only exists if mag_type and T are different types; the method still returns <code>void</code>, as above. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l01952">1952</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a419c96003b0060abc7791226f75f16b2" name="a419c96003b0060abc7791226f75f16b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419c96003b0060abc7791226f75f16b2">&#9670;&#160;</a></span>meanValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::meanValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::ArrayView&lt; <a class="el" href="classTpetra_1_1MultiVector.html#aa6015995ea4c087f317aada3994fbd01">impl_scalar_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>means</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute mean (average) value of each column. </p>
<p>The outcome of this routine is undefined for non-floating point scalar types (e.g., int). </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l02398">2398</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a473b4545e66e12eba553d04c060d201c" name="a473b4545e66e12eba553d04c060d201c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473b4545e66e12eba553d04c060d201c">&#9670;&#160;</a></span>multiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::multiply </td>
          <td>(</td>
          <td class="paramtype">Teuchos::ETransp&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Teuchos::ETransp&#160;</td>
          <td class="paramname"><em>transB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix-matrix multiplication: <code>this = beta*this + alpha*op(A)*op(B)</code>. </p>
<p>If beta is zero, overwrite <code>*this</code> unconditionally, even if it contains NaN entries. This imitates the semantics of analogous BLAS routines like DGEMM. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03814">3814</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a95fae4b1f2891d8438b7fb692a85b3bd" name="a95fae4b1f2891d8438b7fb692a85b3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95fae4b1f2891d8438b7fb692a85b3bd">&#9670;&#160;</a></span>elementWiseMultiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::elementWiseMultiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>scalarAB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Vector.html">Vector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>scalarThis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply a <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Vector</a> A elementwise by a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> B. </p>
<p>Compute <code>this = scalarThis * this + scalarAB * B @ A</code> where <code>@</code> denotes element-wise multiplication. In pseudocode, if C denotes <code>*this</code> <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">C</a>(<a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">i</a>,<a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">j</a>) = <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">scalarThis</a> * <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">C</a>(<a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">i</a>,<a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">j</a>) + <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">scalarAB</a> * <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">B</a>(<a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">i</a>,<a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">j</a>) * <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">A</a>(<a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">i</a>,1);</div>
</div><!-- fragment --><p> for all rows i and columns j of C.</p>
<p>B must have the same dimensions as <code>*this</code>, while A must have the same number of rows but a single column.</p>
<p>We do not require that A, B, and <code>*this</code> have compatible Maps, as long as the number of rows in A, B, and <code>*this</code> on each process is the same. For example, one or more of these vectors might have a locally replicated <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>, or a <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> with a local communicator (<code>MPI_COMM_SELF</code>). This case may occur in block relaxation algorithms when applying a diagonal scaling. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l04049">4049</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a99612db6ea6a62d73eee3a0563e5e561" name="a99612db6ea6a62d73eee3a0563e5e561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99612db6ea6a62d73eee3a0563e5e561">&#9670;&#160;</a></span>getNumVectors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::getNumVectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of columns in the multivector. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l02090">2090</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a5cdc127576764db9045ce5f1258e39d8" name="a5cdc127576764db9045ce5f1258e39d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cdc127576764db9045ce5f1258e39d8">&#9670;&#160;</a></span>getLocalLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::getLocalLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Local number of rows on the calling process. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l00974">974</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a7e008db43eebb57980f9e91d3062f113" name="a7e008db43eebb57980f9e91d3062f113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e008db43eebb57980f9e91d3062f113">&#9670;&#160;</a></span>getGlobalLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceTpetra.html#a9bf6069ab0d0c54962569526f3cc9cf5">global_size_t</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::getGlobalLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global number of rows in the multivector. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l00985">985</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a0ad03fc5b0a480d51837c88d922680f2" name="a0ad03fc5b0a480d51837c88d922680f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad03fc5b0a480d51837c88d922680f2">&#9670;&#160;</a></span>getStride()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::getStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stride between columns in the multivector. </p>
<p>This is only meaningful if <code><a class="el" href="classTpetra_1_1MultiVector.html#add82b0581b87c0b43deb07113054172c" title="Whether this multivector has constant stride between columns.">isConstantStride()</a></code> returns true.</p>
<dl class="section warning"><dt>Warning</dt><dd>This may be different on different processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l00996">996</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="add82b0581b87c0b43deb07113054172c" name="add82b0581b87c0b43deb07113054172c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add82b0581b87c0b43deb07113054172c">&#9670;&#160;</a></span>isConstantStride()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::isConstantStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether this multivector has constant stride between columns. </p>
<dl class="section warning"><dt>Warning</dt><dd>This may be different on different processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l00967">967</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="ac3479ff3024192bdc4eac0ee73e05939" name="ac3479ff3024192bdc4eac0ee73e05939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3479ff3024192bdc4eac0ee73e05939">&#9670;&#160;</a></span>aliases()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::aliases </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether this multivector's memory might alias other. This is conservative: if either this or other is not constant stride, then it simply checks whether the contiguous memory allocations overlap. It doesn't check whether the sets of columns overlap. This is a symmetric relation: X.aliases(Y) == Y.aliases(X). </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l01002">1002</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="ae717adfdc48e6a2c30369645e7de9b5e" name="ae717adfdc48e6a2c30369645e7de9b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae717adfdc48e6a2c30369645e7de9b5e">&#9670;&#160;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A simple one-line description of this object. </p>

<p>Reimplemented from <a class="el" href="classTpetra_1_1DistObject.html#adeca5fe82d6ff5af11d1fcb78753c1ef">Tpetra::DistObject&lt; Scalar, LocalOrdinal, GlobalOrdinal, Node &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classTpetra_1_1Vector.html#ab073d053f1030d6bbf27f07e5a2a4cdf">Tpetra::Vector&lt; Scalar, LocalOrdinal, GlobalOrdinal, Node &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l04298">4298</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="abc13bb2361c48fdcf08d13ebeb351109" name="abc13bb2361c48fdcf08d13ebeb351109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc13bb2361c48fdcf08d13ebeb351109">&#9670;&#160;</a></span>describe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::describe </td>
          <td>(</td>
          <td class="paramtype">Teuchos::FancyOStream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::EVerbosityLevel&#160;</td>
          <td class="paramname"><em>verbLevel</em> = <code>Teuchos::Describable::verbLevel_default</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the object with the given verbosity level to a FancyOStream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>[out] Output stream to which to print. For verbosity levels VERB_LOW and lower, only the process with rank 0 ("Proc 0") in the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s communicator prints. For verbosity levels strictly higher than VERB_LOW, all processes in the communicator need to be able to print to the output stream.</td></tr>
    <tr><td class="paramname">verbLevel</td><td>[in] Verbosity level. The default verbosity (verbLevel=VERB_DEFAULT) is VERB_LOW.</td></tr>
  </table>
  </dd>
</dl>
<p>The amount and content of what this method prints depends on the verbosity level. In the list below, each higher level includes all the content of the previous levels, as well as its own content.</p>
<ul>
<li>VERB_LOW: Only Proc 0 prints; it prints the same thing as <code><a class="el" href="classTpetra_1_1MultiVector.html#ae717adfdc48e6a2c30369645e7de9b5e" title="A simple one-line description of this object.">description()</a></code>.</li>
<li>VERB_MEDIUM: Each process prints its local length (the number of rows that it owns).</li>
<li>VERB_HIGH: Each process prints whether the multivector has constant stride (see <code><a class="el" href="classTpetra_1_1MultiVector.html#add82b0581b87c0b43deb07113054172c" title="Whether this multivector has constant stride between columns.">isConstantStride()</a></code>), and if so, what that stride is. (Stride may differ on different processes.)</li>
<li>VERB_EXTREME: Each process prints the values in its local part of the multivector. This will print out as many rows of data as the global number of rows in the multivector, so beware. </li>
</ul>

<p>Reimplemented from <a class="el" href="classTpetra_1_1DistObject.html#a05ae001a87e9a244a334891d33de8fc7">Tpetra::DistObject&lt; Scalar, LocalOrdinal, GlobalOrdinal, Node &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classTpetra_1_1Vector.html#a7fb20cb74729ebf7e05b4295b3ed4616">Tpetra::Vector&lt; Scalar, LocalOrdinal, GlobalOrdinal, Node &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l04475">4475</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a39d3fc9e6b5759024a8ce7a525b694fc" name="a39d3fc9e6b5759024a8ce7a525b694fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d3fc9e6b5759024a8ce7a525b694fc">&#9670;&#160;</a></span>removeEmptyProcessesInPlace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::removeEmptyProcessesInPlace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove processes owning zero rows from the <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> and their communicator. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method is ONLY for use by experts. We highly recommend using the nonmember function of the same name defined in <a class="el" href="Tpetra__DistObject__decl_8hpp.html" title="Declaration of the Tpetra::DistObject class.">Tpetra_DistObject_decl.hpp</a>.</dd>
<dd>
We make NO promises of backwards compatibility. This method may change or disappear at any time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newMap</td><td>[in] This <em>must</em> be the result of calling the removeEmptyProcesses() method on the row <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>. If it is not, this method's behavior is undefined. This pointer will be null on excluded processes. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l04482">4482</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a970e8a82654c257ecc8333f71ac3538e" name="a970e8a82654c257ecc8333f71ac3538e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a970e8a82654c257ecc8333f71ac3538e">&#9670;&#160;</a></span>setCopyOrView()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::setCopyOrView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::DataAccess&#160;</td>
          <td class="paramname"><em>copyOrView</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set whether this has copy (copyOrView = Teuchos::Copy) or view (copyOrView = Teuchos::View) semantics. </p>
<dl class="section warning"><dt>Warning</dt><dd>The Kokkos refactor version of <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> <em>only</em> implements view semantics. If you attempt to call this method with copyOrView == Teuchos::Copy, it will throw std::invalid_argument.</dd>
<dd>
This method is only for expert use. It may change or disappear at any time. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l02118">2118</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="aada1c2ec10f3f23a5fa7b819a7eb5e4f" name="aada1c2ec10f3f23a5fa7b819a7eb5e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada1c2ec10f3f23a5fa7b819a7eb5e4f">&#9670;&#160;</a></span>getCopyOrView()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::DataAccess <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::getCopyOrView </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether this has copy (copyOrView = Teuchos::Copy) or view (copyOrView = Teuchos::View) semantics. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method is only for expert use. It may change or disappear at any time. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l02135">2135</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a3db220925b8597ba88461d52d7f944ac" name="a3db220925b8597ba88461d52d7f944ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db220925b8597ba88461d52d7f944ac">&#9670;&#160;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the contents of <code>src</code> into <code>*this</code> (deep copy). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>[in] Source <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> (input of the deep copy).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code> ! src.getMap ().is_null () &amp;&amp; ! this-&gt;getMap ().is_null () </code> </dd>
<dd>
<code> src.getMap ()-&gt;isCompatible (* (this-&gt;getMap ()) </code></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Any outstanding views of <code>src</code> or <code>*this</code> remain valid.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>To implementers: The postcondition implies that the implementation must not reallocate any memory of <code>*this</code>, or otherwise change its dimensions. This is <em>not</em> an assignment operator; it does not change anything in <code>*this</code> other than the contents of storage. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l04488">4488</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="ab0b7885b3f166ca65607b6e0d397edf4" name="ab0b7885b3f166ca65607b6e0d397edf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b7885b3f166ca65607b6e0d397edf4">&#9670;&#160;</a></span>convert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &gt; <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::convert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return another <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> with the same entries, but converted to a different Scalar type <code>T</code>. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l04540">4540</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="aef4e380b566a64d2492c0794a82de034" name="aef4e380b566a64d2492c0794a82de034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4e380b566a64d2492c0794a82de034">&#9670;&#160;</a></span>isSameSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::isSameSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>[in] <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code> ! vec.getMap ().is_null () &amp;&amp; ! this-&gt;getMap ().is_null () </code> </dd>
<dd>
<code> vec.getMap ()-&gt;isCompatible (* (this-&gt;getMap ()) </code></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Any outstanding views of <code>src</code> or <code>*this</code> remain valid. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l04552">4552</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a45f2b3b19e6cdb176c8ac84525f4a00a" name="a45f2b3b19e6cdb176c8ac84525f4a00a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f2b3b19e6cdb176c8ac84525f4a00a">&#9670;&#160;</a></span>descriptionImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::descriptionImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>className</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of <a class="el" href="classTpetra_1_1MultiVector.html#ae717adfdc48e6a2c30369645e7de9b5e" title="A simple one-line description of this object.">description()</a> for this class, and its subclass <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">className</td><td>[in] Name of the class calling this method: Either "Tpetra::MultiVector" or "Tpetra::Vector" (no quotes in the string, in either case). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l04269">4269</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="aea8b4ae57b5af420079d548b2aa9cf52" name="aea8b4ae57b5af420079d548b2aa9cf52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8b4ae57b5af420079d548b2aa9cf52">&#9670;&#160;</a></span>localDescribeToString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::localDescribeToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::EVerbosityLevel&#160;</td>
          <td class="paramname"><em>vl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the calling process' verbose <a class="el" href="classTpetra_1_1MultiVector.html#abc13bb2361c48fdcf08d13ebeb351109" title="Print the object with the given verbosity level to a FancyOStream.">describe()</a> information to the returned string. </p>
<p>This is an implementation detail of <a class="el" href="classTpetra_1_1MultiVector.html#abc13bb2361c48fdcf08d13ebeb351109" title="Print the object with the given verbosity level to a FancyOStream.">describe()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vl</td><td>[in] Verbosity level with which to print. </td></tr>
  </table>
  </dd>
</dl>
<p>want to print both the host and device views, <em>without chaging state</em>,</p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l04343">4343</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a2d374c0f351e73e77837bed5b315e8e5" name="a2d374c0f351e73e77837bed5b315e8e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d374c0f351e73e77837bed5b315e8e5">&#9670;&#160;</a></span>describeImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::describeImpl </td>
          <td>(</td>
          <td class="paramtype">Teuchos::FancyOStream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>className</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::EVerbosityLevel&#160;</td>
          <td class="paramname"><em>verbLevel</em> = <code>Teuchos::Describable::verbLevel_default</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of <a class="el" href="classTpetra_1_1MultiVector.html#abc13bb2361c48fdcf08d13ebeb351109" title="Print the object with the given verbosity level to a FancyOStream.">describe()</a> for this class, and its subclass <a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>[out] Output stream to which to write. Only Process 0 in this object's communicator may write to the output stream.</td></tr>
    <tr><td class="paramname">className</td><td>[in] Name of the class calling this method.</td></tr>
    <tr><td class="paramname">verbLevel</td><td>[in] Verbosity level. This also controls whether this method does any communication. At verbosity levels higher (greater) than Teuchos::VERB_LOW, this method behaves as a collective over the object's communicator. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l04404">4404</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a839e4f7803ea583d4114cfabd2a35391" name="a839e4f7803ea583d4114cfabd2a35391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839e4f7803ea583d4114cfabd2a35391">&#9670;&#160;</a></span>getSubArrayRCP()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::ArrayRCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt; <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::getSubArrayRCP </td>
          <td>(</td>
          <td class="paramtype">Teuchos::ArrayRCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">T</a> &gt;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Persisting view of j-th column in the given ArrayRCP. </p>
<p>This method considers <a class="el" href="classTpetra_1_1MultiVector.html#add82b0581b87c0b43deb07113054172c" title="Whether this multivector has constant stride between columns.">isConstantStride()</a>. The ArrayRCP may correspond either to a compute buffer or a host view. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l04242">4242</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="aef58658ae67afa6851887ca31f258650" name="aef58658ae67afa6851887ca31f258650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef58658ae67afa6851887ca31f258650">&#9670;&#160;</a></span>getOrigNumLocalRows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::getOrigNumLocalRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>"Original" number of rows in the (local) data. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03159">3159</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="ae13baf73b3f0da799e89d06e026dee2f" name="ae13baf73b3f0da799e89d06e026dee2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13baf73b3f0da799e89d06e026dee2f">&#9670;&#160;</a></span>getOrigNumLocalCols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::getOrigNumLocalCols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>"Original" number of columns in the (local) data. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l03166">3166</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a1e8f31277205023e77e52140be7bf7fd" name="a1e8f31277205023e77e52140be7bf7fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8f31277205023e77e52140be7bf7fd">&#9670;&#160;</a></span>checkSizes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::checkSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether data redistribution between <code>sourceObj</code> and this object is legal. </p>
<p>This method is called in <a class="el" href="classTpetra_1_1DistObject.html#a82a9a5fd0df1dda55188a340e6b5a2e7" title="Redistribute data across (MPI) processes.">DistObject::doTransfer()</a> to check whether data redistribution between the two objects is legal. </p>

<p>Implements <a class="el" href="classTpetra_1_1DistObject.html#a84bb8e0004dd8a4ae1b2cce20187ee50">Tpetra::DistObject&lt; Scalar, LocalOrdinal, GlobalOrdinal, Node &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l01013">1013</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="aa6261b3d552d1d03f76b69912e55ea81" name="aa6261b3d552d1d03f76b69912e55ea81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6261b3d552d1d03f76b69912e55ea81">&#9670;&#160;</a></span>constantNumberOfPackets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::constantNumberOfPackets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of packets to send per LID. </p>

<p>Reimplemented from <a class="el" href="classTpetra_1_1DistObject.html#ad126b78ec8e6971e3e219629691c95c8">Tpetra::DistObject&lt; Scalar, LocalOrdinal, GlobalOrdinal, Node &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l01035">1035</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a74d198cf6e6d5507e0c142ae020de954" name="a74d198cf6e6d5507e0c142ae020de954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d198cf6e6d5507e0c142ae020de954">&#9670;&#160;</a></span>copyAndPermute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::copyAndPermute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t&#160;</td>
          <td class="paramname"><em>numSameIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#a23e770e950420cc2a0b3018f1fe9315b">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permuteToLIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#a23e770e950420cc2a0b3018f1fe9315b">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permuteFromLIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a>&#160;</td>
          <td class="paramname"><em>CM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#ab52fef102335f8ae2bf93fc45e390757">execution_space</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as copyAndPermute, but do operations in <code>space</code>. </p>

<p>Reimplemented from <a class="el" href="classTpetra_1_1DistObject.html#a454c858836519e8d35e7a3bc928327ed">Tpetra::DistObject&lt; Scalar, LocalOrdinal, GlobalOrdinal, Node &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l01041">1041</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a56c7be23350a211e8e44538ecb36eb75" name="a56c7be23350a211e8e44538ecb36eb75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c7be23350a211e8e44538ecb36eb75">&#9670;&#160;</a></span>copyAndPermute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::copyAndPermute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t&#160;</td>
          <td class="paramname"><em>numSameIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#a23e770e950420cc2a0b3018f1fe9315b">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permuteToLIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#a23e770e950420cc2a0b3018f1fe9315b">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permuteFromLIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a>&#160;</td>
          <td class="paramname"><em>CM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform copies and permutations that are local to the calling (MPI) process. </p>
<p>Subclasses <em>must</em> reimplement this function. Its default implementation does nothing. Note that the &lt;t&gt;target object of the <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> or <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a>, namely <code>*this</code>, packs the <em>source</em> object's data.</p>
<dl class="section pre"><dt>Precondition</dt><dd>permuteToLIDs and permuteFromLIDs are sync'd to both host and device. That is, <code>permuteToLIDs.need_sync_host()</code>, <code>permuteToLIDs.need_sync_device()</code>, <code>permuteFromLIDs.need_sync_host()</code>, and <code>permuteFromLIDs.need_sync_device()</code> are all false.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>[in] On entry, the source object of the <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> or <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> operation. </td></tr>
    <tr><td class="paramname">numSameIDs</td><td>[in] The number of elements that are the same on the source and target objects. These elements live on the same process in both the source and target objects. </td></tr>
    <tr><td class="paramname">permuteToLIDs</td><td>[in] List of the elements that are permuted. They are listed by their local index (LID) in the destination object. </td></tr>
    <tr><td class="paramname">permuteFromLIDs</td><td>[in] List of the elements that are permuted. They are listed by their local index (LID) in the source object. </td></tr>
    <tr><td class="paramname">CM</td><td>[in] CombineMode to be used during copyAndPermute; may or may not be used by the particular object being called; behavior with respect to CombineMode may differ by object. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classTpetra_1_1DistObject.html#abc82b9b77aec9c2eae61417374895ab5">Tpetra::DistObject&lt; Scalar, LocalOrdinal, GlobalOrdinal, Node &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l01403">1403</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a188c72d11d6aaffbb62621d5ef9fb3e7" name="a188c72d11d6aaffbb62621d5ef9fb3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188c72d11d6aaffbb62621d5ef9fb3e7">&#9670;&#160;</a></span>reallocImportsIfNeeded()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::reallocImportsIfNeeded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> std::string *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td>
          <td class="paramname"><em>remoteLIDsContiguous</em> = <code><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a>&#160;</td>
          <td class="paramname"><em>CM</em> = <code><a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094ba8311a4172e79c1f3a25a4ffc2e637b28">INSERT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reallocate imports_ if needed. </p>
<p>This unfortunately must be declared protected, for the same reason that imports_ is declared protected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>[in] New size of imports_. </td></tr>
    <tr><td class="paramname">verbose</td><td>[in] Whether to print verbose debugging output to stderr on every (MPI) process in the communicator. </td></tr>
    <tr><td class="paramname">prefix</td><td>[in] If <code>verbose</code> is <code>true</code>, then this is a nonnull prefix to print at the beginning of each line of verbose debugging output. Otherwise, not used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether we actually reallocated.</dd></dl>
<p>We don't need a "reallocExportsIfNeeded" method, because <code>exports_</code> always gets passed into packAndPrepare() by nonconst reference. Thus, that method can resize the DualView without needing to call other <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> methods. </p>
<p>return false;</p>

<p>Reimplemented from <a class="el" href="classTpetra_1_1DistObject.html#a065de0c79a89661fe820856212ad776f">Tpetra::DistObject&lt; Scalar, LocalOrdinal, GlobalOrdinal, Node &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l01767">1767</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<a id="a2e2cce34ee9698060f87e1fad3695a2d" name="a2e2cce34ee9698060f87e1fad3695a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2cce34ee9698060f87e1fad3695a2d">&#9670;&#160;</a></span>doImport() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::doImport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Import.html">Import</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>importer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a>&#160;</td>
          <td class="paramname"><em>CM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td>
          <td class="paramname"><em>restrictedMode</em> = <code><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> data into this object using an <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> object ("forward mode"). </p>
<p>The input <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> is always the source of the data redistribution operation, and the <code>*this</code> object is always the target.</p>
<p>If you don't know the difference between forward and reverse mode, then you probably want forward mode. Use this method with your precomputed <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> object if you want to do an <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a>, else use <a class="el" href="classTpetra_1_1DistObject.html#ad2623c99b47ce9d88692abdc094d8be6" title="Export data into this object using an Export object (&quot;forward mode&quot;).">doExport()</a> with a precomputed <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> object.</p>
<p>"Restricted Mode" does two things: </p><ol>
<li>
Skips copyAndPermute  </li>
<li>
Allows the "target" <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> of the transfer to be a subset of the <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> of <code>*this</code>, in a "locallyFitted" sense.  </li>
</ol>
<p>This cannot be used if (2) is not true, OR there are permutes. The "source" maps still need to match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>[in] The "source" object for redistribution. </td></tr>
    <tr><td class="paramname">importer</td><td>[in] Precomputed data redistribution plan. Its source <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> must be the same as the input <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a>'s <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>, and its target <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> must be the same as <code>this-&gt;<a class="el" href="classTpetra_1_1DistObject.html#adef545d3737b47c030e0e6a3e7d8b1e7" title="The Map describing the parallel distribution of this object.">getMap()</a></code>. </td></tr>
    <tr><td class="paramname">CM</td><td>[in] How to combine incoming data with the same global index. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00379">379</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="a0cbd89e8cf8df8d477f2c541db4d3215" name="a0cbd89e8cf8df8d477f2c541db4d3215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cbd89e8cf8df8d477f2c541db4d3215">&#9670;&#160;</a></span>doImport() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::doImport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Export.html">Export</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>exporter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a>&#160;</td>
          <td class="paramname"><em>CM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td>
          <td class="paramname"><em>restrictedMode</em> = <code><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> data into this object using an <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> object ("reverse mode"). </p>
<p>The input <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> is always the source of the data redistribution operation, and the <code>*this</code> object is always the target.</p>
<p>If you don't know the difference between forward and reverse mode, then you probably want forward mode. Use the version of <a class="el" href="classTpetra_1_1DistObject.html#a2e2cce34ee9698060f87e1fad3695a2d" title="Import data into this object using an Import object (&quot;forward mode&quot;).">doImport()</a> that takes a precomputed <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> object in that case.</p>
<p>"Restricted Mode" does two things: </p><ol>
<li>
Skips copyAndPermute  </li>
<li>
Allows the "target" <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> of the transfer to be a subset of the <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> of <code>*this</code>, in a "locallyFitted" sense.  </li>
</ol>
<p>This cannot be used if (2) is not true, OR there are permutes. The "source" maps still need to match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>[in] The "source" object for redistribution. </td></tr>
    <tr><td class="paramname">exporter</td><td>[in] Precomputed data redistribution plan. Its <em>target</em> <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> must be the same as the input <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a>'s <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>, and its <em>source</em> <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> must be the same as <code>this-&gt;<a class="el" href="classTpetra_1_1DistObject.html#adef545d3737b47c030e0e6a3e7d8b1e7" title="The Map describing the parallel distribution of this object.">getMap()</a></code>. (Note the difference from forward mode.) </td></tr>
    <tr><td class="paramname">CM</td><td>[in] How to combine incoming data with the same global index. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00446">446</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="ad2623c99b47ce9d88692abdc094d8be6" name="ad2623c99b47ce9d88692abdc094d8be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2623c99b47ce9d88692abdc094d8be6">&#9670;&#160;</a></span>doExport() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::doExport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Export.html">Export</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>exporter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a>&#160;</td>
          <td class="paramname"><em>CM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td>
          <td class="paramname"><em>restrictedMode</em> = <code><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> data into this object using an <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> object ("forward mode"). </p>
<p>The input <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> is always the source of the data redistribution operation, and the <code>*this</code> object is always the target.</p>
<p>If you don't know the difference between forward and reverse mode, then you probably want forward mode. Use this method with your precomputed <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> object if you want to do an <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a>, else use <a class="el" href="classTpetra_1_1DistObject.html#a2e2cce34ee9698060f87e1fad3695a2d" title="Import data into this object using an Import object (&quot;forward mode&quot;).">doImport()</a> with a precomputed <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> object.</p>
<p>"Restricted Mode" does two things: </p><ol>
<li>
Skips copyAndPermute  </li>
<li>
Allows the "target" <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> of the transfer to be a subset of the <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> of <code>*this</code>, in a "locallyFitted" sense.  </li>
</ol>
<p>This cannot be used if (2) is not true, OR there are permutes. The "source" maps still need to match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>[in] The "source" object for redistribution. </td></tr>
    <tr><td class="paramname">exporter</td><td>[in] Precomputed data redistribution plan. Its source <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> must be the same as the input <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a>'s <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>, and its target <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> must be the same as <code>this-&gt;<a class="el" href="classTpetra_1_1DistObject.html#adef545d3737b47c030e0e6a3e7d8b1e7" title="The Map describing the parallel distribution of this object.">getMap()</a></code>. </td></tr>
    <tr><td class="paramname">CM</td><td>[in] How to combine incoming data with the same global index. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00412">412</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="a5b766629940d0400aa98e113b4e5ef3c" name="a5b766629940d0400aa98e113b4e5ef3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b766629940d0400aa98e113b4e5ef3c">&#9670;&#160;</a></span>doExport() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::doExport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Import.html">Import</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>importer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a>&#160;</td>
          <td class="paramname"><em>CM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td>
          <td class="paramname"><em>restrictedMode</em> = <code><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> data into this object using an <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> object ("reverse mode"). </p>
<p>The input <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> is always the source of the data redistribution operation, and the <code>*this</code> object is always the target.</p>
<p>If you don't know the difference between forward and reverse mode, then you probably want forward mode. Use the version of <a class="el" href="classTpetra_1_1DistObject.html#ad2623c99b47ce9d88692abdc094d8be6" title="Export data into this object using an Export object (&quot;forward mode&quot;).">doExport()</a> that takes a precomputed <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> object in that case.</p>
<p>"Restricted Mode" does two things: </p><ol>
<li>
Skips copyAndPermute  </li>
<li>
Allows the "target" <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> of the transfer to be a subset of the <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> of <code>*this</code>, in a "locallyFitted" sense.  </li>
</ol>
<p>This cannot be used if (2) is not true, OR there are permutes. The "source" maps still need to match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>[in] The "source" object for redistribution. </td></tr>
    <tr><td class="paramname">importer</td><td>[in] Precomputed data redistribution plan. Its <em>target</em> <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> must be the same as the input <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a>'s <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>, and its <em>source</em> <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> must be the same as <code>this-&gt;<a class="el" href="classTpetra_1_1DistObject.html#adef545d3737b47c030e0e6a3e7d8b1e7" title="The Map describing the parallel distribution of this object.">getMap()</a></code>. (Note the difference from forward mode.) </td></tr>
    <tr><td class="paramname">CM</td><td>[in] How to combine incoming data with the same global index. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00480">480</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="a47ad53419477919faf1acdcfc4d65daa" name="a47ad53419477919faf1acdcfc4d65daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ad53419477919faf1acdcfc4d65daa">&#9670;&#160;</a></span>transferArrived()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::transferArrived </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the data from an import/export operation has arrived, and is ready for the unpack and combine step. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00535">535</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="afc178c45d66d8232f27b1e79fc0e1535" name="afc178c45d66d8232f27b1e79fc0e1535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc178c45d66d8232f27b1e79fc0e1535">&#9670;&#160;</a></span>isDistributed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::isDistributed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether this is a globally distributed object. </p>
<p>For a definition of "globally distributed" (and its opposite, "locally replicated"), see the documentation of <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>'s <a class="el" href="classTpetra_1_1DistObject.html#afc178c45d66d8232f27b1e79fc0e1535" title="Whether this is a globally distributed object.">isDistributed()</a> method. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00546">546</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="adef545d3737b47c030e0e6a3e7d8b1e7" name="adef545d3737b47c030e0e6a3e7d8b1e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef545d3737b47c030e0e6a3e7d8b1e7">&#9670;&#160;</a></span>getMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">virtual</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a> &gt; <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::getMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> describing the parallel distribution of this object. </p>
<p>Note that some <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> objects might be distributed using multiple <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> objects. For example, <a class="el" href="classTpetra_1_1CrsMatrix.html" title="Sparse matrix that presents a row-oriented interface that lets users read or modify entries.">CrsMatrix</a> has both a row <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> and a column <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>. It is up to the subclass to decide which <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> to use when invoking the <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> constructor. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html#l00554">554</a> of file <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html">Tpetra_DistObject_decl.hpp</a>.</p>

</div>
</div>
<a id="a8f39be1272b2b218c6b734d30fdb7956" name="a8f39be1272b2b218c6b734d30fdb7956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f39be1272b2b218c6b734d30fdb7956">&#9670;&#160;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print this object to the given output stream. </p>
<p>We generally assume that all MPI processes can print to the given stream. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00564">564</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="aead0431a5e0fcdcb0b2147f8351b7792" name="aead0431a5e0fcdcb0b2147f8351b7792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead0431a5e0fcdcb0b2147f8351b7792">&#9670;&#160;</a></span>removeEmptyProcessesInPlace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::removeEmptyProcessesInPlace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Teuchos::RCP&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1DistObject.html#a68d6fd7d67100f1b886af5fb2636efed">map_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove processes which contain no entries in this object's <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method is ONLY for use by experts. We highly recommend using the nonmember function of the same name defined in this file.</dd>
<dd>
We make NO promises of backwards compatibility. This method may change or disappear at any time.</dd></dl>
<p>On input, this object is distributed over the <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> returned by <a class="el" href="classTpetra_1_1DistObject.html#adef545d3737b47c030e0e6a3e7d8b1e7" title="The Map describing the parallel distribution of this object.">getMap()</a> (the "original Map," with its communicator, the "original communicator"). The input <code>newMap</code> of this method <em>must</em> be the same as the result of calling <code><a class="el" href="classTpetra_1_1DistObject.html#adef545d3737b47c030e0e6a3e7d8b1e7" title="The Map describing the parallel distribution of this object.">getMap()</a>-&gt;removeEmptyProcesses()</code>. On processes in the original communicator which contain zero entries ("excluded processes," as opposed to "included processes"), the input <code>newMap</code> must be <code>Teuchos::null</code> (which is what <code><a class="el" href="classTpetra_1_1DistObject.html#adef545d3737b47c030e0e6a3e7d8b1e7" title="The Map describing the parallel distribution of this object.">getMap()</a>-&gt;removeEmptyProcesses()</code> returns anyway).</p>
<p>On included processes, reassign this object's <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> (that would be returned by <a class="el" href="classTpetra_1_1DistObject.html#adef545d3737b47c030e0e6a3e7d8b1e7" title="The Map describing the parallel distribution of this object.">getMap()</a>) to the input <code>newMap</code>, and do any work that needs to be done to restore correct semantics. On excluded processes, free any data that needs freeing, and do any other work that needs to be done to restore correct semantics.</p>
<p>This method has collective semantics over the original communicator. On exit, the only method of this object which is safe to call on excluded processes is the destructor. This implies that subclasses' destructors must not contain communication operations.</p>
<dl class="section return"><dt>Returns</dt><dd>The object's new <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>. Its communicator is a new communicator, distinct from the old <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>'s communicator, which contains a subset of the processes in the old communicator.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The name differs from <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a>'s method removeEmptyProcesses(), in order to emphasize that the operation on <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> happens in place, modifying the input, whereas the operation removeEmptyProcess() on <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> does not modify the input.</dd>
<dd>
To implementers of <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> subclasses: The default implementation of this class throws std::logic_error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00636">636</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="ad01545040824d209ef6f686de7d3b842" name="ad01545040824d209ef6f686de7d3b842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01545040824d209ef6f686de7d3b842">&#9670;&#160;</a></span>getActor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Details::DistributorActor &amp; <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::getActor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for the DistributorActor. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html#l00639">639</a> of file <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html">Tpetra_DistObject_decl.hpp</a>.</p>

</div>
</div>
<a id="a82a9a5fd0df1dda55188a340e6b5a2e7" name="a82a9a5fd0df1dda55188a340e6b5a2e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a9a5fd0df1dda55188a340e6b5a2e7">&#9670;&#160;</a></span>doTransfer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::doTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Details_1_1Transfer.html">::Tpetra::Details::Transfer</a>&lt; <a class="el" href="classTpetra_1_1DistObject.html#a6704de48b06419ddaa09161663702858">local_ordinal_type</a>, <a class="el" href="classTpetra_1_1DistObject.html#a929719b0e24ee6bc9a2c9a58aa155250">global_ordinal_type</a>, <a class="el" href="classTpetra_1_1DistObject.html#acd680979e0f221fb01fd28676da4e79d">node_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">char</a>&#160;</td>
          <td class="paramname"><em>modeString</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1DistObject.html#ac1ff98c164c772986e2a5db411a311ab">ReverseOption</a>&#160;</td>
          <td class="paramname"><em>revOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a>&#160;</td>
          <td class="paramname"><em>CM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td>
          <td class="paramname"><em>restrictedMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redistribute data across (MPI) processes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>[in] The source object, to redistribute into the target object, which is <code>*this</code> object.</td></tr>
    <tr><td class="paramname">transfer</td><td>[in] The <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> or <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a> object representing the communication pattern. (<a class="el" href="classTpetra_1_1Details_1_1Transfer.html" title="Common base class of Import and Export.">Details::Transfer</a> is the common base class of these two objects.)</td></tr>
    <tr><td class="paramname">modeString</td><td>[in] Human-readable string, for verbose debugging output and error output, explaining what function called this method. Example: "doImport (forward)", "doExport (reverse)".</td></tr>
    <tr><td class="paramname">revOp</td><td>[in] Whether to do a forward or reverse mode redistribution.</td></tr>
    <tr><td class="paramname">CM</td><td>[in] The combine mode that describes how to combine values that map to the same global ID on the same process. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00695">695</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="a20429024546804acef2060050d1b22f8" name="a20429024546804acef2060050d1b22f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20429024546804acef2060050d1b22f8">&#9670;&#160;</a></span>reallocArraysForNumPacketsPerLid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::reallocArraysForNumPacketsPerLid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t&#160;</td>
          <td class="paramname"><em>numExportLIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t&#160;</td>
          <td class="paramname"><em>numImportLIDs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reallocate numExportPacketsPerLID_ and/or numImportPacketsPerLID_, if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numExportLIDs</td><td>[in] Number of entries in the exportLIDs input array argument of <a class="el" href="classTpetra_1_1DistObject.html#a82a9a5fd0df1dda55188a340e6b5a2e7" title="Redistribute data across (MPI) processes.">doTransfer()</a>.</td></tr>
    <tr><td class="paramname">numImportLIDs</td><td>[in] Number of entries in the remoteLIDs input array argument of <a class="el" href="classTpetra_1_1DistObject.html#a82a9a5fd0df1dda55188a340e6b5a2e7" title="Redistribute data across (MPI) processes.">doTransfer()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether we actually reallocated either of the arrays.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is an implementation detail of doTransferNew(). This needs to be protected, but that doesn't mean users should call this method. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00717">717</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="a30a2256ab638b7f329b752535553f480" name="a30a2256ab638b7f329b752535553f480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a2256ab638b7f329b752535553f480">&#9670;&#160;</a></span>beginTransfer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::beginTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1Details_1_1Transfer.html">::Tpetra::Details::Transfer</a>&lt; <a class="el" href="classTpetra_1_1DistObject.html#a6704de48b06419ddaa09161663702858">local_ordinal_type</a>, <a class="el" href="classTpetra_1_1DistObject.html#a929719b0e24ee6bc9a2c9a58aa155250">global_ordinal_type</a>, <a class="el" href="classTpetra_1_1DistObject.html#acd680979e0f221fb01fd28676da4e79d">node_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">char</a>&#160;</td>
          <td class="paramname"><em>modeString</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1DistObject.html#ac1ff98c164c772986e2a5db411a311ab">ReverseOption</a>&#160;</td>
          <td class="paramname"><em>revOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a>&#160;</td>
          <td class="paramname"><em>CM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a>&#160;</td>
          <td class="paramname"><em>restrictedMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation detail of doTransfer. </p>
<p>LID DualViews come from the Transfer object given to doTransfer. They are <em>always</em> sync'd on both host and device. Users must never attempt to modify or sync them. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00746">746</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="a484241212e4d1ca7c2669a6729b57801" name="a484241212e4d1ca7c2669a6729b57801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484241212e4d1ca7c2669a6729b57801">&#9670;&#160;</a></span>packAndPrepare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::packAndPrepare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1DistObject.html#a6704de48b06419ddaa09161663702858">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1DistObject.html#a66edb1059ed7db04325605df64fe64c5">buffer_device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>exportLIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1DistObject.html#a79749ff4d4160e4c97116d564f66af92">packet_type</a> *, <a class="el" href="classTpetra_1_1DistObject.html#a66edb1059ed7db04325605df64fe64c5">buffer_device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>exports</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kokkos::DualView&lt; size_t *, <a class="el" href="classTpetra_1_1DistObject.html#a66edb1059ed7db04325605df64fe64c5">buffer_device_type</a> &gt;&#160;</td>
          <td class="paramname"><em>numPacketsPerLID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>constantNumPackets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack data and metadata for communication (sends). </p>
<p>Subclasses <em>must</em> reimplement this function. Its default implementation does nothing. Note that the &lt;t&gt;target object of the <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> or <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a>, namely <code>*this</code>, packs the <em>source</em> object's data.</p>
<dl class="section pre"><dt>Precondition</dt><dd>exportLIDs is sync'd to both host and device. That is, <code>exportLIDs.need_sync_host ()</code> and <code>exportLIDs.need_sync_device()</code> are both false.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>[in] Source object for the redistribution.</td></tr>
    <tr><td class="paramname">exportLIDs</td><td>[in] List of the entries (as local IDs in the source object) that <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> will send to other processes.</td></tr>
    <tr><td class="paramname">exports</td><td>[out] On exit, the packed data to send. Implementations must reallocate this as needed (prefer reusing the existing allocation if possible), and may modify and/or sync this wherever they like.</td></tr>
    <tr><td class="paramname">numPacketsPerLID</td><td>[out] On exit, the implementation of this method must do one of two things: either set <code>numPacketsPerLID[i]</code> to the number of packets to be packed for <code>exportLIDs[i]</code> and set <code>constantNumPackets</code> to zero, or set <code>constantNumPackets</code> to a nonzero value. If the latter, the implementation must not modify the entries of <code>numPacketsPerLID</code>. If the former, the implementation may sync <code>numPacketsPerLID</code> this wherever it likes, either to host or to device. The allocation belongs to <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a>, not to subclasses; don't be tempted to change this to pass by reference.</td></tr>
    <tr><td class="paramname">constantNumPackets</td><td>[out] On exit, 0 if the number of packets per LID could differ, else (if nonzero) the number of packets per LID (which must be constant). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00884">884</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="af3fead8f57b7d0157e507847f3f04f1e" name="af3fead8f57b7d0157e507847f3f04f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fead8f57b7d0157e507847f3f04f1e">&#9670;&#160;</a></span>packAndPrepare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::packAndPrepare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1SrcDistObject.html">SrcDistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1DistObject.html#a6704de48b06419ddaa09161663702858">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1DistObject.html#a66edb1059ed7db04325605df64fe64c5">buffer_device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>exportLIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1DistObject.html#a79749ff4d4160e4c97116d564f66af92">packet_type</a> *, <a class="el" href="classTpetra_1_1DistObject.html#a66edb1059ed7db04325605df64fe64c5">buffer_device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>exports</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kokkos::DualView&lt; size_t *, <a class="el" href="classTpetra_1_1DistObject.html#a66edb1059ed7db04325605df64fe64c5">buffer_device_type</a> &gt;&#160;</td>
          <td class="paramname"><em>numPacketsPerLID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>constantNumPackets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1DistObject.html#a87c43585393cbe182ab96e31389e90fa">execution_space</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as packAndPrepare, but in an execution space instance. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00897">897</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<a id="a9cb9c5a5d2e5532768bb494a583d2ab0" name="a9cb9c5a5d2e5532768bb494a583d2ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb9c5a5d2e5532768bb494a583d2ab0">&#9670;&#160;</a></span>unpackAndCombine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::unpackAndCombine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1DistObject.html#a6704de48b06419ddaa09161663702858">local_ordinal_type</a> *, <a class="el" href="classTpetra_1_1DistObject.html#a66edb1059ed7db04325605df64fe64c5">buffer_device_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>importLIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kokkos::DualView&lt; <a class="el" href="classTpetra_1_1DistObject.html#a79749ff4d4160e4c97116d564f66af92">packet_type</a> *, <a class="el" href="classTpetra_1_1DistObject.html#a66edb1059ed7db04325605df64fe64c5">buffer_device_type</a> &gt;&#160;</td>
          <td class="paramname"><em>imports</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kokkos::DualView&lt; size_t *, <a class="el" href="classTpetra_1_1DistObject.html#a66edb1059ed7db04325605df64fe64c5">buffer_device_type</a> &gt;&#160;</td>
          <td class="paramname"><em>numPacketsPerLID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> size_t&#160;</td>
          <td class="paramname"><em>constantNumPackets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094b">CombineMode</a>&#160;</td>
          <td class="paramname"><em>combineMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform any unpacking and combining after communication. </p>
<p>Subclasses <em>must</em> reimplement this function. Its default implementation does nothing. Note that the &lt;t&gt;target object of the <a class="el" href="classTpetra_1_1Export.html" title="Communication plan for data redistribution from a (possibly) multiply-owned to a uniquely-owned distr...">Export</a> or <a class="el" href="classTpetra_1_1Import.html" title="Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...">Import</a>, namely <code>*this</code>, unpacks the received data into itself, possibly modifying its entries.</p>
<dl class="section pre"><dt>Precondition</dt><dd>importLIDs is sync'd to both host and device. That is, <code>importLIDs.need_sync_host ()</code> and <code>importLIDs.need_sync_device()</code> are both false.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">importLIDs</td><td>[in] List of the entries (as LIDs in the destination object) we received from other processes.</td></tr>
    <tr><td class="paramname">imports</td><td>[in/out] On input: Buffer of received data to unpack. <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> promises nothing about where this is sync'd. Implementations may sync this wherever they like, either to host or to device. The allocation belongs to <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a>, not to subclasses; don't be tempted to change this to pass by reference.</td></tr>
    <tr><td class="paramname">numPacketsPerLID</td><td>[in/out] On input: If <code>constantNumPackets</code> is zero, then <code>numPacketsPerLID[i]</code> contains the number of packets imported for importLIDs[i]. <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a> promises nothing about where this is sync'd. Implementations may sync this wherever they like, either to host or to device. The allocation belongs to <a class="el" href="classTpetra_1_1DistObject.html" title="Base class for distributed Tpetra objects that support data redistribution.">DistObject</a>, not to subclasses; don't be tempted to change this to pass by reference.</td></tr>
    <tr><td class="paramname">constantNumPackets</td><td>[in] If nonzero, then the number of packets per LID is the same for all entries ("constant") and <code>constantNumPackets</code> is that number. If zero, then <code>numPacketsPerLID[i]</code> is the number of packets to unpack for LID <code>importLIDs[i]</code>.</td></tr>
    <tr><td class="paramname">combineMode</td><td>[in] The CombineMode to use when combining the imported entries with existing entries. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__def_8hpp_source.html#l00948">948</a> of file <a class="el" href="Tpetra__DistObject__def_8hpp_source.html">Tpetra_DistObject_def.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a252cfba1878494ff99d2454d92a9823b" name="a252cfba1878494ff99d2454d92a9823b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252cfba1878494ff99d2454d92a9823b">&#9670;&#160;</a></span>deep_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">DS</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">DL</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">DG</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">DN</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">SS</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">SL</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">SG</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">SN</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">void</a> deep_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">DS</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">DL</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">DG</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">DN</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">SS</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">SL</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">SG</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">SN</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the contents of the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> <code>src</code> into <code>dst</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The two inputs must have the same communicator. </dd>
<dd>
The <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> of <code>src</code> must be compatible with the <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> of <code>dst</code>. </dd>
<dd>
The two inputs must have the same number of columns.</dd></dl>
<p>Copy the contents of the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> <code>src</code> into the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> <code>dst</code>. ("Copy the contents" means the same thing as "deep
copy.") The two MultiVectors need not necessarily have the same template parameters, but the assignment of their entries must make sense. Furthermore, their Maps must be compatible, that is, the MultiVectors' local dimensions must be the same on all processes.</p>
<p>This method must always be called as a collective operation on all processes over which the multivector is distributed. This is because the method reserves the right to check for compatibility of the two Maps, at least in debug mode, and throw if they are not compatible. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l02420">2420</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a0d4d99be4ef954d973258b629d7281ac" name="a0d4d99be4ef954d973258b629d7281ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4d99be4ef954d973258b629d7281ac">&#9670;&#160;</a></span>createCopy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> ST , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> LO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> GO , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">NT</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; ST, LO, GO, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">NT</a> &gt; createCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html">MultiVector</a>&lt; ST, LO, GO, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">NT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a deep copy of the given <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s constructor returns a <em>shallow</em> copy of its input, by default. If you want a deep copy, use the two-argument copy constructor with Teuchos::Copy as the second argument, or call this function (createCopy). </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html#l04653">4653</a> of file <a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af79a57ae7d7b00a821871824700dafeb" name="af79a57ae7d7b00a821871824700dafeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79a57ae7d7b00a821871824700dafeb">&#9670;&#160;</a></span>useAtomicUpdatesByDefault</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">bool</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::useAtomicUpdatesByDefault</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keyword">true</span></div>
</div><!-- fragment -->
<p>Whether sumIntoLocalValue and sumIntoGlobalValue should use atomic updates by default. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an implementation detail. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l00811">811</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="a4bec5291531c0ba59fd7131da27a5c4d" name="a4bec5291531c0ba59fd7131da27a5c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bec5291531c0ba59fd7131da27a5c4d">&#9670;&#160;</a></span>view_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTpetra_1_1Details_1_1WrappedDualView.html">wrapped_dual_view_type</a> <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::view_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Kokkos::DualView containing the <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a>'s data. </p>
<p>This has to be declared <code>mutable</code>, so that <a class="el" href="classTpetra_1_1MultiVector.html#a7ecf3d07f3a10ec697787680f0107136" title="Const persisting (1-D) view of this multivector&#39;s local values.">get1dView()</a> can retain its current <code>const</code> marking, even though it has always implied a device-&gt;host synchronization. Lesson to the reader: Use <code>const</code> sparingly! </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l02189">2189</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="ada106f56880af8830af09b11cd4057c5" name="ada106f56880af8830af09b11cd4057c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada106f56880af8830af09b11cd4057c5">&#9670;&#160;</a></span>whichVectors_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">class</a> Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::Array&lt;size_t&gt; <a class="el" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::whichVectors_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indices of columns this multivector is viewing. </p>
<p>If this array has nonzero size, then this multivector is a view of another multivector (the "original" multivector). In that case, whichVectors_ contains the indices of the columns of the original multivector. Furthermore, <a class="el" href="classTpetra_1_1MultiVector.html#add82b0581b87c0b43deb07113054172c" title="Whether this multivector has constant stride between columns.">isConstantStride()</a> returns false in this case.</p>
<p>If this array has zero size, then this multivector is not a view of any other multivector. Furthermore, the stride between columns of this multivector is a constant: thus, <a class="el" href="classTpetra_1_1MultiVector.html#add82b0581b87c0b43deb07113054172c" title="Whether this multivector has constant stride between columns.">isConstantStride()</a> returns true. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html#l02203">2203</a> of file <a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a>.</p>

</div>
</div>
<a id="abd8bf976983da5f805c0d7975dfe45dc" name="abd8bf976983da5f805c0d7975dfe45dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8bf976983da5f805c0d7975dfe45dc">&#9670;&#160;</a></span>map_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Teuchos::RCP&lt;<a class="el" href="classTpetra_1_1CrsMatrixStruct.html">const</a> <a class="el" href="classTpetra_1_1MultiVector.html#aa13797b2505f2b68367b4d4413a2f98c">map_type</a>&gt; <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::map_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="classTpetra_1_1Map.html" title="A parallel distribution of indices over processes.">Map</a> over which this object is distributed. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html#l00973">973</a> of file <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html">Tpetra_DistObject_decl.hpp</a>.</p>

</div>
</div>
<a id="a1e625c329325c60064dc133de40aed3b" name="a1e625c329325c60064dc133de40aed3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e625c329325c60064dc133de40aed3b">&#9670;&#160;</a></span>imports_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::DualView&lt;<a class="el" href="classTpetra_1_1DistObject.html#a79749ff4d4160e4c97116d564f66af92">packet_type</a>*, <a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a>&gt; <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::imports_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Buffer into which packed data are imported (received from other processes). </p>
<p>Unfortunately, I had to declare these protected, because <a class="el" href="classTpetra_1_1CrsMatrix.html" title="Sparse matrix that presents a row-oriented interface that lets users read or modify entries.">CrsMatrix</a> uses them at one point. Please, nobody else use them. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html#l00986">986</a> of file <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html">Tpetra_DistObject_decl.hpp</a>.</p>

</div>
</div>
<a id="a1711cc6d0ea3921bd58fa27ba4a4dff8" name="a1711cc6d0ea3921bd58fa27ba4a4dff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1711cc6d0ea3921bd58fa27ba4a4dff8">&#9670;&#160;</a></span>numImportPacketsPerLID_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::DualView&lt;size_t*, <a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a>&gt; <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::numImportPacketsPerLID_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of packets to receive for each receive operation. </p>
<p>This array is used in <a class="el" href="classTpetra_1_1Distributor.html#a0c2780485997436aa01b53c07908f629" title="Post the data for a forward plan, but do not execute the waits yet.">Distributor::doPosts()</a> (and doReversePosts()) when starting the ireceive operation.</p>
<p>This may be ignored in <a class="el" href="classTpetra_1_1DistObject.html#a82a9a5fd0df1dda55188a340e6b5a2e7" title="Redistribute data across (MPI) processes.">doTransfer()</a> if constantNumPackets is nonzero, indicating a constant number of packets per LID. (For example, <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> sets the constantNumPackets output argument of packAndPrepare() to the number of columns in the multivector.)</p>
<p>Unfortunately, I had to declare this protected, because <a class="el" href="classTpetra_1_1CrsMatrix.html" title="Sparse matrix that presents a row-oriented interface that lets users read or modify entries.">CrsMatrix</a> uses it at one point. Please, nobody else use it. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html#l01026">1026</a> of file <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html">Tpetra_DistObject_decl.hpp</a>.</p>

</div>
</div>
<a id="a1a5ef8b469cce85d13924f7e65318e06" name="a1a5ef8b469cce85d13924f7e65318e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5ef8b469cce85d13924f7e65318e06">&#9670;&#160;</a></span>exports_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::DualView&lt;<a class="el" href="classTpetra_1_1DistObject.html#a79749ff4d4160e4c97116d564f66af92">packet_type</a>*, <a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a>&gt; <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::exports_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Buffer from which packed data are exported (sent to other processes). </p>
<p>Unfortunately, I had to declare this protected, because <a class="el" href="classTpetra_1_1CrsMatrix.html" title="Sparse matrix that presents a row-oriented interface that lets users read or modify entries.">CrsMatrix</a> uses it at one point. Please, nobody else use it. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html#l01033">1033</a> of file <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html">Tpetra_DistObject_decl.hpp</a>.</p>

</div>
</div>
<a id="a9b397a38b1966ac9833d8990e3cae211" name="a9b397a38b1966ac9833d8990e3cae211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b397a38b1966ac9833d8990e3cae211">&#9670;&#160;</a></span>numExportPacketsPerLID_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::DualView&lt;size_t*, <a class="el" href="classTpetra_1_1MultiVector.html#a6576557039b8bae3b2cc06aeefd8c8d7">buffer_device_type</a>&gt; <a class="el" href="classTpetra_1_1DistObject.html">Tpetra::DistObject</a>&lt; <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">Scalar</a> , <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">LocalOrdinal</a>, <a class="el" href="classTpetra_1_1CrsMatrixStruct.html">GlobalOrdinal</a>, Node &gt;::numExportPacketsPerLID_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of packets to send for each send operation. </p>
<p>This array is used in <a class="el" href="classTpetra_1_1Distributor.html#a0c2780485997436aa01b53c07908f629" title="Post the data for a forward plan, but do not execute the waits yet.">Distributor::doPosts()</a> (and doReversePosts()) for preparing for the send operation.</p>
<p>This may be ignored in <a class="el" href="classTpetra_1_1DistObject.html#a82a9a5fd0df1dda55188a340e6b5a2e7" title="Redistribute data across (MPI) processes.">doTransfer()</a> if constantNumPackets is nonzero, indicating a constant number of packets per LID. (For example, <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">MultiVector</a> sets the constantNumPackets output argument of packAndPrepare() to the number of columns in the multivector.)</p>
<p>Unfortunately, I had to declare this protected, because <a class="el" href="classTpetra_1_1CrsMatrix.html" title="Sparse matrix that presents a row-oriented interface that lets users read or modify entries.">CrsMatrix</a> uses them at one point. Please, nobody else use it. </p>

<p class="definition">Definition at line <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html#l01048">1048</a> of file <a class="el" href="Tpetra__DistObject__decl_8hpp_source.html">Tpetra_DistObject_decl.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Tpetra__Details__WrappedDualView_8hpp_source.html">Tpetra_Details_WrappedDualView.hpp</a></li>
<li><a class="el" href="Tpetra__MultiVector__decl_8hpp_source.html">Tpetra_MultiVector_decl.hpp</a></li>
<li><a class="el" href="Tpetra__MultiVector__def_8hpp_source.html">Tpetra_MultiVector_def.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
