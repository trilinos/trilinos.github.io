<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tpetra parallel linear algebra: Tpetra Lesson 05: Redistribution</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tpetra parallel linear algebra<span id="projectnumber">&#160;Version of the Day</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Tpetra Lesson 05: Redistribution</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Parallel data redistribution of <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> objects.</p>
<h1><a class="anchor" id="Tpetra_Lesson05_Topics"></a>
Lesson topics</h1>
<p>The Tpetra_Lesson02_Vector example introduces and describes <a href="http://trilinos.sandia.gov/packages/docs/dev/packages/tpetra/doc/html/classTpetra_1_1Map.html">Tpetra's Map class</a>, which is <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a>'s representation of a data distribution. This example builds on that by showing how to use Maps and <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a>'s <a href="http://trilinos.sandia.gov/packages/docs/dev/packages/tpetra/doc/html/classTpetra_1_1Export.html">Export class</a> to redistribute data. In this case, we build a sparse matrix on one MPI process, and redistribute it to a sparse matrix stored in block row fashion, with an equal number of rows per process.</p>
<h1><a class="anchor" id="Tpetra_Lesson05_Redist"></a>
Tpetra data redistribution: Import and Export</h1>
<p><a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a>'s Map class describes a data distribution over one or more distributed-memory parallel processes. It "maps" global indices (unique labels for the elements of a data structure) to parallel processes. This ability to describe a data distribution calls for a <em>redistribution</em> capability, that is, to reorganize or remap data from one distribution to another. <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> provides this capability through the <a href="http://trilinos.sandia.gov/packages/docs/dev/packages/tpetra/doc/html/classTpetra_1_1Import.html">Import </a> and <a href="http://trilinos.sandia.gov/packages/docs/dev/packages/tpetra/doc/html/classTpetra_1_1Export.html">Export </a> classes.</p>
<p>Import redistributes from a uniquely owned (one-to-one) Map to a possibly not uniquely owned Map. Export redistributes from a possibly not uniquely owned to a uniquely owned Map. We distinguish between these cases both for historical reasons and for performance reasons.</p>
<p>Import and Export objects encapsulate and <em>remember</em> a communication pattern for reuse. Computing the computation pattern requires nontrivial work, but keeping around the Import or Export object lets you reuse that work. This is very important for operations that are performed frequently, such as the Import and Export operations in <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a>'s sparse matrix-vector multiply.</p>
<p>In both cases, Import and Export let the user specify how to combine incoming new data with existing data that has the same global index. For example, one may replace old data with new data or sum them together.</p>
<h1><a class="anchor" id="Tpetra_Lesson05_Example"></a>
Code example</h1>
<p>This example shows how to migrate the data in <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> objects (sparse matrices and vectors) between two different parallel distributions.</p>
<div class="fragment"><div class="line"><span class="comment">// @HEADER</span></div>
<div class="line"><span class="comment">// *****************************************************************************</span></div>
<div class="line"><span class="comment">//          Tpetra: Templated Linear Algebra Services Package</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Copyright 2008 NTESS and the Tpetra contributors.</span></div>
<div class="line"><span class="comment">// SPDX-License-Identifier: BSD-3-Clause</span></div>
<div class="line"><span class="comment">// *****************************************************************************</span></div>
<div class="line"><span class="comment">// @HEADER</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;Teuchos_TimeMonitor.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Tpetra__Core_8hpp.html">Tpetra_Core.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Tpetra_CrsMatrix.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Timer for use in example().</span></div>
<div class="line">Teuchos::RCP&lt;Teuchos::Time&gt; exportTimer;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create and return a simple example CrsMatrix, with row distribution</span></div>
<div class="line"><span class="comment">// over the given Map.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// CrsMatrixType: The type of the Tpetra::CrsMatrix specialization to use.</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> CrsMatrixType&gt;</div>
<div class="line">Teuchos::RCP&lt;const CrsMatrixType&gt;</div>
<div class="line">createMatrix(<span class="keyword">const</span> Teuchos::RCP&lt;const typename CrsMatrixType::map_type&gt;&amp; map) {</div>
<div class="line">  <span class="keyword">using </span>Teuchos::arcp;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::ArrayRCP;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::ArrayView;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::RCP;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::rcp;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::Time;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::TimeMonitor;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::tuple;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::global_size_t</a> GST;</div>
<div class="line">  <span class="comment">// Fetch typedefs from the Tpetra::CrsMatrix.</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> CrsMatrixType::scalar_type scalar_type;</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> CrsMatrixType::local_ordinal_type LO;</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> CrsMatrixType::global_ordinal_type GO;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a timer for sparse matrix creation.</span></div>
<div class="line">  RCP&lt;Time&gt; timer = TimeMonitor::getNewCounter(<span class="stringliteral">&quot;Sparse matrix creation&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Time the whole scope of this routine, not counting timer lookup.</span></div>
<div class="line">  TimeMonitor monitor(*timer);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a Tpetra::Matrix using the Map, with dynamic allocation.</span></div>
<div class="line">  RCP&lt;CrsMatrixType&gt; A(<span class="keyword">new</span> CrsMatrixType(map, 3));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Add rows one at a time.  Off diagonal values will always be -1.</span></div>
<div class="line">  <span class="keyword">const</span> scalar_type two    = <span class="keyword">static_cast&lt;</span>scalar_type<span class="keyword">&gt;</span>(2.0);</div>
<div class="line">  <span class="keyword">const</span> scalar_type negOne = <span class="keyword">static_cast&lt;</span>scalar_type<span class="keyword">&gt;</span>(-1.0);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> GST numGlobalIndices = map-&gt;getGlobalNumElements();</div>
<div class="line">  <span class="comment">// const size_t numMyElements = map-&gt;getLocalNumElements ();</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The list of global elements owned by this MPI process.</span></div>
<div class="line">  ArrayView&lt;const GO&gt; myGlobalElements = map-&gt;getLocalElementList();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ArrayView&lt;const GO&gt;::const_iterator iter_type;</div>
<div class="line">  <span class="keywordflow">for</span> (iter_type it = myGlobalElements.begin(); it != myGlobalElements.end(); ++it) {</div>
<div class="line">    <span class="keyword">const</span> LO i_local  = *it;</div>
<div class="line">    <span class="keyword">const</span> GO i_global = map-&gt;getGlobalElement(i_local);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Can&#39;t insert local indices without a column map, so we insert</span></div>
<div class="line">    <span class="comment">// global indices here.</span></div>
<div class="line">    <span class="keywordflow">if</span> (i_global == 0) {</div>
<div class="line">      A-&gt;insertGlobalValues(i_global,</div>
<div class="line">                            tuple(i_global, i_global + 1),</div>
<div class="line">                            tuple(two, negOne));</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">static_cast&lt;</span>GST<span class="keyword">&gt;</span>(i_global) == numGlobalIndices - 1) {</div>
<div class="line">      A-&gt;insertGlobalValues(i_global,</div>
<div class="line">                            tuple(i_global - 1, i_global),</div>
<div class="line">                            tuple(negOne, two));</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      A-&gt;insertGlobalValues(i_global,</div>
<div class="line">                            tuple(i_global - 1, i_global, i_global + 1),</div>
<div class="line">                            tuple(negOne, two, negOne));</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Finish up the matrix.</span></div>
<div class="line">  A-&gt;fillComplete();</div>
<div class="line">  <span class="keywordflow">return</span> A;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> example(<span class="keyword">const</span> Teuchos::RCP&lt;<span class="keyword">const</span> Teuchos::Comm&lt;int&gt; &gt;&amp; comm,</div>
<div class="line">             std::ostream&amp; out) {</div>
<div class="line">  <span class="keyword">using </span>std::endl;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::ParameterList;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::RCP;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::rcp;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::Time;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::TimeMonitor;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::global_size_t</a> GST;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set up Tpetra typedefs.</span></div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::CrsMatrix&lt;&gt;</a> crs_matrix_type;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Map&lt;&gt;</a> map_type;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Map&lt;&gt;::global_ordinal_type</a> global_ordinal_type;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> myRank = comm-&gt;getRank();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The global number of rows in the matrix A to create.  We scale</span></div>
<div class="line">  <span class="comment">// this relative to the number of (MPI) processes, so that no matter</span></div>
<div class="line">  <span class="comment">// how many MPI processes you run, every process will have 10 rows.</span></div>
<div class="line">  <span class="keyword">const</span> GST numGlobalIndices          = 10 * comm-&gt;getSize();</div>
<div class="line">  <span class="keyword">const</span> global_ordinal_type indexBase = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct a Map that is global (not locally replicated), but puts</span></div>
<div class="line">  <span class="comment">// all the equations on MPI Proc 0.</span></div>
<div class="line">  <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">    out &lt;&lt; <span class="stringliteral">&quot;Construct Process 0 Map&quot;</span> &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line">  RCP&lt;const map_type&gt; procZeroMap;</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> numLocalIndices = (myRank == 0) ? numGlobalIndices : 0;</div>
<div class="line">    procZeroMap                  = rcp(<span class="keyword">new</span> map_type(numGlobalIndices, numLocalIndices,</div>
<div class="line">                                                    indexBase, comm));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct a Map that puts approximately the same number of</span></div>
<div class="line">  <span class="comment">// equations on each processor.</span></div>
<div class="line">  <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">    out &lt;&lt; <span class="stringliteral">&quot;Construct global Map&quot;</span> &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line">  RCP&lt;const map_type&gt; globalMap =</div>
<div class="line">      rcp(<span class="keyword">new</span> map_type(numGlobalIndices, indexBase, comm,</div>
<div class="line">                       Tpetra::GloballyDistributed));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a sparse matrix using procZeroMap.</span></div>
<div class="line">  <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">    out &lt;&lt; <span class="stringliteral">&quot;Create sparse matrix using Process 0 Map&quot;</span> &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line">  RCP&lt;const crs_matrix_type&gt; A = createMatrix&lt;crs_matrix_type&gt;(procZeroMap);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// We&#39;ve created a sparse matrix that lives entirely on Process 0.</span></div>
<div class="line">  <span class="comment">// Now we want to distribute it over all the processes.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Redistribute the matrix.  Since both the source and target Maps</span></div>
<div class="line">  <span class="comment">// are one-to-one, we could use either an Import or an Export.  If</span></div>
<div class="line">  <span class="comment">// only the source Map were one-to-one, we would have to use an</span></div>
<div class="line">  <span class="comment">// Import; if only the target Map were one-to-one, we would have to</span></div>
<div class="line">  <span class="comment">// use an Export.  We do not allow redistribution using Import or</span></div>
<div class="line">  <span class="comment">// Export if neither source nor target Map is one-to-one.</span></div>
<div class="line">  RCP&lt;crs_matrix_type&gt; B;</div>
<div class="line">  <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">    out &lt;&lt; <span class="stringliteral">&quot;Redistribute sparse matrix&quot;</span> &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// We created exportTimer in main().  It&#39;s a global timer.</span></div>
<div class="line">    <span class="comment">// Actually starting and stopping the timer is local, but</span></div>
<div class="line">    <span class="comment">// computing timer statistics (e.g., in TimeMonitor::summarize(),</span></div>
<div class="line">    <span class="comment">// called in main()) is global.  There are ways to restrict the</span></div>
<div class="line">    <span class="comment">// latter to any given MPI communicator; the default is</span></div>
<div class="line">    <span class="comment">// MPI_COMM_WORLD.</span></div>
<div class="line">    TimeMonitor monitor(*exportTimer);  <span class="comment">// Time the redistribution</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Make an Export object with procZeroMap as the source Map, and</span></div>
<div class="line">    <span class="comment">// globalMap as the target Map.  The Export type has the same</span></div>
<div class="line">    <span class="comment">// template parameters as a Map.  Note that Export does not depend</span></div>
<div class="line">    <span class="comment">// on the Scalar template parameter of the objects it</span></div>
<div class="line">    <span class="comment">// redistributes.  You can reuse the same Export for different</span></div>
<div class="line">    <span class="comment">// Tpetra object types, or for Tpetra objects of the same type but</span></div>
<div class="line">    <span class="comment">// different Scalar template parameters (e.g., Scalar=float or</span></div>
<div class="line">    <span class="comment">// Scalar=double).</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Export&lt;&gt;</a> export_type;</div>
<div class="line">    export_type exporter(procZeroMap, globalMap);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Make a new sparse matrix whose row map is the global Map.</span></div>
<div class="line">    B = rcp(<span class="keyword">new</span> crs_matrix_type(globalMap, 0));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Redistribute the data, NOT in place, from matrix A (which lives</span></div>
<div class="line">    <span class="comment">// entirely on Proc 0) to matrix B (which is distributed evenly over</span></div>
<div class="line">    <span class="comment">// the processes).</span></div>
<div class="line">    B-&gt;doExport(*A, exporter, <a class="code hl_enumvalue" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094ba8311a4172e79c1f3a25a4ffc2e637b28">Tpetra::INSERT</a>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// We time redistribution of B separately from fillComplete().</span></div>
<div class="line">  B-&gt;fillComplete();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div>
<div class="line">  <span class="keyword">using </span>Teuchos::TimeMonitor;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classTpetra_1_1ScopeGuard.html">Tpetra::ScopeGuard</a> tpetraScope(&amp;argc, &amp;argv);</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">auto</span> comm        = <a class="code hl_function" href="namespaceTpetra.html#ab0f27babe7678e67ee420a36029ae10a">Tpetra::getDefaultComm</a>();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> myRank = comm-&gt;getRank();</div>
<div class="line">    <span class="comment">// const int numProcs = comm-&gt;getSize ();</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Make global timer for sparse matrix redistribution.</span></div>
<div class="line">    <span class="comment">// We will use (start and stop) this timer in example().</span></div>
<div class="line">    exportTimer =</div>
<div class="line">        TimeMonitor::getNewCounter(<span class="stringliteral">&quot;Sparse matrix redistribution&quot;</span>);</div>
<div class="line">    example(comm, std::cout);  <span class="comment">// Run the whole example.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Summarize global performance timing results, for all timers</span></div>
<div class="line">    <span class="comment">// created using TimeMonitor::getNewCounter().</span></div>
<div class="line">    TimeMonitor::summarize(std::cout);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Make sure that the timer goes away before main() exits.</span></div>
<div class="line">    exportTimer = Teuchos::null;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This tells the Trilinos test framework that the test passed.</span></div>
<div class="line">    <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;End Result: TEST PASSED&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aTpetra__Core_8hpp_html"><div class="ttname"><a href="Tpetra__Core_8hpp.html">Tpetra_Core.hpp</a></div><div class="ttdoc">Functions for initializing and finalizing Tpetra.</div></div>
<div class="ttc" id="aclassTpetra_1_1CrsMatrixStruct_html"><div class="ttname"><a href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::CrsMatrixStruct</a></div><div class="ttdoc">Struct that holds views of the contents of a CrsMatrix.</div><div class="ttdef"><b>Definition</b> <a href="TpetraExt__MMHelpers__decl_8hpp_source.html#l00036">TpetraExt_MMHelpers_decl.hpp:36</a></div></div>
<div class="ttc" id="aclassTpetra_1_1ScopeGuard_html"><div class="ttname"><a href="classTpetra_1_1ScopeGuard.html">Tpetra::ScopeGuard</a></div><div class="ttdoc">Scope guard whose destructor automatically calls Tpetra::finalize for you.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__Core_8hpp_source.html#l00188">Tpetra_Core.hpp:188</a></div></div>
<div class="ttc" id="anamespaceTpetra_html_ab0f27babe7678e67ee420a36029ae10a"><div class="ttname"><a href="namespaceTpetra.html#ab0f27babe7678e67ee420a36029ae10a">Tpetra::getDefaultComm</a></div><div class="ttdeci">Teuchos::RCP&lt; const Teuchos::Comm&lt; int &gt; &gt; getDefaultComm()</div><div class="ttdoc">Get Tpetra's default communicator.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__Core_8cpp_source.html#l00170">Tpetra_Core.cpp:170</a></div></div>
<div class="ttc" id="anamespaceTpetra_html_ae2e9d143601fd81d01d9317bf4d9094ba8311a4172e79c1f3a25a4ffc2e637b28"><div class="ttname"><a href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094ba8311a4172e79c1f3a25a4ffc2e637b28">Tpetra::INSERT</a></div><div class="ttdeci">@ INSERT</div><div class="ttdoc">Insert new values that don't currently exist.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__CombineMode_8hpp_source.html#l00067">Tpetra_CombineMode.hpp:67</a></div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
