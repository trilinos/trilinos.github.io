<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tpetra parallel linear algebra: Tpetra Lesson 03: Power method</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tpetra parallel linear algebra<span id="projectnumber">&#160;Version of the Day</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Tpetra Lesson 03: Power method</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Use <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> sparse matrix and dense vector objects to implement a simple iteration (the power method)</p>
<h1><a class="anchor" id="Tpetra_Lesson03_Topics"></a>
Lesson topics</h1>
<p>This lesson demonstrates the following: </p><ol>
<li>
How to construct a <a class="el" href="classTpetra_1_1CrsMatrix.html" title="Sparse matrix that presents a row-oriented interface that lets users read or modify entries.">Tpetra::CrsMatrix</a> (a distributed sparse matrix)  </li>
<li>
How to modify the entries of a previously constructed CrsMatrix  </li>
<li>
How to use CrsMatrix and Vector to implement a simple iterative eigensolver (the power method)  </li>
</ol>
<p>This example is just like the Epetra power method example with which many users might be familiar, but uses <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> objects in place of Epetra objects.</p>
<h1><a class="anchor" id="Tpetra_Lesson03_Relation"></a>
Relation to other lessons</h1>
<p>Before starting this lesson, it helps to have learned <a class="el" href="Tpetra_Lesson01.html">Tpetra Lesson 01: Initialization</a> (how to initialize <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a>) and <a class="el" href="Tpetra_Lesson02.html#Tpetra_Lesson02_Vector">Tpetra::Vector</a> (how to create distributions and distributed vectors). After completing this lesson, you might want to learn about more efficient ways to add or modify entries in a <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> sparse matrix.</p>
<h1><a class="anchor" id="Tpetra_Lesson03_Fill"></a>
Creating and filling a sparse matrix</h1>
<p>This is the first lesson in the usual sequence which covers adding entries to ("filling") a <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> sparse matrix, and modifying the values of those entries after creating the matrix. Creating and filling a <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> sparse matrix involves the following steps: </p><ol>
<li>
Create the CrsMatrix (by calling one of its constructors)  </li>
<li>
Call methods to add entries to the sparse matrix  </li>
<li>
Call the matrix's <code>fillComplete()</code> method  </li>
</ol>
<p>We will explain each of these steps in turn.</p>
<h2><a class="anchor" id="Tpetra_Lesson03_Fill_create"></a>
Creating the CrsMatrix</h2>
<p><a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a>'s sparse matrices are distributed over one or more parallel processes, just like vectors or other distributed objects. Also just like vectors, you have to tell the sparse matrix its distribution on construction. Unlike vectors, though, sparse matrices have two dimensions over which to be distributed: rows and columns.</p>
<p>Many users are perfectly happy ignoring the column distribution and just distributing the matrix in "one-dimensional" fashion over rows. In that case, you need only supply the "row Map" to the constructor. This implies that for any row which a process owns, that process may insert entries in any column in that row.</p>
<p>Some users want to use the full flexibility of distributing both the rows and columns of the matrix over processes. This "two-dimensional" distribution, if chosen optimally, can significantly reduce the amount of communication needed for distributed-memory parallel sparse matrix-vector multiply. Trilinos packages like Zoltan and Zoltan2 can help you compute this distribution. In that case, you may give both the "row Map" and the "column Map" to the constructor. This implies that for any row which a process owns, that process may insert entries in any column in that row which that process owns in its column Map.</p>
<p>Finally, other users already know the structure of the sparse matrix, and just want to fill in values. These users should first create the graph (a CrsGraph), call <code>fillComplete()</code> on the graph, and then give the graph to the constructor of CrsMatrix. The graph may have either a "1-D" or "2-D" distribution, as mentioned above.</p>
<h2><a class="anchor" id="Tpetra_Lesson03_Fill_add"></a>
Adding entries to the sparse matrix</h2>
<p>Methods of CrsMatrix that start with "insert" actually change the structure of the sparse matrix. Methods that start with "replace" or "sumInto" only modify existing values.</p>
<h2><a class="anchor" id="Tpetra_Lesson03_Fill_fillComplete"></a>
Calling fillComplete()</h2>
<p>Calling <code>fillComplete()</code> signals that you are done changing the structure (if allowed) or values of the sparse matrix. This is an expensive operation, because it both rearranges local data, and communicates in order to build reusable communication patterns for sparse matrix-vector multiply. You should try to amortize the cost of this operation whenever possible over many sparse matrix-vector multiplies.</p>
<p><code>fillComplete()</code> takes two arguments: </p><ul>
<li>
the domain Map (the distribution of the input vector x in a sparse matrix-vector multiply y = A*x)  </li>
<li>
the range Map (the distribution of the output vector y in a sparse matrix-vector multiply y = A*x)  </li>
</ul>
<p>Both the domain and range Maps must be one-to-one: that is, each global index in the Map must be uniquely owned by one and only one process. You will need to supply these two arguments to <code>fillComplete()</code> under any of the following conditions: </p><ul>
<li>
When the row Map is not the same as the range Map (it can't be if the row Map is not one to one)  </li>
<li>
When the domain and range Maps are not equal (e.g., if the matrix is not square)  </li>
<li>
When the domain or range Map as not the same as the row Map </li>
</ul>
<p>If the domain and range Maps equal the row Map and the row Map is one-to-one, then you may call <code>fillComplete()</code> with no arguments.</p>
<p>The most significant difference between Epetra and <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> sparse matrices, is that in order to modify the entries of a <a class="el" href="classTpetra_1_1CrsMatrix.html" title="Sparse matrix that presents a row-oriented interface that lets users read or modify entries.">Tpetra::CrsMatrix</a> once you have called <code>fillComplete()</code>, you must first call <code>resumeFill()</code>. Epetra_CrsMatrix has no corresponding "resume fill" method, and you may modify the values of entries after <code>FillComplete()</code> has been called.</p>
<p>The reason for this difference is that <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a>'s <code>fillComplete()</code> has the right to rearrange the matrix's data in ways that violate user expectations. For example, it may give the data to a third-party library that rearranges them in an opaque way, or even copy them into a different memory space (for example, into GPU memory). Calling <code>resumeFill()</code> signals <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> that you want to change either the values or the structure.</p>
<h1><a class="anchor" id="Tpetra_Lesson03_example"></a>
Code example</h1>
<p>The following code example shows how to fill and compute with a <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> sparse matrix, using the procedure discussed in the text above.</p>
<div class="fragment"><div class="line"><span class="comment">// @HEADER</span></div>
<div class="line"><span class="comment">// *****************************************************************************</span></div>
<div class="line"><span class="comment">//          Tpetra: Templated Linear Algebra Services Package</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Copyright 2008 NTESS and the Tpetra contributors.</span></div>
<div class="line"><span class="comment">// SPDX-License-Identifier: BSD-3-Clause</span></div>
<div class="line"><span class="comment">// *****************************************************************************</span></div>
<div class="line"><span class="comment">// @HEADER</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Tpetra__Core_8hpp.html">Tpetra_Core.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Tpetra_CrsMatrix.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Tpetra_Map.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Tpetra_MultiVector.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Tpetra_Vector.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Tpetra_Version.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;Teuchos_Array.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Teuchos_ScalarTraits.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Teuchos_RCP.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Power method for estimating the eigenvalue of maximum magnitude of</span></div>
<div class="line"><span class="comment">// a matrix.  This function returns the eigenvalue estimate.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// We don&#39;t intend for you to write your own eigensolvers; the Anasazi</span></div>
<div class="line"><span class="comment">// package provides them.  You should instead see this class as a</span></div>
<div class="line"><span class="comment">// surrogate for a Tpetra interface to a Trilinos package.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// TpetraOperatorType: the type of the Tpetra::Operator specialization</span></div>
<div class="line"><span class="comment">//   used to represent the sparse matrix or operator A.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Tpetra::Operator implements a function from one</span></div>
<div class="line"><span class="comment">// Tpetra::(Multi)Vector to another Tpetra::(Multi)Vector.</span></div>
<div class="line"><span class="comment">// Tpetra::CrsMatrix implements Tpetra::Operator; its apply() method</span></div>
<div class="line"><span class="comment">// computes a sparse matrix-(multi)vector multiply.  It&#39;s typical for</span></div>
<div class="line"><span class="comment">// numerical algorithms that use Tpetra objects to be templated on the</span></div>
<div class="line"><span class="comment">// type of the Tpetra::Operator specialization.  We do so here, and</span></div>
<div class="line"><span class="comment">// thus demonstrate how you can use the public typedefs in Tpetra</span></div>
<div class="line"><span class="comment">// classes to write generic code.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// One could use a templated function here instead of a templated</span></div>
<div class="line"><span class="comment">// class with a static (class) method.  I prefer the class approach</span></div>
<div class="line"><span class="comment">// because one can lift typedefs out of the function into the class.</span></div>
<div class="line"><span class="comment">// It tends to makes the function declaration easier to read.</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> TpetraOperatorType&gt;</div>
<div class="line"><span class="keyword">class </span>PowerMethod {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> TpetraOperatorType::scalar_type scalar_type;</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> TpetraOperatorType::local_ordinal_type local_ordinal_type;</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> TpetraOperatorType::global_ordinal_type global_ordinal_type;</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> TpetraOperatorType::node_type node_type;</div>
<div class="line">  <span class="comment">// The type of a Tpetra vector with the same template parameters as</span></div>
<div class="line">  <span class="comment">// those of TpetraOperatorType.</span></div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1Vector.html">Tpetra::Vector</a>&lt;scalar_type, local_ordinal_type,</div>
<div class="line">                         global_ordinal_type, node_type&gt;</div>
<div class="line">      vec_type;</div>
<div class="line">  <span class="comment">// The type of the norm of the above Tpetra::Vector specialization.</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> vec_type::mag_type magnitude_type;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Run the power method and return the eigenvalue estimate.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Input arguments:</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// A: The sparse matrix or operator, as a Tpetra::Operator.</span></div>
<div class="line">  <span class="comment">// niters: Maximum number of iterations of the power method.</span></div>
<div class="line">  <span class="comment">// tolerance: If the 2-norm of the residual A*x-lambda*x (for the</span></div>
<div class="line">  <span class="comment">//   current eigenvalue estimate lambda) is less than this, stop</span></div>
<div class="line">  <span class="comment">//   iterating.  The complicated expression for the type ensures that</span></div>
<div class="line">  <span class="comment">//   if the type of entries in the matrix A (scalar_type) is complex,</span></div>
<div class="line">  <span class="comment">//   then we&#39;ll be using a real-valued type (&quot;magnitude&quot;) for the</span></div>
<div class="line">  <span class="comment">//   tolerance.  (You can&#39;t compare complex numbers using less than,</span></div>
<div class="line">  <span class="comment">//   so you can&#39;t test for convergence using a complex number.)</span></div>
<div class="line">  <span class="comment">// out: output stream to which to print the current status of the</span></div>
<div class="line">  <span class="comment">//   power method.</span></div>
<div class="line">  <span class="keyword">static</span> scalar_type</div>
<div class="line">  run(<span class="keyword">const</span> TpetraOperatorType&amp; A,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span> niters,</div>
<div class="line">      <span class="keyword">const</span> magnitude_type tolerance,</div>
<div class="line">      std::ostream&amp; out) {</div>
<div class="line">    <span class="keyword">using </span>std::endl;</div>
<div class="line">    <span class="keyword">typedef</span> Teuchos::ScalarTraits&lt;scalar_type&gt; STS;</div>
<div class="line">    <span class="keyword">typedef</span> Teuchos::ScalarTraits&lt;magnitude_type&gt; STM;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> myRank = A.getMap()-&gt;getComm()-&gt;getRank();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create three vectors for iterating the power method.  Since the</span></div>
<div class="line">    <span class="comment">// power method computes z = A*q, q should be in the domain of A and</span></div>
<div class="line">    <span class="comment">// z should be in the range.  (Obviously the power method requires</span></div>
<div class="line">    <span class="comment">// that the domain and the range are equal, but it&#39;s a good idea to</span></div>
<div class="line">    <span class="comment">// get into the habit of thinking whether a particular vector</span></div>
<div class="line">    <span class="comment">// &quot;belongs&quot; in the domain or range of the matrix.)  The residual</span></div>
<div class="line">    <span class="comment">// vector &quot;resid&quot; is of course in the range of A.</span></div>
<div class="line">    vec_type q(A.getDomainMap());</div>
<div class="line">    vec_type z(A.getRangeMap());</div>
<div class="line">    vec_type resid(A.getRangeMap());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Fill the iteration vector z with random numbers to start.</span></div>
<div class="line">    <span class="comment">// Don&#39;t have grand expectations about the quality of our</span></div>
<div class="line">    <span class="comment">// pseudorandom number generator, but it is usually good enough</span></div>
<div class="line">    <span class="comment">// for eigensolvers.</span></div>
<div class="line">    z.randomize();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// lambda: Current approximation of the eigenvalue of maximum magnitude.</span></div>
<div class="line">    <span class="comment">// normz: 2-norm of the current iteration vector z.</span></div>
<div class="line">    <span class="comment">// residual: 2-norm of the current residual vector &#39;resid&#39;.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Teuchos::ScalarTraits defines what zero and one means for any</span></div>
<div class="line">    <span class="comment">// type.  Most number types T know how to turn a 0 or a 1 (int)</span></div>
<div class="line">    <span class="comment">// into a T.  I have encountered some number types in C++ that do</span></div>
<div class="line">    <span class="comment">// not.  These tend to be extended-precision types that define</span></div>
<div class="line">    <span class="comment">// number operators and know how to convert from a float or</span></div>
<div class="line">    <span class="comment">// double, but don&#39;t have conversion operators for int.  Thus,</span></div>
<div class="line">    <span class="comment">// using Teuchos::ScalarTraits makes this code maximally general.</span></div>
<div class="line">    scalar_type lambda      = STS::zero();</div>
<div class="line">    magnitude_type normz    = STM::zero();</div>
<div class="line">    magnitude_type residual = STM::zero();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> scalar_type one  = STS::one();</div>
<div class="line">    <span class="keyword">const</span> scalar_type zero = STS::zero();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// How often to report progress in the power method.  Reporting</span></div>
<div class="line">    <span class="comment">// progress requires computing a residual, which can be expensive.</span></div>
<div class="line">    <span class="comment">// However, if you don&#39;t compute the residual often enough, you</span></div>
<div class="line">    <span class="comment">// might keep iterating even after you&#39;ve converged.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> reportFrequency = 10;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Do the power method, until the method has converged or the</span></div>
<div class="line">    <span class="comment">// maximum iteration count has been reached.</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iter = 0; iter &lt; niters; ++iter) {</div>
<div class="line">      normz = z.norm2();        <span class="comment">// Compute the 2-norm of z</span></div>
<div class="line">      q.scale(one / normz, z);  <span class="comment">// q := z / normz</span></div>
<div class="line">      A.apply(q, z);            <span class="comment">// z := A * q</span></div>
<div class="line">      lambda = q.dot(z);        <span class="comment">// Approx. max eigenvalue</span></div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Compute and report the residual norm every reportFrequency</span></div>
<div class="line">      <span class="comment">// iterations, or if we&#39;ve reached the maximum iteration count.</span></div>
<div class="line">      <span class="keywordflow">if</span> (iter % reportFrequency == 0 || iter + 1 == niters) {</div>
<div class="line">        resid.update(one, z, -lambda, q, zero);  <span class="comment">// z := A*q - lambda*q</span></div>
<div class="line">        residual = resid.norm2();                <span class="comment">// 2-norm of the residual vector</span></div>
<div class="line">        <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">          out &lt;&lt; <span class="stringliteral">&quot;Iteration &quot;</span> &lt;&lt; iter &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;- lambda = &quot;</span> &lt;&lt; lambda &lt;&lt; endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;- ||A*q - lambda*q||_2 = &quot;</span> &lt;&lt; residual &lt;&lt; endl;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (residual &lt; tolerance) {</div>
<div class="line">        <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">          out &lt;&lt; <span class="stringliteral">&quot;Converged after &quot;</span> &lt;&lt; iter &lt;&lt; <span class="stringliteral">&quot; iterations&quot;</span> &lt;&lt; endl;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (iter + 1 == niters) {</div>
<div class="line">        <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">          out &lt;&lt; <span class="stringliteral">&quot;Failed to converge after &quot;</span> &lt;&lt; niters</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot; iterations&quot;</span> &lt;&lt; endl;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> lambda;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div>
<div class="line">  <span class="keyword">using </span>std::cout;</div>
<div class="line">  <span class="keyword">using </span>std::endl;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::arcp;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::Array;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::ArrayRCP;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::ArrayView;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::RCP;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::rcp;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::tuple;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Map&lt;&gt;</a> map_type;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Vector&lt;&gt;::scalar_type</a> scalar_type;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Vector&lt;&gt;::local_ordinal_type</a> <a class="code hl_typedef" href="namespaceTpetra_1_1Details_1_1DefaultTypes.html#a30dcc98a8290a6dcb0216e0f54c68d57">local_ordinal_type</a>;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Vector&lt;&gt;::global_ordinal_type</a> global_ordinal_type;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_typedef" href="classTpetra_1_1Vector.html#a3f08d5b43313bdbcab7705a89c19d35e">Tpetra::Vector&lt;&gt;::mag_type</a> magnitude_type;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::CrsMatrix&lt;&gt;</a> crs_matrix_type;</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> crs_matrix_type::nonconst_global_inds_host_view_type gids_type;</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> crs_matrix_type::nonconst_values_host_view_type vals_type;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classTpetra_1_1ScopeGuard.html">Tpetra::ScopeGuard</a> tpetraScope(&amp;argc, &amp;argv);</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Never create Tpetra objects at main() scope.</span></div>
<div class="line">    <span class="comment">// Never allow them to persist past ScopeGuard&#39;s destructor.</span></div>
<div class="line">    <span class="keyword">auto</span> comm = <a class="code hl_function" href="namespaceTpetra.html#ab0f27babe7678e67ee420a36029ae10a">Tpetra::getDefaultComm</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> myRank = comm-&gt;getRank();</div>
<div class="line">    <span class="comment">// const size_t numProcs = comm-&gt;getSize();</span></div>
<div class="line">    <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">      cout &lt;&lt; Tpetra::version() &lt;&lt; endl</div>
<div class="line">           &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The number of rows and columns in the matrix.</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::global_size_t</a> numGblIndices = 50;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Construct a Map that puts approximately the same number of</span></div>
<div class="line">    <span class="comment">// equations on each processor.</span></div>
<div class="line">    <span class="keyword">const</span> global_ordinal_type indexBase = 0;</div>
<div class="line">    RCP&lt;const map_type&gt; map =</div>
<div class="line">        rcp(<span class="keyword">new</span> map_type(numGblIndices, indexBase, comm));</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> numMyElements = map-&gt;getLocalNumElements();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// If you like, you may get the list of global indices that the</span></div>
<div class="line">    <span class="comment">// calling process owns.  This is unnecessary if you don&#39;t mind</span></div>
<div class="line">    <span class="comment">// converting local indices to global indices.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// ArrayView&lt;const global_ordinal_type&gt; myGlobalElements =</span></div>
<div class="line">    <span class="comment">//   map-&gt;getLocalElementList ();</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">      cout &lt;&lt; endl</div>
<div class="line">           &lt;&lt; <span class="stringliteral">&quot;Creating the sparse matrix&quot;</span> &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a Tpetra sparse matrix whose rows have distribution</span></div>
<div class="line">    <span class="comment">// given by the Map.  We expect at most three entries per row.</span></div>
<div class="line">    RCP&lt;crs_matrix_type&gt; A(<span class="keyword">new</span> crs_matrix_type(map, 3));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Fill the sparse matrix, one row at a time.</span></div>
<div class="line">    <span class="keyword">const</span> scalar_type two    = <span class="keyword">static_cast&lt;</span>scalar_type<span class="keyword">&gt;</span>(2.0);</div>
<div class="line">    <span class="keyword">const</span> scalar_type negOne = <span class="keyword">static_cast&lt;</span>scalar_type<span class="keyword">&gt;</span>(-1.0);</div>
<div class="line">    <span class="keywordflow">for</span> (local_ordinal_type lclRow = 0;</div>
<div class="line">         lclRow &lt; static_cast&lt;local_ordinal_type&gt;(numMyElements);</div>
<div class="line">         ++lclRow) {</div>
<div class="line">      <span class="keyword">const</span> global_ordinal_type gblRow = map-&gt;getGlobalElement(lclRow);</div>
<div class="line">      <span class="comment">// A(0, 0:1) = [2, -1]</span></div>
<div class="line">      <span class="keywordflow">if</span> (gblRow == 0) {</div>
<div class="line">        A-&gt;insertGlobalValues(gblRow,</div>
<div class="line">                              tuple&lt;global_ordinal_type&gt;(gblRow, gblRow + 1),</div>
<div class="line">                              tuple&lt;scalar_type&gt;(two, negOne));</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// A(N-1, N-2:N-1) = [-1, 2]</span></div>
<div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">static_cast&lt;</span><a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::global_size_t</a><span class="keyword">&gt;</span>(gblRow) == numGblIndices - 1) {</div>
<div class="line">        A-&gt;insertGlobalValues(gblRow,</div>
<div class="line">                              tuple&lt;global_ordinal_type&gt;(gblRow - 1, gblRow),</div>
<div class="line">                              tuple&lt;scalar_type&gt;(negOne, two));</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// A(i, i-1:i+1) = [-1, 2, -1]</span></div>
<div class="line">      <span class="keywordflow">else</span> {</div>
<div class="line">        A-&gt;insertGlobalValues(gblRow,</div>
<div class="line">                              tuple&lt;global_ordinal_type&gt;(gblRow - 1, gblRow, gblRow + 1),</div>
<div class="line">                              tuple&lt;scalar_type&gt;(negOne, two, negOne));</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Tell the sparse matrix that we are done adding entries to it.</span></div>
<div class="line">    A-&gt;fillComplete();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Number of iterations</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> niters = 500;</div>
<div class="line">    <span class="comment">// Desired (absolute) residual tolerance</span></div>
<div class="line">    <span class="keyword">const</span> magnitude_type tolerance = 1.0e-2;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Run the power method and report the result.</span></div>
<div class="line">    scalar_type lambda =</div>
<div class="line">        PowerMethod&lt;crs_matrix_type&gt;::run(*A, niters, tolerance, cout);</div>
<div class="line">    <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">      cout &lt;&lt; endl</div>
<div class="line">           &lt;&lt; <span class="stringliteral">&quot;Estimated max eigenvalue: &quot;</span> &lt;&lt; lambda &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Now we will change values in the sparse matrix and run the</span></div>
<div class="line">    <span class="comment">// power method again.  In Tpetra, if fillComplete() has been</span></div>
<div class="line">    <span class="comment">// called on a matrix, you must call resumeFill() on that matrix</span></div>
<div class="line">    <span class="comment">// before you may change it.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Increase diagonal dominance</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">      cout &lt;&lt; endl</div>
<div class="line">           &lt;&lt; <span class="stringliteral">&quot;Increasing magnitude of A(0,0), solving again&quot;</span> &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Must call resumeFill() before changing the matrix.</span></div>
<div class="line">    A-&gt;resumeFill();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (A-&gt;getRowMap()-&gt;isNodeGlobalElement(0)) {</div>
<div class="line">      <span class="comment">// Get a copy of the row with global index 0.  Modify the</span></div>
<div class="line">      <span class="comment">// diagonal entry of that row.  Submit the modified values to</span></div>
<div class="line">      <span class="comment">// the matrix.</span></div>
<div class="line">      <span class="keyword">const</span> global_ordinal_type idOfFirstRow = 0;</div>
<div class="line">      <span class="keywordtype">size_t</span> numEntriesInRow                 = A-&gt;getNumEntriesInGlobalRow(idOfFirstRow);</div>
<div class="line">      vals_type rowvals(<span class="stringliteral">&quot;vals&quot;</span>, numEntriesInRow);</div>
<div class="line">      gids_type rowinds(<span class="stringliteral">&quot;gids&quot;</span>, numEntriesInRow);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Fill rowvals and rowinds with the values resp. (global)</span></div>
<div class="line">      <span class="comment">// column indices of the sparse matrix entries owned by the</span></div>
<div class="line">      <span class="comment">// calling process.</span></div>
<div class="line">      <span class="comment">//</span></div>
<div class="line">      <span class="comment">// Note that it&#39;s legal (though we don&#39;t exercise it in this</span></div>
<div class="line">      <span class="comment">// example) for the row Map of the sparse matrix not to be one</span></div>
<div class="line">      <span class="comment">// to one.  This means that more than one process might own</span></div>
<div class="line">      <span class="comment">// entries in the first row.  In general, multiple processes</span></div>
<div class="line">      <span class="comment">// might own the (0,0) entry, so that the global A(0,0) value is</span></div>
<div class="line">      <span class="comment">// really the sum of all processes&#39; values for that entry.</span></div>
<div class="line">      <span class="comment">// However, scaling the entry by a constant factor distributes</span></div>
<div class="line">      <span class="comment">// across that sum, so it&#39;s OK to do so.</span></div>
<div class="line">      <span class="comment">//</span></div>
<div class="line">      <span class="comment">// The parentheses after rowinds and rowvalues indicate &quot;a view</span></div>
<div class="line">      <span class="comment">// of the Array&#39;s data.&quot;  Array::operator() returns an</span></div>
<div class="line">      <span class="comment">// ArrayView.</span></div>
<div class="line">      A-&gt;getGlobalRowCopy(idOfFirstRow, rowinds, rowvals, numEntriesInRow);</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; numEntriesInRow; i++) {</div>
<div class="line">        <span class="keywordflow">if</span> (rowinds[i] == idOfFirstRow) {</div>
<div class="line">          <span class="comment">// We have found the diagonal entry; modify it.</span></div>
<div class="line">          rowvals[i] *= 10.0;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// &quot;Replace global values&quot; means modify the values, but not the</span></div>
<div class="line">      <span class="comment">// structure of the sparse matrix.  If the specified columns</span></div>
<div class="line">      <span class="comment">// aren&#39;t already populated in this row on this process, then this</span></div>
<div class="line">      <span class="comment">// method throws an exception.  If you want to modify the</span></div>
<div class="line">      <span class="comment">// structure (by adding new entries), you&#39;ll need to call</span></div>
<div class="line">      <span class="comment">// insertGlobalValues().</span></div>
<div class="line">      A-&gt;replaceGlobalValues(idOfFirstRow, rowinds, rowvals);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Call fillComplete() again to signal that we are done changing the</span></div>
<div class="line">    <span class="comment">// matrix.</span></div>
<div class="line">    A-&gt;fillComplete();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Run the power method again.</span></div>
<div class="line">    lambda = PowerMethod&lt;crs_matrix_type&gt;::run(*A, niters, tolerance,</div>
<div class="line">                                               cout);</div>
<div class="line">    <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">      cout &lt;&lt; endl</div>
<div class="line">           &lt;&lt; <span class="stringliteral">&quot;Estimated max eigenvalue: &quot;</span> &lt;&lt; lambda &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This tells the Trilinos test framework that the test passed.</span></div>
<div class="line">    <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;End Result: TEST PASSED&quot;</span> &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aTpetra__Core_8hpp_html"><div class="ttname"><a href="Tpetra__Core_8hpp.html">Tpetra_Core.hpp</a></div><div class="ttdoc">Functions for initializing and finalizing Tpetra.</div></div>
<div class="ttc" id="aclassTpetra_1_1CrsMatrixStruct_html"><div class="ttname"><a href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::CrsMatrixStruct</a></div><div class="ttdoc">Struct that holds views of the contents of a CrsMatrix.</div><div class="ttdef"><b>Definition</b> <a href="TpetraExt__MMHelpers__decl_8hpp_source.html#l00036">TpetraExt_MMHelpers_decl.hpp:36</a></div></div>
<div class="ttc" id="aclassTpetra_1_1ScopeGuard_html"><div class="ttname"><a href="classTpetra_1_1ScopeGuard.html">Tpetra::ScopeGuard</a></div><div class="ttdoc">Scope guard whose destructor automatically calls Tpetra::finalize for you.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__Core_8hpp_source.html#l00188">Tpetra_Core.hpp:188</a></div></div>
<div class="ttc" id="aclassTpetra_1_1Vector_html"><div class="ttname"><a href="classTpetra_1_1Vector.html">Tpetra::Vector</a></div><div class="ttdoc">A distributed dense vector.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__Vector__decl_8hpp_source.html#l00044">Tpetra_Vector_decl.hpp:44</a></div></div>
<div class="ttc" id="aclassTpetra_1_1Vector_html_a3f08d5b43313bdbcab7705a89c19d35e"><div class="ttname"><a href="classTpetra_1_1Vector.html#a3f08d5b43313bdbcab7705a89c19d35e">Tpetra::Vector::mag_type</a></div><div class="ttdeci">base_type::mag_type mag_type</div><div class="ttdoc">Type of a norm result.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__Vector__decl_8hpp_source.html#l00088">Tpetra_Vector_decl.hpp:88</a></div></div>
<div class="ttc" id="anamespaceTpetra_1_1Details_1_1DefaultTypes_html_a30dcc98a8290a6dcb0216e0f54c68d57"><div class="ttname"><a href="namespaceTpetra_1_1Details_1_1DefaultTypes.html#a30dcc98a8290a6dcb0216e0f54c68d57">Tpetra::Details::DefaultTypes::local_ordinal_type</a></div><div class="ttdeci">int local_ordinal_type</div><div class="ttdoc">Default value of Scalar template parameter.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__Details__DefaultTypes_8hpp_source.html#l00040">Tpetra_Details_DefaultTypes.hpp:40</a></div></div>
<div class="ttc" id="anamespaceTpetra_html_ab0f27babe7678e67ee420a36029ae10a"><div class="ttname"><a href="namespaceTpetra.html#ab0f27babe7678e67ee420a36029ae10a">Tpetra::getDefaultComm</a></div><div class="ttdeci">Teuchos::RCP&lt; const Teuchos::Comm&lt; int &gt; &gt; getDefaultComm()</div><div class="ttdoc">Get Tpetra's default communicator.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__Core_8cpp_source.html#l00170">Tpetra_Core.cpp:170</a></div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 9 2025 21:01:02 for Tpetra parallel linear algebra by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
