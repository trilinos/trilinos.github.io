<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tpetra parallel linear algebra: Tpetra Lesson 02: Map and Vector</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tpetra parallel linear algebra<span id="projectnumber">&#160;Version of the Day</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Tpetra Lesson 02: Map and Vector</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A lesson on parallel distributions and distributed objects.</p>
<h1><a class="anchor" id="Tpetra_Lesson02_Topics"></a>
Lesson topics</h1>
<p>In this lesson, we will explain how to create the simplest kind of <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> linear algebra object: a Vector, whose entries are distributed over the process(es) in a communicator. The <a href="http://trilinos.sandia.gov/packages/docs/dev/packages/tpetra/doc/html/classTpetra_1_1Map.html">Map</a> object describes this distribution of entries over processes. You create a Map to describe the distribution scheme you want, and then use the Map to create objects (such as Vectors) that have this distribution. We spend a little bit more time than you might initially wish explaining Map, but understanding it is important for getting the best performance out of <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a>. We give examples of different distributions you can create, use their Maps to create Vectors, and then do some arithmetic with the Vectors. All of this gives us an opportunity to explain the various template parameters that are part of the type of nearly every <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> object.</p>
<h1><a class="anchor" id="Tpetra_Lesson02_Map"></a>
Tpetra::Map</h1>
<h2><a class="anchor" id="Tpetra_Lesson02_Map_distribution"></a>
A Map instance describes a data distribution</h2>
<p><a href="http://trilinos.sandia.gov/packages/tpetra/">Tpetra</a>, like <a href="http://trilinos.sandia.gov/packages/epetra/">Epetra</a>, uses objects called "Maps" to encapsulate the details of distributing data over MPI processes. Maps make data distribution into a first-class citizen. Each Map instance represents a particular data distribution.</p>
<p>You can think of a Map instance abstractly as representing a vector space. <br  />
 If two vectors have the same map, it's like they come from the same vector space. For example, you can add them together without performing communication. If they come from different vector spaces, then you need more information to know whether it is legal to add the vectors together.</p>
<p>You can find documentation for <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a>'s Map class <a href="http://trilinos.sandia.gov/packages/docs/dev/packages/tpetra/doc/html/classTpetra_1_1Map.html">here</a>.</p>
<h2><a class="anchor" id="Tpetra_Lesson02_Map_assigns"></a>
A Map assigns entries of a data structure to processes</h2>
<h3><a class="anchor" id="Tpetra_Lesson02_Map_assigns_GIDs"></a>
Global indices matter to you</h3>
<p>For you as the user, the fact that you might be parallelizing your application using MPI is really an implementation detail. You care about what we call <em>global indices</em>. These represent the entries of a distributed object (such as rows or columns of a sparse matrix, or entries of a vector) uniquely over the entire object. The object in turn may be distributed over multiple processes. Just about any data structure containing entries that can be assigned an integer index can be distributed using a Map. For most <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> users, this means entries of a vector, rows of a <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">Tpetra::MultiVector</a>, or rows or columns of a sparse matrix. However, it is not limited to these kinds of objects. You may even use Map for your own distributed objects.</p>
<p>A Map assigns global indices to parallel processes. If it assigns a global index G to a process P, we say that process P <em>owns</em> global index G. It is legal for multiple processes to own the same global index G. In fact, this is how we implement many useful communication patterns, including those in sparse matrix-vector multiply. We won't go into much detail in this lesson about that.</p>
<h3><a class="anchor" id="Tpetra_Lesson02_Map_assigns_LIDs"></a>
Local indices are an implementation detail</h3>
<p>For efficiency, within a process, we refer to a global index using its "local index" on that process. <em>Local indices</em> are local to the process that owns them. If process P owns global index G, then there is a unique local index L on process P corresponding to G. If the local index L is valid on process P, then there is a unique global index G owned by P corresponding to the pair (L, P). However, multiple processes might own the same global index, so a global index G might correspond to multiple (L, P) pairs. In summary, local indices on a process correspond to object "entries" (e.g., sparse matrix rows or columns) owned by that process.</p>
<h3><a class="anchor" id="Tpetra_Lesson02_Map_assigns_exposeLIDs"></a>
We expose local indices for performance reasons</h3>
<p>Local indices matter to you because it may be more efficient to use them to access or modify local data than it is to use global indices. This is because distributed data structures must convert from global to local indices every time a user asks for an element by its global index. This requires a table lookup in general, since a process may own an arbitrary subset of all the global indices, in an arbitrary order. Even though local indices are an implementation detail, we expose them because avoiding that table lookup on each access can improve performance a lot.</p>
<h3><a class="anchor" id="Tpetra_Lesson02_Map_assigns_Maps"></a>
Maps are themselves distributed data</h3>
<p>If a Map has N global entries over P processes, and if no one process owns all the global entries, we <em>never</em> store all N global indices on a single process. Some kinds of Maps require storing all the global indices, but in this case, the indices are themselves distributed over processes. This ensures <em>memory scalability</em> (no one process has to store all the data).</p>
<h2><a class="anchor" id="Tpetra_Lesson02_compat"></a>
Map compatibility</h2>
<p>We mentioned above that a Map behaves much like a vector space. For instance, if two Vectors have the same Map, it is both legal and meaningful to add them together. This makes it useful to be able to compare Maps. <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> gives two ways to compare two Maps. Two Maps <code>map1</code> and <code>map2</code> may either be "compatible" (<code>map1.isCompatible(map2)</code>) or "the same" (<code>map1.isSameAs(map2)</code>).</p>
<p>Compatibility of two Maps corresponds to <a href="https://secure.wikimedia.org/wikipedia/en/wiki/Isomorphism">isomorphism</a> of two vector spaces. Two Maps that are the same are always compatible. The <code>isCompatible()</code> criterion is less restrictive, and also less expensive to check (although checking for compatibility requires a reduction on a Boolean over all processes in the Map's communicator).</p>
<p>Adding together two vectors with compatible but not the same Maps is legal. It might not make mathematical sense, depending on your application. This is because entries of the vectors are ordered differently. (Also, just because two vector spaces are isomorphic, doesn't necessarily mean that adding entries of one to entries of another makes sense.) Adding together two vectors with the same Maps is both legal and mathematically sensible.</p>
<p>Both sameness and compatibility are commutative Boolean relations: for example, <code>map1.isCompatible(map2)</code> means <code>map2.isCompatible(map1)</code>.</p>
<p>Two Maps are <em>compatible</em> when: </p><ul>
<li>
they have the same global number of entries  </li>
<li>
MPI processes in the Map's communicator that have the same MPI rank, own the same number of entries.  </li>
</ul>
<p>Two Maps are <em>the same</em> when: </p><ul>
<li>
their minimum and maximum global indices are the same  </li>
<li>
they have the same global number of entries  </li>
<li>
the Maps are both distributed over multiple processes, or both not distributed over multiple processes  </li>
<li>
the Maps have the same <em>index base</em> (this means the smallest legal global index value, more or less)  </li>
<li>
Processes that have the same rank, own the same number of entries.  </li>
<li>
Processes that have the same rank, own the same entries. That is, their entries have the same indices, in the same order.  </li>
</ul>
<h2><a class="anchor" id="Tpetra_Lesson02_LID_GID_types"></a>
You get to specify the types of local and global indices</h2>
<p>In <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a>, the types of local and global indices are template parameters of Map, Vector, CrsMatrix, and other distributed objects. Local indices have type <code>LocalOrdinal</code>, and global indices have type <code>GlobalOrdinal</code>. Both should be signed built-in C++ integer types. However, you get to pick their size, based on how big your problem is. If your problem has more than 2 billion entries, you will need a 64-bit integer type (such as <code>long long</code> or <code>int64_t</code>) for <code>GlobalOrdinal</code>, but if you have enough processes so that no one process stores more than 2 billion entries locally, then you may use a 32-bit integer type (such as <code>int</code> or <code>int32_t</code>) for <code>LocalOrdinal</code>. The default type of both <code>LocalOrdinal</code> and <code>GlobalOrdinal</code> is <code>int</code>.</p>
<p>You need not specify these types explicitly. If you do not specify them, <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> will pick default values. Furthermore, <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> objects have typedefs, so you can get these types even if you don't know what their default values are. This is the preferred way to find out their default values. The typedef <code>local_ordinal_type</code> tells you the local ordinal type, and the typedef <code>global_ordinal_type</code> tells you the global ordinal type.</p>
<p>It is usually more efficient to use the shortest integer type possible for both local and global indices. "Shortest" means fewest number of bits. Fewer bits mean you use less memory and thus can solve bigger problems or use higher-quality preconditioners that solve problems in fewer iterations. Shorter local indices can also mean better performance for local sparse matrix kernels, such as sparse matrix-vector multiply, sparse triangular solve, and smoothing (for algebraic multigrid).</p>
<p><a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> differs from Epetra in that you, the user, get to decide the types of local and global indices. In Epetra, local and global indices both used to have type <code>int</code>. With the latest Trilinos release, Epetra may use either 32-bit or 64-bit integers for global indices, and always uses 32-bit integers (<code>int</code>) for local indices. <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> lets you decide the types of each.</p>
<h2><a class="anchor" id="Tpetra_Lesson02_Map_categories"></a>
Different categories of Maps</h2>
<h3><a class="anchor" id="Tpetra_Lesson02_Map_categories_one_to_one"></a>
One to one</h3>
<p>A Map is <em>one to one</em> if each global index in the Map is owned by only one process. This means that the function from global index G to its local index and process rank (L,P) is one to one in a mathematical sense ("injective"). In this case, the function is only onto ("surjective") if there is only one process. Knowing whether a Map is one-to-one is important for data redistribution, which <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> exposes as the <a href="http://trilinos.sandia.gov/packages/docs/dev/packages/tpetra/doc/html/classTpetra_1_1Import.html">Import</a> and <a href="http://trilinos.sandia.gov/packages/docs/dev/packages/tpetra/doc/html/classTpetra_1_1Export.html">Export</a> operations. We will cover Import and Export in subsequent lessons.</p>
<p>An example of a one-to-one Map is a Map containing 101 global indices 0 .. 100 and distributed over four processes, where </p><ul>
<li>
Process 0 owns 0 .. 24  </li>
<li>
Process 1 owns 25 .. 49  </li>
<li>
Process 2 owns 50 .. 74  </li>
<li>
Process 3 owns 75 .. 100  </li>
</ul>
<p>An example of a <em>not</em> one-to-one Map is a Map containing 101 global indices 0 .. 100 and distributed over four processes, where </p><ul>
<li>
Process 0 owns 0 .. 25  </li>
<li>
Process 1 owns 25 .. 50  </li>
<li>
Process 2 owns 50 .. 75  </li>
<li>
Process 3 owns 75 .. 100  </li>
</ul>
<p>Note the overlap of one global index between each "adjacent" process. An example of a mathematical problem with an overlapping distribution like this would be a 1-D linear finite element or finite difference discretization, where entries are distributed with unique ownership among the processes, but the boundary node between two adjacent entries on different processes is shared among those two processes.</p>
<h3><a class="anchor" id="Tpetra_Lesson02_Map_categories_contig"></a>
Contiguous or noncontiguous, uniform or not</h3>
<p>A Map is <em>contiguous</em> when each process' list of global indices forms an interval and is strictly increasing, and the globally minimum global index equals the index base. Map optimizes for the contiguous case. In particular, noncontiguous Maps require communication in order to figure out which process owns a particular global index.</p>
<p>Note that in <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a>, "contiguous" is an optimization, not a predicate. <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> may not necessarily work hard to check contiguity. The best way to ensure that your Map is contiguous is to use one of the two constructors that always make a contiguous Map.</p>
<p>An example of a contiguous Map is one containing 101 global indices 0 .. 100 and distributed over four processes, where </p><ul>
<li>
Process 0 owns 0 .. 24  </li>
<li>
Process 1 owns 25 .. 49  </li>
<li>
Process 2 owns 50 .. 74  </li>
<li>
Process 3 owns 75 .. 100  </li>
</ul>
<p>Note that Process 3 in this example owns 26 global indices, whereas the other processes each own 25. We say that a Map is <em>uniform</em> if each process owns the same number of global indices. The above Map is <em>not</em> uniform. Map includes both a constructor for uniform contiguous Maps, where you specify the total number of global indices, and a constructor for possibly nonuniform contiguous Maps, where you specify the number of global indices owned by each process.</p>
<h3><a class="anchor" id="Tpetra_Lesson02_Map_categories_dist_repl"></a>
Globally distributed or locally replicated</h3>
<p><em>Globally distributed</em> means that all of the following are true: </p><ol>
<li>
The Map's communicator has more than one process.  </li>
<li>
There is at least one process in the Map's communicator, whose local number of entries does not equal the number of global entries. (That is, not all the entries are replicated over all the processes.)  </li>
</ol>
<p>If at least one of the above are not true, then we call the Map <em>locally replicated</em>. The two terms are mutually exclusive.</p>
<h3><a class="anchor" id="Tpetra_Lesson02_Map_other_diffs"></a>
Other differences between Tpetra and Epetra</h3>
<p><a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a>'s maps look different than Epetra's maps because of all the template parameters, but they work similiarly. One difference is that <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> maps tend to be handled by Teuchos::RCP (reference-counted smart pointer) rather than copied or passed by const reference. Another difference is that Epetra_Map inherits from Epetra_BlockMap, whereas <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a>'s Map does not inherit from a corresponding block map class. Epetra_Map only has a <code>SameAs()</code> predicate, whereas <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a>'s Map class distinguishes between "compatibility" and "sameness" (see above). Finally, Epetra_Map's <code>SameAs()</code> means about the same thing as <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a>'s <code>isSameAs()</code>.</p>
<h1><a class="anchor" id="Tpetra_Lesson02_Vector"></a>
Tpetra::Vector</h1>
<p><a class="el" href="classTpetra_1_1Vector.html" title="A distributed dense vector.">Tpetra::Vector</a> implements a finite-dimensional vector distributed over processes. Vector inherits from <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a>'s <a href="http://trilinos.sandia.gov/packages/docs/dev/packages/tpetra/doc/html/classTpetra_1_1MultiVector.html">MultiVector</a> class, which represents a collection of one or more vectors with the same Map. <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> favors block algorithms, so it favors MultiVectors over single Vectors. A single Vector is just a MultiVector containing one vector, with a few convenience methods. You'll find documentation for <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a>'s Vector class <a href="http://trilinos.sandia.gov/packages/docs/dev/packages/tpetra/doc/html/classTpetra_1_1Vector.html">here</a>.</p>
<p>Vector's interface contains some common linear algebra operations for vector-vector operations, including operations analogous to those in the BLAS 1 standard.</p>
<h1><a class="anchor" id="Tpetra_Lesson02_template_params"></a>
Tpetra objects' template parameters</h1>
<p>Most <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> objects, including Map and Vector, take several different template parameters. Some of them have default values. For example, Vector has the following template parameters: </p><ul>
<li>
<code>Scalar:</code> The type of data stored in the vector  </li>
<li>
<code>LocalOrdinal:</code> The integer type of local indices  </li>
<li>
<code>GlobalOrdinal:</code> The integer type of global indices  </li>
<li>
<code>Node:</code> The implementation of intranode (within a node) parallelism  </li>
</ul>
<p>Map has the same template parameters, except for <code>Scalar</code> (since the same Map can be used to describe Vectors with different <code>Scalar</code> types).</p>
<h1><a class="anchor" id="Tpetra_Lesson02_example_init"></a>
Code example: Initialize Maps and Vectors</h1>
<p>The following example follows the same initialization steps as in the previous lesson. It then creates two distributed <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> Maps and some <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> Vectors, and does a few computations with the vectors.</p>
<div class="fragment"><div class="line"><span class="comment">// @HEADER</span></div>
<div class="line"><span class="comment">// *****************************************************************************</span></div>
<div class="line"><span class="comment">//          Tpetra: Templated Linear Algebra Services Package</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Copyright 2008 NTESS and the Tpetra contributors.</span></div>
<div class="line"><span class="comment">// SPDX-License-Identifier: BSD-3-Clause</span></div>
<div class="line"><span class="comment">// *****************************************************************************</span></div>
<div class="line"><span class="comment">// @HEADER</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Tpetra__Core_8hpp.html">Tpetra_Core.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Tpetra_Vector.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Tpetra_Version.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Teuchos_Comm.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Teuchos_OrdinalTraits.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> exampleRoutine(<span class="keyword">const</span> Teuchos::RCP&lt;<span class="keyword">const</span> Teuchos::Comm&lt;int&gt; &gt;&amp; comm,</div>
<div class="line">                    std::ostream&amp; out) {</div>
<div class="line">  <span class="keyword">using </span>std::endl;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::Array;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::ArrayView;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::RCP;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::rcp;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> myRank = comm-&gt;getRank();</div>
<div class="line">  <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">    <span class="comment">// Print out the Tpetra software version information.</span></div>
<div class="line">    out &lt;&lt; Tpetra::version() &lt;&lt; endl</div>
<div class="line">        &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// The first thing you might notice that makes Tpetra objects</span></div>
<div class="line">  <span class="comment">// different than their Epetra counterparts, is that Tpetra objects</span></div>
<div class="line">  <span class="comment">// take several template parameters.  These template parameters give</span></div>
<div class="line">  <span class="comment">// Tpetra its features of being able to solve very large problems</span></div>
<div class="line">  <span class="comment">// (of more than 2 billion unknowns) and to exploit intranode</span></div>
<div class="line">  <span class="comment">// parallelism.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Most Tpetra objects come with default values of those template</span></div>
<div class="line">  <span class="comment">// parameters.  In many cases, you might not have to specify _any_</span></div>
<div class="line">  <span class="comment">// of those values explicitly!  You can also control some of their</span></div>
<div class="line">  <span class="comment">// default values, like that of the Node type, when configuring</span></div>
<div class="line">  <span class="comment">// Trilinos.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// It&#39;s common to begin a Tpetra application with some typedefs to</span></div>
<div class="line">  <span class="comment">// make the code more concise and readable.  They also make the code</span></div>
<div class="line">  <span class="comment">// more maintainable, since you can change the typedefs without</span></div>
<div class="line">  <span class="comment">// changing the rest of the program.  You may also want to</span></div>
<div class="line">  <span class="comment">// abbreviate the template parameters.  Standard abbreviations are</span></div>
<div class="line">  <span class="comment">// &quot;LO&quot; for local_ordinal_type and &quot;GO&quot; for global_ordinal_type.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The &quot;Scalar&quot; type is the type of the values stored in the Tpetra</span></div>
<div class="line">  <span class="comment">// objects.  Valid Scalar types include real or complex</span></div>
<div class="line">  <span class="comment">// (std::complex&lt;T&gt;) floating-point types, or more exotic objects</span></div>
<div class="line">  <span class="comment">// with similar behavior.  We use the default type here, which we</span></div>
<div class="line">  <span class="comment">// get from Vector.  &quot;Vector&lt;&gt;&quot; means that we let all template</span></div>
<div class="line">  <span class="comment">// parameters&#39; values revert to their defaults.  The default type is</span></div>
<div class="line">  <span class="comment">// &#39;double&#39;, a 64-bit double-precision binary floating-point value.</span></div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Vector&lt;&gt;::scalar_type</a> scalar_type;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The &quot;LocalOrdinal&quot; (LO) type is the type of &quot;local&quot; indices.</span></div>
<div class="line">  <span class="comment">// Both Epetra and Tpetra index local entries differently than</span></div>
<div class="line">  <span class="comment">// global entries.  Tpetra exploits this so that you can use a</span></div>
<div class="line">  <span class="comment">// shorter integer type for local indices.  This saves bandwidth</span></div>
<div class="line">  <span class="comment">// when computing sparse matrix-vector products.  We use the default</span></div>
<div class="line">  <span class="comment">// LO type here, which we get from Tpetra::Vector.  We could also</span></div>
<div class="line">  <span class="comment">// get it from Tpetra::Map.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// This line is commented out because we don&#39;t actually use this</span></div>
<div class="line">  <span class="comment">// type in the code below.  Leaving the typedef in that case will</span></div>
<div class="line">  <span class="comment">// make the compiler emit &quot;unused typedef&quot; warnings.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// typedef Tpetra::Vector&lt;&gt;::local_ordinal_type local_ordinal_type;</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The &quot;GlobalOrdinal&quot; (GO) type is the type of &quot;global&quot; indices.</span></div>
<div class="line">  <span class="comment">// We use the default GO type here, which we get from</span></div>
<div class="line">  <span class="comment">// Tpetra::Vector.  We could also get it from Tpetra::Map.</span></div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Vector&lt;&gt;::global_ordinal_type</a> global_ordinal_type;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The Kokkos &quot;Node&quot; type describes the type of shared-memory</span></div>
<div class="line">  <span class="comment">// parallelism that Tpetra will use _within_ an MPI process.  The</span></div>
<div class="line">  <span class="comment">// available Node types depend on Trilinos&#39; build options and the</span></div>
<div class="line">  <span class="comment">// availability of certain third-party libraries.  In almost all</span></div>
<div class="line">  <span class="comment">// cases, the default setting will do.  You may set the default Node</span></div>
<div class="line">  <span class="comment">// type when configuring Trilinos.  In this case, we access the</span></div>
<div class="line">  <span class="comment">// default Node type using the typedef in Tpetra::Vector.  Almost</span></div>
<div class="line">  <span class="comment">// all Tpetra classes have default template parameter values.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// This line is commented out because we don&#39;t actually use this</span></div>
<div class="line">  <span class="comment">// type in the code below.  Leaving the typedef in that case will</span></div>
<div class="line">  <span class="comment">// make the compiler emit &quot;unused typedef&quot; warnings.</span></div>
<div class="line">  <span class="comment">// typedef Tpetra::Vector&lt;&gt;::node_type node_type;</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Maps know how to convert between local and global indices, so of</span></div>
<div class="line">  <span class="comment">// course they are templated on the local and global Ordinal types.</span></div>
<div class="line">  <span class="comment">// They are also templated on the Kokkos Node type, because Tpetra</span></div>
<div class="line">  <span class="comment">// objects that use Tpetra::Map are.  It&#39;s important not to mix up</span></div>
<div class="line">  <span class="comment">// Maps for different Kokkos Node types.  In this case, we use all</span></div>
<div class="line">  <span class="comment">// default template parameters, which are the same as the</span></div>
<div class="line">  <span class="comment">// corresponding template parameters of Vector.</span></div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Map&lt;&gt;</a> map_type;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create some Tpetra Map objects</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Like Epetra, Tpetra has local and global Maps.  Local maps</span></div>
<div class="line">  <span class="comment">// describe objects that are replicated over all participating MPI</span></div>
<div class="line">  <span class="comment">// processes.  Global maps describe distributed objects.  You can do</span></div>
<div class="line">  <span class="comment">// imports and exports between local and global maps; this is how</span></div>
<div class="line">  <span class="comment">// you would turn locally replicated objects into distributed</span></div>
<div class="line">  <span class="comment">// objects and vice versa.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// numLocalEntries: The local (on the calling MPI process) number of</span></div>
<div class="line">  <span class="comment">// entries (indices) in the first Map that we create.  Tpetra</span></div>
<div class="line">  <span class="comment">// expects a size_t for this value.</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> numLocalEntries = 5;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// numGlobalEntries: The total (global, i.e., over all MPI</span></div>
<div class="line">  <span class="comment">// processes) number of entries (indices) in the Map.  Tpetra</span></div>
<div class="line">  <span class="comment">// expects Tpetra::global_size_t for this value.  This type is at</span></div>
<div class="line">  <span class="comment">// least 64 bits long on 64-bit machines.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// For this example, we scale the global number of entries in the</span></div>
<div class="line">  <span class="comment">// Map with the number of MPI processes.  That way, you can run this</span></div>
<div class="line">  <span class="comment">// example with any number of MPI processes and every process will</span></div>
<div class="line">  <span class="comment">// still have a positive number of entries.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::global_size_t</a> numGlobalEntries =</div>
<div class="line">      comm-&gt;getSize() * numLocalEntries;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Tpetra can index the entries of a Map starting with 0 (C style),</span></div>
<div class="line">  <span class="comment">// 1 (Fortran style), or any base you want.  1-based indexing is</span></div>
<div class="line">  <span class="comment">// handy when interfacing with Fortran.  We choose 0-based indexing</span></div>
<div class="line">  <span class="comment">// here.</span></div>
<div class="line">  <span class="keyword">const</span> global_ordinal_type indexBase = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Create some Maps.  All Map constructors must be called as a</span></div>
<div class="line">  <span class="comment">// collective over the input communicator.  Not all Map constructors</span></div>
<div class="line">  <span class="comment">// necessarily require communication, but some do, so it&#39;s best to</span></div>
<div class="line">  <span class="comment">// treat them all as collectives.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct a Map that puts the same number of equations on each</span></div>
<div class="line">  <span class="comment">// processor.  The resulting Map is &quot;contiguous and uniform.&quot;</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Maps should be considered immutable objects.  This is why we</span></div>
<div class="line">  <span class="comment">// create it as a &quot;const map_type&quot;.  If you want a new data</span></div>
<div class="line">  <span class="comment">// distribution, create a new Map.</span></div>
<div class="line">  RCP&lt;const map_type&gt; contigMap =</div>
<div class="line">      rcp(<span class="keyword">new</span> map_type(numGlobalEntries, indexBase, comm));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// contigMap is contiguous by construction.  Test this at run time.</span></div>
<div class="line">  <span class="comment">// Lesson 01 introduced the TEUCHOS_TEST_FOR_EXCEPTION macro, which</span></div>
<div class="line">  <span class="comment">// throws an exception of the given type (second argument) with the</span></div>
<div class="line">  <span class="comment">// given message (third argument), if the first argument is true.</span></div>
<div class="line">  TEUCHOS_TEST_FOR_EXCEPTION(</div>
<div class="line">      !contigMap-&gt;isContiguous(), std::logic_error,</div>
<div class="line">      <span class="stringliteral">&quot;The supposedly contiguous Map isn&#39;t contiguous.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// contigMap2: Create a Map which is the same as contigMap, but uses</span></div>
<div class="line">  <span class="comment">// a different Map constructor.  This one asks for the number of</span></div>
<div class="line">  <span class="comment">// entries on each MPI process.  The resulting Map is &quot;contiguous&quot;</span></div>
<div class="line">  <span class="comment">// but not necessarily uniform, since the numbers of entries on</span></div>
<div class="line">  <span class="comment">// different MPI processes may differ.  In this case, the number of</span></div>
<div class="line">  <span class="comment">// entries on each MPI process is the same, but that doesn&#39;t always</span></div>
<div class="line">  <span class="comment">// have to be the case.</span></div>
<div class="line">  RCP&lt;const map_type&gt; contigMap2 =</div>
<div class="line">      rcp(<span class="keyword">new</span> map_type(numGlobalEntries, numLocalEntries, indexBase, comm));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Since contigMap and contigMap2 have the same communicators, and</span></div>
<div class="line">  <span class="comment">// the same number of entries on all MPI processes in their</span></div>
<div class="line">  <span class="comment">// communicators, they are &quot;the same.&quot;</span></div>
<div class="line">  TEUCHOS_TEST_FOR_EXCEPTION(</div>
<div class="line">      !contigMap-&gt;isSameAs(*contigMap2), std::logic_error,</div>
<div class="line">      <span class="stringliteral">&quot;contigMap should be the same as contigMap2, but it&#39;s not.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// contigMap3: Use the same Map constructor as contigMap3, but don&#39;t</span></div>
<div class="line">  <span class="comment">// specify the global number of entries.  This is helpful if you</span></div>
<div class="line">  <span class="comment">// only know how many entries each MPI process has, but don&#39;t know</span></div>
<div class="line">  <span class="comment">// the global number.  Instead of numGlobalEntries, we use the</span></div>
<div class="line">  <span class="comment">// equivalent of Epetra&#39;s -1 for Tpetra::global_size_t (which might</span></div>
<div class="line">  <span class="comment">// be unsigned, so don&#39;t use -1!!!), which we call &quot;INVALID&quot; (an</span></div>
<div class="line">  <span class="comment">// &quot;invalid value&quot; used as a flag).</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::global_size_t</a> INVALID =</div>
<div class="line">      Teuchos::OrdinalTraits&lt;Tpetra::global_size_t&gt;::invalid();</div>
<div class="line">  RCP&lt;const map_type&gt; contigMap3 =</div>
<div class="line">      rcp(<span class="keyword">new</span> map_type(INVALID, numLocalEntries, indexBase, comm));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Even though we made contigMap3 without specifying the global</span></div>
<div class="line">  <span class="comment">// number of entries, it should still be the same as contigMap2.</span></div>
<div class="line">  TEUCHOS_TEST_FOR_EXCEPTION(</div>
<div class="line">      !contigMap2-&gt;isSameAs(*contigMap3), std::logic_error,</div>
<div class="line">      <span class="stringliteral">&quot;contigMap2 should be the same as contigMap3, but it&#39;s not.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a Map which has the same number of global entries per</span></div>
<div class="line">  <span class="comment">// process as contigMap, but distributes them differently, in</span></div>
<div class="line">  <span class="comment">// round-robin (1-D cyclic) fashion instead of contiguously.</span></div>
<div class="line">  RCP&lt;const map_type&gt; cyclicMap;</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// We&#39;ll use the version of the Map constructor that takes, on</span></div>
<div class="line">    <span class="comment">// each MPI process, a list of the global entries in the Map</span></div>
<div class="line">    <span class="comment">// belonging to that process.  You can use this constructor to</span></div>
<div class="line">    <span class="comment">// construct an overlapping (also called &quot;not 1-to-1&quot;) Map, in</span></div>
<div class="line">    <span class="comment">// which one or more entries are owned by multiple processes.  We</span></div>
<div class="line">    <span class="comment">// don&#39;t do that here; we make a nonoverlapping (also called</span></div>
<div class="line">    <span class="comment">// &quot;1-to-1&quot;) Map.</span></div>
<div class="line">    Array&lt;global_ordinal_type&gt;::size_type numEltsPerProc = 5;</div>
<div class="line">    Array&lt;global_ordinal_type&gt; elementList(numEltsPerProc);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> numProcs = comm-&gt;getSize();</div>
<div class="line">    <span class="keywordflow">for</span> (Array&lt;global_ordinal_type&gt;::size_type k = 0; k &lt; numEltsPerProc; ++k) {</div>
<div class="line">      elementList[k] = myRank + k * numProcs;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    cyclicMap = rcp(<span class="keyword">new</span> map_type(numGlobalEntries, elementList, indexBase, comm));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If there&#39;s more than one MPI process in the communicator,</span></div>
<div class="line">  <span class="comment">// then cyclicMap is definitely NOT contiguous.</span></div>
<div class="line">  TEUCHOS_TEST_FOR_EXCEPTION(</div>
<div class="line">      comm-&gt;getSize() &gt; 1 &amp;&amp; cyclicMap-&gt;isContiguous(),</div>
<div class="line">      std::logic_error,</div>
<div class="line">      <span class="stringliteral">&quot;The cyclic Map claims to be contiguous.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// contigMap and cyclicMap should always be compatible.  However, if</span></div>
<div class="line">  <span class="comment">// the communicator contains more than 1 process, then contigMap and</span></div>
<div class="line">  <span class="comment">// cyclicMap are NOT the same.</span></div>
<div class="line">  TEUCHOS_TEST_FOR_EXCEPTION(!contigMap-&gt;isCompatible(*cyclicMap),</div>
<div class="line">                             std::logic_error,</div>
<div class="line">                             <span class="stringliteral">&quot;contigMap should be compatible with cyclicMap, but it&#39;s not.&quot;</span>);</div>
<div class="line">  TEUCHOS_TEST_FOR_EXCEPTION(comm-&gt;getSize() &gt; 1 &amp;&amp; contigMap-&gt;isSameAs(*cyclicMap),</div>
<div class="line">                             std::logic_error,</div>
<div class="line">                             <span class="stringliteral">&quot;contigMap should be compatible with cyclicMap, but it&#39;s not.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// We have maps now, so we can create vectors.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Since Tpetra::Vector takes four template parameters, its type is</span></div>
<div class="line">  <span class="comment">// long.  Here, we use all default values for the template</span></div>
<div class="line">  <span class="comment">// parameters, which helps with the length.  However, I still prefer</span></div>
<div class="line">  <span class="comment">// to use a typedef for encapsulation, so that we only have to</span></div>
<div class="line">  <span class="comment">// change one line of code if we decide to change the template</span></div>
<div class="line">  <span class="comment">// parameters of Vector.</span></div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Vector&lt;&gt;</a> vector_type;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a Vector with the contiguous Map.  This version of the</span></div>
<div class="line">  <span class="comment">// constructor will fill in the vector with zeros.</span></div>
<div class="line">  vector_type x(contigMap);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The two-argument copy constructor with second argument</span></div>
<div class="line">  <span class="comment">// Teuchos::Copy performs a deep copy.  x and y have the same Map.</span></div>
<div class="line">  <span class="comment">// The one-argument copy constructor does a _shallow_ copy.</span></div>
<div class="line">  vector_type y(x, Teuchos::Copy);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a Vector with the 1-D cyclic Map.  Calling the constructor</span></div>
<div class="line">  <span class="comment">// with false for the second argument leaves the data uninitialized,</span></div>
<div class="line">  <span class="comment">// so that you can fill it later without paying the cost of</span></div>
<div class="line">  <span class="comment">// initially filling it with zeros.</span></div>
<div class="line">  vector_type z(cyclicMap, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set the entries of z to (pseudo)random numbers.  Please don&#39;t</span></div>
<div class="line">  <span class="comment">// consider this a good parallel pseudorandom number generator.</span></div>
<div class="line">  z.randomize();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set the entries of x to all ones.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// The code below works because scalar_type=double.  In general, you</span></div>
<div class="line">  <span class="comment">// may use the commented-out line of code, if the conversion from</span></div>
<div class="line">  <span class="comment">// float to scalar_type is not defined for your scalar type.</span></div>
<div class="line">  x.putScalar(1.0);</div>
<div class="line">  <span class="comment">// x.putScalar (Teuchos::ScalarTraits&lt;scalar_type&gt;::one());</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// See comment above about type conversions to scalar_type.</span></div>
<div class="line">  <span class="keyword">const</span> scalar_type alpha = 3.14159;</div>
<div class="line">  <span class="keyword">const</span> scalar_type beta  = 2.71828;</div>
<div class="line">  <span class="keyword">const</span> scalar_type gamma = -10.0;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// x = beta*x + alpha*z</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// This is a legal operation!  Even though the Maps of x and z are</span></div>
<div class="line">  <span class="comment">// not the same, their Maps are compatible.  Whether it makes sense</span></div>
<div class="line">  <span class="comment">// or not depends on your application.</span></div>
<div class="line">  x.update(alpha, z, beta);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// See comment above about type conversions from float to scalar_type.</span></div>
<div class="line">  y.putScalar(42.0);</div>
<div class="line">  <span class="comment">// y = gamma*y + alpha*x + beta*z</span></div>
<div class="line">  y.update(alpha, x, beta, z, gamma);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute the 2-norm of y.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// The norm may have a different type than scalar_type.  For</span></div>
<div class="line">  <span class="comment">// example, if scalar_type is complex, then the norm is real.</span></div>
<div class="line">  <span class="comment">// Tpetra::MultiVector and Tpetra::Vector give us the type of the</span></div>
<div class="line">  <span class="comment">// norm.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// If you are using an older version of Tpetra, this code might not</span></div>
<div class="line">  <span class="comment">// work.  Try the commented-out line instead in that case.</span></div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_typedef" href="classTpetra_1_1Vector.html#a3f08d5b43313bdbcab7705a89c19d35e">Tpetra::Vector&lt;&gt;::mag_type</a> mag_type;</div>
<div class="line">  <span class="comment">// typedef Teuchos::ScalarTraits&lt;scalar_type&gt;::magnitudeType mag_type;</span></div>
<div class="line">  <span class="keyword">const</span> mag_type theNorm = y.norm2();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Print the norm of y on Proc 0.</span></div>
<div class="line">  <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">    out &lt;&lt; <span class="stringliteral">&quot;Norm of y: &quot;</span> &lt;&lt; theNorm &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The same main() driver routine as in the first Tpetra lesson.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div>
<div class="line">  <a class="code hl_class" href="classTpetra_1_1ScopeGuard.html">Tpetra::ScopeGuard</a> tpetraScope(&amp;argc, &amp;argv);</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Never allow Tpetra objects to persist past ScopeGuard&#39;s</span></div>
<div class="line">    <span class="comment">// destructor.</span></div>
<div class="line">    <span class="keyword">auto</span> comm = <a class="code hl_function" href="namespaceTpetra.html#ab0f27babe7678e67ee420a36029ae10a">Tpetra::getDefaultComm</a>();</div>
<div class="line">    exampleRoutine(comm, std::cout);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This tells the Trilinos test framework that the test passed.</span></div>
<div class="line">    <span class="keywordflow">if</span> (comm-&gt;getRank() == 0) {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;End Result: TEST PASSED&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aTpetra__Core_8hpp_html"><div class="ttname"><a href="Tpetra__Core_8hpp.html">Tpetra_Core.hpp</a></div><div class="ttdoc">Functions for initializing and finalizing Tpetra.</div></div>
<div class="ttc" id="aclassTpetra_1_1CrsMatrixStruct_html"><div class="ttname"><a href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::CrsMatrixStruct</a></div><div class="ttdoc">Struct that holds views of the contents of a CrsMatrix.</div><div class="ttdef"><b>Definition</b> <a href="TpetraExt__MMHelpers__decl_8hpp_source.html#l00036">TpetraExt_MMHelpers_decl.hpp:36</a></div></div>
<div class="ttc" id="aclassTpetra_1_1ScopeGuard_html"><div class="ttname"><a href="classTpetra_1_1ScopeGuard.html">Tpetra::ScopeGuard</a></div><div class="ttdoc">Scope guard whose destructor automatically calls Tpetra::finalize for you.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__Core_8hpp_source.html#l00188">Tpetra_Core.hpp:188</a></div></div>
<div class="ttc" id="aclassTpetra_1_1Vector_html_a3f08d5b43313bdbcab7705a89c19d35e"><div class="ttname"><a href="classTpetra_1_1Vector.html#a3f08d5b43313bdbcab7705a89c19d35e">Tpetra::Vector::mag_type</a></div><div class="ttdeci">base_type::mag_type mag_type</div><div class="ttdoc">Type of a norm result.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__Vector__decl_8hpp_source.html#l00088">Tpetra_Vector_decl.hpp:88</a></div></div>
<div class="ttc" id="anamespaceTpetra_html_ab0f27babe7678e67ee420a36029ae10a"><div class="ttname"><a href="namespaceTpetra.html#ab0f27babe7678e67ee420a36029ae10a">Tpetra::getDefaultComm</a></div><div class="ttdeci">Teuchos::RCP&lt; const Teuchos::Comm&lt; int &gt; &gt; getDefaultComm()</div><div class="ttdoc">Get Tpetra's default communicator.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__Core_8cpp_source.html#l00170">Tpetra_Core.cpp:170</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="Tpetra_Lesson02_example_read_modify_vec"></a>
Code example: Read and modify the entries of a Vector</h1>
<p>The following example follows the same initialization steps as in the previous lesson. It then creates a distributed <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> Map and a <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> Vector, and shows how to read and modify the entries of the Vector.</p>
<div class="fragment"><div class="line"><span class="comment">// @HEADER</span></div>
<div class="line"><span class="comment">// *****************************************************************************</span></div>
<div class="line"><span class="comment">//          Tpetra: Templated Linear Algebra Services Package</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Copyright 2008 NTESS and the Tpetra contributors.</span></div>
<div class="line"><span class="comment">// SPDX-License-Identifier: BSD-3-Clause</span></div>
<div class="line"><span class="comment">// *****************************************************************************</span></div>
<div class="line"><span class="comment">// @HEADER</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Tpetra__Core_8hpp.html">Tpetra_Core.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Tpetra_Vector.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Tpetra_Version.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Teuchos_CommHelpers.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> exampleRoutine(<span class="keyword">const</span> Teuchos::RCP&lt;<span class="keyword">const</span> Teuchos::Comm&lt;int&gt; &gt;&amp; comm,</div>
<div class="line">                    std::ostream&amp; out) {</div>
<div class="line">  <span class="keyword">using </span>std::endl;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::Array;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::ArrayRCP;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::ArrayView;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::outArg;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::RCP;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::rcp;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::REDUCE_SUM;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::reduceAll;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> myRank = comm-&gt;getRank();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Print out the Tpetra software version information.</span></div>
<div class="line">  <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">    out &lt;&lt; Tpetra::version() &lt;&lt; endl</div>
<div class="line">        &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Type of the Tpetra::Map specialization to use.</span></div>
<div class="line">  <span class="keyword">using </span>map_type = <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Map&lt;&gt;</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The type of the Tpetra::Vector specialization to use.  The first</span></div>
<div class="line">  <span class="comment">// template parameter is the Scalar type.  The &quot;Scalar&quot; type is the</span></div>
<div class="line">  <span class="comment">// type of the values stored in the Tpetra::Vector.  You could use</span></div>
<div class="line">  <span class="comment">// Tpetra::Vector&lt;&gt;::scalar_type to get the default Scalar type.  We</span></div>
<div class="line">  <span class="comment">// will assume that it&#39;s double.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// using scalar_type = Tpetra::Vector&lt;&gt;::scalar_type;</span></div>
<div class="line">  <span class="keyword">using </span>vector_type = <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Vector&lt;double&gt;</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The &quot;LocalOrdinal&quot; (LO) type is the type of &quot;local&quot; indices.</span></div>
<div class="line">  <span class="comment">// The typedef is commented out to avoid &quot;unused typedef&quot; warnings.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// using local_ordinal_type = vector_type::local_ordinal_type;</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The &quot;GlobalOrdinal&quot; (GO) type is the type of &quot;global&quot; indices.</span></div>
<div class="line">  <span class="keyword">using </span>global_ordinal_type = vector_type::global_ordinal_type;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a Tpetra Map</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The total (global, i.e., over all MPI processes) number of</span></div>
<div class="line">  <span class="comment">// entries in the Map.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// For this example, we scale the global number of entries in the</span></div>
<div class="line">  <span class="comment">// Map with the number of MPI processes.  That way, you can run this</span></div>
<div class="line">  <span class="comment">// example with any number of MPI processes and every process will</span></div>
<div class="line">  <span class="comment">// still have a positive number of entries.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::global_size_t</a> numGlobalEntries = comm-&gt;getSize() * 5;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Index base of the Map.  We choose zero-based (C-style) indexing.</span></div>
<div class="line">  <span class="keyword">const</span> global_ordinal_type indexBase = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct a Map that puts the same number of equations on each</span></div>
<div class="line">  <span class="comment">// MPI process.</span></div>
<div class="line">  RCP&lt;const map_type&gt; contigMap =</div>
<div class="line">      rcp(<span class="keyword">new</span> map_type(numGlobalEntries, indexBase, comm));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a Tpetra Vector</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a Vector with the Map we created above.</span></div>
<div class="line">  <span class="comment">// This version of the constructor will fill in the vector with zeros.</span></div>
<div class="line">  vector_type x(contigMap);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Fill the Vector with a single number, or with random numbers</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set all entries of x to 42.0.</span></div>
<div class="line">  x.putScalar(42.0);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// norm2() is a collective, so we need to call it on all processes</span></div>
<div class="line">  <span class="comment">// in the Vector&#39;s communicator.</span></div>
<div class="line">  <span class="keyword">auto</span> x_norm2 = x.norm2();</div>
<div class="line">  <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">    out &lt;&lt; <span class="stringliteral">&quot;Norm of x (all entries are 42.0): &quot;</span> &lt;&lt; x_norm2 &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set the entries of x to (pseudo)random numbers.  Please don&#39;t</span></div>
<div class="line">  <span class="comment">// consider this a good parallel pseudorandom number generator.</span></div>
<div class="line">  x.randomize();</div>
<div class="line"> </div>
<div class="line">  x_norm2 = x.norm2();</div>
<div class="line">  <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">    out &lt;&lt; <span class="stringliteral">&quot;Norm of x (random numbers): &quot;</span> &lt;&lt; x_norm2 &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Read the entries of the Vector</span></div>
<div class="line"> </div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Get a view of the Vector&#39;s entries.  The view has type</span></div>
<div class="line">    <span class="comment">// Kokkos::View.  Kokkos::View acts like an array, but is</span></div>
<div class="line">    <span class="comment">// reference-counted like std::shared_ptr or Teuchos::RCP.  This</span></div>
<div class="line">    <span class="comment">// means that it may persist beyond the lifetime of the Vector.  A</span></div>
<div class="line">    <span class="comment">// View is like a shallow copy of the data, so be careful</span></div>
<div class="line">    <span class="comment">// modifying the Vector while a view of it exists.  You may</span></div>
<div class="line">    <span class="comment">// decrement the reference count manually by assigning an empty</span></div>
<div class="line">    <span class="comment">// View to it.  We put this code in an inner scope (in an extra</span></div>
<div class="line">    <span class="comment">// pair of {}) so that the Kokkos::View will fall out of scope</span></div>
<div class="line">    <span class="comment">// before the next example, which modifies the entries of the</span></div>
<div class="line">    <span class="comment">// Vector.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We want a _host_ View.  Vector implements &quot;dual view&quot;</span></div>
<div class="line">    <span class="comment">// semantics.  This is really only relevant for architectures with</span></div>
<div class="line">    <span class="comment">// two memory spaces.</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> x_2d = x.getLocalViewHost(Tpetra::Access::ReadOnly);</div>
<div class="line">    <span class="comment">// getLocalView returns a 2-D View by default.  We want a 1-D</span></div>
<div class="line">    <span class="comment">// View, so we take a subview.</span></div>
<div class="line">    <span class="keyword">auto</span> x_1d = Kokkos::subview(x_2d, Kokkos::ALL(), 0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// x_data.extent (0) may be longer than the number of local</span></div>
<div class="line">    <span class="comment">// rows in the Vector, so be sure to ask the Vector for its</span></div>
<div class="line">    <span class="comment">// dimensions, rather than the ArrayRCP.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> localLength = x.getLocalLength();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Count the local number of entries less than 0.5.</span></div>
<div class="line">    <span class="comment">// Use local indices to access the entries of x_data.</span></div>
<div class="line">    <span class="keywordtype">size_t</span> localCount = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k = 0; k &lt; localLength; ++k) {</div>
<div class="line">      <span class="keywordflow">if</span> (x_1d(k) &lt; 0.5) {</div>
<div class="line">        ++localCount;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// &quot;reduceAll&quot; is a type-safe templated version of MPI_Allreduce.</span></div>
<div class="line">    <span class="comment">// &quot;outArg&quot; is like taking the address using &amp;, but makes it more</span></div>
<div class="line">    <span class="comment">// clear that its argument is an output argument of a function.</span></div>
<div class="line">    <span class="keywordtype">size_t</span> globalCount = 0;</div>
<div class="line">    reduceAll&lt;int, size_t&gt;(*comm, REDUCE_SUM, localCount,</div>
<div class="line">                           outArg(globalCount));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Find the total number of entries less than 0.5, over all</span></div>
<div class="line">    <span class="comment">// processes in the Vector&#39;s communicator.  Note the trick for</span></div>
<div class="line">    <span class="comment">// pluralizing the word &quot;entry&quot; conditionally on globalCount.</span></div>
<div class="line">    <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">      out &lt;&lt; <span class="stringliteral">&quot;x has &quot;</span> &lt;&lt; globalCount &lt;&lt; <span class="stringliteral">&quot; entr&quot;</span></div>
<div class="line">          &lt;&lt; (globalCount != 1 ? <span class="stringliteral">&quot;ies&quot;</span> : <span class="stringliteral">&quot;y&quot;</span>)</div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot; less than 0.5.&quot;</span> &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Modify the entries of the Vector</span></div>
<div class="line"> </div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Get a nonconst persisting view of the entries in the Vector.</span></div>
<div class="line">    <span class="comment">// &quot;Nonconst&quot; means that you may modify the entries.  &quot;Persisting&quot;</span></div>
<div class="line">    <span class="comment">// means that the view persists beyond the lifetime of the Vector.</span></div>
<div class="line">    <span class="comment">// Even after the Vector&#39;s destructor is called, the view won&#39;t go</span></div>
<div class="line">    <span class="comment">// away.  If you create two nonconst persisting views of the same</span></div>
<div class="line">    <span class="comment">// Vector, and modify the entries of one view during the lifetime</span></div>
<div class="line">    <span class="comment">// of the other view, the entries of the other view are undefined.</span></div>
<div class="line">    <span class="keyword">auto</span> x_2d = x.getLocalViewHost(Tpetra::Access::ReadWrite);</div>
<div class="line">    <span class="keyword">auto</span> x_1d = Kokkos::subview(x_2d, Kokkos::ALL(), 0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Use local indices to access the entries of x_data.</span></div>
<div class="line">    <span class="comment">// x_data.extent (0) may be longer than the number of local</span></div>
<div class="line">    <span class="comment">// rows in the Vector, so be sure to ask the Vector for its</span></div>
<div class="line">    <span class="comment">// dimensions.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> localLength = x.getLocalLength();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k = 0; k &lt; localLength; ++k) {</div>
<div class="line">      <span class="comment">// Add k (the local index) to every entry of x.  Treat &#39;double&#39;</span></div>
<div class="line">      <span class="comment">// as a function to convert k (an integer) to double.</span></div>
<div class="line">      x_1d(k) += double(k);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Print the norm of x.</span></div>
<div class="line">  x_norm2 = x.norm2();</div>
<div class="line">  <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">    out &lt;&lt; <span class="stringliteral">&quot;Norm of x (modified random numbers): &quot;</span> &lt;&lt; x_norm2 &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The same main() driver routine as in the first Tpetra lesson.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div>
<div class="line">  <a class="code hl_class" href="classTpetra_1_1ScopeGuard.html">Tpetra::ScopeGuard</a> tpetraScope(&amp;argc, &amp;argv);</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">auto</span> comm = <a class="code hl_function" href="namespaceTpetra.html#ab0f27babe7678e67ee420a36029ae10a">Tpetra::getDefaultComm</a>();</div>
<div class="line">    exampleRoutine(comm, std::cout);</div>
<div class="line">    <span class="comment">// Tell the Trilinos test framework that the test passed.</span></div>
<div class="line">    <span class="keywordflow">if</span> (comm-&gt;getRank() == 0) {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;End Result: TEST PASSED&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="Tpetra_Lesson02_Other"></a>
Things not previously explained</h1>
<p>This lesson introduces three new topics: the <code>Node</code> template parameter of <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> objects, the Teuchos::ScalarTraits scalar traits class, and Teuchos memory management classes like Teuchos::Array. We will explain them here.</p>
<h2><a class="anchor" id="Tpetra_Lesson02_Other_Node"></a>
Tpetra's Node template parameter</h2>
<p>The Node template parameter governs the way the <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> objects do parallelism within a node ("intranode," as opposed to MPI's internode parallelism). We have implemented several different Node types. All you need to know for now is that it is part of the type of the object. You can't assign a matrix with one Node type to a matrix with a different Node type; they are incompatible. Usually, you will use one Node type and Node instance for all the <a class="el" href="namespaceTpetra.html" title="Namespace Tpetra contains the class and methods constituting the Tpetra library.">Tpetra</a> objects that you create.</p>
<h2><a class="anchor" id="Tpetra_Lesson02_Other_STS"></a>
The Teuchos::ScalarTraits scalar traits class</h2>
<p>A <em>traits class</em> maps from a C++ type to attributes of that type. It is a standard C++ idiom for generic programming. The C++ Standard Library comes with a few different traits classes, such as std::numeric_traits. Teuchos::ScalarTraits is like std::numeric_traits, but offers more features. For a given scalar type <code>S</code>, <code>Teuchos::ScalarTraits&lt;S&gt;</code> can tell you the type of the magnitude of <code>S</code> (which is real if <code>S</code> is complex), how to compute the magnitude or extract the real or imaginary components, the definition of zero or one for <code>S</code>, and other useful information. Users may also define new <em>specializations</em> (definitions for new "input types") of Teuchos::ScalarTraits.</p>
<h2><a class="anchor" id="Tpetra_Lesson02_Other_Array"></a>
Teuchos memory management classes</h2>
<p>Teuchos::Array is an array container, templated on the type of objects that it contains. It behaves much like std::vector. The difference is that Array interoperates with the other Teuchos memory management classes. For example, Teuchos::ArrayView is a nonowning, nonpersistent view of part or all of an Array. The std::vector class does not have nonowning views; passing std::vector by value copies the data, and there is no way to get a view of part of the std::vector. Array and ArrayView fix these deficiencies. Teuchos::ArrayRCP is the array analog of !RCP; it allows shared ownership of an array. For more details, please refer to the reference guide to the <a href="http://www.cs.sandia.gov/~rabartl/TeuchosMemoryManagementSAND.pdf">Teuchos Memory Management Classes</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 9 2025 21:01:02 for Tpetra parallel linear algebra by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
