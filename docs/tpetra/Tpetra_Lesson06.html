<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tpetra parallel linear algebra: Tpetra Lesson 06: Custom Operator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tpetra parallel linear algebra<span id="projectnumber">&#160;Version of the Day</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Tpetra Lesson 06: Custom Operator</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Writing a custom subclass of <a class="el" href="classTpetra_1_1Operator.html" title="Abstract interface for operators (e.g., matrices and preconditioners).">Tpetra::Operator</a>.</p>
<h1><a class="anchor" id="Tpetra_Lesson06_Topics"></a>
Lesson topics</h1>
<p>This lesson shows an example of a custom subclass of <a class="el" href="classTpetra_1_1Operator.html" title="Abstract interface for operators (e.g., matrices and preconditioners).">Tpetra::Operator</a>. <a class="el" href="classTpetra_1_1Operator.html" title="Abstract interface for operators (e.g., matrices and preconditioners).">Tpetra::Operator</a> generalizes the idea of a sparse matrix-vector product. While <a class="el" href="classTpetra_1_1CrsMatrix.html" title="Sparse matrix that presents a row-oriented interface that lets users read or modify entries.">Tpetra::CrsMatrix</a> always represents a sparse matrix, a <a class="el" href="classTpetra_1_1Operator.html" title="Abstract interface for operators (e.g., matrices and preconditioners).">Tpetra::Operator</a> is just a function from an input <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">Tpetra::MultiVector</a> to an output <a class="el" href="classTpetra_1_1MultiVector.html" title="One or more distributed dense vectors.">Tpetra::MultiVector</a>.</p>
<p>This example implements a <a class="el" href="classTpetra_1_1Operator.html" title="Abstract interface for operators (e.g., matrices and preconditioners).">Tpetra::Operator</a> subclass that applies a 1-D Laplacian with Dirichlet boundary conditions. It accepts a communicator and a global number of mesh points.</p>
<h1><a class="anchor" id="Tpetra_Lesson06_Example"></a>
Code example</h1>
<p>This example shows how to implement a custom <a class="el" href="classTpetra_1_1Operator.html" title="Abstract interface for operators (e.g., matrices and preconditioners).">Tpetra::Operator</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// @HEADER</span></div>
<div class="line"><span class="comment">// *****************************************************************************</span></div>
<div class="line"><span class="comment">//          Tpetra: Templated Linear Algebra Services Package</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Copyright 2008 NTESS and the Tpetra contributors.</span></div>
<div class="line"><span class="comment">// SPDX-License-Identifier: BSD-3-Clause</span></div>
<div class="line"><span class="comment">// *****************************************************************************</span></div>
<div class="line"><span class="comment">// @HEADER</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Tpetra__Core_8hpp.html">Tpetra_Core.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Tpetra_MultiVector.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Tpetra_Operator.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Tpetra_Vector.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Teuchos_TimeMonitor.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span>  <span class="comment">// EXIT_SUCCESS, EXIT_FAILURE</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define a class for our user-defined operator.</span></div>
<div class="line"><span class="comment">// In this case, it is the tridiagonal matrix [-1,2,-1].</span></div>
<div class="line"><span class="comment">// You may define it to be whatever you like.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// In general, Trilinos does NOT require the user to deal with MPI</span></div>
<div class="line"><span class="comment">// communication explicitly.  If you want to define your own operator</span></div>
<div class="line"><span class="comment">// though, there&#39;s no getting around it.  Fortunately, Trilinos makes</span></div>
<div class="line"><span class="comment">// this relatively straightforward with the use of Map and Import</span></div>
<div class="line"><span class="comment">// objects.  All you have to do is define your initial data</span></div>
<div class="line"><span class="comment">// distribution (which is a block row distribution here), and the data</span></div>
<div class="line"><span class="comment">// distribution you need to perform the operations of your</span></div>
<div class="line"><span class="comment">// matrix-vector multiply.  For instance, when performing a</span></div>
<div class="line"><span class="comment">// matrix-vector multiply with a tridiagonal matrix (with a block row</span></div>
<div class="line"><span class="comment">// distribution), each process needs to know the last element owned by</span></div>
<div class="line"><span class="comment">// the previous process and the first element owned by the next</span></div>
<div class="line"><span class="comment">// process.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// If you are only interested in running the code sequentially, you</span></div>
<div class="line"><span class="comment">// may safely ignore everything here regarding Map and Import objects.</span></div>
<div class="line"><span class="keyword">class </span>MyOp : <span class="keyword">public</span> <a class="code hl_class" href="classTpetra_1_1Operator.html">Tpetra::Operator</a>&lt;&gt; {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// Tpetra::Operator subclasses should always define these four typedefs.</span></div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Operator&lt;&gt;::scalar_type</a> <a class="code hl_typedef" href="classTpetra_1_1Operator.html#a4da474a9ef4e2525f16ab222f5668821">scalar_type</a>;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Operator&lt;&gt;::local_ordinal_type</a> <a class="code hl_typedef" href="classTpetra_1_1Operator.html#a741af9161d2a7457b8ec9110d9af7547">local_ordinal_type</a>;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Operator&lt;&gt;::global_ordinal_type</a> <a class="code hl_typedef" href="classTpetra_1_1Operator.html#af3854c49c80eb2bfe7e22186219fd6f0">global_ordinal_type</a>;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_typedef" href="classTpetra_1_1Operator.html#a8f12bf2928798b92dbb570a57fbb47f9">Tpetra::Operator&lt;&gt;::node_type</a> <a class="code hl_typedef" href="classTpetra_1_1Operator.html#a8f12bf2928798b92dbb570a57fbb47f9">node_type</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The type of the input and output arguments of apply().</span></div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a>&lt;<a class="code hl_typedef" href="classTpetra_1_1Operator.html#a4da474a9ef4e2525f16ab222f5668821">scalar_type</a>, <a class="code hl_typedef" href="classTpetra_1_1Operator.html#a741af9161d2a7457b8ec9110d9af7547">local_ordinal_type</a>,</div>
<div class="line">                              <a class="code hl_typedef" href="classTpetra_1_1Operator.html#af3854c49c80eb2bfe7e22186219fd6f0">global_ordinal_type</a>, node_type&gt;</div>
<div class="line">      MV;</div>
<div class="line">  <span class="comment">// The Map specialization used by this class.</span></div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::Map&lt;local_ordinal_type, global_ordinal_type, node_type&gt;</a> map_type;</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  <span class="comment">// This is an implementation detail; users don&#39;t need to see it.</span></div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1Import.html">Tpetra::Import</a>&lt;<a class="code hl_typedef" href="classTpetra_1_1Operator.html#a741af9161d2a7457b8ec9110d9af7547">local_ordinal_type</a>, <a class="code hl_typedef" href="classTpetra_1_1Operator.html#af3854c49c80eb2bfe7e22186219fd6f0">global_ordinal_type</a>,</div>
<div class="line">                         node_type&gt;</div>
<div class="line">      import_type;</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// Constructor</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// n: Global number of rows and columns in the operator.</span></div>
<div class="line">  <span class="comment">// comm: The communicator over which to distribute those rows and columns.</span></div>
<div class="line">  MyOp(<span class="keyword">const</span> global_ordinal_type n,</div>
<div class="line">       <span class="keyword">const</span> Teuchos::RCP&lt;<span class="keyword">const</span> Teuchos::Comm&lt;int&gt; &gt; comm) {</div>
<div class="line">    <span class="keyword">using </span>std::cout;</div>
<div class="line">    <span class="keyword">using </span>std::endl;</div>
<div class="line">    <span class="keyword">using </span>Teuchos::RCP;</div>
<div class="line">    <span class="keyword">using </span>Teuchos::rcp;</div>
<div class="line"> </div>
<div class="line">    TEUCHOS_TEST_FOR_EXCEPTION(</div>
<div class="line">        comm.is_null(), std::invalid_argument,</div>
<div class="line">        <span class="stringliteral">&quot;MyOp constructor: The input Comm object must be nonnull.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Get the rank of this process and the number of processes</span></div>
<div class="line">    <span class="comment">// We&#39;re going to have to do something special with the first and last processes</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> myRank   = comm-&gt;getRank();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> numProcs = comm-&gt;getSize();</div>
<div class="line">    <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;MyOp constructor&quot;</span> &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Construct a map for our block row distribution</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keyword">const</span> global_ordinal_type indexBase = 0;</div>
<div class="line">    opMap_                              = rcp(<span class="keyword">new</span> map_type(n, indexBase, comm));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Get the local number of rows</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    local_ordinal_type nlocal = opMap_-&gt;getLocalNumElements();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Define the distribution that you need for the matvec.  When you</span></div>
<div class="line">    <span class="comment">// define this for your own operator, it is helpful to draw</span></div>
<div class="line">    <span class="comment">// pictures on a sheet of paper to keep track of who needs to</span></div>
<div class="line">    <span class="comment">// receive which entries of the source vector.  Here, each process</span></div>
<div class="line">    <span class="comment">// needs to receive one entry from each of its neighbors.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// All processes but the first will receive one element from the</span></div>
<div class="line">    <span class="comment">// previous process.</span></div>
<div class="line">    <span class="keywordflow">if</span> (myRank &gt; 0) {</div>
<div class="line">      ++nlocal;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// All processes but the last will receive one element from the</span></div>
<div class="line">    <span class="comment">// next process.</span></div>
<div class="line">    <span class="keywordflow">if</span> (myRank &lt; numProcs - 1) {</div>
<div class="line">      ++nlocal;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Construct a list of columns where this process has nonzero</span></div>
<div class="line">    <span class="comment">// elements.  For our tridiagonal matrix, this is</span></div>
<div class="line">    <span class="comment">// firstRowItOwns-1:lastRowItOwns+1.</span></div>
<div class="line">    std::vector&lt;global_ordinal_type&gt; indices;</div>
<div class="line">    indices.reserve(nlocal);</div>
<div class="line">    <span class="comment">// The first process is a special case...</span></div>
<div class="line">    <span class="keywordflow">if</span> (myRank &gt; 0) {</div>
<div class="line">      indices.push_back(opMap_-&gt;getMinGlobalIndex() - 1);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">for</span> (global_ordinal_type i = opMap_-&gt;getMinGlobalIndex();</div>
<div class="line">         i &lt;= opMap_-&gt;getMaxGlobalIndex(); ++i) {</div>
<div class="line">      indices.push_back(i);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// So is the last process...</span></div>
<div class="line">    <span class="keywordflow">if</span> (myRank &lt; numProcs - 1) {</div>
<div class="line">      indices.push_back(opMap_-&gt;getMaxGlobalIndex() + 1);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Wrap our vector in an array view, which is like a pointer</span></div>
<div class="line">    Teuchos::ArrayView&lt;const global_ordinal_type&gt; elementList(indices);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Make a column Map for handling the redistribution.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// There will be some redundancies (i.e., some of the entries will</span></div>
<div class="line">    <span class="comment">// be owned by multiple processes).  Those redundancies will help</span></div>
<div class="line">    <span class="comment">// express the communication pattern for the sparse mat-vec.</span></div>
<div class="line">    <span class="keyword">const</span> global_ordinal_type numGlobalElements = n + 2 * (numProcs - 1);</div>
<div class="line">    redistMap_                                  = rcp(<span class="keyword">new</span> map_type(numGlobalElements, elementList, indexBase, comm));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Make an Import object that describes how data will be</span></div>
<div class="line">    <span class="comment">// redistributed.  It takes a Map describing who owns what</span></div>
<div class="line">    <span class="comment">// originally, and a Map that describes who you WANT to own what.</span></div>
<div class="line">    importer_ = rcp(<span class="keyword">new</span> import_type(opMap_, redistMap_));</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// These functions are required since we inherit from Tpetra::Operator</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Destructor</span></div>
<div class="line">  <span class="keyword">virtual</span> ~MyOp() {}</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get the domain Map of this Operator subclass.</span></div>
<div class="line">  Teuchos::RCP&lt;const map_type&gt; <a class="code hl_function" href="classTpetra_1_1Operator.html#a81a0f2636e24ebe69bdcaf8cafd786be">getDomainMap</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> opMap_; }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get the range Map of this Operator subclass.</span></div>
<div class="line">  Teuchos::RCP&lt;const map_type&gt; <a class="code hl_function" href="classTpetra_1_1Operator.html#a15e31f088868daf38fddf2aa5148be73">getRangeMap</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> opMap_; }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute Y := alpha Op X + beta Y.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// We ignore the cases alpha != 1 and beta != 0 for simplicity.</span></div>
<div class="line">  <span class="keywordtype">void</span></div>
<div class="line">  <a class="code hl_function" href="classTpetra_1_1Operator.html#a900b02363414fa0decad11d466c320ce">apply</a>(<span class="keyword">const</span> MV&amp; X,</div>
<div class="line">        MV&amp; Y,</div>
<div class="line">        Teuchos::ETransp mode = Teuchos::NO_TRANS,</div>
<div class="line">        scalar_type alpha     = Teuchos::ScalarTraits&lt;scalar_type&gt;::one(),</div>
<div class="line">        scalar_type beta      = Teuchos::ScalarTraits&lt;scalar_type&gt;::zero())<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keyword">using </span>std::cout;</div>
<div class="line">    <span class="keyword">using </span>std::endl;</div>
<div class="line">    <span class="keyword">using </span>Teuchos::RCP;</div>
<div class="line">    <span class="keyword">using </span>Teuchos::rcp;</div>
<div class="line">    <span class="keyword">typedef</span> Teuchos::ScalarTraits&lt;scalar_type&gt; STS;</div>
<div class="line"> </div>
<div class="line">    RCP&lt;const Teuchos::Comm&lt;int&gt; &gt; comm = opMap_-&gt;getComm();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> myRank                    = comm-&gt;getRank();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> numProcs                  = comm-&gt;getSize();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;MyOp::apply&quot;</span> &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We&#39;re writing the Operator subclass, so we are responsible for</span></div>
<div class="line">    <span class="comment">// error handling.  You can decide how much error checking you</span></div>
<div class="line">    <span class="comment">// want to do.  Just remember that checking things like Map</span></div>
<div class="line">    <span class="comment">// sameness or compatibility are expensive.</span></div>
<div class="line">    TEUCHOS_TEST_FOR_EXCEPTION(</div>
<div class="line">        X.getNumVectors() != Y.getNumVectors(), std::invalid_argument,</div>
<div class="line">        <span class="stringliteral">&quot;X and Y do not have the same numbers of vectors (columns).&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Let&#39;s make sure alpha is 1 and beta is 0...</span></div>
<div class="line">    <span class="comment">// This will throw an exception if that is not the case.</span></div>
<div class="line">    TEUCHOS_TEST_FOR_EXCEPTION(</div>
<div class="line">        alpha != STS::one() || beta != STS::zero(), std::logic_error,</div>
<div class="line">        <span class="stringliteral">&quot;MyOp::apply was given alpha != 1 or beta != 0. &quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;These cases are not implemented.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Get the number of vectors (columns) in X (and Y).</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> numVecs = X.getNumVectors();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Make a temporary multivector for holding the redistributed</span></div>
<div class="line">    <span class="comment">// data.  You could also create this in the constructor and reuse</span></div>
<div class="line">    <span class="comment">// it across different apply() calls, but you would need to be</span></div>
<div class="line">    <span class="comment">// careful to reallocate if it has a different number of vectors</span></div>
<div class="line">    <span class="comment">// than X.  The number of vectors in X can vary across different</span></div>
<div class="line">    <span class="comment">// apply() calls.</span></div>
<div class="line">    RCP&lt;MV&gt; redistData = rcp(<span class="keyword">new</span> MV(redistMap_, numVecs));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Redistribute the data.</span></div>
<div class="line">    <span class="comment">// This will do all the necessary communication for you.</span></div>
<div class="line">    <span class="comment">// All processes now own enough data to do the matvec.</span></div>
<div class="line">    redistData-&gt;doImport(X, *importer_, <a class="code hl_enumvalue" href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094ba8311a4172e79c1f3a25a4ffc2e637b28">Tpetra::INSERT</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Get the number of local rows in X, on the calling process.</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceTpetra_1_1Details_1_1DefaultTypes.html#a30dcc98a8290a6dcb0216e0f54c68d57">local_ordinal_type</a> nlocRows =</div>
<div class="line">        <span class="keyword">static_cast&lt;</span><a class="code hl_typedef" href="namespaceTpetra_1_1Details_1_1DefaultTypes.html#a30dcc98a8290a6dcb0216e0f54c68d57">local_ordinal_type</a><span class="keyword">&gt;</span>(X.getLocalLength());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Perform the matvec with the data we now locally own.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// For each column...</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> c = 0; c &lt; numVecs; ++c) {</div>
<div class="line">      <span class="comment">// Get a view of the desired column</span></div>
<div class="line">      Teuchos::ArrayRCP&lt;scalar_type&gt; colView = redistData-&gt;getDataNonConst(c);</div>
<div class="line"> </div>
<div class="line">      <a class="code hl_typedef" href="namespaceTpetra_1_1Details_1_1DefaultTypes.html#a30dcc98a8290a6dcb0216e0f54c68d57">local_ordinal_type</a> offset;</div>
<div class="line">      <span class="comment">// Y[0,c] = -colView[0] + 2*colView[1] - colView[2] (using local indices)</span></div>
<div class="line">      <span class="keywordflow">if</span> (myRank &gt; 0) {</div>
<div class="line">        Y.replaceLocalValue(0, c, -colView[0] + 2 * colView[1] - colView[2]);</div>
<div class="line">        offset = 0;</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// Y[0,c] = 2*colView[1] - colView[2] (using local indices)</span></div>
<div class="line">      <span class="keywordflow">else</span> {</div>
<div class="line">        Y.replaceLocalValue(0, c, 2 * colView[0] - colView[1]);</div>
<div class="line">        offset = 1;</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Y[r,c] = -colView[r-offset] + 2*colView[r+1-offset] - colView[r+2-offset]</span></div>
<div class="line">      <span class="keywordflow">for</span> (local_ordinal_type r = 1; r &lt; nlocRows - 1; ++r) {</div>
<div class="line">        <span class="keyword">const</span> scalar_type newVal =</div>
<div class="line">            -colView[r - offset] + 2 * colView[r + 1 - offset] - colView[r + 2 - offset];</div>
<div class="line">        Y.replaceLocalValue(r, c, newVal);</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// Y[nlocRows-1,c] = -colView[nlocRows-1-offset] + 2*colView[nlocRows-offset]</span></div>
<div class="line">      <span class="comment">//                   - colView[nlocRows+1-offset]</span></div>
<div class="line">      <span class="keywordflow">if</span> (myRank &lt; numProcs - 1) {</div>
<div class="line">        <span class="keyword">const</span> scalar_type newVal =</div>
<div class="line">            -colView[nlocRows - 1 - offset] + 2 * colView[nlocRows - offset] - colView[nlocRows + 1 - offset];</div>
<div class="line">        Y.replaceLocalValue(nlocRows - 1, c, newVal);</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// Y[nlocRows-1,c] = -colView[nlocRows-1-offset] + 2*colView[nlocRows-offset]</span></div>
<div class="line">      <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keyword">const</span> scalar_type newVal =</div>
<div class="line">            -colView[nlocRows - 1 - offset] + 2 * colView[nlocRows - offset];</div>
<div class="line">        Y.replaceLocalValue(nlocRows - 1, c, newVal);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  Teuchos::RCP&lt;const map_type&gt; opMap_, redistMap_;</div>
<div class="line">  Teuchos::RCP&lt;const import_type&gt; importer_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div>
<div class="line">  <span class="keyword">using </span>std::cout;</div>
<div class="line">  <span class="keyword">using </span>std::endl;</div>
<div class="line">  <span class="keyword">using </span>Teuchos::RCP;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classTpetra_1_1ScopeGuard.html">Tpetra::ScopeGuard</a> tpetraScope(&amp;argc, &amp;argv);</div>
<div class="line">  <span class="keywordtype">bool</span> success = <span class="keyword">true</span>;</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">auto</span> comm        = <a class="code hl_function" href="namespaceTpetra.html#ab0f27babe7678e67ee420a36029ae10a">Tpetra::getDefaultComm</a>();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> myRank = comm-&gt;getRank();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Get parameters from command-line processor</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    MyOp::global_ordinal_type n = 100;</div>
<div class="line">    Teuchos::CommandLineProcessor cmdp(<span class="keyword">false</span>, <span class="keyword">true</span>);</div>
<div class="line">    cmdp.setOption(<span class="stringliteral">&quot;n&quot;</span>, &amp;n, <span class="stringliteral">&quot;Number of rows of our operator.&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (cmdp.parse(argc, argv) !=</div>
<div class="line">        Teuchos::CommandLineProcessor::PARSE_SUCCESSFUL) {</div>
<div class="line">      <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Construct the operator.  Note that the operator does not have</span></div>
<div class="line">    <span class="comment">// to be an explicitly stored matrix.  Here, we are using our</span></div>
<div class="line">    <span class="comment">// user-defined operator.</span></div>
<div class="line">    MyOp K(n, comm);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Construct a Vector of all ones, using the above Operator&#39;s</span></div>
<div class="line">    <span class="comment">// domain Map.</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code hl_class" href="classTpetra_1_1Vector.html">Tpetra::Vector</a>&lt;MyOp::scalar_type,</div>
<div class="line">                           MyOp::local_ordinal_type,</div>
<div class="line">                           MyOp::global_ordinal_type,</div>
<div class="line">                           MyOp::node_type&gt;</div>
<div class="line">        vec_type;</div>
<div class="line">    vec_type x(K.getDomainMap());</div>
<div class="line">    x.putScalar(1.0);</div>
<div class="line">    <span class="comment">// Construct an output Vector for K*x.</span></div>
<div class="line">    vec_type y(K.getRangeMap());</div>
<div class="line">    K.apply(x, y);  <span class="comment">// Compute y := K*x.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The operator has a stencil (-1, 2, -1), except for the</span></div>
<div class="line">    <span class="comment">// boundaries.  At the left boundary (global row 0), the stencil is</span></div>
<div class="line">    <span class="comment">// (2, -1), and at the right boundary (global row n-1), the stencil</span></div>
<div class="line">    <span class="comment">// is (-1, 2).  Thus, we know that if all entries of the input</span></div>
<div class="line">    <span class="comment">// Vector are 1, then all entries of the output Vector are 0, except</span></div>
<div class="line">    <span class="comment">// for the boundary entries, which are both 1.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// To test this, construct the expected output vector y_expected,</span></div>
<div class="line">    <span class="comment">// and compare y to y_expected using the max norm.  Even in single</span></div>
<div class="line">    <span class="comment">// precision, the max norm of y - y_expected should be exactly zero.</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>map_type               = MyOp::map_type;</div>
<div class="line">    RCP&lt;const map_type&gt; rangeMap = K.getRangeMap();</div>
<div class="line"> </div>
<div class="line">    vec_type y_expected(rangeMap);</div>
<div class="line">    y_expected.putScalar(0.0);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (rangeMap-&gt;isNodeGlobalElement(0)) {</div>
<div class="line">      y_expected.replaceGlobalValue(0, 1.0);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (rangeMap-&gt;isNodeGlobalElement(n - 1)) {</div>
<div class="line">      y_expected.replaceGlobalValue(n - 1, 1.0);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    y_expected.update(1.0, y, -1.0);      <span class="comment">// y_expected := y - y_expected</span></div>
<div class="line">    <span class="keyword">typedef</span> vec_type::mag_type mag_type;  <span class="comment">// type of a norm of vec_type</span></div>
<div class="line">    <span class="keyword">const</span> mag_type diffMaxNorm = y_expected.normInf();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">      <span class="keywordflow">if</span> (diffMaxNorm == 0.0) {</div>
<div class="line">        <span class="comment">// This tells the Trilinos test framework that the test passed.</span></div>
<div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Yay!  ||y - y_expected||_inf = 0.&quot;</span> &lt;&lt; endl</div>
<div class="line">             &lt;&lt; <span class="stringliteral">&quot;End Result: TEST PASSED&quot;</span> &lt;&lt; endl;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        success = <span class="keyword">false</span>;</div>
<div class="line">        <span class="comment">// This tells the Trilinos test framework that the test passed.</span></div>
<div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Oops!  ||y - y_expected||_inf = &quot;</span> &lt;&lt; diffMaxNorm</div>
<div class="line">             &lt;&lt; <span class="stringliteral">&quot; != 0.&quot;</span> &lt;&lt; endl</div>
<div class="line">             &lt;&lt; <span class="stringliteral">&quot;End Result: TEST FAILED&quot;</span> &lt;&lt; endl;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> success ? EXIT_SUCCESS : EXIT_FAILURE;</div>
<div class="line">}</div>
<div class="ttc" id="aTpetra__Core_8hpp_html"><div class="ttname"><a href="Tpetra__Core_8hpp.html">Tpetra_Core.hpp</a></div><div class="ttdoc">Functions for initializing and finalizing Tpetra.</div></div>
<div class="ttc" id="aclassTpetra_1_1CrsMatrixStruct_html"><div class="ttname"><a href="classTpetra_1_1CrsMatrixStruct.html">Tpetra::CrsMatrixStruct</a></div><div class="ttdoc">Struct that holds views of the contents of a CrsMatrix.</div><div class="ttdef"><b>Definition</b> <a href="TpetraExt__MMHelpers__decl_8hpp_source.html#l00036">TpetraExt_MMHelpers_decl.hpp:36</a></div></div>
<div class="ttc" id="aclassTpetra_1_1Import_html"><div class="ttname"><a href="classTpetra_1_1Import.html">Tpetra::Import</a></div><div class="ttdoc">Communication plan for data redistribution from a uniquely-owned to a (possibly) multiply-owned distr...</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__Import__decl_8hpp_source.html#l00077">Tpetra_Import_decl.hpp:77</a></div></div>
<div class="ttc" id="aclassTpetra_1_1MultiVector_html"><div class="ttname"><a href="classTpetra_1_1MultiVector.html">Tpetra::MultiVector</a></div><div class="ttdoc">One or more distributed dense vectors.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__MultiVector__decl_8hpp_source.html#l00350">Tpetra_MultiVector_decl.hpp:350</a></div></div>
<div class="ttc" id="aclassTpetra_1_1Operator_html"><div class="ttname"><a href="classTpetra_1_1Operator.html">Tpetra::Operator</a></div><div class="ttdoc">Abstract interface for operators (e.g., matrices and preconditioners).</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__Operator_8hpp_source.html#l00055">Tpetra_Operator.hpp:55</a></div></div>
<div class="ttc" id="aclassTpetra_1_1Operator_html_a15e31f088868daf38fddf2aa5148be73"><div class="ttname"><a href="classTpetra_1_1Operator.html#a15e31f088868daf38fddf2aa5148be73">Tpetra::Operator::getRangeMap</a></div><div class="ttdeci">virtual Teuchos::RCP&lt; const Map&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt; getRangeMap() const =0</div><div class="ttdoc">The Map associated with the range of this operator, which must be compatible with Y....</div></div>
<div class="ttc" id="aclassTpetra_1_1Operator_html_a4da474a9ef4e2525f16ab222f5668821"><div class="ttname"><a href="classTpetra_1_1Operator.html#a4da474a9ef4e2525f16ab222f5668821">Tpetra::Operator::scalar_type</a></div><div class="ttdeci">Scalar scalar_type</div><div class="ttdoc">The type of the entries of the input and output multivectors.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__Operator_8hpp_source.html#l00061">Tpetra_Operator.hpp:61</a></div></div>
<div class="ttc" id="aclassTpetra_1_1Operator_html_a741af9161d2a7457b8ec9110d9af7547"><div class="ttname"><a href="classTpetra_1_1Operator.html#a741af9161d2a7457b8ec9110d9af7547">Tpetra::Operator::local_ordinal_type</a></div><div class="ttdeci">LocalOrdinal local_ordinal_type</div><div class="ttdoc">The local index type.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__Operator_8hpp_source.html#l00064">Tpetra_Operator.hpp:64</a></div></div>
<div class="ttc" id="aclassTpetra_1_1Operator_html_a81a0f2636e24ebe69bdcaf8cafd786be"><div class="ttname"><a href="classTpetra_1_1Operator.html#a81a0f2636e24ebe69bdcaf8cafd786be">Tpetra::Operator::getDomainMap</a></div><div class="ttdeci">virtual Teuchos::RCP&lt; const Map&lt; LocalOrdinal, GlobalOrdinal, Node &gt; &gt; getDomainMap() const =0</div><div class="ttdoc">The Map associated with the domain of this operator, which must be compatible with X....</div></div>
<div class="ttc" id="aclassTpetra_1_1Operator_html_a8f12bf2928798b92dbb570a57fbb47f9"><div class="ttname"><a href="classTpetra_1_1Operator.html#a8f12bf2928798b92dbb570a57fbb47f9">Tpetra::Operator::node_type</a></div><div class="ttdeci">Node node_type</div><div class="ttdoc">The Kokkos Node type.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__Operator_8hpp_source.html#l00070">Tpetra_Operator.hpp:70</a></div></div>
<div class="ttc" id="aclassTpetra_1_1Operator_html_a900b02363414fa0decad11d466c320ce"><div class="ttname"><a href="classTpetra_1_1Operator.html#a900b02363414fa0decad11d466c320ce">Tpetra::Operator::apply</a></div><div class="ttdeci">virtual void apply(const MultiVector&lt; Scalar, LocalOrdinal, GlobalOrdinal, Node &gt; &amp;X, MultiVector&lt; Scalar, LocalOrdinal, GlobalOrdinal, Node &gt; &amp;Y, Teuchos::ETransp mode=Teuchos::NO_TRANS, Scalar alpha=Teuchos::ScalarTraits&lt; Scalar &gt;::one(), Scalar beta=Teuchos::ScalarTraits&lt; Scalar &gt;::zero()) const =0</div><div class="ttdoc">Computes the operator-multivector application.</div></div>
<div class="ttc" id="aclassTpetra_1_1Operator_html_af3854c49c80eb2bfe7e22186219fd6f0"><div class="ttname"><a href="classTpetra_1_1Operator.html#af3854c49c80eb2bfe7e22186219fd6f0">Tpetra::Operator::global_ordinal_type</a></div><div class="ttdeci">GlobalOrdinal global_ordinal_type</div><div class="ttdoc">The global index type.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__Operator_8hpp_source.html#l00067">Tpetra_Operator.hpp:67</a></div></div>
<div class="ttc" id="aclassTpetra_1_1ScopeGuard_html"><div class="ttname"><a href="classTpetra_1_1ScopeGuard.html">Tpetra::ScopeGuard</a></div><div class="ttdoc">Scope guard whose destructor automatically calls Tpetra::finalize for you.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__Core_8hpp_source.html#l00188">Tpetra_Core.hpp:188</a></div></div>
<div class="ttc" id="aclassTpetra_1_1Vector_html"><div class="ttname"><a href="classTpetra_1_1Vector.html">Tpetra::Vector</a></div><div class="ttdoc">A distributed dense vector.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__Vector__decl_8hpp_source.html#l00044">Tpetra_Vector_decl.hpp:44</a></div></div>
<div class="ttc" id="anamespaceTpetra_1_1Details_1_1DefaultTypes_html_a30dcc98a8290a6dcb0216e0f54c68d57"><div class="ttname"><a href="namespaceTpetra_1_1Details_1_1DefaultTypes.html#a30dcc98a8290a6dcb0216e0f54c68d57">Tpetra::Details::DefaultTypes::local_ordinal_type</a></div><div class="ttdeci">int local_ordinal_type</div><div class="ttdoc">Default value of Scalar template parameter.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__Details__DefaultTypes_8hpp_source.html#l00040">Tpetra_Details_DefaultTypes.hpp:40</a></div></div>
<div class="ttc" id="anamespaceTpetra_html_ab0f27babe7678e67ee420a36029ae10a"><div class="ttname"><a href="namespaceTpetra.html#ab0f27babe7678e67ee420a36029ae10a">Tpetra::getDefaultComm</a></div><div class="ttdeci">Teuchos::RCP&lt; const Teuchos::Comm&lt; int &gt; &gt; getDefaultComm()</div><div class="ttdoc">Get Tpetra's default communicator.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__Core_8cpp_source.html#l00170">Tpetra_Core.cpp:170</a></div></div>
<div class="ttc" id="anamespaceTpetra_html_ae2e9d143601fd81d01d9317bf4d9094ba8311a4172e79c1f3a25a4ffc2e637b28"><div class="ttname"><a href="namespaceTpetra.html#ae2e9d143601fd81d01d9317bf4d9094ba8311a4172e79c1f3a25a4ffc2e637b28">Tpetra::INSERT</a></div><div class="ttdeci">@ INSERT</div><div class="ttdoc">Insert new values that don't currently exist.</div><div class="ttdef"><b>Definition</b> <a href="Tpetra__CombineMode_8hpp_source.html#l00067">Tpetra_CombineMode.hpp:67</a></div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 9 2025 21:01:02 for Tpetra parallel linear algebra by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
