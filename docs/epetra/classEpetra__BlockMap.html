<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Epetra: Epetra_BlockMap Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Epetra<span id="projectnumber">&#160;Development</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classEpetra__BlockMap-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Epetra_BlockMap Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a>: A class for partitioning block element vectors and matrices.  
 <a href="classEpetra__BlockMap.html#details">More...</a></p>

<p><code>#include &lt;Epetra_BlockMap.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Epetra_BlockMap:</div>
<div class="dyncontent">
<div class="center"><img src="classEpetra__BlockMap__inherit__graph.gif" border="0" usemap="#aEpetra__BlockMap_inherit__map" alt="Inheritance graph"/></div>
<map name="aEpetra__BlockMap_inherit__map" id="aEpetra__BlockMap_inherit__map">
<area shape="rect" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices." alt="" coords="5,79,140,104"/>
<area shape="rect" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices." alt="" coords="23,152,122,177"/>
<area shape="poly" title=" " alt="" coords="75,118,75,152,70,152,70,118"/>
<area shape="rect" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class." alt="" coords="16,5,129,31"/>
<area shape="poly" title=" " alt="" coords="75,44,75,79,70,79,70,44"/>
<area shape="rect" href="classEpetra__LocalMap.html" title="Epetra_LocalMap: A class for replicating vectors and matrices across multiple processors." alt="" coords="6,225,139,251"/>
<area shape="poly" title=" " alt="" coords="75,191,75,225,70,225,70,191"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Epetra_BlockMap:</div>
<div class="dyncontent">
<div class="center"><img src="classEpetra__BlockMap__coll__graph.gif" border="0" usemap="#aEpetra__BlockMap_coll__map" alt="Collaboration graph"/></div>
<map name="aEpetra__BlockMap_coll__map" id="aEpetra__BlockMap_coll__map">
<area shape="rect" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices." alt="" coords="47,168,181,193"/>
<area shape="rect" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class." alt="" coords="5,80,119,105"/>
<area shape="poly" title=" " alt="" coords="78,116,109,166,104,169,74,119"/>
<area shape="rect" href="classEpetra__BlockMapData.html" title="Epetra_BlockMapData: The Epetra BlockMap Data Class." alt="" coords="143,80,309,105"/>
<area shape="poly" title=" " alt="" coords="201,116,131,170,128,166,198,112"/>
<area shape="rect" href="classEpetra__Data.html" title="Epetra_Data: The Epetra Base Data Class." alt="" coords="175,5,277,31"/>
<area shape="poly" title=" " alt="" coords="229,45,229,80,223,80,223,45"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acb72862428ef67f753c207230deaaa62" id="r_acb72862428ef67f753c207230deaaa62"><td class="memItemLeft" align="right" valign="top"><a id="acb72862428ef67f753c207230deaaa62" name="acb72862428ef67f753c207230deaaa62"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:acb72862428ef67f753c207230deaaa62"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GlobalIndicesIsType</b> () const</td></tr>
<tr class="separator:acb72862428ef67f753c207230deaaa62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb72862428ef67f753c207230deaaa62" id="r_acb72862428ef67f753c207230deaaa62"><td class="memItemLeft" align="right" valign="top"><a id="acb72862428ef67f753c207230deaaa62" name="acb72862428ef67f753c207230deaaa62"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:acb72862428ef67f753c207230deaaa62"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GlobalIndicesIsType</b> () const</td></tr>
<tr class="separator:acb72862428ef67f753c207230deaaa62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors/destructors</div></td></tr>
<tr class="memitem:a5941203fc98a8d9bdb79a32d070b4583" id="r_a5941203fc98a8d9bdb79a32d070b4583"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__BlockMap.html#a5941203fc98a8d9bdb79a32d070b4583">Epetra_BlockMap</a> (int <a class="el" href="classEpetra__BlockMap.html#abc70320a09789d1bf51871c5262ed835">NumGlobalElements</a>, int <a class="el" href="classEpetra__BlockMap.html#a9284c2b577bbb54ded9566669341e4a6">ElementSize</a>, int <a class="el" href="classEpetra__BlockMap.html#a8097c084ba5a22916a49624c2b90998f">IndexBase</a>, const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;<a class="el" href="classEpetra__BlockMap.html#abd9d6c774319c3bb5e79039058416a92">Comm</a>)</td></tr>
<tr class="memdesc:a5941203fc98a8d9bdb79a32d070b4583"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> constructor for a Epetra-defined uniform linear distribution of constant size elements.  <br /></td></tr>
<tr class="separator:a5941203fc98a8d9bdb79a32d070b4583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad6020893a957cf3c988bbcd451d219" id="r_acad6020893a957cf3c988bbcd451d219"><td class="memItemLeft" align="right" valign="top"><a id="acad6020893a957cf3c988bbcd451d219" name="acad6020893a957cf3c988bbcd451d219"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_BlockMap</b> (long long <a class="el" href="classEpetra__BlockMap.html#abc70320a09789d1bf51871c5262ed835">NumGlobalElements</a>, int <a class="el" href="classEpetra__BlockMap.html#a9284c2b577bbb54ded9566669341e4a6">ElementSize</a>, int <a class="el" href="classEpetra__BlockMap.html#a8097c084ba5a22916a49624c2b90998f">IndexBase</a>, const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;<a class="el" href="classEpetra__BlockMap.html#abd9d6c774319c3bb5e79039058416a92">Comm</a>)</td></tr>
<tr class="separator:acad6020893a957cf3c988bbcd451d219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84119650a054c6834e4a2e5cbe00f6a" id="r_ae84119650a054c6834e4a2e5cbe00f6a"><td class="memItemLeft" align="right" valign="top"><a id="ae84119650a054c6834e4a2e5cbe00f6a" name="ae84119650a054c6834e4a2e5cbe00f6a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_BlockMap</b> (long long <a class="el" href="classEpetra__BlockMap.html#abc70320a09789d1bf51871c5262ed835">NumGlobalElements</a>, int <a class="el" href="classEpetra__BlockMap.html#a9284c2b577bbb54ded9566669341e4a6">ElementSize</a>, long long <a class="el" href="classEpetra__BlockMap.html#a8097c084ba5a22916a49624c2b90998f">IndexBase</a>, const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;<a class="el" href="classEpetra__BlockMap.html#abd9d6c774319c3bb5e79039058416a92">Comm</a>)</td></tr>
<tr class="separator:ae84119650a054c6834e4a2e5cbe00f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41066a9457d18d8bf5c64c873a95480" id="r_aa41066a9457d18d8bf5c64c873a95480"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__BlockMap.html#aa41066a9457d18d8bf5c64c873a95480">Epetra_BlockMap</a> (int <a class="el" href="classEpetra__BlockMap.html#abc70320a09789d1bf51871c5262ed835">NumGlobalElements</a>, int <a class="el" href="classEpetra__BlockMap.html#acdb9f7c41ae4fb986326a8fff49b1b17">NumMyElements</a>, int <a class="el" href="classEpetra__BlockMap.html#a9284c2b577bbb54ded9566669341e4a6">ElementSize</a>, int <a class="el" href="classEpetra__BlockMap.html#a8097c084ba5a22916a49624c2b90998f">IndexBase</a>, const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;<a class="el" href="classEpetra__BlockMap.html#abd9d6c774319c3bb5e79039058416a92">Comm</a>)</td></tr>
<tr class="memdesc:aa41066a9457d18d8bf5c64c873a95480"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> constructor for a user-defined linear distribution of constant size elements.  <br /></td></tr>
<tr class="separator:aa41066a9457d18d8bf5c64c873a95480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7ce35d94418a03743493b53f3a775c" id="r_a8c7ce35d94418a03743493b53f3a775c"><td class="memItemLeft" align="right" valign="top"><a id="a8c7ce35d94418a03743493b53f3a775c" name="a8c7ce35d94418a03743493b53f3a775c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_BlockMap</b> (long long <a class="el" href="classEpetra__BlockMap.html#abc70320a09789d1bf51871c5262ed835">NumGlobalElements</a>, int <a class="el" href="classEpetra__BlockMap.html#acdb9f7c41ae4fb986326a8fff49b1b17">NumMyElements</a>, int <a class="el" href="classEpetra__BlockMap.html#a9284c2b577bbb54ded9566669341e4a6">ElementSize</a>, int <a class="el" href="classEpetra__BlockMap.html#a8097c084ba5a22916a49624c2b90998f">IndexBase</a>, const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;<a class="el" href="classEpetra__BlockMap.html#abd9d6c774319c3bb5e79039058416a92">Comm</a>)</td></tr>
<tr class="separator:a8c7ce35d94418a03743493b53f3a775c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ad9d0577fd081333865c55ac830474" id="r_ab1ad9d0577fd081333865c55ac830474"><td class="memItemLeft" align="right" valign="top"><a id="ab1ad9d0577fd081333865c55ac830474" name="ab1ad9d0577fd081333865c55ac830474"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_BlockMap</b> (long long <a class="el" href="classEpetra__BlockMap.html#abc70320a09789d1bf51871c5262ed835">NumGlobalElements</a>, int <a class="el" href="classEpetra__BlockMap.html#acdb9f7c41ae4fb986326a8fff49b1b17">NumMyElements</a>, int <a class="el" href="classEpetra__BlockMap.html#a9284c2b577bbb54ded9566669341e4a6">ElementSize</a>, long long <a class="el" href="classEpetra__BlockMap.html#a8097c084ba5a22916a49624c2b90998f">IndexBase</a>, const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;<a class="el" href="classEpetra__BlockMap.html#abd9d6c774319c3bb5e79039058416a92">Comm</a>)</td></tr>
<tr class="separator:ab1ad9d0577fd081333865c55ac830474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe05ca45ffccf1d037b497702dcc4971" id="r_afe05ca45ffccf1d037b497702dcc4971"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__BlockMap.html#afe05ca45ffccf1d037b497702dcc4971">Epetra_BlockMap</a> (int <a class="el" href="classEpetra__BlockMap.html#abc70320a09789d1bf51871c5262ed835">NumGlobalElements</a>, int <a class="el" href="classEpetra__BlockMap.html#acdb9f7c41ae4fb986326a8fff49b1b17">NumMyElements</a>, const int *<a class="el" href="classEpetra__BlockMap.html#a1f6ef71a397909d0219167b339eb3164">MyGlobalElements</a>, int <a class="el" href="classEpetra__BlockMap.html#a9284c2b577bbb54ded9566669341e4a6">ElementSize</a>, int <a class="el" href="classEpetra__BlockMap.html#a8097c084ba5a22916a49624c2b90998f">IndexBase</a>, const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;<a class="el" href="classEpetra__BlockMap.html#abd9d6c774319c3bb5e79039058416a92">Comm</a>)</td></tr>
<tr class="memdesc:afe05ca45ffccf1d037b497702dcc4971"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> constructor for a user-defined arbitrary distribution of constant size elements.  <br /></td></tr>
<tr class="separator:afe05ca45ffccf1d037b497702dcc4971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56b6ff9481f3cdd3591148ed811156e" id="r_ad56b6ff9481f3cdd3591148ed811156e"><td class="memItemLeft" align="right" valign="top"><a id="ad56b6ff9481f3cdd3591148ed811156e" name="ad56b6ff9481f3cdd3591148ed811156e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_BlockMap</b> (long long <a class="el" href="classEpetra__BlockMap.html#abc70320a09789d1bf51871c5262ed835">NumGlobalElements</a>, int <a class="el" href="classEpetra__BlockMap.html#acdb9f7c41ae4fb986326a8fff49b1b17">NumMyElements</a>, const long long *<a class="el" href="classEpetra__BlockMap.html#a1f6ef71a397909d0219167b339eb3164">MyGlobalElements</a>, int <a class="el" href="classEpetra__BlockMap.html#a9284c2b577bbb54ded9566669341e4a6">ElementSize</a>, int <a class="el" href="classEpetra__BlockMap.html#a8097c084ba5a22916a49624c2b90998f">IndexBase</a>, const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;<a class="el" href="classEpetra__BlockMap.html#abd9d6c774319c3bb5e79039058416a92">Comm</a>)</td></tr>
<tr class="separator:ad56b6ff9481f3cdd3591148ed811156e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67123632de53ad834b7fc56629ebf1d5" id="r_a67123632de53ad834b7fc56629ebf1d5"><td class="memItemLeft" align="right" valign="top"><a id="a67123632de53ad834b7fc56629ebf1d5" name="a67123632de53ad834b7fc56629ebf1d5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_BlockMap</b> (long long <a class="el" href="classEpetra__BlockMap.html#abc70320a09789d1bf51871c5262ed835">NumGlobalElements</a>, int <a class="el" href="classEpetra__BlockMap.html#acdb9f7c41ae4fb986326a8fff49b1b17">NumMyElements</a>, const long long *<a class="el" href="classEpetra__BlockMap.html#a1f6ef71a397909d0219167b339eb3164">MyGlobalElements</a>, int <a class="el" href="classEpetra__BlockMap.html#a9284c2b577bbb54ded9566669341e4a6">ElementSize</a>, long long <a class="el" href="classEpetra__BlockMap.html#a8097c084ba5a22916a49624c2b90998f">IndexBase</a>, const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;<a class="el" href="classEpetra__BlockMap.html#abd9d6c774319c3bb5e79039058416a92">Comm</a>)</td></tr>
<tr class="separator:a67123632de53ad834b7fc56629ebf1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911491bf44f662dfba5f74c804480a42" id="r_a911491bf44f662dfba5f74c804480a42"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__BlockMap.html#a911491bf44f662dfba5f74c804480a42">Epetra_BlockMap</a> (int <a class="el" href="classEpetra__BlockMap.html#abc70320a09789d1bf51871c5262ed835">NumGlobalElements</a>, int <a class="el" href="classEpetra__BlockMap.html#acdb9f7c41ae4fb986326a8fff49b1b17">NumMyElements</a>, const int *<a class="el" href="classEpetra__BlockMap.html#a1f6ef71a397909d0219167b339eb3164">MyGlobalElements</a>, const int *<a class="el" href="classEpetra__BlockMap.html#a515b2e0528c74147c94300b41c733440">ElementSizeList</a>, int <a class="el" href="classEpetra__BlockMap.html#a8097c084ba5a22916a49624c2b90998f">IndexBase</a>, const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;<a class="el" href="classEpetra__BlockMap.html#abd9d6c774319c3bb5e79039058416a92">Comm</a>)</td></tr>
<tr class="memdesc:a911491bf44f662dfba5f74c804480a42"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> constructor for a user-defined arbitrary distribution of variable size elements.  <br /></td></tr>
<tr class="separator:a911491bf44f662dfba5f74c804480a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbde77884bcb0fc0f7572878ec7a014f" id="r_adbde77884bcb0fc0f7572878ec7a014f"><td class="memItemLeft" align="right" valign="top"><a id="adbde77884bcb0fc0f7572878ec7a014f" name="adbde77884bcb0fc0f7572878ec7a014f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_BlockMap</b> (long long <a class="el" href="classEpetra__BlockMap.html#abc70320a09789d1bf51871c5262ed835">NumGlobalElements</a>, int <a class="el" href="classEpetra__BlockMap.html#acdb9f7c41ae4fb986326a8fff49b1b17">NumMyElements</a>, const long long *<a class="el" href="classEpetra__BlockMap.html#a1f6ef71a397909d0219167b339eb3164">MyGlobalElements</a>, const int *<a class="el" href="classEpetra__BlockMap.html#a515b2e0528c74147c94300b41c733440">ElementSizeList</a>, int <a class="el" href="classEpetra__BlockMap.html#a8097c084ba5a22916a49624c2b90998f">IndexBase</a>, const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;<a class="el" href="classEpetra__BlockMap.html#abd9d6c774319c3bb5e79039058416a92">Comm</a>)</td></tr>
<tr class="separator:adbde77884bcb0fc0f7572878ec7a014f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d66f592c9dfc49b1a9ebaa45860cdf9" id="r_a5d66f592c9dfc49b1a9ebaa45860cdf9"><td class="memItemLeft" align="right" valign="top"><a id="a5d66f592c9dfc49b1a9ebaa45860cdf9" name="a5d66f592c9dfc49b1a9ebaa45860cdf9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_BlockMap</b> (long long <a class="el" href="classEpetra__BlockMap.html#abc70320a09789d1bf51871c5262ed835">NumGlobalElements</a>, int <a class="el" href="classEpetra__BlockMap.html#acdb9f7c41ae4fb986326a8fff49b1b17">NumMyElements</a>, const long long *<a class="el" href="classEpetra__BlockMap.html#a1f6ef71a397909d0219167b339eb3164">MyGlobalElements</a>, const int *<a class="el" href="classEpetra__BlockMap.html#a515b2e0528c74147c94300b41c733440">ElementSizeList</a>, long long <a class="el" href="classEpetra__BlockMap.html#a8097c084ba5a22916a49624c2b90998f">IndexBase</a>, const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;<a class="el" href="classEpetra__BlockMap.html#abd9d6c774319c3bb5e79039058416a92">Comm</a>)</td></tr>
<tr class="separator:a5d66f592c9dfc49b1a9ebaa45860cdf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5e453a9d1231ccfae2f4b2a63c736f" id="r_add5e453a9d1231ccfae2f4b2a63c736f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__BlockMap.html#add5e453a9d1231ccfae2f4b2a63c736f">Epetra_BlockMap</a> (long long NumGlobal_Elements, int NumMy_Elements, const long long *myGlobalElements, int <a class="el" href="classEpetra__BlockMap.html#a9284c2b577bbb54ded9566669341e4a6">ElementSize</a>, int indexBase, const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;comm, bool UserIsDistributedGlobal, long long UserMinAllGID, long long UserMaxAllGID)</td></tr>
<tr class="memdesc:add5e453a9d1231ccfae2f4b2a63c736f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> constructor for a user-defined arbitrary distribution of constant size elements, where the user provides all the globals.  <br /></td></tr>
<tr class="separator:add5e453a9d1231ccfae2f4b2a63c736f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d145a1099a3da42727a7b7519e25239" id="r_a7d145a1099a3da42727a7b7519e25239"><td class="memItemLeft" align="right" valign="top"><a id="a7d145a1099a3da42727a7b7519e25239" name="a7d145a1099a3da42727a7b7519e25239"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_BlockMap</b> (long long NumGlobal_Elements, int NumMy_Elements, const long long *myGlobalElements, int <a class="el" href="classEpetra__BlockMap.html#a9284c2b577bbb54ded9566669341e4a6">ElementSize</a>, long long indexBase, const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;comm, bool UserIsDistributedGlobal, long long UserMinAllGID, long long UserMaxAllGID)</td></tr>
<tr class="separator:a7d145a1099a3da42727a7b7519e25239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f2fec5e782fc7e8ed3eb65b33e0f5a" id="r_a07f2fec5e782fc7e8ed3eb65b33e0f5a"><td class="memItemLeft" align="right" valign="top"><a id="a07f2fec5e782fc7e8ed3eb65b33e0f5a" name="a07f2fec5e782fc7e8ed3eb65b33e0f5a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_BlockMap</b> (int NumGlobal_Elements, int NumMy_Elements, const int *myGlobalElements, int <a class="el" href="classEpetra__BlockMap.html#a9284c2b577bbb54ded9566669341e4a6">ElementSize</a>, int indexBase, const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;comm, bool UserIsDistributedGlobal, int UserMinAllGID, int UserMaxAllGID)</td></tr>
<tr class="separator:a07f2fec5e782fc7e8ed3eb65b33e0f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920e6a54a30f51e8e114c94e1c71d315" id="r_a920e6a54a30f51e8e114c94e1c71d315"><td class="memItemLeft" align="right" valign="top"><a id="a920e6a54a30f51e8e114c94e1c71d315" name="a920e6a54a30f51e8e114c94e1c71d315"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_BlockMap</b> (const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;map)</td></tr>
<tr class="memdesc:a920e6a54a30f51e8e114c94e1c71d315"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> copy constructor. <br /></td></tr>
<tr class="separator:a920e6a54a30f51e8e114c94e1c71d315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b67893bf7060c3f982b9ec4f448231" id="r_ac5b67893bf7060c3f982b9ec4f448231"><td class="memItemLeft" align="right" valign="top"><a id="ac5b67893bf7060c3f982b9ec4f448231" name="ac5b67893bf7060c3f982b9ec4f448231"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_BlockMap</b> (void)</td></tr>
<tr class="memdesc:ac5b67893bf7060c3f982b9ec4f448231"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> destructor. <br /></td></tr>
<tr class="separator:ac5b67893bf7060c3f982b9ec4f448231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Local/Global ID accessor methods</div></td></tr>
<tr class="memitem:a0adc24b09a0bb734f6750a82ed37493c" id="r_a0adc24b09a0bb734f6750a82ed37493c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__BlockMap.html#a0adc24b09a0bb734f6750a82ed37493c">RemoteIDList</a> (int NumIDs, const int *GIDList, int *PIDList, int *LIDList) const</td></tr>
<tr class="memdesc:a0adc24b09a0bb734f6750a82ed37493c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the processor IDs and corresponding local index value for a given list of global indices.  <br /></td></tr>
<tr class="separator:a0adc24b09a0bb734f6750a82ed37493c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa4663cf4858ce3dca1dc8bd8dec2b2" id="r_a8aa4663cf4858ce3dca1dc8bd8dec2b2"><td class="memItemLeft" align="right" valign="top"><a id="a8aa4663cf4858ce3dca1dc8bd8dec2b2" name="a8aa4663cf4858ce3dca1dc8bd8dec2b2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>RemoteIDList</b> (int NumIDs, const long long *GIDList, int *PIDList, int *LIDList) const</td></tr>
<tr class="separator:a8aa4663cf4858ce3dca1dc8bd8dec2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2366a59e075efc9974eeb42077b90a6" id="r_ad2366a59e075efc9974eeb42077b90a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__BlockMap.html#ad2366a59e075efc9974eeb42077b90a6">RemoteIDList</a> (int NumIDs, const int *GIDList, int *PIDList, int *LIDList, int *SizeList) const</td></tr>
<tr class="memdesc:ad2366a59e075efc9974eeb42077b90a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the processor IDs, corresponding local index value, and element size for a given list of global indices.  <br /></td></tr>
<tr class="separator:ad2366a59e075efc9974eeb42077b90a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa382795654c8411e1d75b2cf94e849f2" id="r_aa382795654c8411e1d75b2cf94e849f2"><td class="memItemLeft" align="right" valign="top"><a id="aa382795654c8411e1d75b2cf94e849f2" name="aa382795654c8411e1d75b2cf94e849f2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>RemoteIDList</b> (int NumIDs, const long long *GIDList, int *PIDList, int *LIDList, int *SizeList) const</td></tr>
<tr class="separator:aa382795654c8411e1d75b2cf94e849f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78140db7635060b875e0a9da876af238" id="r_a78140db7635060b875e0a9da876af238"><td class="memItemLeft" align="right" valign="top"><a id="a78140db7635060b875e0a9da876af238" name="a78140db7635060b875e0a9da876af238"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>LID</b> (int <a class="el" href="classEpetra__BlockMap.html#a7936ee0c8456487842749b78db913065">GID</a>) const</td></tr>
<tr class="memdesc:a78140db7635060b875e0a9da876af238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns local ID of global ID, return -1 if not found on this processor. <br /></td></tr>
<tr class="separator:a78140db7635060b875e0a9da876af238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8654e35c799b0cbb5acd5c790fb0ed04" id="r_a8654e35c799b0cbb5acd5c790fb0ed04"><td class="memItemLeft" align="right" valign="top"><a id="a8654e35c799b0cbb5acd5c790fb0ed04" name="a8654e35c799b0cbb5acd5c790fb0ed04"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>LID</b> (long long <a class="el" href="classEpetra__BlockMap.html#a7936ee0c8456487842749b78db913065">GID</a>) const</td></tr>
<tr class="separator:a8654e35c799b0cbb5acd5c790fb0ed04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7936ee0c8456487842749b78db913065" id="r_a7936ee0c8456487842749b78db913065"><td class="memItemLeft" align="right" valign="top"><a id="a7936ee0c8456487842749b78db913065" name="a7936ee0c8456487842749b78db913065"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>GID</b> (int <a class="el" href="classEpetra__BlockMap.html#a78140db7635060b875e0a9da876af238">LID</a>) const</td></tr>
<tr class="memdesc:a7936ee0c8456487842749b78db913065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns global ID of local ID, return IndexBase-1 if not found on this processor. <br /></td></tr>
<tr class="separator:a7936ee0c8456487842749b78db913065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc3f3250a1273f95cad488f0d7a080e" id="r_a8cc3f3250a1273f95cad488f0d7a080e"><td class="memItemLeft" align="right" valign="top"><a id="a8cc3f3250a1273f95cad488f0d7a080e" name="a8cc3f3250a1273f95cad488f0d7a080e"></a>
long long&#160;</td><td class="memItemRight" valign="bottom"><b>GID64</b> (int <a class="el" href="classEpetra__BlockMap.html#a78140db7635060b875e0a9da876af238">LID</a>) const</td></tr>
<tr class="separator:a8cc3f3250a1273f95cad488f0d7a080e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab641e3bf336a34390b3905bf31a63fce" id="r_ab641e3bf336a34390b3905bf31a63fce"><td class="memItemLeft" align="right" valign="top"><a id="ab641e3bf336a34390b3905bf31a63fce" name="ab641e3bf336a34390b3905bf31a63fce"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>FindLocalElementID</b> (int PointID, int &amp;ElementID, int &amp;ElementOffset) const</td></tr>
<tr class="memdesc:ab641e3bf336a34390b3905bf31a63fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the LID of the element that contains the given local PointID, and the Offset of the point in that element. <br /></td></tr>
<tr class="separator:ab641e3bf336a34390b3905bf31a63fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64742259d9a0727b159b7ede5a82013" id="r_ae64742259d9a0727b159b7ede5a82013"><td class="memItemLeft" align="right" valign="top"><a id="ae64742259d9a0727b159b7ede5a82013" name="ae64742259d9a0727b159b7ede5a82013"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MyGID</b> (int GID_in) const</td></tr>
<tr class="memdesc:ae64742259d9a0727b159b7ede5a82013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the GID passed in belongs to the calling processor in this map, otherwise returns false. <br /></td></tr>
<tr class="separator:ae64742259d9a0727b159b7ede5a82013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619f71c8565fb6c403ae8206cd39bda5" id="r_a619f71c8565fb6c403ae8206cd39bda5"><td class="memItemLeft" align="right" valign="top"><a id="a619f71c8565fb6c403ae8206cd39bda5" name="a619f71c8565fb6c403ae8206cd39bda5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MyGID</b> (long long GID_in) const</td></tr>
<tr class="separator:a619f71c8565fb6c403ae8206cd39bda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35858be549abb12a2b041ba56c8c019" id="r_ad35858be549abb12a2b041ba56c8c019"><td class="memItemLeft" align="right" valign="top"><a id="ad35858be549abb12a2b041ba56c8c019" name="ad35858be549abb12a2b041ba56c8c019"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MyLID</b> (int lid) const</td></tr>
<tr class="memdesc:ad35858be549abb12a2b041ba56c8c019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the LID passed in belongs to the calling processor in this map, otherwise returns false. <br /></td></tr>
<tr class="separator:ad35858be549abb12a2b041ba56c8c019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03490ae6df53443c621bf51b8b4adad0" id="r_a03490ae6df53443c621bf51b8b4adad0"><td class="memItemLeft" align="right" valign="top"><a id="a03490ae6df53443c621bf51b8b4adad0" name="a03490ae6df53443c621bf51b8b4adad0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MinAllGID</b> () const</td></tr>
<tr class="memdesc:a03490ae6df53443c621bf51b8b4adad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum global ID across the entire map. <br /></td></tr>
<tr class="separator:a03490ae6df53443c621bf51b8b4adad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac678487d5e7148f2ed1cbc2e2b3699e6" id="r_ac678487d5e7148f2ed1cbc2e2b3699e6"><td class="memItemLeft" align="right" valign="top"><a id="ac678487d5e7148f2ed1cbc2e2b3699e6" name="ac678487d5e7148f2ed1cbc2e2b3699e6"></a>
long long&#160;</td><td class="memItemRight" valign="bottom"><b>MinAllGID64</b> () const</td></tr>
<tr class="separator:ac678487d5e7148f2ed1cbc2e2b3699e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b12fa71e84b7f8703864bb76a10f050" id="r_a8b12fa71e84b7f8703864bb76a10f050"><td class="memItemLeft" align="right" valign="top"><a id="a8b12fa71e84b7f8703864bb76a10f050" name="a8b12fa71e84b7f8703864bb76a10f050"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MaxAllGID</b> () const</td></tr>
<tr class="memdesc:a8b12fa71e84b7f8703864bb76a10f050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum global ID across the entire map. <br /></td></tr>
<tr class="separator:a8b12fa71e84b7f8703864bb76a10f050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc212c255016517359d6112e9372ac5" id="r_a2fc212c255016517359d6112e9372ac5"><td class="memItemLeft" align="right" valign="top"><a id="a2fc212c255016517359d6112e9372ac5" name="a2fc212c255016517359d6112e9372ac5"></a>
long long&#160;</td><td class="memItemRight" valign="bottom"><b>MaxAllGID64</b> () const</td></tr>
<tr class="separator:a2fc212c255016517359d6112e9372ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cc84ba931bb016ff562ab795cd8879" id="r_a33cc84ba931bb016ff562ab795cd8879"><td class="memItemLeft" align="right" valign="top"><a id="a33cc84ba931bb016ff562ab795cd8879" name="a33cc84ba931bb016ff562ab795cd8879"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MinMyGID</b> () const</td></tr>
<tr class="memdesc:a33cc84ba931bb016ff562ab795cd8879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum global ID owned by this processor. <br /></td></tr>
<tr class="separator:a33cc84ba931bb016ff562ab795cd8879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1c9b5284c09603708c0607ace8f252" id="r_acb1c9b5284c09603708c0607ace8f252"><td class="memItemLeft" align="right" valign="top"><a id="acb1c9b5284c09603708c0607ace8f252" name="acb1c9b5284c09603708c0607ace8f252"></a>
long long&#160;</td><td class="memItemRight" valign="bottom"><b>MinMyGID64</b> () const</td></tr>
<tr class="separator:acb1c9b5284c09603708c0607ace8f252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af381e1a19930d7d6b933322a0cccd665" id="r_af381e1a19930d7d6b933322a0cccd665"><td class="memItemLeft" align="right" valign="top"><a id="af381e1a19930d7d6b933322a0cccd665" name="af381e1a19930d7d6b933322a0cccd665"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MaxMyGID</b> () const</td></tr>
<tr class="memdesc:af381e1a19930d7d6b933322a0cccd665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum global ID owned by this processor. <br /></td></tr>
<tr class="separator:af381e1a19930d7d6b933322a0cccd665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7d1e3a5d31977fe89d2b111d1d768c" id="r_a3c7d1e3a5d31977fe89d2b111d1d768c"><td class="memItemLeft" align="right" valign="top"><a id="a3c7d1e3a5d31977fe89d2b111d1d768c" name="a3c7d1e3a5d31977fe89d2b111d1d768c"></a>
long long&#160;</td><td class="memItemRight" valign="bottom"><b>MaxMyGID64</b> () const</td></tr>
<tr class="separator:a3c7d1e3a5d31977fe89d2b111d1d768c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b28b8462a4dc6beb9ef08fbebbac892" id="r_a9b28b8462a4dc6beb9ef08fbebbac892"><td class="memItemLeft" align="right" valign="top"><a id="a9b28b8462a4dc6beb9ef08fbebbac892" name="a9b28b8462a4dc6beb9ef08fbebbac892"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MinLID</b> () const</td></tr>
<tr class="memdesc:a9b28b8462a4dc6beb9ef08fbebbac892"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum local index value on the calling processor. <br /></td></tr>
<tr class="separator:a9b28b8462a4dc6beb9ef08fbebbac892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd609dcfcd9e67b3a7845a6907704f7" id="r_adfd609dcfcd9e67b3a7845a6907704f7"><td class="memItemLeft" align="right" valign="top"><a id="adfd609dcfcd9e67b3a7845a6907704f7" name="adfd609dcfcd9e67b3a7845a6907704f7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MaxLID</b> () const</td></tr>
<tr class="memdesc:adfd609dcfcd9e67b3a7845a6907704f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum local index value on the calling processor. <br /></td></tr>
<tr class="separator:adfd609dcfcd9e67b3a7845a6907704f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Size and dimension accessor functions</div></td></tr>
<tr class="memitem:abc70320a09789d1bf51871c5262ed835" id="r_abc70320a09789d1bf51871c5262ed835"><td class="memItemLeft" align="right" valign="top"><a id="abc70320a09789d1bf51871c5262ed835" name="abc70320a09789d1bf51871c5262ed835"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>NumGlobalElements</b> () const</td></tr>
<tr class="memdesc:abc70320a09789d1bf51871c5262ed835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements across all processors. <br /></td></tr>
<tr class="separator:abc70320a09789d1bf51871c5262ed835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec48bb22ca0b9e7e5dae4394968869d" id="r_a9ec48bb22ca0b9e7e5dae4394968869d"><td class="memItemLeft" align="right" valign="top"><a id="a9ec48bb22ca0b9e7e5dae4394968869d" name="a9ec48bb22ca0b9e7e5dae4394968869d"></a>
long long&#160;</td><td class="memItemRight" valign="bottom"><b>NumGlobalElements64</b> () const</td></tr>
<tr class="separator:a9ec48bb22ca0b9e7e5dae4394968869d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb9f7c41ae4fb986326a8fff49b1b17" id="r_acdb9f7c41ae4fb986326a8fff49b1b17"><td class="memItemLeft" align="right" valign="top"><a id="acdb9f7c41ae4fb986326a8fff49b1b17" name="acdb9f7c41ae4fb986326a8fff49b1b17"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>NumMyElements</b> () const</td></tr>
<tr class="memdesc:acdb9f7c41ae4fb986326a8fff49b1b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements on the calling processor. <br /></td></tr>
<tr class="separator:acdb9f7c41ae4fb986326a8fff49b1b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6ef71a397909d0219167b339eb3164" id="r_a1f6ef71a397909d0219167b339eb3164"><td class="memItemLeft" align="right" valign="top"><a id="a1f6ef71a397909d0219167b339eb3164" name="a1f6ef71a397909d0219167b339eb3164"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MyGlobalElements</b> (int *MyGlobalElementList) const</td></tr>
<tr class="memdesc:a1f6ef71a397909d0219167b339eb3164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts list of global elements on this processor into the user-provided array. <br /></td></tr>
<tr class="separator:a1f6ef71a397909d0219167b339eb3164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4880d30b5029a37d58cbc79e58901fb8" id="r_a4880d30b5029a37d58cbc79e58901fb8"><td class="memItemLeft" align="right" valign="top"><a id="a4880d30b5029a37d58cbc79e58901fb8" name="a4880d30b5029a37d58cbc79e58901fb8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MyGlobalElements</b> (long long *MyGlobalElementList) const</td></tr>
<tr class="separator:a4880d30b5029a37d58cbc79e58901fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fe8dff72b46a6d3dc5837e47efb9f2" id="r_af6fe8dff72b46a6d3dc5837e47efb9f2"><td class="memItemLeft" align="right" valign="top"><a id="af6fe8dff72b46a6d3dc5837e47efb9f2" name="af6fe8dff72b46a6d3dc5837e47efb9f2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MyGlobalElementsPtr</b> (int *&amp;MyGlobalElementList) const</td></tr>
<tr class="separator:af6fe8dff72b46a6d3dc5837e47efb9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ec4dd2c2e3091600bb598db794851b" id="r_a94ec4dd2c2e3091600bb598db794851b"><td class="memItemLeft" align="right" valign="top"><a id="a94ec4dd2c2e3091600bb598db794851b" name="a94ec4dd2c2e3091600bb598db794851b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MyGlobalElementsPtr</b> (long long *&amp;MyGlobalElementList) const</td></tr>
<tr class="separator:a94ec4dd2c2e3091600bb598db794851b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9284c2b577bbb54ded9566669341e4a6" id="r_a9284c2b577bbb54ded9566669341e4a6"><td class="memItemLeft" align="right" valign="top"><a id="a9284c2b577bbb54ded9566669341e4a6" name="a9284c2b577bbb54ded9566669341e4a6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ElementSize</b> () const</td></tr>
<tr class="memdesc:a9284c2b577bbb54ded9566669341e4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of elements in the map; only valid if map has constant element size. <br /></td></tr>
<tr class="separator:a9284c2b577bbb54ded9566669341e4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658c268d39f08becd8d6bf88b4d2ab06" id="r_a658c268d39f08becd8d6bf88b4d2ab06"><td class="memItemLeft" align="right" valign="top"><a id="a658c268d39f08becd8d6bf88b4d2ab06" name="a658c268d39f08becd8d6bf88b4d2ab06"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ElementSize</b> (int <a class="el" href="classEpetra__BlockMap.html#a78140db7635060b875e0a9da876af238">LID</a>) const</td></tr>
<tr class="memdesc:a658c268d39f08becd8d6bf88b4d2ab06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of element for specified LID. <br /></td></tr>
<tr class="separator:a658c268d39f08becd8d6bf88b4d2ab06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf56009a4616b5d281c8e4426a9bb71" id="r_adbf56009a4616b5d281c8e4426a9bb71"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__BlockMap.html#adbf56009a4616b5d281c8e4426a9bb71">FirstPointInElement</a> (int <a class="el" href="classEpetra__BlockMap.html#a78140db7635060b875e0a9da876af238">LID</a>) const</td></tr>
<tr class="memdesc:adbf56009a4616b5d281c8e4426a9bb71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested entry in the FirstPointInElementList; see <a class="el" href="classEpetra__BlockMap.html#a9656f504b645c02dc262e2ddac4940c1" title="Pointer to internal array containing a mapping between the local elements and the first local point n...">FirstPointInElementList()</a> for details.  <br /></td></tr>
<tr class="separator:adbf56009a4616b5d281c8e4426a9bb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8097c084ba5a22916a49624c2b90998f" id="r_a8097c084ba5a22916a49624c2b90998f"><td class="memItemLeft" align="right" valign="top"><a id="a8097c084ba5a22916a49624c2b90998f" name="a8097c084ba5a22916a49624c2b90998f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>IndexBase</b> () const</td></tr>
<tr class="memdesc:a8097c084ba5a22916a49624c2b90998f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index base for this map. <br /></td></tr>
<tr class="separator:a8097c084ba5a22916a49624c2b90998f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0217ebeefad40b5948b7bd9dc08159db" id="r_a0217ebeefad40b5948b7bd9dc08159db"><td class="memItemLeft" align="right" valign="top"><a id="a0217ebeefad40b5948b7bd9dc08159db" name="a0217ebeefad40b5948b7bd9dc08159db"></a>
long long&#160;</td><td class="memItemRight" valign="bottom"><b>IndexBase64</b> () const</td></tr>
<tr class="separator:a0217ebeefad40b5948b7bd9dc08159db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16fe243431c514ef8977f7c20340887" id="r_ae16fe243431c514ef8977f7c20340887"><td class="memItemLeft" align="right" valign="top"><a id="ae16fe243431c514ef8977f7c20340887" name="ae16fe243431c514ef8977f7c20340887"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>NumGlobalPoints</b> () const</td></tr>
<tr class="memdesc:ae16fe243431c514ef8977f7c20340887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of global points for this map; equals the sum of all element sizes across all processors. <br /></td></tr>
<tr class="separator:ae16fe243431c514ef8977f7c20340887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f1a5188c0ab7e21ab12a1e67d4432e" id="r_ad6f1a5188c0ab7e21ab12a1e67d4432e"><td class="memItemLeft" align="right" valign="top"><a id="ad6f1a5188c0ab7e21ab12a1e67d4432e" name="ad6f1a5188c0ab7e21ab12a1e67d4432e"></a>
long long&#160;</td><td class="memItemRight" valign="bottom"><b>NumGlobalPoints64</b> () const</td></tr>
<tr class="separator:ad6f1a5188c0ab7e21ab12a1e67d4432e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abeb174d2076c8f0a55c2d14643a520" id="r_a6abeb174d2076c8f0a55c2d14643a520"><td class="memItemLeft" align="right" valign="top"><a id="a6abeb174d2076c8f0a55c2d14643a520" name="a6abeb174d2076c8f0a55c2d14643a520"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>NumMyPoints</b> () const</td></tr>
<tr class="memdesc:a6abeb174d2076c8f0a55c2d14643a520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of local points for this map; equals the sum of all element sizes on the calling processor. <br /></td></tr>
<tr class="separator:a6abeb174d2076c8f0a55c2d14643a520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e1ef9841ad6e7671f9d78b984b2d15" id="r_a29e1ef9841ad6e7671f9d78b984b2d15"><td class="memItemLeft" align="right" valign="top"><a id="a29e1ef9841ad6e7671f9d78b984b2d15" name="a29e1ef9841ad6e7671f9d78b984b2d15"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MinMyElementSize</b> () const</td></tr>
<tr class="memdesc:a29e1ef9841ad6e7671f9d78b984b2d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum element size on the calling processor. <br /></td></tr>
<tr class="separator:a29e1ef9841ad6e7671f9d78b984b2d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6ed1fadd1a64d1c98c9abf34c25478" id="r_a9a6ed1fadd1a64d1c98c9abf34c25478"><td class="memItemLeft" align="right" valign="top"><a id="a9a6ed1fadd1a64d1c98c9abf34c25478" name="a9a6ed1fadd1a64d1c98c9abf34c25478"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MaxMyElementSize</b> () const</td></tr>
<tr class="memdesc:a9a6ed1fadd1a64d1c98c9abf34c25478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum element size on the calling processor. <br /></td></tr>
<tr class="separator:a9a6ed1fadd1a64d1c98c9abf34c25478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3293b5d058ff520bf38b3fa098ca929" id="r_ab3293b5d058ff520bf38b3fa098ca929"><td class="memItemLeft" align="right" valign="top"><a id="ab3293b5d058ff520bf38b3fa098ca929" name="ab3293b5d058ff520bf38b3fa098ca929"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MinElementSize</b> () const</td></tr>
<tr class="memdesc:ab3293b5d058ff520bf38b3fa098ca929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum element size across all processors. <br /></td></tr>
<tr class="separator:ab3293b5d058ff520bf38b3fa098ca929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acd6c39420651c31e12b1a702f66598" id="r_a1acd6c39420651c31e12b1a702f66598"><td class="memItemLeft" align="right" valign="top"><a id="a1acd6c39420651c31e12b1a702f66598" name="a1acd6c39420651c31e12b1a702f66598"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MaxElementSize</b> () const</td></tr>
<tr class="memdesc:a1acd6c39420651c31e12b1a702f66598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum element size across all processors. <br /></td></tr>
<tr class="separator:a1acd6c39420651c31e12b1a702f66598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous boolean tests</div></td></tr>
<tr class="memitem:a9b7edc72eafa284a4845467d4dd8b5c5" id="r_a9b7edc72eafa284a4845467d4dd8b5c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__BlockMap.html#a9b7edc72eafa284a4845467d4dd8b5c5">UniqueGIDs</a> () const</td></tr>
<tr class="memdesc:a9b7edc72eafa284a4845467d4dd8b5c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if map GIDs are 1-to-1.  <br /></td></tr>
<tr class="separator:a9b7edc72eafa284a4845467d4dd8b5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8848ab5b0aec1878105a1ccbcdd6a0" id="r_aad8848ab5b0aec1878105a1ccbcdd6a0"><td class="memItemLeft" align="right" valign="top"><a id="aad8848ab5b0aec1878105a1ccbcdd6a0" name="aad8848ab5b0aec1878105a1ccbcdd6a0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GlobalIndicesInt</b> () const</td></tr>
<tr class="memdesc:aad8848ab5b0aec1878105a1ccbcdd6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if map create with int NumGlobalElements. <br /></td></tr>
<tr class="separator:aad8848ab5b0aec1878105a1ccbcdd6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3044582eb75fd3c51cc00c14abdbb20" id="r_af3044582eb75fd3c51cc00c14abdbb20"><td class="memItemLeft" align="right" valign="top"><a id="af3044582eb75fd3c51cc00c14abdbb20" name="af3044582eb75fd3c51cc00c14abdbb20"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GlobalIndicesLongLong</b> () const</td></tr>
<tr class="memdesc:af3044582eb75fd3c51cc00c14abdbb20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if map create with long long NumGlobalElements. <br /></td></tr>
<tr class="separator:af3044582eb75fd3c51cc00c14abdbb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27332b60080cf1d679dab2e227134b0d" id="r_a27332b60080cf1d679dab2e227134b0d"><td class="memTemplParams" colspan="2"><a id="a27332b60080cf1d679dab2e227134b0d" name="a27332b60080cf1d679dab2e227134b0d"></a>
template&lt;typename int_type &gt; </td></tr>
<tr class="memitem:a27332b60080cf1d679dab2e227134b0d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GlobalIndicesIsType</b> () const</td></tr>
<tr class="separator:a27332b60080cf1d679dab2e227134b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e175f60e112da148a7b5ad7de3afb17" id="r_a4e175f60e112da148a7b5ad7de3afb17"><td class="memItemLeft" align="right" valign="top"><a id="a4e175f60e112da148a7b5ad7de3afb17" name="a4e175f60e112da148a7b5ad7de3afb17"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GlobalIndicesTypeValid</b> () const</td></tr>
<tr class="separator:a4e175f60e112da148a7b5ad7de3afb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fb1adc8baff2b6bf8f89d8e36847fb" id="r_a48fb1adc8baff2b6bf8f89d8e36847fb"><td class="memItemLeft" align="right" valign="top"><a id="a48fb1adc8baff2b6bf8f89d8e36847fb" name="a48fb1adc8baff2b6bf8f89d8e36847fb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GlobalIndicesTypeMatch</b> (const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;other) const</td></tr>
<tr class="separator:a48fb1adc8baff2b6bf8f89d8e36847fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb6071af4d976639eb0fef6354c4267" id="r_abfb6071af4d976639eb0fef6354c4267"><td class="memItemLeft" align="right" valign="top"><a id="abfb6071af4d976639eb0fef6354c4267" name="abfb6071af4d976639eb0fef6354c4267"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ConstantElementSize</b> () const</td></tr>
<tr class="memdesc:abfb6071af4d976639eb0fef6354c4267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if map has constant element size. <br /></td></tr>
<tr class="separator:abfb6071af4d976639eb0fef6354c4267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a90c00ae92c719b863a2b57cd48850b" id="r_a2a90c00ae92c719b863a2b57cd48850b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__BlockMap.html#a2a90c00ae92c719b863a2b57cd48850b">SameBlockMapDataAs</a> (const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;Map) const</td></tr>
<tr class="separator:a2a90c00ae92c719b863a2b57cd48850b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2417dee2f2a187fb0e86a5701ac2f0d" id="r_aa2417dee2f2a187fb0e86a5701ac2f0d"><td class="memItemLeft" align="right" valign="top"><a id="aa2417dee2f2a187fb0e86a5701ac2f0d" name="aa2417dee2f2a187fb0e86a5701ac2f0d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>SameAs</b> (const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;Map) const</td></tr>
<tr class="memdesc:aa2417dee2f2a187fb0e86a5701ac2f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <em>this</em> and Map are identical maps. <br /></td></tr>
<tr class="separator:aa2417dee2f2a187fb0e86a5701ac2f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf3d7bcc7ad8b59bb5d9ec1658bb3a9" id="r_a1cf3d7bcc7ad8b59bb5d9ec1658bb3a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__BlockMap.html#a1cf3d7bcc7ad8b59bb5d9ec1658bb3a9">PointSameAs</a> (const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;Map) const</td></tr>
<tr class="memdesc:a1cf3d7bcc7ad8b59bb5d9ec1658bb3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <em>this</em> and Map have identical point-wise structure.  <br /></td></tr>
<tr class="separator:a1cf3d7bcc7ad8b59bb5d9ec1658bb3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8f51710701a1f1e18b5354877d4972" id="r_a7e8f51710701a1f1e18b5354877d4972"><td class="memItemLeft" align="right" valign="top"><a id="a7e8f51710701a1f1e18b5354877d4972" name="a7e8f51710701a1f1e18b5354877d4972"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>LinearMap</b> () const</td></tr>
<tr class="memdesc:a7e8f51710701a1f1e18b5354877d4972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the global ID space is contiguously divided (but not necessarily uniformly) across all processors. <br /></td></tr>
<tr class="separator:a7e8f51710701a1f1e18b5354877d4972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d4351dab5b7e3d93670b48b679cffc" id="r_a66d4351dab5b7e3d93670b48b679cffc"><td class="memItemLeft" align="right" valign="top"><a id="a66d4351dab5b7e3d93670b48b679cffc" name="a66d4351dab5b7e3d93670b48b679cffc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>DistributedGlobal</b> () const</td></tr>
<tr class="memdesc:a66d4351dab5b7e3d93670b48b679cffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if map is defined across more than one processor. <br /></td></tr>
<tr class="separator:a66d4351dab5b7e3d93670b48b679cffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Array accessor functions</div></td></tr>
<tr class="memitem:acd4b760f215b5fd86107b649eb568c48" id="r_acd4b760f215b5fd86107b649eb568c48"><td class="memItemLeft" align="right" valign="top"><a id="acd4b760f215b5fd86107b649eb568c48" name="acd4b760f215b5fd86107b649eb568c48"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><b>MyGlobalElements</b> () const</td></tr>
<tr class="memdesc:acd4b760f215b5fd86107b649eb568c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to internal array containing list of global IDs assigned to the calling processor. <br /></td></tr>
<tr class="separator:acd4b760f215b5fd86107b649eb568c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a5d3b6b7cd04e97cfbe758e6e06d2d" id="r_a21a5d3b6b7cd04e97cfbe758e6e06d2d"><td class="memItemLeft" align="right" valign="top"><a id="a21a5d3b6b7cd04e97cfbe758e6e06d2d" name="a21a5d3b6b7cd04e97cfbe758e6e06d2d"></a>
long long *&#160;</td><td class="memItemRight" valign="bottom"><b>MyGlobalElements64</b> () const</td></tr>
<tr class="separator:a21a5d3b6b7cd04e97cfbe758e6e06d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe83505c532a4766b1dd5bbad2561a1" id="r_aabe83505c532a4766b1dd5bbad2561a1"><td class="memItemLeft" align="right" valign="top"><a id="aabe83505c532a4766b1dd5bbad2561a1" name="aabe83505c532a4766b1dd5bbad2561a1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MyGlobalElements</b> (const int *&amp;IntGIDs, const long long *&amp;LLGIDs) const</td></tr>
<tr class="separator:aabe83505c532a4766b1dd5bbad2561a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969e881c68b6b020bea77bfab381b7a4" id="r_a969e881c68b6b020bea77bfab381b7a4"><td class="memItemLeft" align="right" valign="top"><a id="a969e881c68b6b020bea77bfab381b7a4" name="a969e881c68b6b020bea77bfab381b7a4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MyGlobalElements</b> (int *&amp;IntGIDs, long long *&amp;LLGIDs)</td></tr>
<tr class="separator:a969e881c68b6b020bea77bfab381b7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9656f504b645c02dc262e2ddac4940c1" id="r_a9656f504b645c02dc262e2ddac4940c1"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__BlockMap.html#a9656f504b645c02dc262e2ddac4940c1">FirstPointInElementList</a> () const</td></tr>
<tr class="memdesc:a9656f504b645c02dc262e2ddac4940c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to internal array containing a mapping between the local elements and the first local point number in each element.  <br /></td></tr>
<tr class="separator:a9656f504b645c02dc262e2ddac4940c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515b2e0528c74147c94300b41c733440" id="r_a515b2e0528c74147c94300b41c733440"><td class="memItemLeft" align="right" valign="top"><a id="a515b2e0528c74147c94300b41c733440" name="a515b2e0528c74147c94300b41c733440"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><b>ElementSizeList</b> () const</td></tr>
<tr class="memdesc:a515b2e0528c74147c94300b41c733440"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of the element sizes corresponding to the array <a class="el" href="classEpetra__BlockMap.html#a1f6ef71a397909d0219167b339eb3164" title="Puts list of global elements on this processor into the user-provided array.">MyGlobalElements()</a>. <br /></td></tr>
<tr class="separator:a515b2e0528c74147c94300b41c733440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53783efdb17f76d177d4454c9a5fa649" id="r_a53783efdb17f76d177d4454c9a5fa649"><td class="memItemLeft" align="right" valign="top"><a id="a53783efdb17f76d177d4454c9a5fa649" name="a53783efdb17f76d177d4454c9a5fa649"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><b>PointToElementList</b> () const</td></tr>
<tr class="memdesc:a53783efdb17f76d177d4454c9a5fa649"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each local point, indicates the local element ID that the point belongs to. <br /></td></tr>
<tr class="separator:a53783efdb17f76d177d4454c9a5fa649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af652e2edb115d91cb9b9c8de0b911713" id="r_af652e2edb115d91cb9b9c8de0b911713"><td class="memItemLeft" align="right" valign="top"><a id="af652e2edb115d91cb9b9c8de0b911713" name="af652e2edb115d91cb9b9c8de0b911713"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ElementSizeList</b> (int *ElementSizeList) const</td></tr>
<tr class="memdesc:af652e2edb115d91cb9b9c8de0b911713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classEpetra__BlockMap.html#a515b2e0528c74147c94300b41c733440" title="List of the element sizes corresponding to the array MyGlobalElements().">ElementSizeList()</a> except it fills the user array that is passed in. <br /></td></tr>
<tr class="separator:af652e2edb115d91cb9b9c8de0b911713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b539d91f27c6b0afadcc0a2a1afae4" id="r_ad7b539d91f27c6b0afadcc0a2a1afae4"><td class="memItemLeft" align="right" valign="top"><a id="ad7b539d91f27c6b0afadcc0a2a1afae4" name="ad7b539d91f27c6b0afadcc0a2a1afae4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>FirstPointInElementList</b> (int *FirstPointInElementList) const</td></tr>
<tr class="memdesc:ad7b539d91f27c6b0afadcc0a2a1afae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classEpetra__BlockMap.html#a9656f504b645c02dc262e2ddac4940c1" title="Pointer to internal array containing a mapping between the local elements and the first local point n...">FirstPointInElementList()</a> except it fills the user array that is passed in. <br /></td></tr>
<tr class="separator:ad7b539d91f27c6b0afadcc0a2a1afae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f526958011024b38dcac0eed1645f5c" id="r_a8f526958011024b38dcac0eed1645f5c"><td class="memItemLeft" align="right" valign="top"><a id="a8f526958011024b38dcac0eed1645f5c" name="a8f526958011024b38dcac0eed1645f5c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>PointToElementList</b> (int *PointToElementList) const</td></tr>
<tr class="memdesc:a8f526958011024b38dcac0eed1645f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classEpetra__BlockMap.html#a53783efdb17f76d177d4454c9a5fa649" title="For each local point, indicates the local element ID that the point belongs to.">PointToElementList()</a> except it fills the user array that is passed in. <br /></td></tr>
<tr class="separator:a8f526958011024b38dcac0eed1645f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous</div></td></tr>
<tr class="memitem:a0525899b954213a2901eaf06dce855b9" id="r_a0525899b954213a2901eaf06dce855b9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__BlockMap.html#a0525899b954213a2901eaf06dce855b9">Print</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:a0525899b954213a2901eaf06dce855b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print object to an output stream.  <br /></td></tr>
<tr class="separator:a0525899b954213a2901eaf06dce855b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9d6c774319c3bb5e79039058416a92" id="r_abd9d6c774319c3bb5e79039058416a92"><td class="memItemLeft" align="right" valign="top"><a id="abd9d6c774319c3bb5e79039058416a92" name="abd9d6c774319c3bb5e79039058416a92"></a>
const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Comm</b> () const</td></tr>
<tr class="memdesc:abd9d6c774319c3bb5e79039058416a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> communicator. <br /></td></tr>
<tr class="separator:abd9d6c774319c3bb5e79039058416a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01b6465f8f8177a2323fcc8d9d29ec9" id="r_ad01b6465f8f8177a2323fcc8d9d29ec9"><td class="memItemLeft" align="right" valign="top"><a id="ad01b6465f8f8177a2323fcc8d9d29ec9" name="ad01b6465f8f8177a2323fcc8d9d29ec9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsOneToOne</b> () const</td></tr>
<tr class="separator:ad01b6465f8f8177a2323fcc8d9d29ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c16e9e5f1f6b9f45443f3350fe3a8b6" id="r_a6c16e9e5f1f6b9f45443f3350fe3a8b6"><td class="memItemLeft" align="right" valign="top"><a id="a6c16e9e5f1f6b9f45443f3350fe3a8b6" name="a6c16e9e5f1f6b9f45443f3350fe3a8b6"></a>
<a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;map)</td></tr>
<tr class="memdesc:a6c16e9e5f1f6b9f45443f3350fe3a8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment Operator. <br /></td></tr>
<tr class="separator:a6c16e9e5f1f6b9f45443f3350fe3a8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__Object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__Object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__Object.html">Epetra_Object</a></td></tr>
<tr class="memitem:a7676631aca0d619c4e8d3e877c2b87a2 inherit pub_methods_classEpetra__Object" id="r_a7676631aca0d619c4e8d3e877c2b87a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a7676631aca0d619c4e8d3e877c2b87a2">Epetra_Object</a> (int TracebackModeIn=-1, bool set_label=true)</td></tr>
<tr class="memdesc:a7676631aca0d619c4e8d3e877c2b87a2 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Constructor.  <br /></td></tr>
<tr class="separator:a7676631aca0d619c4e8d3e877c2b87a2 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf156d9c8874a2a455ec305826c7313f inherit pub_methods_classEpetra__Object" id="r_acf156d9c8874a2a455ec305826c7313f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#acf156d9c8874a2a455ec305826c7313f">Epetra_Object</a> (const char *const <a class="el" href="classEpetra__Object.html#a1910d1c04e70ac482f7e377b271f6c26">Label</a>, int TracebackModeIn=-1)</td></tr>
<tr class="memdesc:acf156d9c8874a2a455ec305826c7313f inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Constructor.  <br /></td></tr>
<tr class="separator:acf156d9c8874a2a455ec305826c7313f inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f8bd631f2a97276ea07cea8c9c7057 inherit pub_methods_classEpetra__Object" id="r_ac5f8bd631f2a97276ea07cea8c9c7057"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#ac5f8bd631f2a97276ea07cea8c9c7057">Epetra_Object</a> (const <a class="el" href="classEpetra__Object.html">Epetra_Object</a> &amp;Object)</td></tr>
<tr class="memdesc:ac5f8bd631f2a97276ea07cea8c9c7057 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Copy Constructor.  <br /></td></tr>
<tr class="separator:ac5f8bd631f2a97276ea07cea8c9c7057 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742c256d523738e458d0256f72ba9e4b inherit pub_methods_classEpetra__Object" id="r_a742c256d523738e458d0256f72ba9e4b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a742c256d523738e458d0256f72ba9e4b">~Epetra_Object</a> ()</td></tr>
<tr class="memdesc:a742c256d523738e458d0256f72ba9e4b inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Destructor.  <br /></td></tr>
<tr class="separator:a742c256d523738e458d0256f72ba9e4b inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff5c5266120410acbe6ccb63734b5c8 inherit pub_methods_classEpetra__Object" id="r_a9ff5c5266120410acbe6ccb63734b5c8"><td class="memItemLeft" align="right" valign="top">
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>ReportError</b> (const std::string Message, int ErrorCode) const</td></tr>
<tr class="memdesc:a9ff5c5266120410acbe6ccb63734b5c8 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error reporting method. <br /></td></tr>
<tr class="separator:a9ff5c5266120410acbe6ccb63734b5c8 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049c5235b19bd286f95914b547b9f528 inherit pub_methods_classEpetra__Object" id="r_a049c5235b19bd286f95914b547b9f528"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a049c5235b19bd286f95914b547b9f528">SetLabel</a> (const char *const <a class="el" href="classEpetra__Object.html#a1910d1c04e70ac482f7e377b271f6c26">Label</a>)</td></tr>
<tr class="memdesc:a049c5235b19bd286f95914b547b9f528 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Label definition using char *.  <br /></td></tr>
<tr class="separator:a049c5235b19bd286f95914b547b9f528 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1910d1c04e70ac482f7e377b271f6c26 inherit pub_methods_classEpetra__Object" id="r_a1910d1c04e70ac482f7e377b271f6c26"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a1910d1c04e70ac482f7e377b271f6c26">Label</a> () const</td></tr>
<tr class="memdesc:a1910d1c04e70ac482f7e377b271f6c26 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Label access funtion.  <br /></td></tr>
<tr class="separator:a1910d1c04e70ac482f7e377b271f6c26 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac3372eb5708115b3095f01b37e6c1815" id="r_ac3372eb5708115b3095f01b37e6c1815"><td class="memItemLeft" align="right" valign="top"><a id="ac3372eb5708115b3095f01b37e6c1815" name="ac3372eb5708115b3095f01b37e6c1815"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_Directory</b></td></tr>
<tr class="separator:ac3372eb5708115b3095f01b37e6c1815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce93d8ef91ad3ef3d550c2bc25e7c10" id="r_a8ce93d8ef91ad3ef3d550c2bc25e7c10"><td class="memItemLeft" align="right" valign="top"><a id="a8ce93d8ef91ad3ef3d550c2bc25e7c10" name="a8ce93d8ef91ad3ef3d550c2bc25e7c10"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_LocalMap</b></td></tr>
<tr class="separator:a8ce93d8ef91ad3ef3d550c2bc25e7c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Expert Users and Developers Only</h2></td></tr>
<tr class="memitem:a88105ec1d2085d7d0f33ccfc0b19e69f" id="r_a88105ec1d2085d7d0f33ccfc0b19e69f"><td class="memItemLeft" align="right" valign="top"><a id="a88105ec1d2085d7d0f33ccfc0b19e69f" name="a88105ec1d2085d7d0f33ccfc0b19e69f"></a>
<a class="el" href="classEpetra__BlockMapData.html">Epetra_BlockMapData</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>BlockMapData_</b></td></tr>
<tr class="separator:a88105ec1d2085d7d0f33ccfc0b19e69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744937f28dfd5a848d4a56e86a9d9176" id="r_a744937f28dfd5a848d4a56e86a9d9176"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__BlockMap.html#a744937f28dfd5a848d4a56e86a9d9176">ReferenceCount</a> () const</td></tr>
<tr class="memdesc:a744937f28dfd5a848d4a56e86a9d9176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reference count of BlockMapData.  <br /></td></tr>
<tr class="separator:a744937f28dfd5a848d4a56e86a9d9176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23a7f6139fbf16100970671b578861b" id="r_ac23a7f6139fbf16100970671b578861b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEpetra__BlockMapData.html">Epetra_BlockMapData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__BlockMap.html#ac23a7f6139fbf16100970671b578861b">DataPtr</a> () const</td></tr>
<tr class="memdesc:ac23a7f6139fbf16100970671b578861b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the BlockMapData instance this BlockMap uses.  <br /></td></tr>
<tr class="separator:ac23a7f6139fbf16100970671b578861b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6546269d6f644cd94622415e1490fcc" id="r_af6546269d6f644cd94622415e1490fcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__BlockMap.html#af6546269d6f644cd94622415e1490fcc">RemoveEmptyProcesses</a> () const</td></tr>
<tr class="memdesc:af6546269d6f644cd94622415e1490fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new BlockMap with processes with zero elements removed.  <br /></td></tr>
<tr class="separator:af6546269d6f644cd94622415e1490fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5dbbf0d7527627e29ccc7d02a19342d" id="r_ab5dbbf0d7527627e29ccc7d02a19342d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__BlockMap.html#ab5dbbf0d7527627e29ccc7d02a19342d">ReplaceCommWithSubset</a> (const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> *<a class="el" href="classEpetra__BlockMap.html#abd9d6c774319c3bb5e79039058416a92">Comm</a>) const</td></tr>
<tr class="memdesc:ab5dbbf0d7527627e29ccc7d02a19342d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace this BlockMap's communicator with a subset communicator.  <br /></td></tr>
<tr class="separator:ab5dbbf0d7527627e29ccc7d02a19342d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec89fefa5cc46e08d3973c5c3da6ba8e" id="r_aec89fefa5cc46e08d3973c5c3da6ba8e"><td class="memItemLeft" align="right" valign="top"><a id="aec89fefa5cc46e08d3973c5c3da6ba8e" name="aec89fefa5cc46e08d3973c5c3da6ba8e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CleanupData</b> ()</td></tr>
<tr class="separator:aec89fefa5cc46e08d3973c5c3da6ba8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classEpetra__Object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classEpetra__Object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classEpetra__Object.html">Epetra_Object</a></td></tr>
<tr class="memitem:a3e039dae700d04726e0e78d73b69e7f6 inherit pub_static_methods_classEpetra__Object" id="r_a3e039dae700d04726e0e78d73b69e7f6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a3e039dae700d04726e0e78d73b69e7f6">SetTracebackMode</a> (int TracebackModeValue)</td></tr>
<tr class="memdesc:a3e039dae700d04726e0e78d73b69e7f6 inherit pub_static_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the <a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> error traceback report mode.  <br /></td></tr>
<tr class="separator:a3e039dae700d04726e0e78d73b69e7f6 inherit pub_static_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20914bd9b7bb7278ab332415c77ba999 inherit pub_static_methods_classEpetra__Object" id="r_a20914bd9b7bb7278ab332415c77ba999"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><b>GetTracebackMode</b> ()</td></tr>
<tr class="memdesc:a20914bd9b7bb7278ab332415c77ba999 inherit pub_static_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the <a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> error report mode. <br /></td></tr>
<tr class="separator:a20914bd9b7bb7278ab332415c77ba999 inherit pub_static_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661d6081fb13e1b4a4350faa88808f38 inherit pub_static_methods_classEpetra__Object" id="r_a661d6081fb13e1b4a4350faa88808f38"><td class="memItemLeft" align="right" valign="top">
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetTracebackStream</b> ()</td></tr>
<tr class="memdesc:a661d6081fb13e1b4a4350faa88808f38 inherit pub_static_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the output stream for error reporting. <br /></td></tr>
<tr class="separator:a661d6081fb13e1b4a4350faa88808f38 inherit pub_static_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classEpetra__Object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classEpetra__Object')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classEpetra__Object.html">Epetra_Object</a></td></tr>
<tr class="memitem:abcc693a0058b9910543df8c4ae76e5d9 inherit pub_static_attribs_classEpetra__Object" id="r_abcc693a0058b9910543df8c4ae76e5d9"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><b>TracebackMode</b></td></tr>
<tr class="separator:abcc693a0058b9910543df8c4ae76e5d9 inherit pub_static_attribs_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classEpetra__Object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classEpetra__Object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classEpetra__Object.html">Epetra_Object</a></td></tr>
<tr class="memitem:a4e3832c165d22a45d3dd6fecd16d91f4 inherit pro_methods_classEpetra__Object" id="r_a4e3832c165d22a45d3dd6fecd16d91f4"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (const int &amp;x) const</td></tr>
<tr class="separator:a4e3832c165d22a45d3dd6fecd16d91f4 inherit pro_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3f57c8b22b5b0df91400fca8447ab2 inherit pro_methods_classEpetra__Object" id="r_aaa3f57c8b22b5b0df91400fca8447ab2"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (const long long &amp;x) const</td></tr>
<tr class="separator:aaa3f57c8b22b5b0df91400fca8447ab2 inherit pro_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a2fa958fffb21a0479a19956185be1 inherit pro_methods_classEpetra__Object" id="r_ab8a2fa958fffb21a0479a19956185be1"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (const double &amp;x) const</td></tr>
<tr class="separator:ab8a2fa958fffb21a0479a19956185be1 inherit pro_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a>: A class for partitioning block element vectors and matrices. </p>
<p>It is often the case that multiple matrix and vector objects have an identical distribution of elements on a parallel machine. The <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> class keeps information that describes this distribution for matrices and vectors that have block elements. The definition of an element can vary depending on the situation. For vectors (and multi-vectors), an element is a span of one or more contiguous entries. For matrices, it is a span of one or more matrix rows. More generally, an element in the BlockMap class is an ordered list of points. (NOTE: Points do not have global ID's.) Two additional definitions useful in understanding the BlockMap class follow: </p><ul>
<li>
BlockMap - A distributed ordered list of elements. </li>
<li>
First Point - First ordered point in an element </li>
</ul>
<p>This class has a variety of constructors that can be separated into two categories: </p><ol>
<li>
Fixed element size constructors: All map elements have an identical size. This corresponds to a block partitioning of matrices and vectors where the element size is the same for all elements. A common example is multiple degrees of freedom per mesh node in finite element computations where the number of degrees of freedom is the same for all nodes. </li>
<li>
Variable element size constructor: Map element sizes may vary and are individually defined via a list of element sizes. This is the most general case and corresponds to a variable block partitioning of the matrices and vectors. A common example is multiple degrees of freedom per mesh node in finite element computations where the number of degrees of freedom varies. This happens, for example, if regions have differing material types or there are chemical reactions in the simulation. </li>
</ol>
<p><a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> allows the storage and retrieval of the following information. Depending on the constructor that is used, some of the information is defined by the user and some is determined by the constructor. Once an <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> is constructed any of the following can be obtained by calling a query function that has the same name as the attribute, e.g. to get the value of NumGlobalElements, you can call a function <a class="el" href="classEpetra__BlockMap.html#abc70320a09789d1bf51871c5262ed835" title="Number of elements across all processors.">NumGlobalElements()</a>. For attributes that are lists, the query functions return the list values in a user allocated array.</p>
<ul>
<li>
NumGlobalElements - The total number of elements across all processors. If this parameter and NumMyElements are both passed in to the constructor, one of the three cases will apply: <ol>
<li>
If NumGlobalElements = NumMyElements (and not equal to zero) the map is defined to be a local replicated map. In this case, objects constructed using this map will be identically replicated across all processors in the communicator. </li>
<li>
If NumGlobalElements = -1 and NumMyElements is passed in then NumGlobalElements will be computed as the sum of NumMyElements across all processors. </li>
<li>
If neither of the above is true, NumGlobalElements will be checked against the sum of NumMyElements across all processors. An error is issued if the comparison is not equal. </li>
</ol>
</li>
<li>
NumMyElements - The number of elements owned by the calling processor. </li>
<li>
MyGlobalElements - A list of length NumMyElements that contains the global element IDs of the elements owned by the calling processor. </li>
<li>
ElementSize - The size of elements if the size of all elements is the same. This will be the case if the query function <a class="el" href="classEpetra__BlockMap.html#abfb6071af4d976639eb0fef6354c4267" title="Returns true if map has constant element size.">ConstantElementSize()</a> returns true. Otherwise this value will be set to zero. </li>
<li>
ElementSizeList - A list of the element sizes for elements owned by the calling processor. This list is always accessible, even if the element sizes are all one or of constant value. However, in these cases, the ElementSizeList will not be generated unless a query for the list is called. </li>
<li>
IndexBase - The base integer value for indexed array references. Typically this is 0 for C/C++ and 1 for Fortran, but it can be set to any integer value. </li>
<li>
Comm - The <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> communicator. This communicator can in turn be queried for processor rank and size information. </li>
</ul>
<p>In addition to the information above that is passed in to or created by the <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> constructor, the following attributes are computed and available via query to the user using the same scheme as above, e.g., use <a class="el" href="classEpetra__BlockMap.html#ae16fe243431c514ef8977f7c20340887" title="Number of global points for this map; equals the sum of all element sizes across all processors.">NumGlobalPoints()</a> to get the value of NumGlobalPoints.</p>
<ul>
<li>
NumGlobalPoints - The total number of points across all processors. </li>
<li>
NumMyPoints - The number of points on the calling processor. </li>
<li>
MinAllGID - The minimum global index value across all processors. </li>
<li>
MaxAllGID - The maximum global index value across all processors. </li>
<li>
MinMyGID - The minimum global index value on the calling processor. </li>
<li>
MaxMyGID - The maximum global index value on the calling processor. </li>
<li>
MinLID - The minimum local index value on the calling processor. </li>
<li>
MaxLID - The maximum local index value on the calling processor. </li>
<li>
MinElementSize - The minimum element size across all processors. </li>
<li>
MaxElementSize - The maximum element size across all processors. </li>
</ul>
<p>The following functions allow boolean tests for certain properties.</p>
<ul>
<li>
<a class="el" href="classEpetra__BlockMap.html#abfb6071af4d976639eb0fef6354c4267" title="Returns true if map has constant element size.">ConstantElementSize()</a> - Returns true if the element size for this map is the same for all elements. </li>
<li>
<a class="el" href="classEpetra__BlockMap.html#a7e8f51710701a1f1e18b5354877d4972" title="Returns true if the global ID space is contiguously divided (but not necessarily uniformly) across al...">LinearMap()</a> - Returns true if the elements are distributed linear across processors, i.e., processor 0 gets the first n/p elements, processor 1 gets the next n/p elements, etc. where n is the number of elements and p is the number of processors. </li>
<li>
<a class="el" href="classEpetra__BlockMap.html#a66d4351dab5b7e3d93670b48b679cffc" title="Returns true if map is defined across more than one processor.">DistributedGlobal()</a> - Returns true if the element space of the map spans more than one processor. This will be true in most cases, but will be false on in serial and for objects that are created via the derived <a class="el" href="classEpetra__LocalMap.html" title="Epetra_LocalMap: A class for replicating vectors and matrices across multiple processors.">Epetra_LocalMap</a> class. </li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>A <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> object is required for all <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> constructors.</dd></dl>
<p><b>error handling</b></p>
<p>Most methods in <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> return an integer error code. If the error code is 0, then no error occurred. If &gt; 0 then a warning error occurred. If &lt; 0 then a fatal error occurred.</p>
<p><a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> constructors will throw an exception of an error occurrs. These exceptions will alway be negative integer values as follows: </p><ol>
<li>
-1 NumGlobalElements &lt; -1. Should be &gt;= -1 (Should be &gt;= 0 for first BlockMap constructor). </li>
<li>
-2 NumMyElements &lt; 0. Should be &gt;= 0. </li>
<li>
-3 ElementSize &lt;= 0. Should be &gt; 0. </li>
<li>
-4 Invalid NumGlobalElements. Should equal sum of MyGlobalElements, or set to -1 to compute automatically. </li>
<li>
-5 Minimum global element index is less than index base. </li>
<li>
-99 Internal <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> error. Contact developer. </li>
</ol>
<p>For robust code, <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> constructor calls should be caught using the try {...} catch {...} mechanism. For example:</p>
<pre class="fragment">  try {

    Epetra_BlockMap * map = new Epetra_BlockMap(NumGlobalElements, ElementSize, IndexBase, Comm);
  }
  catch (int Error) {
    if (Error==-1) { // handle error }
    if (Error==-2) ...
</pre><dl class="section note"><dt>Note</dt><dd>{ In the current implementation, <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> is the base class for: <ul>
<li>
<a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a>. </li>
<li>
Epetra_LocalBlockMap. </li>
</ul>
} </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5941203fc98a8d9bdb79a32d070b4583" name="a5941203fc98a8d9bdb79a32d070b4583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5941203fc98a8d9bdb79a32d070b4583">&#9670;&#160;</a></span>Epetra_BlockMap() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_BlockMap::Epetra_BlockMap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumGlobalElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ElementSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>IndexBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>Comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> constructor for a Epetra-defined uniform linear distribution of constant size elements. </p>
<p>Creates a map that distributes NumGlobalElements elements evenly across all processors in the <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> communicator. If NumGlobalElements does not divide exactly into the number of processors, the first processors in the communicator get one extra element until the remainder is gone.</p>
<p>The elements are defined to have a constant fixed size specified by ElementSize.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>NumGlobalElements - Number of elements to distribute.</td></tr>
    <tr><td class="paramname">In</td><td>ElementSize - Number of points or vector entries per element.</td></tr>
    <tr><td class="paramname">In</td><td>IndexBase - Minimum index value used for arrays that use this map. Typically 0 for C/C++ and 1 for Fortran.</td></tr>
    <tr><td class="paramname">In</td><td>Comm - <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> communicator containing information on the number of processors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> object. </dd></dl>

</div>
</div>
<a id="aa41066a9457d18d8bf5c64c873a95480" name="aa41066a9457d18d8bf5c64c873a95480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41066a9457d18d8bf5c64c873a95480">&#9670;&#160;</a></span>Epetra_BlockMap() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_BlockMap::Epetra_BlockMap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumGlobalElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumMyElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ElementSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>IndexBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>Comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> constructor for a user-defined linear distribution of constant size elements. </p>
<p>Creates a map that puts NumMyElements on the calling processor. If NumGlobalElements=-1, the number of global elements will be the computed sum of NumMyElements across all processors in the <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> communicator.</p>
<p>The elements are defined to have a constant fixed size specified by ElementSize.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>NumGlobalElements - Number of elements to distribute. Must be either -1 or equal to the computed sum of NumMyElements across all processors in the <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> communicator.</td></tr>
    <tr><td class="paramname">In</td><td>NumMyElements - Number of elements owned by the calling processor.</td></tr>
    <tr><td class="paramname">In</td><td>ElementSize - Number of points or vector entries per element.</td></tr>
    <tr><td class="paramname">In</td><td>IndexBase - Minimum index value used for arrays that use this map. Typically 0 for C/C++ and 1 for Fortran.</td></tr>
    <tr><td class="paramname">In</td><td>Comm - <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> communicator containing information on the number of processors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> object. </dd></dl>

</div>
</div>
<a id="afe05ca45ffccf1d037b497702dcc4971" name="afe05ca45ffccf1d037b497702dcc4971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe05ca45ffccf1d037b497702dcc4971">&#9670;&#160;</a></span>Epetra_BlockMap() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_BlockMap::Epetra_BlockMap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumGlobalElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumMyElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>MyGlobalElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ElementSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>IndexBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>Comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> constructor for a user-defined arbitrary distribution of constant size elements. </p>
<p>Creates a map that puts NumMyElements on the calling processor. The indices of the elements are determined from the list MyGlobalElements. If NumGlobalElements=-1, the number of global elements will be the computed sum of NumMyElements across all processors in the <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> communicator.</p>
<p>The elements are defined to have a constant fixed size specified by ElementSize.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>NumGlobalElements - Number of elements to distribute. Must be either -1 or equal to the computed sum of NumMyElements across all processors in the <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> communicator.</td></tr>
    <tr><td class="paramname">In</td><td>NumMyElements - Number of elements owned by the calling processor.</td></tr>
    <tr><td class="paramname">In</td><td>MyGlobalElements - Integer array of length NumMyElements. The ith entry contains the global index value of the ith element on this processor. Index values are not required to be contiguous on a processor, or to be within the range of 0 to NumGlobalElements. As long as the index values are consistently defined and used, any set of NumGlobalElements distinct integer values is acceptable.</td></tr>
    <tr><td class="paramname">In</td><td>ElementSize - Number of points or vector entries per element.</td></tr>
    <tr><td class="paramname">In</td><td>IndexBase - Minimum index value used for arrays that use this map. Typically 0 for C/C++ and 1 for Fortran.</td></tr>
    <tr><td class="paramname">In</td><td>Comm - <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> communicator containing information on the number of processors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> object. </dd></dl>

</div>
</div>
<a id="a911491bf44f662dfba5f74c804480a42" name="a911491bf44f662dfba5f74c804480a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911491bf44f662dfba5f74c804480a42">&#9670;&#160;</a></span>Epetra_BlockMap() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_BlockMap::Epetra_BlockMap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumGlobalElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumMyElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>MyGlobalElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ElementSizeList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>IndexBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>Comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> constructor for a user-defined arbitrary distribution of variable size elements. </p>
<p>Creates a map that puts NumMyElements on the calling processor. If NumGlobalElements=-1, the number of global elements will be the computed sum of NumMyElements across all processors in the <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> communicator.</p>
<p>The elements are defined to have a variable size defined by ElementSizeList.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>NumGlobalElements - Number of elements to distribute. Must be either -1 or equal to the computed sum of NumMyElements across all processors in the <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> communicator.</td></tr>
    <tr><td class="paramname">In</td><td>NumMyElements - Number of elements owned by the calling processor.</td></tr>
    <tr><td class="paramname">In</td><td>MyGlobalElements - Integer array of length NumMyElements. The ith entry contains the global index value of the ith element on this processor. Index values are not required to be contiguous on a processor, or to be within the range of 0 to NumGlobalElements. As long as the index values are consistently defined and used, any set of NumGlobalElements distinct integer values is acceptable.</td></tr>
    <tr><td class="paramname">In</td><td>ElementSizeList - A list of the element sizes for elements owned by the calling processor. The ith entry contains the element size of the ith element on this processor.</td></tr>
    <tr><td class="paramname">In</td><td>IndexBase - Minimum index value used for arrays that use this map. Typically 0 for C/C++ and 1 for Fortran.</td></tr>
    <tr><td class="paramname">In</td><td>Comm - <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> communicator containing information on the number of processors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> object. </dd></dl>

</div>
</div>
<a id="add5e453a9d1231ccfae2f4b2a63c736f" name="add5e453a9d1231ccfae2f4b2a63c736f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5e453a9d1231ccfae2f4b2a63c736f">&#9670;&#160;</a></span>Epetra_BlockMap() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_BlockMap::Epetra_BlockMap </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>NumGlobal_Elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumMy_Elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long *&#160;</td>
          <td class="paramname"><em>myGlobalElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ElementSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indexBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>UserIsDistributedGlobal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>UserMinAllGID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>UserMaxAllGID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> constructor for a user-defined arbitrary distribution of constant size elements, where the user provides all the globals. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method is intended for expert developer use only, and should never be called by user code. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac23a7f6139fbf16100970671b578861b" name="ac23a7f6139fbf16100970671b578861b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23a7f6139fbf16100970671b578861b">&#9670;&#160;</a></span>DataPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEpetra__BlockMapData.html">Epetra_BlockMapData</a> * Epetra_BlockMap::DataPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the BlockMapData instance this BlockMap uses. </p>
<p>(Intended for developer use only for testing purposes.) </p>

</div>
</div>
<a id="adbf56009a4616b5d281c8e4426a9bb71" name="adbf56009a4616b5d281c8e4426a9bb71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf56009a4616b5d281c8e4426a9bb71">&#9670;&#160;</a></span>FirstPointInElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_BlockMap::FirstPointInElement </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>LID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the requested entry in the FirstPointInElementList; see <a class="el" href="classEpetra__BlockMap.html#a9656f504b645c02dc262e2ddac4940c1" title="Pointer to internal array containing a mapping between the local elements and the first local point n...">FirstPointInElementList()</a> for details. </p>
<p>This function provides similar functionality to <a class="el" href="classEpetra__BlockMap.html#a9656f504b645c02dc262e2ddac4940c1" title="Pointer to internal array containing a mapping between the local elements and the first local point n...">FirstPointInElementList()</a>, but for simple maps may avoid the explicit construction of the FirstPointInElementList array. Returns -1 if LID is out-of-range. </p>

</div>
</div>
<a id="a9656f504b645c02dc262e2ddac4940c1" name="a9656f504b645c02dc262e2ddac4940c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9656f504b645c02dc262e2ddac4940c1">&#9670;&#160;</a></span>FirstPointInElementList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int * Epetra_BlockMap::FirstPointInElementList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to internal array containing a mapping between the local elements and the first local point number in each element. </p>
<p>This array is a scan sum of the ElementSizeList such that the ith entry in FirstPointInElementList is the sum of the first i-1 entries of <a class="el" href="classEpetra__BlockMap.html#a515b2e0528c74147c94300b41c733440" title="List of the element sizes corresponding to the array MyGlobalElements().">ElementSizeList()</a>. </p>

</div>
</div>
<a id="a1cf3d7bcc7ad8b59bb5d9ec1658bb3a9" name="a1cf3d7bcc7ad8b59bb5d9ec1658bb3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf3d7bcc7ad8b59bb5d9ec1658bb3a9">&#9670;&#160;</a></span>PointSameAs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Epetra_BlockMap::PointSameAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;&#160;</td>
          <td class="paramname"><em>Map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <em>this</em> and Map have identical point-wise structure. </p>
<p>If both maps have the same number of global points and the same point distribution across processors then this method returns true. </p>

</div>
</div>
<a id="a0525899b954213a2901eaf06dce855b9" name="a0525899b954213a2901eaf06dce855b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0525899b954213a2901eaf06dce855b9">&#9670;&#160;</a></span>Print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Epetra_BlockMap::Print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print object to an output stream. </p>

<p>Reimplemented from <a class="el" href="classEpetra__Object.html#af40e8f4c7d6701b84f741d3158db7c37">Epetra_Object</a>.</p>

</div>
</div>
<a id="a744937f28dfd5a848d4a56e86a9d9176" name="a744937f28dfd5a848d4a56e86a9d9176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744937f28dfd5a848d4a56e86a9d9176">&#9670;&#160;</a></span>ReferenceCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_BlockMap::ReferenceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the reference count of BlockMapData. </p>
<p>(Intended for testing purposes.) </p>

</div>
</div>
<a id="a0adc24b09a0bb734f6750a82ed37493c" name="a0adc24b09a0bb734f6750a82ed37493c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0adc24b09a0bb734f6750a82ed37493c">&#9670;&#160;</a></span>RemoteIDList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_BlockMap::RemoteIDList </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>GIDList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>PIDList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>LIDList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the processor IDs and corresponding local index value for a given list of global indices. </p>
<p>For each element (GID) of a given list of global element numbers (stored in GIDList) of length NumIDs, this function returns (in PIDList) the ID (rank) of the processor that owns the GID for this map and returns the local index (in LIDList) of the GID on that processor.</p>
<p>If a GID is present on more than one processor, the lowest rank processor ID is used, as is the LID for that processor. If a GID is not present on any processor, the corresponding PID will return as -1. </p>

</div>
</div>
<a id="ad2366a59e075efc9974eeb42077b90a6" name="ad2366a59e075efc9974eeb42077b90a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2366a59e075efc9974eeb42077b90a6">&#9670;&#160;</a></span>RemoteIDList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_BlockMap::RemoteIDList </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>GIDList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>PIDList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>LIDList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>SizeList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the processor IDs, corresponding local index value, and element size for a given list of global indices. </p>
<p>For each element (GID) of a given a list of global element numbers (stored in GIDList) of length NumIDs, this function returns (in PIDList) the with processor that owns the GID for this map and returns the local index (in LIDList) of the GID on that processor. Finally it returns the element sizes in SizeList. </p>

</div>
</div>
<a id="af6546269d6f644cd94622415e1490fcc" name="af6546269d6f644cd94622415e1490fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6546269d6f644cd94622415e1490fcc">&#9670;&#160;</a></span>RemoveEmptyProcesses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> * Epetra_BlockMap::RemoveEmptyProcesses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new BlockMap with processes with zero elements removed. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method is only for expert users. Understanding how to use this method correctly requires some familiarity with semantics of MPI communicators.</dd>
<dd>
We make no promises of backwards compatibility for this method. It may go away or change at any time.</dd></dl>
<p>This method first computes a new communicator, which contains only those processes in this Map's communicator (the "original
communicator") that have a nonzero number of elements in this BlockMap (the "original BlockMap"). It then returns a new BlockMap distributed over the new communicator. The new BlockMap represents the same distribution as the original BlockMap, except that processes containing zero elements are not included in the new BlockMap or its communicator. On processes not included in the new BlockMap or communicator, this method returns NULL.</p>
<p>The returned BlockMap always has a distinct communicator from this BlockMap's original communicator. The new communicator contains a subset of processes from the original communicator. Even if the number of processes in the new communicator equals the number of processes in the original communicator, the new communicator is distinct. (In an MPI implementation, the new communicator is created using MPI_Comm_split.)</p>
<p>This method must be called collectively on the original communicator. It leaves the original Map and communicator unchanged.</p>
<p>This method was intended for applications such as algebraic multigrid or other multilevel preconditioners. Construction of each level of the multilevel preconditioner typically requires constructing sparse matrices, which in turn requires all-reduces over all participating processes at that level. Matrix sizes at successively coarser levels shrink geometrically. At the coarsest levels, some processes might be left with zero rows of the matrix, or the multigrid implementation might "rebalance" (redistribute the matrix) and intentionally leave some processes with zero rows. Removing processes with zero rows makes the all-reduces and other communication operations cheaper. </p>

</div>
</div>
<a id="ab5dbbf0d7527627e29ccc7d02a19342d" name="ab5dbbf0d7527627e29ccc7d02a19342d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5dbbf0d7527627e29ccc7d02a19342d">&#9670;&#160;</a></span>ReplaceCommWithSubset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> * Epetra_BlockMap::ReplaceCommWithSubset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> *&#160;</td>
          <td class="paramname"><em>Comm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace this BlockMap's communicator with a subset communicator. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method is only for expert users. Understanding how to use this method correctly requires some familiarity with semantics of MPI communicators.</dd>
<dd>
We make no promises of backwards compatibility for this method. It may go away or change at any time.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input communicator's processes are a subset of this BlockMap's current communicator's processes. </dd>
<dd>
On processes which are not included in the input communicator, the input communicator is null.</dd></dl>
<p>This method must be called collectively on the original communicator. It leaves the original BlockMap and communicator unchanged.</p>
<dl class="section note"><dt>Note</dt><dd>This method differs from removeEmptyProcesses(), in that it does not assume that excluded processes have zero entries. For example, one might wish to remove empty processes from the row BlockMap of a CrsGraph using removeEmptyProcesses(), and then apply the resulting subset communicator to the column, domain, and range Maps of the same graph. For the latter three Maps, one would in general use this method instead of removeEmptyProcesses(), giving the new row BlockMap's communicator to this method. </dd></dl>

</div>
</div>
<a id="a2a90c00ae92c719b863a2b57cd48850b" name="a2a90c00ae92c719b863a2b57cd48850b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a90c00ae92c719b863a2b57cd48850b">&#9670;&#160;</a></span>SameBlockMapDataAs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Epetra_BlockMap::SameBlockMapDataAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;&#160;</td>
          <td class="paramname"><em>Map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if maps share same block map data underneath. This is a very cheap check whether two maps are identical. </p>

</div>
</div>
<a id="a9b7edc72eafa284a4845467d4dd8b5c5" name="a9b7edc72eafa284a4845467d4dd8b5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7edc72eafa284a4845467d4dd8b5c5">&#9670;&#160;</a></span>UniqueGIDs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Epetra_BlockMap::UniqueGIDs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if map GIDs are 1-to-1. </p>
<p>Certain operations involving <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> and <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> objects are well-defined only if the map GIDs are uniquely present in the map. In other words, if a GID occurs in the map, it occurs only once on a single processor and nowhere else. This boolean test returns true if this property is true, otherwise it returns false. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><b>Epetra_BlockMap.h</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 9 2025 20:37:13 for Epetra by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
