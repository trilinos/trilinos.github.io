<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Epetra: Epetra Lesson 05: Redistribution</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Epetra<span id="projectnumber">&#160;Development</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Epetra Lesson 05: Redistribution</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Parallel data redistribution of Epetra objects.</p>
<h1><a class="anchor" id="Epetra_Lesson05_Topics"></a>
Lesson topics</h1>
<p>The Epetra_Lesson02_Vector example introduces and describes the <a href="http://trilinos.sandia.gov/packages/docs/dev/packages/epetra/doc/html/classEpetra__Map.html">Epetra_Map</a> class, which is Epetra's representation of a data distribution. This example builds on that by showing how to use Maps and the <a href="http://trilinos.sandia.gov/packages/docs/dev/packages/epetra/doc/html/classEpetra__Export.html">Epetra_Export</a> class to redistribute data. In this case, we build a sparse matrix on one MPI process, and redistribute it to a sparse matrix stored in block row fashion, with an equal number of rows per process.</p>
<h1><a class="anchor" id="Epetra_Lesson05_Redist"></a>
Epetra data redistribution: Import and Export</h1>
<p>The <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> class describes a data distribution over one or more distributed-memory parallel processes. It "maps" global indices (unique labels for the elements of a data structure) to parallel processes. This ability to describe a data distribution calls for a <em>redistribution</em> capability, that is, to reorganize or remap data from one distribution to another. Epetra provides this capability through the <a href="http://trilinos.sandia.gov/packages/docs/dev/packages/epetra/doc/html/classEpetra__Import.html">Epetra_Import </a> and <a href="http://trilinos.sandia.gov/packages/docs/dev/packages/epetra/doc/html/classEpetra__Export.html">Epetra_Export </a> classes.</p>
<p>Import redistributes from a uniquely owned (one-to-one) Map to a possibly not uniquely owned Map. Export redistributes from a possibly not uniquely owned to a uniquely owned Map. We distinguish between these cases both for historical reasons and for performance reasons.</p>
<p>Import and Export objects encapsulate and <em>remember</em> a communication pattern for reuse. Computing the computation pattern requires nontrivial work, but keeping around the Import or Export object lets you reuse that work. This is very important for operations that are performed frequently, such as the Import and Export operations in Epetra's sparse matrix-vector multiply.</p>
<p>In both cases, Import and Export let the user specify how to combine incoming new data with existing data that has the same global index. For example, one may replace old data with new data or sum them together.</p>
<h1><a class="anchor" id="Epetra_Lesson05_Example"></a>
Code example</h1>
<p>This example shows how to migrate the data in Epetra objects (sparse matrices and vectors) between two different parallel distributions.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="comment">// This defines useful macros like HAVE_MPI, which is defined if and</span></div>
<div class="line"><span class="comment">// only if Epetra was built with MPI enabled.</span></div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_config.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef HAVE_MPI</span></div>
<div class="line"><span class="preprocessor">#  include &lt;mpi.h&gt;</span></div>
<div class="line"><span class="comment">// Epetra&#39;s wrapper for MPI_Comm.  This header file only exists if</span></div>
<div class="line"><span class="comment">// Epetra was built with MPI enabled.</span></div>
<div class="line"><span class="preprocessor">#  include &lt;Epetra_MpiComm.h&gt;</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#  include &lt;Epetra_SerialComm.h&gt;</span></div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// HAVE_MPI</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_CrsMatrix.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_Export.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_Map.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_Vector.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_Version.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdexcept&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// The type of global indices.  You could just set this to int,</span></div>
<div class="line"><span class="comment">// but we want the example to work for Epetra64 as well.</span></div>
<div class="line"><span class="preprocessor">#ifdef EPETRA_NO_32BIT_GLOBAL_INDICES</span></div>
<div class="line"><span class="comment">// Epetra was compiled only with 64-bit global index support,</span></div>
<div class="line"><span class="comment">// so use 64-bit global indices.</span></div>
<div class="line"><span class="preprocessor">#    define EXAMPLE_USES_64BIT_GLOBAL_INDICES 1</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> global_ordinal_type;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#  ifdef EPETRA_NO_64BIT_GLOBAL_INDICES</span></div>
<div class="line"><span class="comment">// Epetra was compiled only with 32-bit global index support,</span></div>
<div class="line"><span class="comment">// so use 32-bit global indices.</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span> global_ordinal_type;</div>
<div class="line"><span class="preprocessor">#  else</span></div>
<div class="line"><span class="preprocessor">#    define EXAMPLE_USES_64BIT_GLOBAL_INDICES 1</span></div>
<div class="line"><span class="comment">// Epetra was compiled with both 64-bit and 32-bit global index</span></div>
<div class="line"><span class="comment">// support.  Use 64-bit global indices for maximum generality.</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> global_ordinal_type;</div>
<div class="line"><span class="preprocessor">#  endif </span><span class="comment">// EPETRA_NO_64BIT_GLOBAL_INDICES</span></div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// EPETRA_NO_32BIT_GLOBAL_INDICES</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create and return a pointer to an example CrsMatrix, with row</span></div>
<div class="line"><span class="comment">// distribution over the given Map.  The caller is responsible for</span></div>
<div class="line"><span class="comment">// freeing the result.</span></div>
<div class="line"><a class="code hl_class" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a>*</div>
<div class="line">createCrsMatrix (<span class="keyword">const</span> <a class="code hl_class" href="classEpetra__Map.html">Epetra_Map</a>&amp; map)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classEpetra__Comm.html">Epetra_Comm</a>&amp; comm = map.<a class="code hl_function" href="classEpetra__BlockMap.html#abd9d6c774319c3bb5e79039058416a92">Comm</a> ();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create an Epetra_CrsMatrix using the Map, with dynamic allocation.</span></div>
<div class="line">  <a class="code hl_class" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a>* A = <span class="keyword">new</span> <a class="code hl_class" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> (<a class="code hl_enumvalue" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928aad81934e8f3b9399beea932f0b0e57d8">Copy</a>, map, 3);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The list of global indices owned by this MPI process.</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> global_ordinal_type* myGblElts = NULL;</div>
<div class="line">  global_ordinal_type numGblElts = 0;</div>
<div class="line"><span class="preprocessor">#ifdef EXAMPLE_USES_64BIT_GLOBAL_INDICES</span></div>
<div class="line">  myGblElts = map.MyGlobalElements64 ();</div>
<div class="line">  numGblElts = map.NumGlobalElements64 ();</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  myGblElts = map.<a class="code hl_function" href="classEpetra__BlockMap.html#a1f6ef71a397909d0219167b339eb3164">MyGlobalElements</a> ();</div>
<div class="line">  numGblElts = map.<a class="code hl_function" href="classEpetra__BlockMap.html#abc70320a09789d1bf51871c5262ed835">NumGlobalElements</a> ();</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// EXAMPLE_USES_64BIT_GLOBAL_INDICES</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of global indices owned by this MPI process.</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> numMyElts = map.<a class="code hl_function" href="classEpetra__BlockMap.html#acdb9f7c41ae4fb986326a8fff49b1b17">NumMyElements</a> ();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// In general, tests like this really should synchronize across all</span></div>
<div class="line">  <span class="comment">// processes.  However, the likely cause for this case is a</span></div>
<div class="line">  <span class="comment">// misconfiguration of Epetra, so we expect it to happen on all</span></div>
<div class="line">  <span class="comment">// processes, if it happens at all.</span></div>
<div class="line">  <span class="keywordflow">if</span> (numMyElts &gt; 0 &amp;&amp; myGblElts == NULL) {</div>
<div class="line">    <span class="keywordflow">throw</span> std::logic_error (<span class="stringliteral">&quot;Failed to get the list of global indices&quot;</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Local error code for use below.</span></div>
<div class="line">  <span class="keywordtype">int</span> lclerr = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Fill the sparse matrix, one row at a time.</span></div>
<div class="line">  <span class="keywordtype">double</span> tempVals[3];</div>
<div class="line">  global_ordinal_type tempGblInds[3];</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numMyElts; ++i) {</div>
<div class="line">    <span class="comment">// A(0, 0:1) = [2, -1]</span></div>
<div class="line">    <span class="keywordflow">if</span> (myGblElts[i] == 0) {</div>
<div class="line">      tempVals[0] = 2.0;</div>
<div class="line">      tempVals[1] = -1.0;</div>
<div class="line">      tempGblInds[0] = myGblElts[i];</div>
<div class="line">      tempGblInds[1] = myGblElts[i] + 1;</div>
<div class="line">      <span class="keywordflow">if</span> (lclerr == 0) {</div>
<div class="line">        lclerr = A-&gt;InsertGlobalValues (myGblElts[i], 2, tempVals, tempGblInds);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (lclerr != 0) {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// A(N-1, N-2:N-1) = [-1, 2]</span></div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (myGblElts[i] == numGblElts - 1) {</div>
<div class="line">      tempVals[0] = -1.0;</div>
<div class="line">      tempVals[1] = 2.0;</div>
<div class="line">      tempGblInds[0] = myGblElts[i] - 1;</div>
<div class="line">      tempGblInds[1] = myGblElts[i];</div>
<div class="line">      <span class="keywordflow">if</span> (lclerr == 0) {</div>
<div class="line">        lclerr = A-&gt;InsertGlobalValues (myGblElts[i], 2, tempVals, tempGblInds);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (lclerr != 0) {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// A(i, i-1:i+1) = [-1, 2, -1]</span></div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">      tempVals[0] = -1.0;</div>
<div class="line">      tempVals[1] = 2.0;</div>
<div class="line">      tempVals[2] = -1.0;</div>
<div class="line">      tempGblInds[0] = myGblElts[i] - 1;</div>
<div class="line">      tempGblInds[1] = myGblElts[i];</div>
<div class="line">      tempGblInds[2] = myGblElts[i] + 1;</div>
<div class="line">      <span class="keywordflow">if</span> (lclerr == 0) {</div>
<div class="line">        lclerr = A-&gt;InsertGlobalValues (myGblElts[i], 3, tempVals, tempGblInds);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (lclerr != 0) {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If any process failed to insert at least one entry, throw.</span></div>
<div class="line">  <span class="keywordtype">int</span> gblerr = 0;</div>
<div class="line">  (void) comm.<a class="code hl_function" href="classEpetra__Comm.html#a04039ddd27c1aae04104d62992a58787">MaxAll</a> (&amp;lclerr, &amp;gblerr, 1);</div>
<div class="line">  <span class="keywordflow">if</span> (gblerr != 0) {</div>
<div class="line">    <span class="keywordflow">if</span> (A != NULL) {</div>
<div class="line">      <span class="keyword">delete</span> A;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error (<span class="stringliteral">&quot;Some process failed to insert an entry.&quot;</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Tell the sparse matrix that we are done adding entries to it.</span></div>
<div class="line">  gblerr = A-&gt;FillComplete ();</div>
<div class="line">  <span class="keywordflow">if</span> (gblerr != 0) {</div>
<div class="line">    <span class="keywordflow">if</span> (A != NULL) {</div>
<div class="line">      <span class="keyword">delete</span> A;</div>
<div class="line">    }</div>
<div class="line">    std::ostringstream os;</div>
<div class="line">    os &lt;&lt; <span class="stringliteral">&quot;A-&gt;FillComplete() failed with error code &quot;</span> &lt;&lt; gblerr &lt;&lt; <span class="stringliteral">&quot;.&quot;</span>;</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error (os.str ());</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> A;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">example (<span class="keyword">const</span> <a class="code hl_class" href="classEpetra__Comm.html">Epetra_Comm</a>&amp; comm)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// The global number of rows in the matrix A to create.  We scale</span></div>
<div class="line">  <span class="comment">// this relative to the number of (MPI) processes, so that no matter</span></div>
<div class="line">  <span class="comment">// how many MPI processes you run, every process will have 10 rows.</span></div>
<div class="line">  <span class="keyword">const</span> global_ordinal_type numGblElts = 10 * comm.<a class="code hl_function" href="classEpetra__Comm.html#a08ed286ec280a7bae33ea6b6e772ff1a">NumProc</a> ();</div>
<div class="line">  <span class="comment">// The global min global index in all the Maps here.</span></div>
<div class="line">  <span class="keyword">const</span> global_ordinal_type indexBase = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Local error code for use below.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// In the ideal case, we would use this to emulate behavior like</span></div>
<div class="line">  <span class="comment">// that of Haskell&#39;s Maybe in the context of MPI.  That is, if one</span></div>
<div class="line">  <span class="comment">// process experiences an error, we don&#39;t want to abort early and</span></div>
<div class="line">  <span class="comment">// cause the other processes to deadlock on MPI communication</span></div>
<div class="line">  <span class="comment">// operators.  Rather, we want to chain along the local error state,</span></div>
<div class="line">  <span class="comment">// until we reach a point where it&#39;s natural to pass along that</span></div>
<div class="line">  <span class="comment">// state with other processes.  For example, if one is doing an</span></div>
<div class="line">  <span class="comment">// MPI_Allreduce anyway, it makes sense to pass along one more bit</span></div>
<div class="line">  <span class="comment">// of information: whether the calling process is in a local error</span></div>
<div class="line">  <span class="comment">// state.  Epetra&#39;s interface doesn&#39;t let one chain the local error</span></div>
<div class="line">  <span class="comment">// state in this way, so we use extra collectives below to propagate</span></div>
<div class="line">  <span class="comment">// that state.  The code below uses very conservative error checks;</span></div>
<div class="line">  <span class="comment">// typical user code would not need to be so conservative and could</span></div>
<div class="line">  <span class="comment">// therefore avoid all the all-reduces.</span></div>
<div class="line">  <span class="keywordtype">int</span> lclerr = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct a Map that is global (not locally replicated), but puts</span></div>
<div class="line">  <span class="comment">// all the equations on MPI Proc 0.</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> procZeroMapNumLclElts = (comm.<a class="code hl_function" href="classEpetra__Comm.html#a60135f8b72809635695dd2b8f539da6b">MyPID</a> () == 0) ?</div>
<div class="line">    numGblElts :</div>
<div class="line">    static_cast&lt;global_ordinal_type&gt; (0);</div>
<div class="line">  <a class="code hl_class" href="classEpetra__Map.html">Epetra_Map</a> procZeroMap (numGblElts, procZeroMapNumLclElts, indexBase, comm);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct a Map that puts approximately the same number of</span></div>
<div class="line">  <span class="comment">// equations on each processor.</span></div>
<div class="line">  <a class="code hl_class" href="classEpetra__Map.html">Epetra_Map</a> globalMap (numGblElts, indexBase, comm);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a sparse matrix using procZeroMap.</span></div>
<div class="line">  <a class="code hl_class" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a>* A = createCrsMatrix (procZeroMap);</div>
<div class="line">  <span class="keywordflow">if</span> (A == NULL) {</div>
<div class="line">    lclerr = 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Make sure that sparse matrix creation succeeded.  Normally you</span></div>
<div class="line">  <span class="comment">// don&#39;t have to check this; we are being extra conservative because</span></div>
<div class="line">  <span class="comment">// this example is also a test.  Even though the matrix&#39;s rows live</span></div>
<div class="line">  <span class="comment">// entirely on Process 0, the matrix is nonnull on all processes in</span></div>
<div class="line">  <span class="comment">// its Map&#39;s communicator.</span></div>
<div class="line">  <span class="keywordtype">int</span> gblerr = 0;</div>
<div class="line">  (void) comm.<a class="code hl_function" href="classEpetra__Comm.html#a04039ddd27c1aae04104d62992a58787">MaxAll</a> (&amp;lclerr, &amp;gblerr, 1);</div>
<div class="line">  <span class="keywordflow">if</span> (gblerr != 0) {</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error (<span class="stringliteral">&quot;createCrsMatrix returned NULL on at least one &quot;</span></div>
<div class="line">                              <span class="stringliteral">&quot;process.&quot;</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// We&#39;ve created a sparse matrix whose rows live entirely on MPI</span></div>
<div class="line">  <span class="comment">// Process 0.  Now we want to distribute it over all the processes.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Redistribute the matrix.  Since both the source and target Maps</span></div>
<div class="line">  <span class="comment">// are one-to-one, we could use either an Import or an Export.  If</span></div>
<div class="line">  <span class="comment">// only the source Map were one-to-one, we would have to use an</span></div>
<div class="line">  <span class="comment">// Import; if only the target Map were one-to-one, we would have to</span></div>
<div class="line">  <span class="comment">// use an Export.  We do not allow redistribution using Import or</span></div>
<div class="line">  <span class="comment">// Export if neither source nor target Map is one-to-one.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Make an export object with procZeroMap as the source Map, and</span></div>
<div class="line">  <span class="comment">// globalMap as the target Map.  The Export type has the same</span></div>
<div class="line">  <span class="comment">// template parameters as a Map.  Note that Export does not depend</span></div>
<div class="line">  <span class="comment">// on the Scalar template parameter of the objects it</span></div>
<div class="line">  <span class="comment">// redistributes.  You can reuse the same Export for different</span></div>
<div class="line">  <span class="comment">// Tpetra object types, or for Tpetra objects of the same type but</span></div>
<div class="line">  <span class="comment">// different Scalar template parameters (e.g., Scalar=float or</span></div>
<div class="line">  <span class="comment">// Scalar=double).</span></div>
<div class="line">  <a class="code hl_class" href="classEpetra__Export.html">Epetra_Export</a> exporter (procZeroMap, globalMap);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Make a new sparse matrix whose row map is the global Map.</span></div>
<div class="line">  <a class="code hl_class" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> B (<a class="code hl_enumvalue" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928aad81934e8f3b9399beea932f0b0e57d8">Copy</a>, globalMap, 0);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Redistribute the data, NOT in place, from matrix A (which lives</span></div>
<div class="line">  <span class="comment">// entirely on Proc 0) to matrix B (which is distributed evenly over</span></div>
<div class="line">  <span class="comment">// the processes).</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Export() has collective semantics, so we must always call it on</span></div>
<div class="line">  <span class="comment">// all processes collectively.  This is why we don&#39;t select on</span></div>
<div class="line">  <span class="comment">// lclerr, as we do for the local operations above.</span></div>
<div class="line">  lclerr = B.Export (*A, exporter, <a class="code hl_enumvalue" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020fa0a84e3d16cff840b05790b811b0152d9">Insert</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Make sure that the Export succeeded.  Normally you don&#39;t have to</span></div>
<div class="line">  <span class="comment">// check this; we are being extra conservative because this example</span></div>
<div class="line">  <span class="comment">// example is also a test.  We test both min and max, since lclerr</span></div>
<div class="line">  <span class="comment">// may be negative, zero, or positive.</span></div>
<div class="line">  gblerr = 0;</div>
<div class="line">  (void) comm.<a class="code hl_function" href="classEpetra__Comm.html#a4588d35d60afc8456dcc165afe2fefc5">MinAll</a> (&amp;lclerr, &amp;gblerr, 1);</div>
<div class="line">  <span class="keywordflow">if</span> (gblerr != 0) {</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error (<span class="stringliteral">&quot;Export() failed on at least one process.&quot;</span>);</div>
<div class="line">  }</div>
<div class="line">  (void) comm.<a class="code hl_function" href="classEpetra__Comm.html#a04039ddd27c1aae04104d62992a58787">MaxAll</a> (&amp;lclerr, &amp;gblerr, 1);</div>
<div class="line">  <span class="keywordflow">if</span> (gblerr != 0) {</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error (<span class="stringliteral">&quot;Export() failed on at least one process.&quot;</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// FillComplete has collective semantics, so we must always call it</span></div>
<div class="line">  <span class="comment">// on all processes collectively.  This is why we don&#39;t select on</span></div>
<div class="line">  <span class="comment">// lclerr, as we do for the local operations above.</span></div>
<div class="line">  lclerr = B.FillComplete ();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Make sure that FillComplete succeeded.  Normally you don&#39;t have</span></div>
<div class="line">  <span class="comment">// to check this; we are being extra conservative because this</span></div>
<div class="line">  <span class="comment">// example is also a test.  We test both min and max, since lclerr</span></div>
<div class="line">  <span class="comment">// may be negative, zero, or positive.</span></div>
<div class="line">  gblerr = 0;</div>
<div class="line">  (void) comm.<a class="code hl_function" href="classEpetra__Comm.html#a4588d35d60afc8456dcc165afe2fefc5">MinAll</a> (&amp;lclerr, &amp;gblerr, 1);</div>
<div class="line">  <span class="keywordflow">if</span> (gblerr != 0) {</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error (<span class="stringliteral">&quot;B.FillComplete() failed on at least one process.&quot;</span>);</div>
<div class="line">  }</div>
<div class="line">  (void) comm.<a class="code hl_function" href="classEpetra__Comm.html#a04039ddd27c1aae04104d62992a58787">MaxAll</a> (&amp;lclerr, &amp;gblerr, 1);</div>
<div class="line">  <span class="keywordflow">if</span> (gblerr != 0) {</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error (<span class="stringliteral">&quot;B.FillComplete() failed on at least one process.&quot;</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (A != NULL) {</div>
<div class="line">    <span class="keyword">delete</span> A;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using </span>std::cout;</div>
<div class="line">  <span class="keyword">using </span>std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef HAVE_MPI</span></div>
<div class="line">  MPI_Init (&amp;argc, &amp;argv);</div>
<div class="line">  <a class="code hl_class" href="classEpetra__MpiComm.html">Epetra_MpiComm</a> comm (MPI_COMM_WORLD);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <a class="code hl_class" href="classEpetra__SerialComm.html">Epetra_SerialComm</a> comm;</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// HAVE_MPI</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> myRank = comm.<a class="code hl_function" href="classEpetra__SerialComm.html#a237a6407573dea22f0366936d158486d">MyPID</a> ();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> numProcs = comm.<a class="code hl_function" href="classEpetra__SerialComm.html#af55220ff6540694c810aa9f2b3ec146f">NumProc</a> ();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">    <span class="comment">// Print out the Epetra software version.</span></div>
<div class="line">    cout &lt;&lt; Epetra_Version () &lt;&lt; endl &lt;&lt; endl</div>
<div class="line">         &lt;&lt; <span class="stringliteral">&quot;Total number of processes: &quot;</span> &lt;&lt; numProcs &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  example (comm); <span class="comment">// Run the whole example.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// This tells the Trilinos test framework that the test passed.</span></div>
<div class="line">  <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;End Result: TEST PASSED&quot;</span> &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef HAVE_MPI</span></div>
<div class="line">  (void) MPI_Finalize ();</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// HAVE_MPI</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aEpetra__CombineMode_8h_html_aae659d58333dccaf8db7230bd834020fa0a84e3d16cff840b05790b811b0152d9"><div class="ttname"><a href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020fa0a84e3d16cff840b05790b811b0152d9">Insert</a></div><div class="ttdeci">@ Insert</div><div class="ttdef"><b>Definition</b> Epetra_CombineMode.h:76</div></div>
<div class="ttc" id="aEpetra__DataAccess_8h_html_ad1a985e79f94ad63030815a0d7d90928aad81934e8f3b9399beea932f0b0e57d8"><div class="ttname"><a href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928aad81934e8f3b9399beea932f0b0e57d8">Copy</a></div><div class="ttdeci">@ Copy</div><div class="ttdef"><b>Definition</b> Epetra_DataAccess.h:63</div></div>
<div class="ttc" id="aclassEpetra__BlockMap_html_a1f6ef71a397909d0219167b339eb3164"><div class="ttname"><a href="classEpetra__BlockMap.html#a1f6ef71a397909d0219167b339eb3164">Epetra_BlockMap::MyGlobalElements</a></div><div class="ttdeci">int MyGlobalElements(int *MyGlobalElementList) const</div><div class="ttdoc">Puts list of global elements on this processor into the user-provided array.</div></div>
<div class="ttc" id="aclassEpetra__BlockMap_html_abc70320a09789d1bf51871c5262ed835"><div class="ttname"><a href="classEpetra__BlockMap.html#abc70320a09789d1bf51871c5262ed835">Epetra_BlockMap::NumGlobalElements</a></div><div class="ttdeci">int NumGlobalElements() const</div><div class="ttdoc">Number of elements across all processors.</div><div class="ttdef"><b>Definition</b> Epetra_BlockMap.h:554</div></div>
<div class="ttc" id="aclassEpetra__BlockMap_html_abd9d6c774319c3bb5e79039058416a92"><div class="ttname"><a href="classEpetra__BlockMap.html#abd9d6c774319c3bb5e79039058416a92">Epetra_BlockMap::Comm</a></div><div class="ttdeci">const Epetra_Comm &amp; Comm() const</div><div class="ttdoc">Access function for Epetra_Comm communicator.</div><div class="ttdef"><b>Definition</b> Epetra_BlockMap.h:778</div></div>
<div class="ttc" id="aclassEpetra__BlockMap_html_acdb9f7c41ae4fb986326a8fff49b1b17"><div class="ttname"><a href="classEpetra__BlockMap.html#acdb9f7c41ae4fb986326a8fff49b1b17">Epetra_BlockMap::NumMyElements</a></div><div class="ttdeci">int NumMyElements() const</div><div class="ttdoc">Number of elements on the calling processor.</div><div class="ttdef"><b>Definition</b> Epetra_BlockMap.h:563</div></div>
<div class="ttc" id="aclassEpetra__Comm_html"><div class="ttname"><a href="classEpetra__Comm.html">Epetra_Comm</a></div><div class="ttdoc">Epetra_Comm: The Epetra Communication Abstract Base Class.</div><div class="ttdef"><b>Definition</b> Epetra_Comm.h:81</div></div>
<div class="ttc" id="aclassEpetra__Comm_html_a04039ddd27c1aae04104d62992a58787"><div class="ttname"><a href="classEpetra__Comm.html#a04039ddd27c1aae04104d62992a58787">Epetra_Comm::MaxAll</a></div><div class="ttdeci">virtual int MaxAll(double *PartialMaxs, double *GlobalMaxs, int Count) const =0</div><div class="ttdoc">Epetra_Comm Global Max function.</div></div>
<div class="ttc" id="aclassEpetra__Comm_html_a08ed286ec280a7bae33ea6b6e772ff1a"><div class="ttname"><a href="classEpetra__Comm.html#a08ed286ec280a7bae33ea6b6e772ff1a">Epetra_Comm::NumProc</a></div><div class="ttdeci">virtual int NumProc() const =0</div><div class="ttdoc">Returns total number of processes.</div></div>
<div class="ttc" id="aclassEpetra__Comm_html_a4588d35d60afc8456dcc165afe2fefc5"><div class="ttname"><a href="classEpetra__Comm.html#a4588d35d60afc8456dcc165afe2fefc5">Epetra_Comm::MinAll</a></div><div class="ttdeci">virtual int MinAll(double *PartialMins, double *GlobalMins, int Count) const =0</div><div class="ttdoc">Epetra_Comm Global Min function.</div></div>
<div class="ttc" id="aclassEpetra__Comm_html_a60135f8b72809635695dd2b8f539da6b"><div class="ttname"><a href="classEpetra__Comm.html#a60135f8b72809635695dd2b8f539da6b">Epetra_Comm::MyPID</a></div><div class="ttdeci">virtual int MyPID() const =0</div><div class="ttdoc">Return my process ID.</div></div>
<div class="ttc" id="aclassEpetra__CrsMatrix_html"><div class="ttname"><a href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a></div><div class="ttdoc">Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...</div><div class="ttdef"><b>Definition</b> Epetra_CrsMatrix.h:181</div></div>
<div class="ttc" id="aclassEpetra__Export_html"><div class="ttname"><a href="classEpetra__Export.html">Epetra_Export</a></div><div class="ttdoc">Epetra_Export: This class builds an export object for efficient exporting of off-processor elements.</div><div class="ttdef"><b>Definition</b> Epetra_Export.h:70</div></div>
<div class="ttc" id="aclassEpetra__Map_html"><div class="ttname"><a href="classEpetra__Map.html">Epetra_Map</a></div><div class="ttdoc">Epetra_Map: A class for partitioning vectors and matrices.</div><div class="ttdef"><b>Definition</b> Epetra_Map.h:127</div></div>
<div class="ttc" id="aclassEpetra__MpiComm_html"><div class="ttname"><a href="classEpetra__MpiComm.html">Epetra_MpiComm</a></div><div class="ttdoc">Epetra_MpiComm: The Epetra MPI Communication Class.</div><div class="ttdef"><b>Definition</b> Epetra_MpiComm.h:72</div></div>
<div class="ttc" id="aclassEpetra__SerialComm_html"><div class="ttname"><a href="classEpetra__SerialComm.html">Epetra_SerialComm</a></div><div class="ttdoc">Epetra_SerialComm: The Epetra Serial Communication Class.</div><div class="ttdef"><b>Definition</b> Epetra_SerialComm.h:69</div></div>
<div class="ttc" id="aclassEpetra__SerialComm_html_a237a6407573dea22f0366936d158486d"><div class="ttname"><a href="classEpetra__SerialComm.html#a237a6407573dea22f0366936d158486d">Epetra_SerialComm::MyPID</a></div><div class="ttdeci">int MyPID() const</div><div class="ttdoc">Return my process ID.</div><div class="ttdef"><b>Definition</b> Epetra_SerialComm.h:440</div></div>
<div class="ttc" id="aclassEpetra__SerialComm_html_af55220ff6540694c810aa9f2b3ec146f"><div class="ttname"><a href="classEpetra__SerialComm.html#af55220ff6540694c810aa9f2b3ec146f">Epetra_SerialComm::NumProc</a></div><div class="ttdeci">int NumProc() const</div><div class="ttdoc">Returns total number of processes (always returns 1 for SerialComm).</div><div class="ttdef"><b>Definition</b> Epetra_SerialComm.h:443</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 9 2025 20:37:13 for Epetra by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
