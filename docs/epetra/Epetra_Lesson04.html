<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Epetra: Epetra Lesson 04: Sparse matrix fill</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Epetra<span id="projectnumber">&#160;Development</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Epetra Lesson 04: Sparse matrix fill</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Different ways to add entries to Epetra sparse matrix.</p>
<h1><a class="anchor" id="Epetra_Lesson04_Topics"></a>
Lesson topics</h1>
<p>This lesson explains how to add entries to a Epetra sparse matrix (<a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a>). It explains how you can choose any of various ways to add entries to the matrix. Some are more flexible but less efficient, and others are more efficient but less flexible. In general, knowing the sparse matrix structure in advance will reduce both peak memory usage and total run time.</p>
<p>This lesson does not currently include code examples. The section <a class="el" href="Epetra_Lesson04.html#Epetra_Lesson04_Exercise">Exercise</a> at the end suggests modifying the example <a class="el" href="Epetra_Lesson03.html">Epetra Lesson 03: Power method</a> in order to learn about the different ways to add or change the entries of a sparse matrix.</p>
<h1><a class="anchor" id="Epetra_Lesson04_Fill"></a>
Filling a sparse matrix</h1>
<p>We call adding entries to a sparse matrix <em>filling</em> it, and call the general procedure "sparse matrix fill" or just <em>fill</em>. Often people have finite element assembly in mind when they use this expression, but fill here means adding entries for any reason. For example, you might want to </p><ul>
<li>
solve an optimization problem with a set of linear constraints, so you would add one row to the sparse matrix for each constraint; or  </li>
<li>
represent a weighted graph as a sparse matrix, so that each row of the matrix represents a vertex's adjacency list and corresponding edge weights.  </li>
</ul>
<p>Also, by extension, "fill" might refer to modifying existing entries of a sparse matrix.</p>
<h1><a class="anchor" id="Epetra_Lesson04_Rowwise"></a>
Rowwise access, not rowwise distribution</h1>
<p><a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> inherits from the <a class="el" href="classEpetra__RowMatrix.html" title="Epetra_RowMatrix: A pure virtual class for using real-valued double-precision row matrices.">Epetra_RowMatrix</a> interface; it "is
a" RowMatrix. Some people have the misconception that "RowMatrix" (and therefore CrsMatrix) refers to a rowwise distribution of the sparse matrix over parallel processes. It does not. CrsMatrix supports an arbitrary "two-dimensional" distribution of rows and columns over processes. The term instead refers to rowwise access to the data. That is, the methods in this interface and in CrsMatrix let you add or access entries on each process by row.</p>
<p>This distinction matters because two or more processes might share entries in a row. Asking for "all the entries in a row" on a particular process only accesses the entries owned by that process, which is not necessarily all the entries in a row.</p>
<p>Whether adding entries or modifying existing ones, you may always do so for any number of entries in the row, such that their columns are owned by the calling process. You should always modify as many entries with one method call as possible, in order to amortize function call and data access overhead.</p>
<h1><a class="anchor" id="Epetra_Lesson04_Phases"></a>
Phases of fill</h1>
<p>An <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> may be in either of two different states: </p><ol>
<li>
Post construction, before user calls <code>FillComplete()</code>  </li>
<li>
After user calls <code>FillComplete()</code>  </li>
</ol>
<p>In both states, you are allowed to set or modify values in the matrix. In State 1, if the matrix was not created with a constant graph (see below), and if there is room in the row (see "static profile" discussion below), you are allowed to change the graph structure of the matrix by inserting entries.</p>
<p>We call a matrix in State 2 "fill complete." In State 2, you are <em>not</em> allowed to modify the graph structure of the matrix, but you <em>are</em> allowed to modify the values in the matrix.</p>
<p>Calling <code>FillComplete()</code> does a lot of work. In general, it requires distributed-memory communication as well as local rearrangement of data. The intent is that you should exploit this work for as long as possible before creating a new matrix with a different graph structure. You can do so by performing multiple sparse matrix-vector multiplies or triangular solves.</p>
<h1><a class="anchor" id="Epetra_Lesson04_Tradeoffs"></a>
Trade-offs between flexibility and performance</h1>
<h2><a class="anchor" id="Epetra_Lesson04_Tradeoffs_dyn_no_hint"></a>
The most general case: dynamic allocation, no size hint</h2>
<p>CrsMatrix lets you make trade-offs between flexibility and performance. All of these trade-offs revolve around how much you know about the structure of the sparse matrix &ndash; that is, its graph &ndash; in advance. In the most general case, all you know is which process owns which row &ndash; the row Map. </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEpetra__Map.html">Epetra_Map</a> rowMap (...); <span class="comment">// whatever row Map you want</span></div>
<div class="line"><a class="code hl_class" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> A (<a class="code hl_enumvalue" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928aad81934e8f3b9399beea932f0b0e57d8">Copy</a>, rowMap, 0);</div>
<div class="ttc" id="aEpetra__DataAccess_8h_html_ad1a985e79f94ad63030815a0d7d90928aad81934e8f3b9399beea932f0b0e57d8"><div class="ttname"><a href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928aad81934e8f3b9399beea932f0b0e57d8">Copy</a></div><div class="ttdeci">@ Copy</div><div class="ttdef"><b>Definition</b> Epetra_DataAccess.h:63</div></div>
<div class="ttc" id="aclassEpetra__CrsMatrix_html"><div class="ttname"><a href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a></div><div class="ttdoc">Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...</div><div class="ttdef"><b>Definition</b> Epetra_CrsMatrix.h:181</div></div>
<div class="ttc" id="aclassEpetra__Map_html"><div class="ttname"><a href="classEpetra__Map.html">Epetra_Map</a></div><div class="ttdoc">Epetra_Map: A class for partitioning vectors and matrices.</div><div class="ttdef"><b>Definition</b> Epetra_Map.h:127</div></div>
</div><!-- fragment --><p> This code snippet says that you want to create a sparse matrix with the given row distribution. It also says that you intend each process to own all the entries in a given row. If you want to allow a more general "2-D" distribution, you must also tell the constructor which process owns which columns of the matrix. You do so by supplying a "column Map": </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEpetra__Map.html">Epetra_Map</a> rowMap (...); <span class="comment">// whatever row Map you want</span></div>
<div class="line"><a class="code hl_class" href="classEpetra__Map.html">Epetra_Map</a> colMap (...); <span class="comment">// whatever column Map you want</span></div>
<div class="line"><a class="code hl_class" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> A (<a class="code hl_enumvalue" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928aad81934e8f3b9399beea932f0b0e57d8">Copy</a>, rowMap, colMap, 0);</div>
</div><!-- fragment --><p> All the examples that follow allow you to supply a column Map if you which, so we omit this for brevity.</p>
<p>Both of these ways to create a sparse matrix allocate memory for the entries in each row dynamically. This means that it reallocates space as necessary. We call this <em>dynamic profile</em>, where "profile" refers to the structure (the graph) of the sparse matrix. (<em>Static profile</em>, which we describe later, does not reallocate; it fixes an upper bound on the number of entries allowed per row.) CrsMatrix implements this currently as an array of arrays, one array per row, though this may change. You might hear this array of arrays structure referred to as "2-D storage," versus the "1-D" storage of the conventional compressed sparse row format.</p>
<h1><a class="anchor" id="Epetra_Lesson04_Tradeoffs_dyn_hint"></a>
Dynamic allocation with a size hint</h1>
<p>In the above examples, the matrix has no information about how many entries you want to add to each row. Thus, it has to make some default assumption. The "size hint" defaults to zero, to ensure that empty or nearly empty sparse matrices take as little memory as possible. An initial reservation of zero entries per row may cause frequent reallocation if you add entries to a row many times. Reallocation takes time, because it requires talking to the C++ run-time library or the system library. It also tends to fragment memory and thus disturb locality, further reducing performance.</p>
<p>If you have a pretty good idea how many entries will be in each row, you may give a "size hint" to the constructor. You may do so either with a single number, which is an expected upper bound on the number of entries in any one row, or with an upper bound for each row of the matrix. The typical use case is a single upper bound, which we illustrate below. </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEpetra__Map.html">Epetra_Map</a> rowMap (...); <span class="comment">// whatever row Map you want</span></div>
<div class="line"><span class="comment">// With dynamic profile, this is only a hint, not a hard constraint.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> maxEntriesPerRow = 3;</div>
<div class="line"><a class="code hl_class" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> A (<a class="code hl_enumvalue" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928aad81934e8f3b9399beea932f0b0e57d8">Copy</a>, rowMap, maxEntriesPerRow);</div>
</div><!-- fragment --><p> If you have an upper bound for each row, you probably could use static profile, but it is still legal to use dynamic profile in this case.</p>
<p>Giving an upper bound on the number of entries per row allows the matrix to preallocate space for each row. Dynamic profile still allows you to put more entries in a row than that, but if you don't, then the matrix will only allocate space once per row during the fill phase.</p>
<h1><a class="anchor" id="Epetra_Lesson04_Tradeoffs_static"></a>
Static allocation</h1>
<p>Static allocation, what we call <em>static profile</em>, means that the "size hint" becomes a hard constraint. You may either specify a single upper bound on the number of entries in any row, or an array with a separate upper bound for each row. Here is an example of the former: </p><div class="fragment"><div class="line"><span class="comment">// With static profile, this is a hard constraint.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> maxEntriesPerRow = 3;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> staticProfile = <span class="keyword">true</span>;</div>
<div class="line"><a class="code hl_class" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> A (<a class="code hl_enumvalue" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928aad81934e8f3b9399beea932f0b0e57d8">Copy</a>, rowMap, maxEntriesPerRow, staticProfile);</div>
</div><!-- fragment --><p> What happens when you specify static profile is that the matrix allocates "1-D" storage. That is, rather than the aforementioned "2-D" array of arrays, the matrix allocates the usual three compressed sparse row arrays (ptr, ind, val), with fixed space in each row (given either by the upper bound, or by the aforementioned array). When you're done filling and call <code>FillComplete()</code>, this means the matrix need only "pack" the 1-D storage into its final representation by copying the entries that you filled in (and not any of the "slack
space" you might have left). Static profile also may use less memory than dynamic profile, because you don't have to store a complicated dynamic data structure for each row of the matrix.</p>
<h1><a class="anchor" id="Epetra_Lesson04_Tradeoffs_const_graph"></a>
Constant graph</h1>
<p>The most efficient but least flexible fill method is to create the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> with a constant graph. That is, you create a <a class="el" href="classEpetra__CrsGraph.html" title="Epetra_CrsGraph: A class for constructing and using sparse compressed row graphs.">Epetra_CrsGraph</a> separately, fill it, call its <code>FillComplete()</code> method, then pass the graph to the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> constructor. This completely constrains the structure of the CrsMatrix. You may only set or modify values in the matrix, not the structure. (This means you may not call <code>InsertGlobalValues()</code> or <code>InsertMyValues()</code>, only the <code>Replace*Values()</code>, <code>SumInto*Values</code>, <code>Scale()</code>, and <code>PutScalar()</code> methods.</p>
<div class="fragment"><div class="line"><span class="comment">// Note that the CrsMatrix constructor takes a &quot;const&quot; graph.</span></div>
<div class="line"><span class="comment">// This means that the CrsMatrix is not allowed to change the</span></div>
<div class="line"><span class="comment">// graph.  You shouldn&#39;t either.  The graph must be fill complete.</span></div>
<div class="line"><a class="code hl_class" href="classEpetra__CrsGraph.html">Epetra_CrsGraph</a> graph (...);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The graph comes with the row and column Maps already built in.</span></div>
<div class="line"><span class="comment">// CrsMatrix&#39;s constructor takes the graph by &quot;value,&quot; but this </span></div>
<div class="line"><span class="comment">// does a shallow copy; it does not copy the entries in the graph.</span></div>
<div class="line"><a class="code hl_class" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> A (<a class="code hl_enumvalue" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928aad81934e8f3b9399beea932f0b0e57d8">Copy</a>, graph);</div>
<div class="ttc" id="aclassEpetra__CrsGraph_html"><div class="ttname"><a href="classEpetra__CrsGraph.html">Epetra_CrsGraph</a></div><div class="ttdoc">Epetra_CrsGraph: A class for constructing and using sparse compressed row graphs.</div><div class="ttdef"><b>Definition</b> Epetra_CrsGraph.h:221</div></div>
</div><!-- fragment --><p> Filling the CrsGraph works much like filling a CrsMatrix, except that you only specify structure, not values. Furthermore, the same size hint and dynamic profile vs. static profile options apply to CrsGraph.</p>
<h1><a class="anchor" id="Epetra_Lesson04_local_vs_global"></a>
Local vs. global indices</h1>
<p>Please see <a class="el" href="Epetra_Lesson02.html">Epetra Lesson 02: Map and Vector</a> for a detailed explanation of global and local indices.</p>
<p>In the sparse matrix's final state, it represents column indices as local indices. This is faster for operations like sparse matrix-vector multiply. It saves storage as well, especially if Epetra was configured to use 64-bit global indices. However, accessing or inserting entries by local index is only allowed under certain conditions. In particular, the matrix must have a column Map, which tells it how to convert between global and local indices for the column indices of the matrix. If you didn't create the matrix with a precomputed column Map (either in its constructor, or in the constant graph), it has to compute the column Map on its own. It does so in <code>FillComplete()</code>.</p>
<p>If the matrix doesn't have a column Map yet, you must use global indices, since local indices don't exist yet. However, if you can use local indices, you should. For global indices, the matrix must go to the Map to look up the corresponding local index for every global index. Local indices only require an array access.</p>
<p>Remember that if column indices are local, then they are counted with respect to the column Map. Local row and column indices may not necessarily be the same. For example, the matrix entry at position <code>(i_local, i_local)</code>, where the first <code>i_local</code> is the local row index and the second <code>i_local</code> the local column index, may not necessarily be a diagonal entry of the matrix. However, the matrix entry at global position <code>(i_global, i_global)</code> is always a diagonal entry of the matrix.</p>
<h1><a class="anchor" id="Epetra_Lesson04_Exercise"></a>
Exercise</h1>
<p>Start with the <a class="el" href="Epetra_Lesson03.html">Epetra Lesson 03: Power method</a> example, which uses a dynamic profile and global indices. Try all of the different fill techniques described in this lesson. If you like, you may also try cyclic boundary conditions instead of Dirichlet boundary conditions in the 1-D Poisson discretization. (This makes the number of entries per row the same for all rows.) </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
