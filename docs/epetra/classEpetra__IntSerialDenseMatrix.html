<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Epetra: Epetra_IntSerialDenseMatrix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Epetra<span id="projectnumber">&#160;Development</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classEpetra__IntSerialDenseMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Epetra_IntSerialDenseMatrix Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classEpetra__IntSerialDenseMatrix.html" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices.">Epetra_IntSerialDenseMatrix</a>: A class for constructing and using general dense integer matrices.  
 <a href="classEpetra__IntSerialDenseMatrix.html#details">More...</a></p>

<p><code>#include &lt;Epetra_IntSerialDenseMatrix.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Epetra_IntSerialDenseMatrix:</div>
<div class="dyncontent">
<div class="center"><img src="classEpetra__IntSerialDenseMatrix__inherit__graph.gif" border="0" usemap="#aEpetra__IntSerialDenseMatrix_inherit__map" alt="Inheritance graph"/></div>
<map name="aEpetra__IntSerialDenseMatrix_inherit__map" id="aEpetra__IntSerialDenseMatrix_inherit__map">
<area shape="rect" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices." alt="" coords="5,79,213,104"/>
<area shape="rect" href="classEpetra__IntSerialDenseVector.html" title="Epetra_IntSerialDenseVector: A class for constructing and using dense vectors." alt="" coords="6,152,213,177"/>
<area shape="poly" title=" " alt="" coords="112,118,112,152,107,152,107,118"/>
<area shape="rect" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class." alt="" coords="53,5,166,31"/>
<area shape="poly" title=" " alt="" coords="112,44,112,79,107,79,107,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Epetra_IntSerialDenseMatrix:</div>
<div class="dyncontent">
<div class="center"><img src="classEpetra__IntSerialDenseMatrix__coll__graph.gif" border="0" usemap="#aEpetra__IntSerialDenseMatrix_coll__map" alt="Collaboration graph"/></div>
<map name="aEpetra__IntSerialDenseMatrix_coll__map" id="aEpetra__IntSerialDenseMatrix_coll__map">
<area shape="rect" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices." alt="" coords="5,79,213,104"/>
<area shape="rect" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class." alt="" coords="53,5,166,31"/>
<area shape="poly" title=" " alt="" coords="112,44,112,79,107,79,107,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructor/Destructor Methods</div></td></tr>
<tr class="memitem:a1016207c3d343f3a3a3362474b86c153" id="r_a1016207c3d343f3a3a3362474b86c153"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__IntSerialDenseMatrix.html#a1016207c3d343f3a3a3362474b86c153">Epetra_IntSerialDenseMatrix</a> ()</td></tr>
<tr class="memdesc:a1016207c3d343f3a3a3362474b86c153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor; defines a zero size object.  <br /></td></tr>
<tr class="separator:a1016207c3d343f3a3a3362474b86c153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f93b9c08e9cb2c8028852a7c7bfaf9d" id="r_a5f93b9c08e9cb2c8028852a7c7bfaf9d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__IntSerialDenseMatrix.html#a5f93b9c08e9cb2c8028852a7c7bfaf9d">Epetra_IntSerialDenseMatrix</a> (int NumRows, int NumCols)</td></tr>
<tr class="memdesc:a5f93b9c08e9cb2c8028852a7c7bfaf9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shaped constructor; defines a variable-sized object.  <br /></td></tr>
<tr class="separator:a5f93b9c08e9cb2c8028852a7c7bfaf9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d3bd956bc682ca5cbb81625ea9d860" id="r_ac3d3bd956bc682ca5cbb81625ea9d860"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__IntSerialDenseMatrix.html#ac3d3bd956bc682ca5cbb81625ea9d860">Epetra_IntSerialDenseMatrix</a> (<a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a> <a class="el" href="classEpetra__IntSerialDenseMatrix.html#af288e36515dc8c24dc97d3e85a060738">CV</a>, int *<a class="el" href="classEpetra__IntSerialDenseMatrix.html#af2f4c8ed6978009cbfdc29b10775e6ee">A</a>, int <a class="el" href="classEpetra__IntSerialDenseMatrix.html#a1c13666099f9fe9f9043065e9b941250">LDA</a>, int NumRows, int NumCols)</td></tr>
<tr class="memdesc:ac3d3bd956bc682ca5cbb81625ea9d860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set object values from two-dimensional array.  <br /></td></tr>
<tr class="separator:ac3d3bd956bc682ca5cbb81625ea9d860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c373a0bb1741a2e76609f418d86633" id="r_a34c373a0bb1741a2e76609f418d86633"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__IntSerialDenseMatrix.html#a34c373a0bb1741a2e76609f418d86633">Epetra_IntSerialDenseMatrix</a> (const <a class="el" href="classEpetra__IntSerialDenseMatrix.html">Epetra_IntSerialDenseMatrix</a> &amp;Source)</td></tr>
<tr class="memdesc:a34c373a0bb1741a2e76609f418d86633"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__IntSerialDenseMatrix.html" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices.">Epetra_IntSerialDenseMatrix</a> copy constructor.  <br /></td></tr>
<tr class="separator:a34c373a0bb1741a2e76609f418d86633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad240ff45ab3aa61d77026ff44b617711" id="r_ad240ff45ab3aa61d77026ff44b617711"><td class="memItemLeft" align="right" valign="top"><a id="ad240ff45ab3aa61d77026ff44b617711" name="ad240ff45ab3aa61d77026ff44b617711"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_IntSerialDenseMatrix</b> ()</td></tr>
<tr class="memdesc:ad240ff45ab3aa61d77026ff44b617711"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__IntSerialDenseMatrix.html" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices.">Epetra_IntSerialDenseMatrix</a> destructor. <br /></td></tr>
<tr class="separator:ad240ff45ab3aa61d77026ff44b617711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Shaping/sizing Methods</div></td></tr>
<tr class="memitem:a0351dbd71b0c581b3b8ba01a5b6181ad" id="r_a0351dbd71b0c581b3b8ba01a5b6181ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__IntSerialDenseMatrix.html#a0351dbd71b0c581b3b8ba01a5b6181ad">Shape</a> (int NumRows, int NumCols)</td></tr>
<tr class="memdesc:a0351dbd71b0c581b3b8ba01a5b6181ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set dimensions of a <a class="el" href="classEpetra__IntSerialDenseMatrix.html" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices.">Epetra_IntSerialDenseMatrix</a> object; init values to zero.  <br /></td></tr>
<tr class="separator:a0351dbd71b0c581b3b8ba01a5b6181ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698463711b648d02e5abea3d2f6cb899" id="r_a698463711b648d02e5abea3d2f6cb899"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__IntSerialDenseMatrix.html#a698463711b648d02e5abea3d2f6cb899">Reshape</a> (int NumRows, int NumCols)</td></tr>
<tr class="memdesc:a698463711b648d02e5abea3d2f6cb899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape a <a class="el" href="classEpetra__IntSerialDenseMatrix.html" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices.">Epetra_IntSerialDenseMatrix</a> object.  <br /></td></tr>
<tr class="separator:a698463711b648d02e5abea3d2f6cb899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data Accessor methods</div></td></tr>
<tr class="memitem:a66b6e34905430b47d29f37f156bcd9ec" id="r_a66b6e34905430b47d29f37f156bcd9ec"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__IntSerialDenseMatrix.html#a66b6e34905430b47d29f37f156bcd9ec">OneNorm</a> ()</td></tr>
<tr class="memdesc:a66b6e34905430b47d29f37f156bcd9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the 1-Norm of the <em>this</em> matrix.  <br /></td></tr>
<tr class="separator:a66b6e34905430b47d29f37f156bcd9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef39e08ca518ae2b4e020ee590286b7" id="r_a0ef39e08ca518ae2b4e020ee590286b7"><td class="memItemLeft" align="right" valign="top"><a id="a0ef39e08ca518ae2b4e020ee590286b7" name="a0ef39e08ca518ae2b4e020ee590286b7"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>InfNorm</b> ()</td></tr>
<tr class="memdesc:a0ef39e08ca518ae2b4e020ee590286b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Infinity-Norm of the <em>this</em> matrix. <br /></td></tr>
<tr class="separator:a0ef39e08ca518ae2b4e020ee590286b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f0d3485c6d2e4f1135ce609680828e" id="r_ac2f0d3485c6d2e4f1135ce609680828e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEpetra__IntSerialDenseMatrix.html">Epetra_IntSerialDenseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__IntSerialDenseMatrix.html#ac2f0d3485c6d2e4f1135ce609680828e">operator=</a> (const <a class="el" href="classEpetra__IntSerialDenseMatrix.html">Epetra_IntSerialDenseMatrix</a> &amp;Source)</td></tr>
<tr class="memdesc:ac2f0d3485c6d2e4f1135ce609680828e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from one matrix to another.  <br /></td></tr>
<tr class="separator:ac2f0d3485c6d2e4f1135ce609680828e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89708a315b5996fee266354d6a91acf8" id="r_a89708a315b5996fee266354d6a91acf8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__IntSerialDenseMatrix.html#a89708a315b5996fee266354d6a91acf8">operator==</a> (const <a class="el" href="classEpetra__IntSerialDenseMatrix.html">Epetra_IntSerialDenseMatrix</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a89708a315b5996fee266354d6a91acf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <br /></td></tr>
<tr class="separator:a89708a315b5996fee266354d6a91acf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527378b18ce6d0e2a68ee263441c7d67" id="r_a527378b18ce6d0e2a68ee263441c7d67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__IntSerialDenseMatrix.html#a527378b18ce6d0e2a68ee263441c7d67">operator!=</a> (const <a class="el" href="classEpetra__IntSerialDenseMatrix.html">Epetra_IntSerialDenseMatrix</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a527378b18ce6d0e2a68ee263441c7d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <br /></td></tr>
<tr class="separator:a527378b18ce6d0e2a68ee263441c7d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af752f376eb7f0c449f3da2f5c43cfae8" id="r_af752f376eb7f0c449f3da2f5c43cfae8"><td class="memItemLeft" align="right" valign="top">int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__IntSerialDenseMatrix.html#af752f376eb7f0c449f3da2f5c43cfae8">operator()</a> (int RowIndex, int ColIndex)</td></tr>
<tr class="memdesc:af752f376eb7f0c449f3da2f5c43cfae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element access function.  <br /></td></tr>
<tr class="separator:af752f376eb7f0c449f3da2f5c43cfae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77599b93a37d6cc99f41f8afaae3fdc6" id="r_a77599b93a37d6cc99f41f8afaae3fdc6"><td class="memItemLeft" align="right" valign="top">const int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__IntSerialDenseMatrix.html#a77599b93a37d6cc99f41f8afaae3fdc6">operator()</a> (int RowIndex, int ColIndex) const</td></tr>
<tr class="memdesc:a77599b93a37d6cc99f41f8afaae3fdc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element access function.  <br /></td></tr>
<tr class="separator:a77599b93a37d6cc99f41f8afaae3fdc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710056cbcb8d7fa7d1ec98502715aaab" id="r_a710056cbcb8d7fa7d1ec98502715aaab"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__IntSerialDenseMatrix.html#a710056cbcb8d7fa7d1ec98502715aaab">operator[]</a> (int ColIndex)</td></tr>
<tr class="memdesc:a710056cbcb8d7fa7d1ec98502715aaab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column access function.  <br /></td></tr>
<tr class="separator:a710056cbcb8d7fa7d1ec98502715aaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0609240bd6eecef31c743f9dfb134a6" id="r_af0609240bd6eecef31c743f9dfb134a6"><td class="memItemLeft" align="right" valign="top">const int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__IntSerialDenseMatrix.html#af0609240bd6eecef31c743f9dfb134a6">operator[]</a> (int ColIndex) const</td></tr>
<tr class="memdesc:af0609240bd6eecef31c743f9dfb134a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column access function.  <br /></td></tr>
<tr class="separator:af0609240bd6eecef31c743f9dfb134a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af258e9f58fa635b7ead9f057ad97e33d" id="r_af258e9f58fa635b7ead9f057ad97e33d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__IntSerialDenseMatrix.html#af258e9f58fa635b7ead9f057ad97e33d">Random</a> ()</td></tr>
<tr class="memdesc:af258e9f58fa635b7ead9f057ad97e33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set matrix values to random numbers.  <br /></td></tr>
<tr class="separator:af258e9f58fa635b7ead9f057ad97e33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2f89c4738dd05270fb917685371f90" id="r_a1d2f89c4738dd05270fb917685371f90"><td class="memItemLeft" align="right" valign="top"><a id="a1d2f89c4738dd05270fb917685371f90" name="a1d2f89c4738dd05270fb917685371f90"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>M</b> () const</td></tr>
<tr class="memdesc:a1d2f89c4738dd05270fb917685371f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns row dimension of system. <br /></td></tr>
<tr class="separator:a1d2f89c4738dd05270fb917685371f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f79fe79b76e7fe82fe817a219e1b9b7" id="r_a9f79fe79b76e7fe82fe817a219e1b9b7"><td class="memItemLeft" align="right" valign="top"><a id="a9f79fe79b76e7fe82fe817a219e1b9b7" name="a9f79fe79b76e7fe82fe817a219e1b9b7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>N</b> () const</td></tr>
<tr class="memdesc:a9f79fe79b76e7fe82fe817a219e1b9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns column dimension of system. <br /></td></tr>
<tr class="separator:a9f79fe79b76e7fe82fe817a219e1b9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f4c8ed6978009cbfdc29b10775e6ee" id="r_af2f4c8ed6978009cbfdc29b10775e6ee"><td class="memItemLeft" align="right" valign="top"><a id="af2f4c8ed6978009cbfdc29b10775e6ee" name="af2f4c8ed6978009cbfdc29b10775e6ee"></a>
const int *&#160;</td><td class="memItemRight" valign="bottom"><b>A</b> () const</td></tr>
<tr class="memdesc:af2f4c8ed6978009cbfdc29b10775e6ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const pointer to the <em>this</em> matrix. <br /></td></tr>
<tr class="separator:af2f4c8ed6978009cbfdc29b10775e6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51911b21018b4b8a5492d2e53ef17618" id="r_a51911b21018b4b8a5492d2e53ef17618"><td class="memItemLeft" align="right" valign="top"><a id="a51911b21018b4b8a5492d2e53ef17618" name="a51911b21018b4b8a5492d2e53ef17618"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><b>A</b> ()</td></tr>
<tr class="memdesc:a51911b21018b4b8a5492d2e53ef17618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the <em>this</em> matrix. <br /></td></tr>
<tr class="separator:a51911b21018b4b8a5492d2e53ef17618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c13666099f9fe9f9043065e9b941250" id="r_a1c13666099f9fe9f9043065e9b941250"><td class="memItemLeft" align="right" valign="top"><a id="a1c13666099f9fe9f9043065e9b941250" name="a1c13666099f9fe9f9043065e9b941250"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>LDA</b> () const</td></tr>
<tr class="memdesc:a1c13666099f9fe9f9043065e9b941250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the leading dimension of the <em>this</em> matrix. <br /></td></tr>
<tr class="separator:a1c13666099f9fe9f9043065e9b941250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af288e36515dc8c24dc97d3e85a060738" id="r_af288e36515dc8c24dc97d3e85a060738"><td class="memItemLeft" align="right" valign="top"><a id="af288e36515dc8c24dc97d3e85a060738" name="af288e36515dc8c24dc97d3e85a060738"></a>
<a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CV</b> () const</td></tr>
<tr class="memdesc:af288e36515dc8c24dc97d3e85a060738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data access mode of the <em>this</em> matrix. <br /></td></tr>
<tr class="separator:af288e36515dc8c24dc97d3e85a060738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">I/O methods</div></td></tr>
<tr class="memitem:af70d0eccb70d1f7c85fd9792ccbaef9a" id="r_af70d0eccb70d1f7c85fd9792ccbaef9a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__IntSerialDenseMatrix.html#af70d0eccb70d1f7c85fd9792ccbaef9a">Print</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:af70d0eccb70d1f7c85fd9792ccbaef9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print service methods; defines behavior of ostream &lt;&lt; operator.  <br /></td></tr>
<tr class="separator:af70d0eccb70d1f7c85fd9792ccbaef9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__Object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__Object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__Object.html">Epetra_Object</a></td></tr>
<tr class="memitem:a7676631aca0d619c4e8d3e877c2b87a2 inherit pub_methods_classEpetra__Object" id="r_a7676631aca0d619c4e8d3e877c2b87a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a7676631aca0d619c4e8d3e877c2b87a2">Epetra_Object</a> (int TracebackModeIn=-1, bool set_label=true)</td></tr>
<tr class="memdesc:a7676631aca0d619c4e8d3e877c2b87a2 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Constructor.  <br /></td></tr>
<tr class="separator:a7676631aca0d619c4e8d3e877c2b87a2 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf156d9c8874a2a455ec305826c7313f inherit pub_methods_classEpetra__Object" id="r_acf156d9c8874a2a455ec305826c7313f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#acf156d9c8874a2a455ec305826c7313f">Epetra_Object</a> (const char *const <a class="el" href="classEpetra__Object.html#a1910d1c04e70ac482f7e377b271f6c26">Label</a>, int TracebackModeIn=-1)</td></tr>
<tr class="memdesc:acf156d9c8874a2a455ec305826c7313f inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Constructor.  <br /></td></tr>
<tr class="separator:acf156d9c8874a2a455ec305826c7313f inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f8bd631f2a97276ea07cea8c9c7057 inherit pub_methods_classEpetra__Object" id="r_ac5f8bd631f2a97276ea07cea8c9c7057"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#ac5f8bd631f2a97276ea07cea8c9c7057">Epetra_Object</a> (const <a class="el" href="classEpetra__Object.html">Epetra_Object</a> &amp;Object)</td></tr>
<tr class="memdesc:ac5f8bd631f2a97276ea07cea8c9c7057 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Copy Constructor.  <br /></td></tr>
<tr class="separator:ac5f8bd631f2a97276ea07cea8c9c7057 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742c256d523738e458d0256f72ba9e4b inherit pub_methods_classEpetra__Object" id="r_a742c256d523738e458d0256f72ba9e4b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a742c256d523738e458d0256f72ba9e4b">~Epetra_Object</a> ()</td></tr>
<tr class="memdesc:a742c256d523738e458d0256f72ba9e4b inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Destructor.  <br /></td></tr>
<tr class="separator:a742c256d523738e458d0256f72ba9e4b inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff5c5266120410acbe6ccb63734b5c8 inherit pub_methods_classEpetra__Object" id="r_a9ff5c5266120410acbe6ccb63734b5c8"><td class="memItemLeft" align="right" valign="top">
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>ReportError</b> (const std::string Message, int ErrorCode) const</td></tr>
<tr class="memdesc:a9ff5c5266120410acbe6ccb63734b5c8 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error reporting method. <br /></td></tr>
<tr class="separator:a9ff5c5266120410acbe6ccb63734b5c8 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049c5235b19bd286f95914b547b9f528 inherit pub_methods_classEpetra__Object" id="r_a049c5235b19bd286f95914b547b9f528"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a049c5235b19bd286f95914b547b9f528">SetLabel</a> (const char *const <a class="el" href="classEpetra__Object.html#a1910d1c04e70ac482f7e377b271f6c26">Label</a>)</td></tr>
<tr class="memdesc:a049c5235b19bd286f95914b547b9f528 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Label definition using char *.  <br /></td></tr>
<tr class="separator:a049c5235b19bd286f95914b547b9f528 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1910d1c04e70ac482f7e377b271f6c26 inherit pub_methods_classEpetra__Object" id="r_a1910d1c04e70ac482f7e377b271f6c26"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a1910d1c04e70ac482f7e377b271f6c26">Label</a> () const</td></tr>
<tr class="memdesc:a1910d1c04e70ac482f7e377b271f6c26 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Label access funtion.  <br /></td></tr>
<tr class="separator:a1910d1c04e70ac482f7e377b271f6c26 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Expert-only unsupported methods</h2></td></tr>
<tr class="memitem:ae2652503c065fefdb3c6eae2beee4f06" id="r_ae2652503c065fefdb3c6eae2beee4f06"><td class="memItemLeft" align="right" valign="top"><a id="ae2652503c065fefdb3c6eae2beee4f06" name="ae2652503c065fefdb3c6eae2beee4f06"></a>
<a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CV_</b></td></tr>
<tr class="separator:ae2652503c065fefdb3c6eae2beee4f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bde6f07f5d3cd0a58a3b1b01516c43a" id="r_a8bde6f07f5d3cd0a58a3b1b01516c43a"><td class="memItemLeft" align="right" valign="top"><a id="a8bde6f07f5d3cd0a58a3b1b01516c43a" name="a8bde6f07f5d3cd0a58a3b1b01516c43a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>A_Copied_</b></td></tr>
<tr class="separator:a8bde6f07f5d3cd0a58a3b1b01516c43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5175f3949667ebd857a9903e394a09c1" id="r_a5175f3949667ebd857a9903e394a09c1"><td class="memItemLeft" align="right" valign="top"><a id="a5175f3949667ebd857a9903e394a09c1" name="a5175f3949667ebd857a9903e394a09c1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>M_</b></td></tr>
<tr class="separator:a5175f3949667ebd857a9903e394a09c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ffb3bab847d698820b2ebd7eb63428" id="r_aa5ffb3bab847d698820b2ebd7eb63428"><td class="memItemLeft" align="right" valign="top"><a id="aa5ffb3bab847d698820b2ebd7eb63428" name="aa5ffb3bab847d698820b2ebd7eb63428"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>N_</b></td></tr>
<tr class="separator:aa5ffb3bab847d698820b2ebd7eb63428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04febb040b00754a08fc1c90b235556" id="r_ab04febb040b00754a08fc1c90b235556"><td class="memItemLeft" align="right" valign="top"><a id="ab04febb040b00754a08fc1c90b235556" name="ab04febb040b00754a08fc1c90b235556"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>LDA_</b></td></tr>
<tr class="separator:ab04febb040b00754a08fc1c90b235556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d3566298a32eb01abc5a2d6b36fafa" id="r_a01d3566298a32eb01abc5a2d6b36fafa"><td class="memItemLeft" align="right" valign="top"><a id="a01d3566298a32eb01abc5a2d6b36fafa" name="a01d3566298a32eb01abc5a2d6b36fafa"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><b>A_</b></td></tr>
<tr class="separator:a01d3566298a32eb01abc5a2d6b36fafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1312c6ef9d15a646dd53689d4345181c" id="r_a1312c6ef9d15a646dd53689d4345181c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__IntSerialDenseMatrix.html#a1312c6ef9d15a646dd53689d4345181c">MakeViewOf</a> (const <a class="el" href="classEpetra__IntSerialDenseMatrix.html">Epetra_IntSerialDenseMatrix</a> &amp;Source)</td></tr>
<tr class="memdesc:a1312c6ef9d15a646dd53689d4345181c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset an existing IntSerialDenseMatrix to point to another Matrix.  <br /></td></tr>
<tr class="separator:a1312c6ef9d15a646dd53689d4345181c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d26b3325f5dbf2fac8a94d6067c066" id="r_a71d26b3325f5dbf2fac8a94d6067c066"><td class="memItemLeft" align="right" valign="top"><a id="a71d26b3325f5dbf2fac8a94d6067c066" name="a71d26b3325f5dbf2fac8a94d6067c066"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CopyMat</b> (int *Source, int Source_LDA, int NumRows, int NumCols, int *Target, int Target_LDA)</td></tr>
<tr class="separator:a71d26b3325f5dbf2fac8a94d6067c066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b8209355b22d30a6fbb78be45a84d1" id="r_ae2b8209355b22d30a6fbb78be45a84d1"><td class="memItemLeft" align="right" valign="top"><a id="ae2b8209355b22d30a6fbb78be45a84d1" name="ae2b8209355b22d30a6fbb78be45a84d1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CleanupData</b> ()</td></tr>
<tr class="separator:ae2b8209355b22d30a6fbb78be45a84d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classEpetra__Object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classEpetra__Object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classEpetra__Object.html">Epetra_Object</a></td></tr>
<tr class="memitem:a3e039dae700d04726e0e78d73b69e7f6 inherit pub_static_methods_classEpetra__Object" id="r_a3e039dae700d04726e0e78d73b69e7f6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a3e039dae700d04726e0e78d73b69e7f6">SetTracebackMode</a> (int TracebackModeValue)</td></tr>
<tr class="memdesc:a3e039dae700d04726e0e78d73b69e7f6 inherit pub_static_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the <a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> error traceback report mode.  <br /></td></tr>
<tr class="separator:a3e039dae700d04726e0e78d73b69e7f6 inherit pub_static_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20914bd9b7bb7278ab332415c77ba999 inherit pub_static_methods_classEpetra__Object" id="r_a20914bd9b7bb7278ab332415c77ba999"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><b>GetTracebackMode</b> ()</td></tr>
<tr class="memdesc:a20914bd9b7bb7278ab332415c77ba999 inherit pub_static_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the <a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> error report mode. <br /></td></tr>
<tr class="separator:a20914bd9b7bb7278ab332415c77ba999 inherit pub_static_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661d6081fb13e1b4a4350faa88808f38 inherit pub_static_methods_classEpetra__Object" id="r_a661d6081fb13e1b4a4350faa88808f38"><td class="memItemLeft" align="right" valign="top">
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetTracebackStream</b> ()</td></tr>
<tr class="memdesc:a661d6081fb13e1b4a4350faa88808f38 inherit pub_static_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the output stream for error reporting. <br /></td></tr>
<tr class="separator:a661d6081fb13e1b4a4350faa88808f38 inherit pub_static_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classEpetra__Object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classEpetra__Object')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classEpetra__Object.html">Epetra_Object</a></td></tr>
<tr class="memitem:abcc693a0058b9910543df8c4ae76e5d9 inherit pub_static_attribs_classEpetra__Object" id="r_abcc693a0058b9910543df8c4ae76e5d9"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><b>TracebackMode</b></td></tr>
<tr class="separator:abcc693a0058b9910543df8c4ae76e5d9 inherit pub_static_attribs_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classEpetra__Object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classEpetra__Object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classEpetra__Object.html">Epetra_Object</a></td></tr>
<tr class="memitem:a4e3832c165d22a45d3dd6fecd16d91f4 inherit pro_methods_classEpetra__Object" id="r_a4e3832c165d22a45d3dd6fecd16d91f4"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (const int &amp;x) const</td></tr>
<tr class="separator:a4e3832c165d22a45d3dd6fecd16d91f4 inherit pro_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3f57c8b22b5b0df91400fca8447ab2 inherit pro_methods_classEpetra__Object" id="r_aaa3f57c8b22b5b0df91400fca8447ab2"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (const long long &amp;x) const</td></tr>
<tr class="separator:aaa3f57c8b22b5b0df91400fca8447ab2 inherit pro_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a2fa958fffb21a0479a19956185be1 inherit pro_methods_classEpetra__Object" id="r_ab8a2fa958fffb21a0479a19956185be1"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (const double &amp;x) const</td></tr>
<tr class="separator:ab8a2fa958fffb21a0479a19956185be1 inherit pro_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classEpetra__IntSerialDenseMatrix.html" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices.">Epetra_IntSerialDenseMatrix</a>: A class for constructing and using general dense integer matrices. </p>
<p>The <a class="el" href="classEpetra__IntSerialDenseMatrix.html" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices.">Epetra_IntSerialDenseMatrix</a> class enables the construction and use of integer-valued, general dense matrices.</p>
<p>The <a class="el" href="classEpetra__IntSerialDenseMatrix.html" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices.">Epetra_IntSerialDenseMatrix</a> class is intended to provide very basic support for dense rectangular matrices.</p>
<p><b>Constructing <a class="el" href="classEpetra__IntSerialDenseMatrix.html" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices.">Epetra_IntSerialDenseMatrix</a> Objects</b></p>
<p>There are four <a class="el" href="classEpetra__IntSerialDenseMatrix.html" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices.">Epetra_IntSerialDenseMatrix</a> constructors. The first constructs a zero-sized object which should be made to appropriate length using the <a class="el" href="classEpetra__IntSerialDenseMatrix.html#a0351dbd71b0c581b3b8ba01a5b6181ad" title="Set dimensions of a Epetra_IntSerialDenseMatrix object; init values to zero.">Shape()</a> or <a class="el" href="classEpetra__IntSerialDenseMatrix.html#a698463711b648d02e5abea3d2f6cb899" title="Reshape a Epetra_IntSerialDenseMatrix object.">Reshape()</a> functions and then filled with the [] or () operators. The second constructs an object sized to the dimensions specified, which should be filled with the [] or () operators. The third is a constructor that accepts user data as a 2D array, and the fourth is a copy constructor. The third constructor has two data access modes (specified by the Epetra_DataAccess argument): </p><ol>
<li>
Copy mode - Allocates memory and makes a copy of the user-provided data. In this case, the user data is not needed after construction. </li>
<li>
View mode - Creates a "view" of the user data. In this case, the user data is required to remain intact for the life of the object. </li>
</ol>
<dl class="section warning"><dt>Warning</dt><dd>View mode is <em>extremely</em> dangerous from a data hiding perspective. Therefore, we strongly encourage users to develop code using Copy mode first and only use the View mode in a secondary optimization phase.</dd></dl>
<p><a class="el" href="classEpetra__IntSerialDenseMatrix.html" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices.">Epetra_IntSerialDenseMatrix</a> constructors will throw an exception if an error occurrs. These exceptions will alway be negative integer values as follows: </p><ol>
<li>
-1 Invalid dimension specified. </li>
<li>
-2 Shape returned non-zero. </li>
<li>
-3 Null pointer specified for user's data. </li>
<li>
-99 Internal <a class="el" href="classEpetra__IntSerialDenseMatrix.html" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices.">Epetra_IntSerialDenseMatrix</a> error. Contact developer. </li>
</ol>
<p>Other <a class="el" href="classEpetra__IntSerialDenseMatrix.html" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices.">Epetra_IntSerialDenseMatrix</a> functions that do not return an integer error code (such as operators () and [] ) will throw an exception if an error occurrs. These exceptions will be integer values as follows: </p><ol>
<li>
-1 Invalid row specified. </li>
<li>
-2 Invalid column specified. </li>
<li>
-5 Invalid assignment (type mismatch). </li>
<li>
-99 Internal <a class="el" href="classEpetra__IntSerialDenseMatrix.html" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices.">Epetra_IntSerialDenseMatrix</a> error. Contact developer. </li>
</ol>
<p>b<b>Extracting Data from <a class="el" href="classEpetra__IntSerialDenseMatrix.html" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices.">Epetra_IntSerialDenseMatrix</a> Objects</b></p>
<p>Once a <a class="el" href="classEpetra__IntSerialDenseMatrix.html" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices.">Epetra_IntSerialDenseMatrix</a> is constructed, it is possible to view the data via access functions.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use of these access functions cam be <em>extremely</em> dangerous from a data hiding perspective.</dd></dl>
<p><b>Vector and Utility Functions</b></p>
<p>Once a <a class="el" href="classEpetra__IntSerialDenseMatrix.html" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices.">Epetra_IntSerialDenseMatrix</a> is constructed, several mathematical functions can be applied to the object. Specifically: </p><ul>
<li>
Multiplication. </li>
<li>
Norms. </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1016207c3d343f3a3a3362474b86c153" name="a1016207c3d343f3a3a3362474b86c153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1016207c3d343f3a3a3362474b86c153">&#9670;&#160;</a></span>Epetra_IntSerialDenseMatrix() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_IntSerialDenseMatrix::Epetra_IntSerialDenseMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor; defines a zero size object. </p>
<p><a class="el" href="classEpetra__IntSerialDenseMatrix.html" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices.">Epetra_IntSerialDenseMatrix</a> objects defined by the default constructor should be sized with the <a class="el" href="classEpetra__IntSerialDenseMatrix.html#a0351dbd71b0c581b3b8ba01a5b6181ad" title="Set dimensions of a Epetra_IntSerialDenseMatrix object; init values to zero.">Shape()</a> or Reshape functions. Values should be defined by using the [] or () operators. </p>

</div>
</div>
<a id="a5f93b9c08e9cb2c8028852a7c7bfaf9d" name="a5f93b9c08e9cb2c8028852a7c7bfaf9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f93b9c08e9cb2c8028852a7c7bfaf9d">&#9670;&#160;</a></span>Epetra_IntSerialDenseMatrix() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_IntSerialDenseMatrix::Epetra_IntSerialDenseMatrix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shaped constructor; defines a variable-sized object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>NumRows - Number of rows in object. </td></tr>
    <tr><td class="paramname">In</td><td>NumCols - Number of columns in object.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="classEpetra__SerialDenseMatrix.html" title="Epetra_SerialDenseMatrix: A class for constructing and using real double precision general dense matr...">Epetra_SerialDenseMatrix</a> objects defined by the shaped constructor are already shaped to the dimensions given as a parameters. All values are initialized to 0. Calling this constructor is equivalent to using the default constructor, and then calling the Shape function on it. Values should be defined by using the [] or () operators. </p>

</div>
</div>
<a id="ac3d3bd956bc682ca5cbb81625ea9d860" name="ac3d3bd956bc682ca5cbb81625ea9d860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d3bd956bc682ca5cbb81625ea9d860">&#9670;&#160;</a></span>Epetra_IntSerialDenseMatrix() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_IntSerialDenseMatrix::Epetra_IntSerialDenseMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a>&#160;</td>
          <td class="paramname"><em>CV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set object values from two-dimensional array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>Epetra_DataAccess - Enumerated type set to Copy or View. </td></tr>
    <tr><td class="paramname">In</td><td>A - Pointer to an array of integer numbers. The first vector starts at A. The second vector starts at A+LDA, the third at A+2*LDA, and so on. </td></tr>
    <tr><td class="paramname">In</td><td>LDA - The "Leading Dimension", or stride between vectors in memory. </td></tr>
    <tr><td class="paramname">In</td><td>NumRows - Number of rows in object. </td></tr>
    <tr><td class="paramname">In</td><td>NumCols - Number of columns in object.</td></tr>
  </table>
  </dd>
</dl>
<p>See Detailed Description section for further discussion. </p>

</div>
</div>
<a id="a34c373a0bb1741a2e76609f418d86633" name="a34c373a0bb1741a2e76609f418d86633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c373a0bb1741a2e76609f418d86633">&#9670;&#160;</a></span>Epetra_IntSerialDenseMatrix() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_IntSerialDenseMatrix::Epetra_IntSerialDenseMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__IntSerialDenseMatrix.html">Epetra_IntSerialDenseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>Source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classEpetra__IntSerialDenseMatrix.html" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices.">Epetra_IntSerialDenseMatrix</a> copy constructor. </p>
<p>This matrix will take on the data access mode of the Source matrix. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1312c6ef9d15a646dd53689d4345181c" name="a1312c6ef9d15a646dd53689d4345181c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1312c6ef9d15a646dd53689d4345181c">&#9670;&#160;</a></span>MakeViewOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_IntSerialDenseMatrix::MakeViewOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__IntSerialDenseMatrix.html">Epetra_IntSerialDenseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>Source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset an existing IntSerialDenseMatrix to point to another Matrix. </p>
<p>Allows an existing IntSerialDenseMatrix to become a View of another matrix's data, regardless of the DataAccess mode of the Source matrix. It is assumed that the Source matrix is an independent matrix, and no checking is done to verify this.</p>
<p>This is used by <a class="el" href="classEpetra__CrsGraph.html" title="Epetra_CrsGraph: A class for constructing and using sparse compressed row graphs.">Epetra_CrsGraph</a> in the OptimizeStorage method. It is used so that an existing (Copy) matrix can be converted to a View. This frees up memory that CrsGraph no longer needs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Source</td><td>The IntSerialDenseMatrix this will become a view of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful, and set to -1 if a type mismatch occured.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method is extremely dangerous and should only be used by experts. </dd></dl>

</div>
</div>
<a id="a66b6e34905430b47d29f37f156bcd9ec" name="a66b6e34905430b47d29f37f156bcd9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b6e34905430b47d29f37f156bcd9ec">&#9670;&#160;</a></span>OneNorm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Epetra_IntSerialDenseMatrix::OneNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the 1-Norm of the <em>this</em> matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="a527378b18ce6d0e2a68ee263441c7d67" name="a527378b18ce6d0e2a68ee263441c7d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527378b18ce6d0e2a68ee263441c7d67">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Epetra_IntSerialDenseMatrix::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__IntSerialDenseMatrix.html">Epetra_IntSerialDenseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator. </p>
<p>operator!= simply returns the negation of operator==. </p>

</div>
</div>
<a id="af752f376eb7f0c449f3da2f5c43cfae8" name="af752f376eb7f0c449f3da2f5c43cfae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af752f376eb7f0c449f3da2f5c43cfae8">&#9670;&#160;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int &amp; Epetra_IntSerialDenseMatrix::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>RowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ColIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element access function. </p>
<p>The parentheses operator returns the element in the ith row and jth column if A(i,j) is specified, the expression A[j][i] (note that i and j are reversed) will return the same element. Thus, A(i,j) = A[j][i] for all valid i and j.</p>
<dl class="section return"><dt>Returns</dt><dd>Element from the specified row and column. <pre class="fragment">\warning No bounds checking is done unless Epetra is compiled with HAVE_EPETRA_ARRAY_BOUNDS_CHECK.
</pre> </dd></dl>

<p class="reference">References <a class="el" href="classEpetra__Object.html#a9ff5c5266120410acbe6ccb63734b5c8">Epetra_Object::ReportError()</a>.</p>

</div>
</div>
<a id="a77599b93a37d6cc99f41f8afaae3fdc6" name="a77599b93a37d6cc99f41f8afaae3fdc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77599b93a37d6cc99f41f8afaae3fdc6">&#9670;&#160;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int &amp; Epetra_IntSerialDenseMatrix::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>RowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ColIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element access function. </p>
<p>The parentheses operator returns the element in the ith row and jth column if A(i,j) is specified, the expression A[j][i] (note that i and j are reversed) will return the same element. Thus, A(i,j) = A[j][i] for all valid i and j.</p>
<dl class="section return"><dt>Returns</dt><dd>Element from the specified row and column. <pre class="fragment">\warning No bounds checking is done unless Epetra is compiled with HAVE_EPETRA_ARRAY_BOUNDS_CHECK.
</pre> </dd></dl>

<p class="reference">References <a class="el" href="classEpetra__Object.html#a9ff5c5266120410acbe6ccb63734b5c8">Epetra_Object::ReportError()</a>.</p>

</div>
</div>
<a id="ac2f0d3485c6d2e4f1135ce609680828e" name="ac2f0d3485c6d2e4f1135ce609680828e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f0d3485c6d2e4f1135ce609680828e">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEpetra__IntSerialDenseMatrix.html">Epetra_IntSerialDenseMatrix</a> &amp; Epetra_IntSerialDenseMatrix::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__IntSerialDenseMatrix.html">Epetra_IntSerialDenseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>Source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy from one matrix to another. </p>
<p>The operator= allows one to copy the values from one existing IntSerialDenseMatrix to another. The left hand side matrix will take on the data access mode of the right hand side matrix.</p>
<dl class="section return"><dt>Returns</dt><dd>Values of the left hand side matrix are modified by the values of the right hand side matrix. </dd></dl>

</div>
</div>
<a id="a89708a315b5996fee266354d6a91acf8" name="a89708a315b5996fee266354d6a91acf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89708a315b5996fee266354d6a91acf8">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Epetra_IntSerialDenseMatrix::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__IntSerialDenseMatrix.html">Epetra_IntSerialDenseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>operator== compares two <a class="el" href="classEpetra__IntSerialDenseMatrix.html" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices.">Epetra_IntSerialDenseMatrix</a> objects, returns false if sizes are different, or if any coefficients differ. </p>

</div>
</div>
<a id="a710056cbcb8d7fa7d1ec98502715aaab" name="a710056cbcb8d7fa7d1ec98502715aaab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710056cbcb8d7fa7d1ec98502715aaab">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int * Epetra_IntSerialDenseMatrix::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ColIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Column access function. </p>
<p>The parentheses operator returns the element in the ith row and jth column if A(i,j) is specified, the expression A[j][i] (note that i and j are reversed) will return the same element. Thus, A(i,j) = A[j][i] for all valid i and j.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to address of specified column.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No bounds checking can be done for the index i in the expression A[j][i]. </dd>
<dd>
No bounds checking is done unless Epetra is compiled with HAVE_EPETRA_ARRAY_BOUNDS_CHECK. </dd></dl>

<p class="reference">References <a class="el" href="classEpetra__Object.html#a9ff5c5266120410acbe6ccb63734b5c8">Epetra_Object::ReportError()</a>.</p>

</div>
</div>
<a id="af0609240bd6eecef31c743f9dfb134a6" name="af0609240bd6eecef31c743f9dfb134a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0609240bd6eecef31c743f9dfb134a6">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int * Epetra_IntSerialDenseMatrix::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ColIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Column access function. </p>
<p>The parentheses operator returns the element in the ith row and jth column if A(i,j) is specified, the expression A[j][i] (note that i and j are reversed) will return the same element. Thus, A(i,j) = A[j][i] for all valid i and j.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to address of specified column.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No bounds checking can be done for the index i in the expression A[j][i]. </dd>
<dd>
No bounds checking is done unless Epetra is compiled with HAVE_EPETRA_ARRAY_BOUNDS_CHECK. </dd></dl>

<p class="reference">References <a class="el" href="classEpetra__Object.html#a9ff5c5266120410acbe6ccb63734b5c8">Epetra_Object::ReportError()</a>.</p>

</div>
</div>
<a id="af70d0eccb70d1f7c85fd9792ccbaef9a" name="af70d0eccb70d1f7c85fd9792ccbaef9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70d0eccb70d1f7c85fd9792ccbaef9a">&#9670;&#160;</a></span>Print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Epetra_IntSerialDenseMatrix::Print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print service methods; defines behavior of ostream &lt;&lt; operator. </p>

<p>Reimplemented from <a class="el" href="classEpetra__Object.html#af40e8f4c7d6701b84f741d3158db7c37">Epetra_Object</a>.</p>

<p>Reimplemented in <a class="el" href="classEpetra__IntSerialDenseVector.html#a6acf3bcb7afc0bbd548fdaf654932331">Epetra_IntSerialDenseVector</a>.</p>

</div>
</div>
<a id="af258e9f58fa635b7ead9f057ad97e33d" name="af258e9f58fa635b7ead9f057ad97e33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af258e9f58fa635b7ead9f057ad97e33d">&#9670;&#160;</a></span>Random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_IntSerialDenseMatrix::Random </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set matrix values to random numbers. </p>
<pre class="fragment">IntSerialDenseMatrix uses the random number generator provided by Epetra_Util.
The matrix values will be set to random values on the interval (0, 2^31 - 1).
</pre> <dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="a698463711b648d02e5abea3d2f6cb899" name="a698463711b648d02e5abea3d2f6cb899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698463711b648d02e5abea3d2f6cb899">&#9670;&#160;</a></span>Reshape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_IntSerialDenseMatrix::Reshape </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reshape a <a class="el" href="classEpetra__IntSerialDenseMatrix.html" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices.">Epetra_IntSerialDenseMatrix</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>NumRows - Number of rows in object. </td></tr>
    <tr><td class="paramname">In</td><td>NumCols - Number of columns in object.</td></tr>
  </table>
  </dd>
</dl>
<p>Allows user to define the dimensions of a <a class="el" href="classEpetra__IntSerialDenseMatrix.html" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices.">Epetra_IntSerialDenseMatrix</a> at any point. This function can be called at any point after construction. Any values that were previously in this object are copied into the new shape. If the new shape is smaller than the original, the upper left portion of the original matrix (the principal submatrix) is copied to the new matrix.</p>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classEpetra__IntSerialDenseVector.html#a4439b733f82c98ad6a3a0e52aec4496b">Epetra_IntSerialDenseVector::Resize()</a>.</p>

</div>
</div>
<a id="a0351dbd71b0c581b3b8ba01a5b6181ad" name="a0351dbd71b0c581b3b8ba01a5b6181ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0351dbd71b0c581b3b8ba01a5b6181ad">&#9670;&#160;</a></span>Shape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_IntSerialDenseMatrix::Shape </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set dimensions of a <a class="el" href="classEpetra__IntSerialDenseMatrix.html" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices.">Epetra_IntSerialDenseMatrix</a> object; init values to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>NumRows - Number of rows in object. </td></tr>
    <tr><td class="paramname">In</td><td>NumCols - Number of columns in object.</td></tr>
  </table>
  </dd>
</dl>
<p>Allows user to define the dimensions of a <a class="el" href="classEpetra__IntSerialDenseMatrix.html" title="Epetra_IntSerialDenseMatrix: A class for constructing and using general dense integer matrices.">Epetra_IntSerialDenseMatrix</a> at any point. This function can be called at any point after construction. Any values that were previously in this object are destroyed and the resized matrix starts off with all zero values.</p>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classEpetra__IntSerialDenseVector.html#a4e37ecf403d980714c7dd2648c34e7c5">Epetra_IntSerialDenseVector::Size()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><b>Epetra_IntSerialDenseMatrix.h</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
