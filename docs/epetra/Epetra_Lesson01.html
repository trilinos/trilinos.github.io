<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Epetra: Epetra Lesson 01: Initialization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Epetra<span id="projectnumber">&#160;Development</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Epetra Lesson 01: Initialization</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>"Hello world!" initialization.</p>
<h1><a class="anchor" id="Epetra_Lesson01_Topics"></a>
Lesson topics</h1>
<p>The Epetra package provides distributed sparse linear algebra. It includes sparse matrices, vectors, and other linear algebra objects, along with computational kernels. This lesson shows the MPI (or non-MPI) initialization you need to do in order to start using Epetra. The initialization procedure differs slightly, depending on whether you are writing a code from scratch, or introducing Epetra into an existing code base. We will give example codes and discussion for the following three use cases: </p><ol>
<li>
A code which only uses MPI through Trilinos  </li>
<li>
A code which uses MPI on its own as well as through Trilinos  </li>
<li>
A code which does not use MPI  </li>
</ol>
<h1><a class="anchor" id="Epetra_Lesson01_MpiOnlyThroughTrilinos"></a>
Initialization for a code that only uses MPI through Trilinos</h1>
<p>This section explains how to set up the distributed-memory parallel environment for using Epetra, in a code which only uses MPI through Trilinos. If you want to introduce Epetra into an existing MPI application, please see the next section. This example works whether or not Trilinos was built with MPI support.</p>
<p>Epetra was written for distributed-memory parallel programming. It uses <a href="http://en.wikipedia.org/wiki/Message_Passing_Interface">MPI</a> (the Message Passing Interface) for this. However, Epetra will work correctly whether or not you have built Trilinos with MPI support. It does so by interacting with MPI through an interface called <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a>. If MPI is enabled, then this wraps an MPI_Comm. Otherwise, this is a "serial communicator" with one process, analogous to MPI_COMM_SELF.</p>
<p>Epetra expects that the user call MPI_Init before using MPI, and call MPI_Finalize after using MPI (usually at the end of the program). You may either do this manually, or use Teuchos::GlobalMPISession. The latter calls MPI_Init and MPI_Finalize for you in an MPI build, and does not call them if you did not build Trilinos with MPI support. However, you may only use Teuchos::GlobalMPISession if Trilinos was built with the Teuchos package enabled. Epetra does not require the Teuchos package, so the the following example illustrates the standard idiom for initializing MPI (if available) and getting an <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> corresponding to MPI_COMM_WORLD. The example works whether or not Trilinos was build with MPI support.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// This example includes conditional MPI initialization, getting an</span></div>
<div class="line"><span class="comment">// Epetra communicator wrapper, and printing out Epetra version</span></div>
<div class="line"><span class="comment">// information.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// This defines useful macros like HAVE_MPI, which is defined if and</span></div>
<div class="line"><span class="comment">// only if Epetra was built with MPI enabled.</span></div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_config.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef HAVE_MPI</span></div>
<div class="line"><span class="comment">// Your code is an existing MPI code, so it presumably includes mpi.h directly.</span></div>
<div class="line"><span class="preprocessor">#  include &lt;mpi.h&gt;</span></div>
<div class="line"><span class="comment">// Epetra&#39;s wrapper for MPI_Comm.  This header file only exists if</span></div>
<div class="line"><span class="comment">// Epetra was built with MPI enabled.</span></div>
<div class="line"><span class="preprocessor">#  include &lt;Epetra_MpiComm.h&gt;</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#  include &lt;Epetra_SerialComm.h&gt;</span></div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// HAVE_MPI</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_Version.h&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// ... Your other include files go here ...</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Do something with the given communicator.  In this case, we just</span></div>
<div class="line"><span class="comment">// print Epetra&#39;s version to the given output stream, on Process 0.</span></div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">exampleRoutine (<span class="keyword">const</span> <a class="code hl_class" href="classEpetra__Comm.html">Epetra_Comm</a>&amp; comm,</div>
<div class="line">                std::ostream&amp; out)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (comm.<a class="code hl_function" href="classEpetra__Comm.html#a60135f8b72809635695dd2b8f539da6b">MyPID</a> () == 0) {</div>
<div class="line">    <span class="comment">// On (MPI) Process 0, print out the Epetra software version.</span></div>
<div class="line">    out &lt;&lt; Epetra_Version () &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// These &quot;using&quot; declarations make the code more concise, in that</span></div>
<div class="line">  <span class="comment">// you don&#39;t have to write the namespace along with the class or</span></div>
<div class="line">  <span class="comment">// object name.  This is especially helpful with commonly used</span></div>
<div class="line">  <span class="comment">// things like std::endl.</span></div>
<div class="line">  <span class="keyword">using </span>std::cout;</div>
<div class="line">  <span class="keyword">using </span>std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef HAVE_MPI</span></div>
<div class="line">  <span class="comment">// Start up MPI, if using MPI.  Trilinos doesn&#39;t have to be built</span></div>
<div class="line">  <span class="comment">// with MPI; it&#39;s called a &quot;serial&quot; build if you build without MPI.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// It&#39;s bad form to ignore the error codes returned by MPI</span></div>
<div class="line">  <span class="comment">// functions, but we do so here for brevity.</span></div>
<div class="line">  (void) MPI_Init (&amp;argc, &amp;argv);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Wrap MPI_COMM_WORLD in an Epetra communicator wrapper.</span></div>
<div class="line">  <span class="comment">// Epetra_MpiComm is a subclass of Epetra_Comm, so you may use it</span></div>
<div class="line">  <span class="comment">// wherever an Epetra_Comm is required.</span></div>
<div class="line">  <a class="code hl_class" href="classEpetra__MpiComm.html">Epetra_MpiComm</a> comm (MPI_COMM_WORLD);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <span class="comment">// Make a &quot;serial&quot; (non-MPI) communicator.  It doesn&#39;t actually</span></div>
<div class="line">  <span class="comment">// &quot;communicate,&quot; because it only has one process, whose rank is</span></div>
<div class="line">  <span class="comment">// always 0.  Epetra_SerialComm is a subclass of Epetra_Comm, so you</span></div>
<div class="line">  <span class="comment">// may use it wherever an Epetra_Comm is required.</span></div>
<div class="line">  <a class="code hl_class" href="classEpetra__SerialComm.html">Epetra_SerialComm</a> comm;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Epetra_Comm has methods that wrap basic MPI functionality.</span></div>
<div class="line">  <span class="comment">// MyPID() is equivalent to MPI_Comm_rank, and NumProc() to</span></div>
<div class="line">  <span class="comment">// MPI_Comm_size.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// With a &quot;serial&quot; communicator, the rank is always 0, and the</span></div>
<div class="line">  <span class="comment">// number of processes is always 1.</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> myRank = comm.<a class="code hl_function" href="classEpetra__SerialComm.html#a237a6407573dea22f0366936d158486d">MyPID</a> ();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> numProcs = comm.<a class="code hl_function" href="classEpetra__SerialComm.html#af55220ff6540694c810aa9f2b3ec146f">NumProc</a> ();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Total number of processes: &quot;</span> &lt;&lt; numProcs &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Do something with the new Epetra communicator.</span></div>
<div class="line">  exampleRoutine (comm, cout);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// This tells the Trilinos test framework that the test passed.</span></div>
<div class="line">  <span class="keywordflow">if</span> (comm.<a class="code hl_function" href="classEpetra__SerialComm.html#a237a6407573dea22f0366936d158486d">MyPID</a> () == 0) {</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;End Result: TEST PASSED&quot;</span> &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef HAVE_MPI</span></div>
<div class="line">  <span class="comment">// Since you called MPI_Init, you are responsible for calling</span></div>
<div class="line">  <span class="comment">// MPI_Finalize after you are done using MPI.</span></div>
<div class="line">  (void) MPI_Finalize ();</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// HAVE_MPI</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassEpetra__Comm_html"><div class="ttname"><a href="classEpetra__Comm.html">Epetra_Comm</a></div><div class="ttdoc">Epetra_Comm: The Epetra Communication Abstract Base Class.</div><div class="ttdef"><b>Definition</b> Epetra_Comm.h:81</div></div>
<div class="ttc" id="aclassEpetra__Comm_html_a60135f8b72809635695dd2b8f539da6b"><div class="ttname"><a href="classEpetra__Comm.html#a60135f8b72809635695dd2b8f539da6b">Epetra_Comm::MyPID</a></div><div class="ttdeci">virtual int MyPID() const =0</div><div class="ttdoc">Return my process ID.</div></div>
<div class="ttc" id="aclassEpetra__MpiComm_html"><div class="ttname"><a href="classEpetra__MpiComm.html">Epetra_MpiComm</a></div><div class="ttdoc">Epetra_MpiComm: The Epetra MPI Communication Class.</div><div class="ttdef"><b>Definition</b> Epetra_MpiComm.h:72</div></div>
<div class="ttc" id="aclassEpetra__SerialComm_html"><div class="ttname"><a href="classEpetra__SerialComm.html">Epetra_SerialComm</a></div><div class="ttdoc">Epetra_SerialComm: The Epetra Serial Communication Class.</div><div class="ttdef"><b>Definition</b> Epetra_SerialComm.h:69</div></div>
<div class="ttc" id="aclassEpetra__SerialComm_html_a237a6407573dea22f0366936d158486d"><div class="ttname"><a href="classEpetra__SerialComm.html#a237a6407573dea22f0366936d158486d">Epetra_SerialComm::MyPID</a></div><div class="ttdeci">int MyPID() const</div><div class="ttdoc">Return my process ID.</div><div class="ttdef"><b>Definition</b> Epetra_SerialComm.h:440</div></div>
<div class="ttc" id="aclassEpetra__SerialComm_html_af55220ff6540694c810aa9f2b3ec146f"><div class="ttname"><a href="classEpetra__SerialComm.html#af55220ff6540694c810aa9f2b3ec146f">Epetra_SerialComm::NumProc</a></div><div class="ttdeci">int NumProc() const</div><div class="ttdoc">Returns total number of processes (always returns 1 for SerialComm).</div><div class="ttdef"><b>Definition</b> Epetra_SerialComm.h:443</div></div>
</div><!-- fragment --><h1><a class="anchor" id="Epetra_Lesson01_ExistingMpiCode"></a>
Initialization for an existing MPI code</h1>
<p>Epetra also works fine in an existing MPI code. For this example, we assume that your code initializes MPI on its own by calling MPI_Init, and calls MPI_Finalize at the end. It also must get an MPI_Comm (an MPI communicator) somewhere, either by using a predefined communicator such as MPI_COMM_WORLD, or by creating a new one.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// This example shows how to wrap the MPI_Comm (MPI communicator) that</span></div>
<div class="line"><span class="comment">// you are using, so that Epetra can use it as well.  it includes MPI</span></div>
<div class="line"><span class="comment">// initialization, wrapping your MPI_Comm in an Epetra communicator</span></div>
<div class="line"><span class="comment">// wrapper, and printing out Epetra version information.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// This defines useful macros like HAVE_MPI, which is defined if and</span></div>
<div class="line"><span class="comment">// only if Epetra was built with MPI enabled.</span></div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_config.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef HAVE_MPI</span></div>
<div class="line"><span class="comment">// Your code is an existing MPI code, so it presumably includes mpi.h directly.</span></div>
<div class="line"><span class="preprocessor">#  include &lt;mpi.h&gt;</span></div>
<div class="line"><span class="comment">// Epetra&#39;s wrapper for MPI_Comm.  This header file only exists if</span></div>
<div class="line"><span class="comment">// Epetra was built with MPI enabled.</span></div>
<div class="line"><span class="preprocessor">#  include &lt;Epetra_MpiComm.h&gt;</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#  error &quot;This example requires MPI in order to build.&quot;</span></div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// HAVE_MPI</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_Version.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// ... Your other include files go here ...</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Do something with the given communicator.  In this case, we just</span></div>
<div class="line"><span class="comment">// print Epetra&#39;s version to the given output stream, on Process 0.</span></div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">exampleRoutine (<span class="keyword">const</span> <a class="code hl_class" href="classEpetra__Comm.html">Epetra_Comm</a>&amp; comm,</div>
<div class="line">                std::ostream&amp; out)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (comm.<a class="code hl_function" href="classEpetra__Comm.html#a60135f8b72809635695dd2b8f539da6b">MyPID</a> () == 0) {</div>
<div class="line">    <span class="comment">// On (MPI) Process 0, print out the Epetra software version.</span></div>
<div class="line">    out &lt;&lt; Epetra_Version () &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// These &quot;using&quot; declarations make the code more concise, in that</span></div>
<div class="line">  <span class="comment">// you don&#39;t have to write the namespace along with the class or</span></div>
<div class="line">  <span class="comment">// object name.  This is especially helpful with commonly used</span></div>
<div class="line">  <span class="comment">// things like std::endl.</span></div>
<div class="line">  <span class="keyword">using </span>std::cout;</div>
<div class="line">  <span class="keyword">using </span>std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// We assume that your code calls MPI_Init.  It&#39;s bad form</span></div>
<div class="line">  <span class="comment">// to ignore the error codes returned by MPI functions, but</span></div>
<div class="line">  <span class="comment">// we do so here for brevity.</span></div>
<div class="line">  (void) MPI_Init (&amp;argc, &amp;argv);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// This code takes the place of whatever you do to get an MPI_Comm.</span></div>
<div class="line">  MPI_Comm yourComm = MPI_COMM_WORLD;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If your code plans to use MPI on its own, as well as through</span></div>
<div class="line">  <span class="comment">// Trilinos, you should strongly consider giving Trilinos a copy</span></div>
<div class="line">  <span class="comment">// of your MPI_Comm (created via MPI_Comm_dup).  Trilinos may in</span></div>
<div class="line">  <span class="comment">// the future duplicate the MPI_Comm automatically, but it does</span></div>
<div class="line">  <span class="comment">// not currently do this.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Wrap the MPI_Comm.  You are responsible for calling MPI_Comm_free</span></div>
<div class="line">  <span class="comment">// on your MPI_Comm after use, if necessary.  (It&#39;s not necessary or</span></div>
<div class="line">  <span class="comment">// legal to do this for built-in communicators like MPI_COMM_WORLD</span></div>
<div class="line">  <span class="comment">// or MPI_COMM_SELF.)</span></div>
<div class="line">  <a class="code hl_class" href="classEpetra__MpiComm.html">Epetra_MpiComm</a> comm (yourComm);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Epetra_Comm has methods that wrap basic MPI functionality.</span></div>
<div class="line">  <span class="comment">// MyPID() is equivalent to MPI_Comm_rank; it returns my process&#39;</span></div>
<div class="line">  <span class="comment">// rank.  NumProc() is equivalent to MPI_Comm_size; it returns the</span></div>
<div class="line">  <span class="comment">// total number of processes in the communicator.</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> myRank = comm.<a class="code hl_function" href="classEpetra__Comm.html#a60135f8b72809635695dd2b8f539da6b">MyPID</a> ();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> numProcs = comm.<a class="code hl_function" href="classEpetra__Comm.html#a08ed286ec280a7bae33ea6b6e772ff1a">NumProc</a> ();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Total number of processes: &quot;</span> &lt;&lt; numProcs &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Do something with the new Epetra communicator.</span></div>
<div class="line">  exampleRoutine (comm, cout);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// This tells the Trilinos test framework that the test passed.</span></div>
<div class="line">  <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;End Result: TEST PASSED&quot;</span> &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If you need to call MPI_Comm_free on your MPI_Comm, now would be</span></div>
<div class="line">  <span class="comment">// the time to do so, before calling MPI_Finalize.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Since you called MPI_Init, you are responsible for calling</span></div>
<div class="line">  <span class="comment">// MPI_Finalize after you are done using MPI.</span></div>
<div class="line">  (void) MPI_Finalize ();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassEpetra__Comm_html_a08ed286ec280a7bae33ea6b6e772ff1a"><div class="ttname"><a href="classEpetra__Comm.html#a08ed286ec280a7bae33ea6b6e772ff1a">Epetra_Comm::NumProc</a></div><div class="ttdeci">virtual int NumProc() const =0</div><div class="ttdoc">Returns total number of processes.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="Epetra_Lesson01_ExistingNonMpiCode"></a>
Initialization for an existing non-MPI code</h1>
<p>If are using a build of Trilinos that has MPI enabled, but you don't want to use MPI in your application, you may either imitate the first example above, or create an <a class="el" href="classEpetra__SerialComm.html" title="Epetra_SerialComm: The Epetra Serial Communication Class.">Epetra_SerialComm</a> directly as the "communicator." The following example shows how to create an <a class="el" href="classEpetra__SerialComm.html" title="Epetra_SerialComm: The Epetra Serial Communication Class.">Epetra_SerialComm</a>.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_config.h&gt;</span></div>
<div class="line"><span class="comment">// Wrapper for a &quot;communicator&quot; containing only one process.  This</span></div>
<div class="line"><span class="comment">// header file always exists, whether or not Epetra was built with MPI</span></div>
<div class="line"><span class="comment">// enabled.</span></div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_SerialComm.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_Version.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdexcept&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// ... Your other include files go here ...</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Do something with the given communicator.  In this case, we just</span></div>
<div class="line"><span class="comment">// print Epetra&#39;s version to the given output stream, on Process 0.</span></div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">exampleRoutine (<span class="keyword">const</span> <a class="code hl_class" href="classEpetra__Comm.html">Epetra_Comm</a>&amp; comm,</div>
<div class="line">                std::ostream&amp; out)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (comm.<a class="code hl_function" href="classEpetra__Comm.html#a60135f8b72809635695dd2b8f539da6b">MyPID</a> () == 0) {</div>
<div class="line">    <span class="comment">// On (MPI) Process 0, print out the Epetra software version.</span></div>
<div class="line">    out &lt;&lt; Epetra_Version () &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main (<span class="keywordtype">int</span> <span class="comment">/* argc */</span>, <span class="keywordtype">char</span> * <span class="comment">/* argv */</span>[])</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// These &quot;using&quot; declarations make the code more concise, in that</span></div>
<div class="line">  <span class="comment">// you don&#39;t have to write the namespace along with the class or</span></div>
<div class="line">  <span class="comment">// object name.  This is especially helpful with commonly used</span></div>
<div class="line">  <span class="comment">// things like std::endl.</span></div>
<div class="line">  <span class="keyword">using </span>std::cout;</div>
<div class="line">  <span class="keyword">using </span>std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Make a &quot;serial&quot; (non-MPI) communicator.  It doesn&#39;t actually</span></div>
<div class="line">  <span class="comment">// &quot;communicate,&quot; because it only has one process, whose rank is</span></div>
<div class="line">  <span class="comment">// always 0.  Epetra_SerialComm is a subclass of Epetra_Comm, so you</span></div>
<div class="line">  <span class="comment">// may use it wherever an Epetra_Comm is required.</span></div>
<div class="line">  <a class="code hl_class" href="classEpetra__SerialComm.html">Epetra_SerialComm</a> comm;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Epetra_Comm has methods that wrap basic MPI functionality.</span></div>
<div class="line">  <span class="comment">// MyPID() is equivalent to MPI_Comm_rank, and NumProc() to</span></div>
<div class="line">  <span class="comment">// MPI_Comm_size.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// With a &quot;serial&quot; communicator, the rank is always 0, and the</span></div>
<div class="line">  <span class="comment">// number of processes is always 1.</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> myRank = comm.<a class="code hl_function" href="classEpetra__SerialComm.html#a237a6407573dea22f0366936d158486d">MyPID</a> ();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> numProcs = comm.<a class="code hl_function" href="classEpetra__SerialComm.html#af55220ff6540694c810aa9f2b3ec146f">NumProc</a> ();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Test the two assertions in the previous comment.</span></div>
<div class="line">  <span class="keywordflow">if</span> (numProcs != 1) {</div>
<div class="line">    std::ostringstream err;</div>
<div class="line">    err &lt;&lt; <span class="stringliteral">&quot;This is a serial (non-MPI) example, but the number of processes &quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;in the Epetra_Comm is &quot;</span> &lt;&lt; numProcs &lt;&lt; <span class="stringliteral">&quot; != 1.  Please report &quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;this bug.&quot;</span>;</div>
<div class="line">    <span class="keywordflow">throw</span> std::logic_error (err.str ());</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> (myRank != 0) {</div>
<div class="line">    std::ostringstream err;</div>
<div class="line">    err &lt;&lt; <span class="stringliteral">&quot;This is a serial (non-MPI) example, but the rank of the calling &quot;</span></div>
<div class="line">      <span class="stringliteral">&quot;process in the Epetra_Comm is &quot;</span> &lt;&lt; myRank &lt;&lt; <span class="stringliteral">&quot; != 0.  Please report &quot;</span></div>
<div class="line">      <span class="stringliteral">&quot;this bug.&quot;</span>;</div>
<div class="line">    <span class="keywordflow">throw</span> std::logic_error (err.str ());</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Do something with the new communicator.</span></div>
<div class="line">  exampleRoutine (comm, cout);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// This tells the Trilinos test framework that the test passed.</span></div>
<div class="line">  <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;End Result: TEST PASSED&quot;</span> &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="Epetra_Lesson01_Other"></a>
Things we didn't explain above</h1>
<h2><a class="anchor" id="Epetra_Lesson01_Other_Comm"></a>
Epetra_Comm, Epetra_MpiComm, and Epetra_SerialComm</h2>
<p><a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> is Epetra's interface to distributed-memory parallel communication. It is an abstract base class. The <a class="el" href="classEpetra__MpiComm.html" title="Epetra_MpiComm: The Epetra MPI Communication Class.">Epetra_MpiComm</a> and <a class="el" href="classEpetra__SerialComm.html" title="Epetra_SerialComm: The Epetra Serial Communication Class.">Epetra_SerialComm</a> classes implement this interface. As the name indicates, <a class="el" href="classEpetra__MpiComm.html" title="Epetra_MpiComm: The Epetra MPI Communication Class.">Epetra_MpiComm</a> implements <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> by using MPI calls. <a class="el" href="classEpetra__SerialComm.html" title="Epetra_SerialComm: The Epetra Serial Communication Class.">Epetra_SerialComm</a> implements <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> without MPI, as a "communicator" with only one process, whose rank is always zero. (This is more or less equivalent to MPI_COMM_SELF, except without actually using MPI.)</p>
<p>Since <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> is an abstract base class, you cannot create it directly. You must handle it by pointer or reference. However, you may create an instance of a subclass of <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a>. The above examples show how to do this. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
