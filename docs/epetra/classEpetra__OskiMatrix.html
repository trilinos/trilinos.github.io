<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Epetra: Epetra_OskiMatrix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Epetra<span id="projectnumber">&#160;Development</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classEpetra__OskiMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Epetra_OskiMatrix Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classEpetra__OskiMatrix.html" title="Epetra_OskiMatrix: A class for constructing and using OSKI Matrices within Epetra....">Epetra_OskiMatrix</a>: A class for constructing and using OSKI Matrices within Epetra. For information on known issues with OSKI see the detailed description.  
 <a href="classEpetra__OskiMatrix.html#details">More...</a></p>

<p><code>#include &lt;Epetra_OskiMatrix.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Epetra_OskiMatrix:</div>
<div class="dyncontent">
<div class="center"><img src="classEpetra__OskiMatrix__inherit__graph.gif" border="0" usemap="#aEpetra__OskiMatrix_inherit__map" alt="Inheritance graph"/></div>
<map name="aEpetra__OskiMatrix_inherit__map" id="aEpetra__OskiMatrix_inherit__map">
<area shape="rect" title="Epetra_OskiMatrix: A class for constructing and using OSKI Matrices within Epetra...." alt="" coords="320,225,463,251"/>
<area shape="rect" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real&#45;valued double&#45;precision sparse compressed r..." alt="" coords="324,152,459,177"/>
<area shape="poly" title=" " alt="" coords="394,191,394,225,389,225,389,191"/>
<area shape="rect" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi&#45;vectors, vectors and matrices in pa..." alt="" coords="73,79,211,104"/>
<area shape="poly" title=" " alt="" coords="196,105,352,149,350,154,195,110"/>
<area shape="rect" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class." alt="" coords="5,5,119,31"/>
<area shape="poly" title=" " alt="" coords="87,38,131,76,127,80,83,42"/>
<area shape="rect" href="classEpetra__SrcDistObject.html" title="Epetra_SrcDistObject: A class for supporting flexible source distributed objects for import/export op..." alt="" coords="143,5,301,31"/>
<area shape="poly" title=" " alt="" coords="201,42,157,80,153,76,197,38"/>
<area shape="rect" href="classEpetra__RowMatrix.html" title="Epetra_RowMatrix: A pure virtual class for using real&#45;valued double&#45;precision row matrices." alt="" coords="235,79,377,104"/>
<area shape="poly" title=" " alt="" coords="248,38,294,76,291,80,244,42"/>
<area shape="rect" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes." alt="" coords="401,79,552,104"/>
<area shape="poly" title=" " alt="" coords="454,115,407,154,404,150,451,110"/>
<area shape="rect" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class." alt="" coords="576,79,681,104"/>
<area shape="poly" title=" " alt="" coords="578,110,431,154,429,149,577,105"/>
<area shape="poly" title=" " alt="" coords="332,110,379,150,376,154,328,115"/>
<area shape="rect" href="classEpetra__Operator.html" title="Epetra_Operator: A pure virtual class for using real&#45;valued double&#45;precision operators." alt="" coords="326,5,454,31"/>
<area shape="poly" title=" " alt="" coords="368,42,321,80,318,76,364,38"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Epetra_OskiMatrix:</div>
<div class="dyncontent">
<div class="center"><img src="classEpetra__OskiMatrix__coll__graph.gif" border="0" usemap="#aEpetra__OskiMatrix_coll__map" alt="Collaboration graph"/></div>
<map name="aEpetra__OskiMatrix_coll__map" id="aEpetra__OskiMatrix_coll__map">
<area shape="rect" title="Epetra_OskiMatrix: A class for constructing and using OSKI Matrices within Epetra...." alt="" coords="1448,133,1591,159"/>
<area shape="rect" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real&#45;valued double&#45;precision sparse compressed r..." alt="" coords="1264,133,1399,159"/>
<area shape="poly" title=" " alt="" coords="1413,143,1448,143,1448,149,1413,149"/>
<area shape="rect" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi&#45;vectors, vectors and matrices in pa..." alt="" coords="782,167,921,192"/>
<area shape="poly" title=" " alt="" coords="935,171,1263,148,1264,153,935,176"/>
<area shape="rect" href="classEpetra__CrsGraph.html" title="Epetra_CrsGraph: A class for constructing and using sparse compressed row graphs." alt="" coords="983,209,1114,235"/>
<area shape="poly" title=" " alt="" coords="924,192,990,207,989,212,923,197"/>
<area shape="rect" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi&#45;vectors, vectors and matrices in p..." alt="" coords="976,51,1121,76"/>
<area shape="poly" title=" " alt="" coords="884,157,1024,74,1027,78,887,162"/>
<area shape="rect" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class." alt="" coords="184,85,297,111"/>
<area shape="poly" title=" " alt="" coords="311,90,401,88,512,91,633,104,694,116,753,131,793,147,828,164,826,169,791,152,751,136,693,121,633,109,512,96,401,93,311,96"/>
<area shape="rect" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices." alt="" coords="491,127,625,152"/>
<area shape="poly" title=" " alt="" coords="311,104,491,128,490,133,311,110"/>
<area shape="rect" href="classEpetra__SrcDistObject.html" title="Epetra_SrcDistObject: A class for supporting flexible source distributed objects for import/export op..." alt="" coords="479,229,637,255"/>
<area shape="poly" title=" " alt="" coords="631,224,790,189,791,195,632,229"/>
<area shape="rect" href="classEpetra__RowMatrix.html" title="Epetra_RowMatrix: A pure virtual class for using real&#45;valued double&#45;precision row matrices." alt="" coords="781,260,922,285"/>
<area shape="poly" title=" " alt="" coords="651,249,781,263,780,268,651,254"/>
<area shape="poly" title=" " alt="" coords="640,148,782,167,782,172,639,153"/>
<area shape="rect" href="classEpetra__BlockMapData.html" title="Epetra_BlockMapData: The Epetra BlockMap Data Class." alt="" coords="157,144,324,169"/>
<area shape="poly" title=" " alt="" coords="338,156,454,153,490,148,491,154,455,158,338,162"/>
<area shape="rect" href="classEpetra__Data.html" title="Epetra_Data: The Epetra Base Data Class." alt="" coords="5,144,108,169"/>
<area shape="poly" title=" " alt="" coords="122,154,157,154,157,159,122,159"/>
<area shape="rect" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class." alt="" coords="501,176,615,201"/>
<area shape="poly" title=" " alt="" coords="629,185,752,182,781,181,782,186,752,187,629,190"/>
<area shape="rect" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes." alt="" coords="776,24,927,49"/>
<area shape="poly" title=" " alt="" coords="916,18,986,8,1069,3,1113,5,1157,10,1200,21,1241,37,1271,57,1295,83,1326,132,1322,134,1291,86,1267,61,1239,42,1199,26,1156,16,1113,10,1069,8,987,13,917,24"/>
<area shape="poly" title=" " alt="" coords="941,46,976,51,976,56,940,51"/>
<area shape="rect" href="classEpetra__Flops.html" title="Epetra_Flops: The Epetra Floating Point Operations Class." alt="" coords="505,24,611,49"/>
<area shape="poly" title=" " alt="" coords="625,34,776,34,776,39,625,39"/>
<area shape="rect" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class." alt="" coords="799,89,904,115"/>
<area shape="poly" title=" " alt="" coords="918,105,1264,137,1264,142,917,111"/>
<area shape="poly" title=" " alt="" coords="917,86,983,73,984,79,918,92"/>
<area shape="poly" title=" " alt="" coords="936,276,1004,276,1082,269,1162,254,1202,242,1239,226,1263,211,1285,193,1318,157,1322,161,1289,197,1266,215,1241,231,1203,247,1164,259,1083,275,1004,281,936,281"/>
<area shape="rect" href="classEpetra__Operator.html" title="Epetra_Operator: A pure virtual class for using real&#45;valued double&#45;precision operators." alt="" coords="494,285,622,311"/>
<area shape="poly" title=" " alt="" coords="635,289,780,276,781,281,636,294"/>
<area shape="poly" title=" " alt="" coords="1127,221,1183,215,1239,202,1281,181,1314,157,1317,161,1284,185,1241,207,1184,221,1128,226"/>
<area shape="poly" title=" " alt="" coords="1135,69,1188,78,1241,93,1280,111,1313,131,1310,135,1278,116,1239,98,1187,83,1134,74"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors/Destructor</div></td></tr>
<tr class="memitem:a2ad88c0027c640b6ddfdab3da1fa5732" id="r_a2ad88c0027c640b6ddfdab3da1fa5732"><td class="memItemLeft" align="right" valign="top"><a id="a2ad88c0027c640b6ddfdab3da1fa5732" name="a2ad88c0027c640b6ddfdab3da1fa5732"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_OskiMatrix</b> (const <a class="el" href="classEpetra__OskiMatrix.html">Epetra_OskiMatrix</a> &amp;Source)</td></tr>
<tr class="memdesc:a2ad88c0027c640b6ddfdab3da1fa5732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:a2ad88c0027c640b6ddfdab3da1fa5732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44a60151a8f228b93a425efba414307" id="r_ac44a60151a8f228b93a425efba414307"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#ac44a60151a8f228b93a425efba414307">Epetra_OskiMatrix</a> (const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;Source, const Teuchos::ParameterList &amp;List)</td></tr>
<tr class="memdesc:ac44a60151a8f228b93a425efba414307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor creates an <a class="el" href="classEpetra__OskiMatrix.html" title="Epetra_OskiMatrix: A class for constructing and using OSKI Matrices within Epetra....">Epetra_OskiMatrix</a> from an <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a>.  <br /></td></tr>
<tr class="separator:ac44a60151a8f228b93a425efba414307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1378bd384197504983e07e112578f5f" id="r_ab1378bd384197504983e07e112578f5f"><td class="memItemLeft" align="right" valign="top"><a id="ab1378bd384197504983e07e112578f5f" name="ab1378bd384197504983e07e112578f5f"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_OskiMatrix</b> ()</td></tr>
<tr class="memdesc:ab1378bd384197504983e07e112578f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor <br  />
 <br /></td></tr>
<tr class="separator:ab1378bd384197504983e07e112578f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Extract/Replace Values</div></td></tr>
<tr class="memitem:a9a84a63df971df7916e0fdbcb93e57e2" id="r_a9a84a63df971df7916e0fdbcb93e57e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#a9a84a63df971df7916e0fdbcb93e57e2">ReplaceMyValues</a> (int MyRow, int NumEntries, double *Values, int *Indices)</td></tr>
<tr class="memdesc:a9a84a63df971df7916e0fdbcb93e57e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace current values with this list of entries for a given local row of the matrix. Warning this could be expensive.  <br /></td></tr>
<tr class="separator:a9a84a63df971df7916e0fdbcb93e57e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d7f7c6a1ab1ef30e36c9207a99ace9" id="r_ad3d7f7c6a1ab1ef30e36c9207a99ace9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#ad3d7f7c6a1ab1ef30e36c9207a99ace9">SumIntoMyValues</a> (int MyRow, int NumEntries, double *Values, int *Indices)</td></tr>
<tr class="memdesc:ad3d7f7c6a1ab1ef30e36c9207a99ace9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add this list of entries to existing values for a given local row of the matrix. WARNING: this could be expensive.  <br /></td></tr>
<tr class="separator:ad3d7f7c6a1ab1ef30e36c9207a99ace9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8d003780d497d0bc93c7b5ce13ca2c" id="r_afe8d003780d497d0bc93c7b5ce13ca2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#afe8d003780d497d0bc93c7b5ce13ca2c">ExtractDiagonalCopy</a> (<a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;Diagonal) const</td></tr>
<tr class="memdesc:afe8d003780d497d0bc93c7b5ce13ca2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the main diagonal in a user-provided vector.  <br /></td></tr>
<tr class="separator:afe8d003780d497d0bc93c7b5ce13ca2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239ea34f07aa866de0d7e147ef855c86" id="r_a239ea34f07aa866de0d7e147ef855c86"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#a239ea34f07aa866de0d7e147ef855c86">ReplaceDiagonalValues</a> (const <a class="el" href="classEpetra__OskiVector.html">Epetra_OskiVector</a> &amp;Diagonal)</td></tr>
<tr class="memdesc:a239ea34f07aa866de0d7e147ef855c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces diagonal values of the matrix with those in the user-provided vector.  <br /></td></tr>
<tr class="separator:a239ea34f07aa866de0d7e147ef855c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computational methods</div></td></tr>
<tr class="memitem:a2f6d5086d176738f4c5f09a8dfaa4a69" id="r_a2f6d5086d176738f4c5f09a8dfaa4a69"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#a2f6d5086d176738f4c5f09a8dfaa4a69">Multiply</a> (bool TransA, const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x, <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;y) const</td></tr>
<tr class="memdesc:a2f6d5086d176738f4c5f09a8dfaa4a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a matrix vector multiply of y = this^TransA*x.  <br /></td></tr>
<tr class="separator:a2f6d5086d176738f4c5f09a8dfaa4a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6600118e669a8383fd24fdfaaf9a95c7" id="r_a6600118e669a8383fd24fdfaaf9a95c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#a6600118e669a8383fd24fdfaaf9a95c7">Multiply</a> (bool TransA, const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x, <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;y, double Alpha, double Beta=0.0) const</td></tr>
<tr class="memdesc:a6600118e669a8383fd24fdfaaf9a95c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a matrix vector multiply of y = Alpha*this^TransA*x + Beta*y.  <br /></td></tr>
<tr class="separator:a6600118e669a8383fd24fdfaaf9a95c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac000bc93d45717f12893b5921d01ac93" id="r_ac000bc93d45717f12893b5921d01ac93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#ac000bc93d45717f12893b5921d01ac93">Multiply</a> (bool TransA, const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;X, <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;Y) const</td></tr>
<tr class="memdesc:ac000bc93d45717f12893b5921d01ac93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a matrix multi-vector multiply of Y = this^TransA*X.  <br /></td></tr>
<tr class="separator:ac000bc93d45717f12893b5921d01ac93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59881beeff02a1ed3d0a6df41d5442a2" id="r_a59881beeff02a1ed3d0a6df41d5442a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#a59881beeff02a1ed3d0a6df41d5442a2">Multiply</a> (bool TransA, const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;X, <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;Y, double Alpha, double Beta=0.0) const</td></tr>
<tr class="memdesc:a59881beeff02a1ed3d0a6df41d5442a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a matrix multi-vector multiply of Y = Alpha*this^TransA*X + Beta*Y.  <br /></td></tr>
<tr class="separator:a59881beeff02a1ed3d0a6df41d5442a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081bca726094afb2277501a42c48e92a" id="r_a081bca726094afb2277501a42c48e92a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#a081bca726094afb2277501a42c48e92a">Solve</a> (bool Upper, bool TransA, bool UnitDiagonal, const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x, <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;y) const</td></tr>
<tr class="memdesc:a081bca726094afb2277501a42c48e92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a triangular solve of y = (this^TransA)^-1*x where this is a triangular matrix.  <br /></td></tr>
<tr class="separator:a081bca726094afb2277501a42c48e92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8538413a8a2f101bb96d1e3d737a96" id="r_aad8538413a8a2f101bb96d1e3d737a96"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#aad8538413a8a2f101bb96d1e3d737a96">Solve</a> (bool TransA, const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x, <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;y, double Alpha=1.0) const</td></tr>
<tr class="memdesc:aad8538413a8a2f101bb96d1e3d737a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a triangular solve of y = Alpha*(this^TransA)^-1*x where this is a triangular matrix.  <br /></td></tr>
<tr class="separator:aad8538413a8a2f101bb96d1e3d737a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd52a0fdbc6c92a2f38ed32d92d5fc8" id="r_acbd52a0fdbc6c92a2f38ed32d92d5fc8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#acbd52a0fdbc6c92a2f38ed32d92d5fc8">Solve</a> (bool Upper, bool TransA, bool UnitDiagonal, const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;X, <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;Y) const</td></tr>
<tr class="memdesc:acbd52a0fdbc6c92a2f38ed32d92d5fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a triangular solve of Y = (this^TransA)^-1*X where this is a triangular matrix.  <br /></td></tr>
<tr class="separator:acbd52a0fdbc6c92a2f38ed32d92d5fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50ee697e244e527a3acccf0ec4da905" id="r_ac50ee697e244e527a3acccf0ec4da905"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#ac50ee697e244e527a3acccf0ec4da905">Solve</a> (bool TransA, const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;X, <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;Y, double Alpha=1.0) const</td></tr>
<tr class="memdesc:ac50ee697e244e527a3acccf0ec4da905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a triangular solve of Y = Alpha*(this^TransA)^-1*X where this is a triangular matrix.  <br /></td></tr>
<tr class="separator:ac50ee697e244e527a3acccf0ec4da905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc866fcba5d81ff9cc0295682d891ffd" id="r_adc866fcba5d81ff9cc0295682d891ffd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#adc866fcba5d81ff9cc0295682d891ffd">MatTransMatMultiply</a> (bool ATA, const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x, <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;y, <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> *t, double Alpha=1.0, double Beta=0.0) const</td></tr>
<tr class="memdesc:adc866fcba5d81ff9cc0295682d891ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two matrix vector multiplies of y = Alpha*this^TransA*this*x + Beta*y or y = Alpha*this*this^TransA*x + Beta*y.  <br /></td></tr>
<tr class="separator:adc866fcba5d81ff9cc0295682d891ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4082a9a243ef4eaefb72354130d0ef4" id="r_aa4082a9a243ef4eaefb72354130d0ef4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#aa4082a9a243ef4eaefb72354130d0ef4">MatTransMatMultiply</a> (bool ATA, const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;X, <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;Y, <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> *T, double Alpha=1.0, double Beta=0.0) const</td></tr>
<tr class="memdesc:aa4082a9a243ef4eaefb72354130d0ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two matrix multi-vector multiplies of Y = Alpha*this^TransA*this*X + Beta*Y or Y = Alpha*this*this^TransA*X + Beta*Y.  <br /></td></tr>
<tr class="separator:aa4082a9a243ef4eaefb72354130d0ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bc42d2e7700e683bdf4a26f17cc9b7" id="r_a43bc42d2e7700e683bdf4a26f17cc9b7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#a43bc42d2e7700e683bdf4a26f17cc9b7">MultiplyAndMatTransMultiply</a> (bool TransA, const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x, <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;y, const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;w, <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;z, double Alpha=1.0, double Beta=0.0, double Omega=1.0, double Zeta=0.0) const</td></tr>
<tr class="memdesc:a43bc42d2e7700e683bdf4a26f17cc9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the two matrix vector multiplies of y = Alpha*this*x + Beta*y and z = Omega*this^TransA*w + Zeta*z.  <br /></td></tr>
<tr class="separator:a43bc42d2e7700e683bdf4a26f17cc9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5157f31307b78d5cb6110105405b87" id="r_abe5157f31307b78d5cb6110105405b87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#abe5157f31307b78d5cb6110105405b87">MultiplyAndMatTransMultiply</a> (bool TransA, const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;X, <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;Y, const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;W, <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;Z, double Alpha=1.0, double Beta=0.0, double Omega=1.0, double Zeta=0.0) const</td></tr>
<tr class="memdesc:abe5157f31307b78d5cb6110105405b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the two matrix multi-vector multiplies of Y = Alpha*this*X + Beta*Y and Z = Omega*this^TransA*W + Zeta*Z.  <br /></td></tr>
<tr class="separator:abe5157f31307b78d5cb6110105405b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbd13e61ec5df6a2451f4879264aef0" id="r_a9cbd13e61ec5df6a2451f4879264aef0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#a9cbd13e61ec5df6a2451f4879264aef0">MatPowMultiply</a> (bool TransA, const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x, <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;y, <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;T, int Power=2, double Alpha=1.0, double Beta=0.0) const</td></tr>
<tr class="memdesc:a9cbd13e61ec5df6a2451f4879264aef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a matrix vector multiply of y = Alpha*(this^TransA)^Power*x + Beta*y. This is not implemented as described in the detailed description.  <br /></td></tr>
<tr class="separator:a9cbd13e61ec5df6a2451f4879264aef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d2e116142f0ae610a5381959e0aadc" id="r_a27d2e116142f0ae610a5381959e0aadc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#a27d2e116142f0ae610a5381959e0aadc">MatPowMultiply</a> (bool TransA, const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x, <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;y, int Power=2, double Alpha=1.0, double Beta=0.0) const</td></tr>
<tr class="memdesc:a27d2e116142f0ae610a5381959e0aadc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a matrix vector multiply of y = Alpha*(this^TransA)^Power*x + Beta*y. This is not implemented as described in the detailed description.  <br /></td></tr>
<tr class="separator:a27d2e116142f0ae610a5381959e0aadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tuning</div></td></tr>
<tr class="memitem:a2cdb2a4883683ed6e17166e00f1be37d" id="r_a2cdb2a4883683ed6e17166e00f1be37d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#a2cdb2a4883683ed6e17166e00f1be37d">SetHint</a> (const Teuchos::ParameterList &amp;List)</td></tr>
<tr class="memdesc:a2cdb2a4883683ed6e17166e00f1be37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the hints in List in the matrix structure.  <br /></td></tr>
<tr class="separator:a2cdb2a4883683ed6e17166e00f1be37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69e471aa245c327dfaed65f376f8193" id="r_ad69e471aa245c327dfaed65f376f8193"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#ad69e471aa245c327dfaed65f376f8193">SetHintMultiply</a> (bool TransA, double Alpha, const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;InVec, double Beta, const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;OutVec, int NumCalls, const Teuchos::ParameterList &amp;List)</td></tr>
<tr class="memdesc:ad69e471aa245c327dfaed65f376f8193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Workload hints for computing a matrix-vector multiply used by OskiTuneMat to optimize the data structure storage, and the routine to compute the calculation.  <br /></td></tr>
<tr class="separator:ad69e471aa245c327dfaed65f376f8193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf907924477a099556ee005a1e06abcc" id="r_abf907924477a099556ee005a1e06abcc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#abf907924477a099556ee005a1e06abcc">SetHintSolve</a> (bool TransA, double Alpha, const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;Vector, int NumCalls, const Teuchos::ParameterList &amp;List)</td></tr>
<tr class="memdesc:abf907924477a099556ee005a1e06abcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Workload hints for computing a triangular solve used by OskiTuneMat to optimize the data structure storage, and the routine to compute the calculation.  <br /></td></tr>
<tr class="separator:abf907924477a099556ee005a1e06abcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a9521fa5d2058f53acad5dd9707d6d" id="r_a64a9521fa5d2058f53acad5dd9707d6d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#a64a9521fa5d2058f53acad5dd9707d6d">SetHintMatTransMatMultiply</a> (bool ATA, double Alpha, const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;InVec, double Beta, const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;OutVec, const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;Intermediate, int NumCalls, const Teuchos::ParameterList &amp;List)</td></tr>
<tr class="memdesc:a64a9521fa5d2058f53acad5dd9707d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Workload hints for computing a two matrix-vector multiplies that are composed used by OskiTuneMat to optimize the data structure storage, and the routine to compute the calculation.  <br /></td></tr>
<tr class="separator:a64a9521fa5d2058f53acad5dd9707d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984e426d6ebd3241c3efd24a3553fa4b" id="r_a984e426d6ebd3241c3efd24a3553fa4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#a984e426d6ebd3241c3efd24a3553fa4b">SetHintMultiplyAndMatTransMultiply</a> (bool TransA, double Alpha, const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;InVec, double Beta, const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;OutVec, double Omega, const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;InVec2, double Zeta, const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;OutVec2, int NumCalls, const Teuchos::ParameterList &amp;List)</td></tr>
<tr class="memdesc:a984e426d6ebd3241c3efd24a3553fa4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Workload hints for computing two matrix-vector multiplies used by OskiTuneMat to optimize the data structure storage, and the routine to compute the calculation.  <br /></td></tr>
<tr class="separator:a984e426d6ebd3241c3efd24a3553fa4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec6ae371bde9abea93db54d00895bc4" id="r_aaec6ae371bde9abea93db54d00895bc4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#aaec6ae371bde9abea93db54d00895bc4">SetHintPowMultiply</a> (bool TransA, double Alpha, const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;InVec, double Beta, const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;OutVec, const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;Intermediate, int Power, int NumCalls, const Teuchos::ParameterList &amp;List)</td></tr>
<tr class="memdesc:aaec6ae371bde9abea93db54d00895bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Workload hints for computing a matrix-vector multiply performed Power times used by OskiTuneMat to optimize the data structure storage and the routine to compute the calculation.  <br /></td></tr>
<tr class="separator:aaec6ae371bde9abea93db54d00895bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335af3df905a0b748eb7d8381c9301de" id="r_a335af3df905a0b748eb7d8381c9301de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#a335af3df905a0b748eb7d8381c9301de">TuneMatrix</a> ()</td></tr>
<tr class="memdesc:a335af3df905a0b748eb7d8381c9301de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tunes the matrix multiply if its deemed profitable.  <br /></td></tr>
<tr class="separator:a335af3df905a0b748eb7d8381c9301de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__CrsMatrix"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__CrsMatrix')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a></td></tr>
<tr class="memitem:af174457dccd1ff7612126172863614c0 inherit pub_methods_classEpetra__CrsMatrix" id="r_af174457dccd1ff7612126172863614c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#af174457dccd1ff7612126172863614c0">Epetra_CrsMatrix</a> (<a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a> CV, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;<a class="el" href="classEpetra__CrsMatrix.html#a24855eec1cf6aeb201be88ba654d22bf">RowMap</a>, const int *NumEntriesPerRow, bool StaticProfile=false)</td></tr>
<tr class="memdesc:af174457dccd1ff7612126172863614c0 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> constructor with variable number of indices per row.  <br /></td></tr>
<tr class="separator:af174457dccd1ff7612126172863614c0 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d9a06553f57f94b1f294356a91823b inherit pub_methods_classEpetra__CrsMatrix" id="r_ad4d9a06553f57f94b1f294356a91823b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ad4d9a06553f57f94b1f294356a91823b">Epetra_CrsMatrix</a> (<a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a> CV, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;<a class="el" href="classEpetra__CrsMatrix.html#a24855eec1cf6aeb201be88ba654d22bf">RowMap</a>, int NumEntriesPerRow, bool StaticProfile=false)</td></tr>
<tr class="memdesc:ad4d9a06553f57f94b1f294356a91823b inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> constructor with fixed number of indices per row.  <br /></td></tr>
<tr class="separator:ad4d9a06553f57f94b1f294356a91823b inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e3f3a7c450a7443bd3b41580d11513 inherit pub_methods_classEpetra__CrsMatrix" id="r_a83e3f3a7c450a7443bd3b41580d11513"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a83e3f3a7c450a7443bd3b41580d11513">Epetra_CrsMatrix</a> (<a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a> CV, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;<a class="el" href="classEpetra__CrsMatrix.html#a24855eec1cf6aeb201be88ba654d22bf">RowMap</a>, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;<a class="el" href="classEpetra__CrsMatrix.html#aab3589bfaac41458ab698d3d53780e61">ColMap</a>, const int *NumEntriesPerRow, bool StaticProfile=false)</td></tr>
<tr class="memdesc:a83e3f3a7c450a7443bd3b41580d11513 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> constructor with variable number of indices per row.  <br /></td></tr>
<tr class="separator:a83e3f3a7c450a7443bd3b41580d11513 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976b94f3d9dbfe17aa425d29a3b0c0d7 inherit pub_methods_classEpetra__CrsMatrix" id="r_a976b94f3d9dbfe17aa425d29a3b0c0d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a976b94f3d9dbfe17aa425d29a3b0c0d7">Epetra_CrsMatrix</a> (<a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a> CV, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;<a class="el" href="classEpetra__CrsMatrix.html#a24855eec1cf6aeb201be88ba654d22bf">RowMap</a>, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;<a class="el" href="classEpetra__CrsMatrix.html#aab3589bfaac41458ab698d3d53780e61">ColMap</a>, int NumEntriesPerRow, bool StaticProfile=false)</td></tr>
<tr class="memdesc:a976b94f3d9dbfe17aa425d29a3b0c0d7 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> constuctor with fixed number of indices per row.  <br /></td></tr>
<tr class="separator:a976b94f3d9dbfe17aa425d29a3b0c0d7 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea2e6fa0f05885ec6bb758283777251 inherit pub_methods_classEpetra__CrsMatrix" id="r_abea2e6fa0f05885ec6bb758283777251"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#abea2e6fa0f05885ec6bb758283777251">Epetra_CrsMatrix</a> (<a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a> CV, const <a class="el" href="classEpetra__CrsGraph.html">Epetra_CrsGraph</a> &amp;<a class="el" href="classEpetra__CrsMatrix.html#a98ed3d3f3cb0ab79ffceb1974b9a8809">Graph</a>)</td></tr>
<tr class="memdesc:abea2e6fa0f05885ec6bb758283777251 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix using an existing <a class="el" href="classEpetra__CrsGraph.html" title="Epetra_CrsGraph: A class for constructing and using sparse compressed row graphs.">Epetra_CrsGraph</a> object.  <br /></td></tr>
<tr class="separator:abea2e6fa0f05885ec6bb758283777251 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7002382b0e988660cc450a8453987e inherit pub_methods_classEpetra__CrsMatrix" id="r_a8b7002382b0e988660cc450a8453987e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a8b7002382b0e988660cc450a8453987e">Epetra_CrsMatrix</a> (const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;SourceMatrix, const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> &amp;RowImporter, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c">DomainMap</a>=0, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222">RangeMap</a>=0, bool RestrictCommunicator=false)</td></tr>
<tr class="memdesc:a8b7002382b0e988660cc450a8453987e inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epetra CrsMatrix constructor that also fuses Import and <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a>.  <br /></td></tr>
<tr class="separator:a8b7002382b0e988660cc450a8453987e inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa47469f36f75bc7147e443cc045685d inherit pub_methods_classEpetra__CrsMatrix" id="r_afa47469f36f75bc7147e443cc045685d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#afa47469f36f75bc7147e443cc045685d">Epetra_CrsMatrix</a> (const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;SourceMatrix, const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> &amp;RowImporter, const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> *DomainImporter, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c">DomainMap</a>, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222">RangeMap</a>, bool RestrictCommunicator)</td></tr>
<tr class="memdesc:afa47469f36f75bc7147e443cc045685d inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epetra CrsMatrix constructor that also fuses Import and <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a>.  <br /></td></tr>
<tr class="separator:afa47469f36f75bc7147e443cc045685d inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9e9a8fc2eb865889c9e090528f6215 inherit pub_methods_classEpetra__CrsMatrix" id="r_a8a9e9a8fc2eb865889c9e090528f6215"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a8a9e9a8fc2eb865889c9e090528f6215">Epetra_CrsMatrix</a> (const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;SourceMatrix, const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> &amp;RowExporter, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c">DomainMap</a>=0, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222">RangeMap</a>=0, bool RestrictCommunicator=false)</td></tr>
<tr class="memdesc:a8a9e9a8fc2eb865889c9e090528f6215 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epetra CrsMatrix constructor that also fuses Ex[prt and <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a>.  <br /></td></tr>
<tr class="separator:a8a9e9a8fc2eb865889c9e090528f6215 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93a987aa9463831451960dc462c5985 inherit pub_methods_classEpetra__CrsMatrix" id="r_ad93a987aa9463831451960dc462c5985"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ad93a987aa9463831451960dc462c5985">Epetra_CrsMatrix</a> (const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;SourceMatrix, const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> &amp;RowExporter, const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> *DomainExporter, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c">DomainMap</a>, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222">RangeMap</a>, bool RestrictCommunicator)</td></tr>
<tr class="memdesc:ad93a987aa9463831451960dc462c5985 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epetra CrsMatrix constructor that also fuses Ex[prt and <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a>.  <br /></td></tr>
<tr class="separator:ad93a987aa9463831451960dc462c5985 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7e88dafd4636c054c36c1ccbb1a5fb inherit pub_methods_classEpetra__CrsMatrix" id="r_a4a7e88dafd4636c054c36c1ccbb1a5fb"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_CrsMatrix</b> (const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;Matrix)</td></tr>
<tr class="memdesc:a4a7e88dafd4636c054c36c1ccbb1a5fb inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:a4a7e88dafd4636c054c36c1ccbb1a5fb inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af947e9ec91d35d85a7a3d410d391b878 inherit pub_methods_classEpetra__CrsMatrix" id="r_af947e9ec91d35d85a7a3d410d391b878"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_CrsMatrix</b> ()</td></tr>
<tr class="memdesc:af947e9ec91d35d85a7a3d410d391b878 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> Destructor. <br /></td></tr>
<tr class="separator:af947e9ec91d35d85a7a3d410d391b878 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac12887d3d6c815496702ee9c07d097b inherit pub_methods_classEpetra__CrsMatrix" id="r_aac12887d3d6c815496702ee9c07d097b"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;src)</td></tr>
<tr class="memdesc:aac12887d3d6c815496702ee9c07d097b inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br /></td></tr>
<tr class="separator:aac12887d3d6c815496702ee9c07d097b inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2eb1fc1151fef071b29a37bff8822b inherit pub_methods_classEpetra__CrsMatrix" id="r_a3c2eb1fc1151fef071b29a37bff8822b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a3c2eb1fc1151fef071b29a37bff8822b">PutScalar</a> (double ScalarConstant)</td></tr>
<tr class="memdesc:a3c2eb1fc1151fef071b29a37bff8822b inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize all values in the matrix with constant value.  <br /></td></tr>
<tr class="separator:a3c2eb1fc1151fef071b29a37bff8822b inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89dca01cc1dcf5c46cd34ecba9a0c6d1 inherit pub_methods_classEpetra__CrsMatrix" id="r_a89dca01cc1dcf5c46cd34ecba9a0c6d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a89dca01cc1dcf5c46cd34ecba9a0c6d1">Scale</a> (double ScalarConstant)</td></tr>
<tr class="memdesc:a89dca01cc1dcf5c46cd34ecba9a0c6d1 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply all values in the matrix by a constant value (in place: A &lt;- ScalarConstant * A).  <br /></td></tr>
<tr class="separator:a89dca01cc1dcf5c46cd34ecba9a0c6d1 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7ff1b3a9be1c41fe218538af97cfdb inherit pub_methods_classEpetra__CrsMatrix" id="r_a2f7ff1b3a9be1c41fe218538af97cfdb"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a2f7ff1b3a9be1c41fe218538af97cfdb">InsertGlobalValues</a> (int GlobalRow, int NumEntries, const double *Values, const int *Indices)</td></tr>
<tr class="memdesc:a2f7ff1b3a9be1c41fe218538af97cfdb inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a list of elements in a given global row of the matrix.  <br /></td></tr>
<tr class="separator:a2f7ff1b3a9be1c41fe218538af97cfdb inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179573693006a56a83006815f238e6a8 inherit pub_methods_classEpetra__CrsMatrix" id="r_a179573693006a56a83006815f238e6a8"><td class="memItemLeft" align="right" valign="top">
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>InsertGlobalValues</b> (long long GlobalRow, int NumEntries, const double *Values, const long long *Indices)</td></tr>
<tr class="separator:a179573693006a56a83006815f238e6a8 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c56a411752216cae73ca1fa04239c28 inherit pub_methods_classEpetra__CrsMatrix" id="r_a8c56a411752216cae73ca1fa04239c28"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a8c56a411752216cae73ca1fa04239c28">InsertGlobalValues</a> (int GlobalRow, int NumEntries, double *Values, int *Indices)</td></tr>
<tr class="memdesc:a8c56a411752216cae73ca1fa04239c28 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a list of elements in a given global row of the matrix.  <br /></td></tr>
<tr class="separator:a8c56a411752216cae73ca1fa04239c28 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f5217b07252ea2aed727737dbe0003 inherit pub_methods_classEpetra__CrsMatrix" id="r_a42f5217b07252ea2aed727737dbe0003"><td class="memItemLeft" align="right" valign="top">
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>InsertGlobalValues</b> (long long GlobalRow, int NumEntries, double *Values, long long *Indices)</td></tr>
<tr class="separator:a42f5217b07252ea2aed727737dbe0003 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36048758bcfe082ca07090569607d574 inherit pub_methods_classEpetra__CrsMatrix" id="r_a36048758bcfe082ca07090569607d574"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a36048758bcfe082ca07090569607d574">ReplaceGlobalValues</a> (int GlobalRow, int NumEntries, const double *Values, const int *Indices)</td></tr>
<tr class="memdesc:a36048758bcfe082ca07090569607d574 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace specified existing values with this list of entries for a given global row of the matrix.  <br /></td></tr>
<tr class="separator:a36048758bcfe082ca07090569607d574 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5644462862e06698585cafa7d3eddd0 inherit pub_methods_classEpetra__CrsMatrix" id="r_af5644462862e06698585cafa7d3eddd0"><td class="memItemLeft" align="right" valign="top">
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>ReplaceGlobalValues</b> (long long GlobalRow, int NumEntries, const double *Values, const long long *Indices)</td></tr>
<tr class="separator:af5644462862e06698585cafa7d3eddd0 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1291bfb498b94ac4f1563b48d11dfae5 inherit pub_methods_classEpetra__CrsMatrix" id="r_a1291bfb498b94ac4f1563b48d11dfae5"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a1291bfb498b94ac4f1563b48d11dfae5">SumIntoGlobalValues</a> (int GlobalRow, int NumEntries, const double *Values, const int *Indices)</td></tr>
<tr class="memdesc:a1291bfb498b94ac4f1563b48d11dfae5 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add this list of entries to existing values for a given global row of the matrix.  <br /></td></tr>
<tr class="separator:a1291bfb498b94ac4f1563b48d11dfae5 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd087c54f1e5a75a2ae6beb41b7e7d5 inherit pub_methods_classEpetra__CrsMatrix" id="r_a2fd087c54f1e5a75a2ae6beb41b7e7d5"><td class="memItemLeft" align="right" valign="top">
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>SumIntoGlobalValues</b> (long long GlobalRow, int NumEntries, const double *Values, const long long *Indices)</td></tr>
<tr class="separator:a2fd087c54f1e5a75a2ae6beb41b7e7d5 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0a4c3e447466758bd8608b077e90a0 inherit pub_methods_classEpetra__CrsMatrix" id="r_ada0a4c3e447466758bd8608b077e90a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ada0a4c3e447466758bd8608b077e90a0">InsertMyValues</a> (int MyRow, int NumEntries, const double *Values, const int *Indices)</td></tr>
<tr class="memdesc:ada0a4c3e447466758bd8608b077e90a0 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a list of elements in a given local row of the matrix.  <br /></td></tr>
<tr class="separator:ada0a4c3e447466758bd8608b077e90a0 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3aff1cbaa86e32fc971f3613b350d2 inherit pub_methods_classEpetra__CrsMatrix" id="r_abc3aff1cbaa86e32fc971f3613b350d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#abc3aff1cbaa86e32fc971f3613b350d2">InsertMyValues</a> (int MyRow, int NumEntries, double *Values, int *Indices)</td></tr>
<tr class="memdesc:abc3aff1cbaa86e32fc971f3613b350d2 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a list of elements in a given local row of the matrix.  <br /></td></tr>
<tr class="separator:abc3aff1cbaa86e32fc971f3613b350d2 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecf7e5bf939b56644e25c57f67e137d inherit pub_methods_classEpetra__CrsMatrix" id="r_acecf7e5bf939b56644e25c57f67e137d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#acecf7e5bf939b56644e25c57f67e137d">ReplaceMyValues</a> (int MyRow, int NumEntries, const double *Values, const int *Indices)</td></tr>
<tr class="memdesc:acecf7e5bf939b56644e25c57f67e137d inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace current values with this list of entries for a given local row of the matrix.  <br /></td></tr>
<tr class="separator:acecf7e5bf939b56644e25c57f67e137d inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e93959017a68cb0103110d80b124c82 inherit pub_methods_classEpetra__CrsMatrix" id="r_a8e93959017a68cb0103110d80b124c82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a8e93959017a68cb0103110d80b124c82">SumIntoMyValues</a> (int MyRow, int NumEntries, const double *Values, const int *Indices)</td></tr>
<tr class="memdesc:a8e93959017a68cb0103110d80b124c82 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add this list of entries to existing values for a given local row of the matrix.  <br /></td></tr>
<tr class="separator:a8e93959017a68cb0103110d80b124c82 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecb739b8f837a91406050f6f8bd7b9a inherit pub_methods_classEpetra__CrsMatrix" id="r_aeecb739b8f837a91406050f6f8bd7b9a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#aeecb739b8f837a91406050f6f8bd7b9a">ReplaceDiagonalValues</a> (const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;Diagonal)</td></tr>
<tr class="memdesc:aeecb739b8f837a91406050f6f8bd7b9a inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces diagonal values of the matrix with those in the user-provided vector.  <br /></td></tr>
<tr class="separator:aeecb739b8f837a91406050f6f8bd7b9a inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355b4e8d1e28b16bacf37ab637ac0c3f inherit pub_methods_classEpetra__CrsMatrix" id="r_a355b4e8d1e28b16bacf37ab637ac0c3f"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>FillComplete</b> (bool OptimizeDataStorage=true)</td></tr>
<tr class="memdesc:a355b4e8d1e28b16bacf37ab637ac0c3f inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal that data entry is complete. Perform transformations to local index space. <br /></td></tr>
<tr class="separator:a355b4e8d1e28b16bacf37ab637ac0c3f inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3c13275e8dbe80826e820abbb8e49c inherit pub_methods_classEpetra__CrsMatrix" id="r_aac3c13275e8dbe80826e820abbb8e49c"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>FillComplete</b> (const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;<a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c">DomainMap</a>, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;<a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222">RangeMap</a>, bool OptimizeDataStorage=true)</td></tr>
<tr class="memdesc:aac3c13275e8dbe80826e820abbb8e49c inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal that data entry is complete. Perform transformations to local index space. <br /></td></tr>
<tr class="separator:aac3c13275e8dbe80826e820abbb8e49c inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54a33eafbaa0a966cf2c0ce454a7d59 inherit pub_methods_classEpetra__CrsMatrix" id="r_ac54a33eafbaa0a966cf2c0ce454a7d59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ac54a33eafbaa0a966cf2c0ce454a7d59">OptimizeStorage</a> ()</td></tr>
<tr class="memdesc:ac54a33eafbaa0a966cf2c0ce454a7d59 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make consecutive row index sections contiguous, minimize internal storage used for constructing graph.  <br /></td></tr>
<tr class="separator:ac54a33eafbaa0a966cf2c0ce454a7d59 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5d779243fdca3b068cdc4cf5781f86 inherit pub_methods_classEpetra__CrsMatrix" id="r_a1d5d779243fdca3b068cdc4cf5781f86"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>MakeDataContiguous</b> ()</td></tr>
<tr class="memdesc:a1d5d779243fdca3b068cdc4cf5781f86 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates memory that is used for construction. Make consecutive row index sections contiguous. <br /></td></tr>
<tr class="separator:a1d5d779243fdca3b068cdc4cf5781f86 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70846bbd75f7f2f0c2453ac9446d6c2c inherit pub_methods_classEpetra__CrsMatrix" id="r_a70846bbd75f7f2f0c2453ac9446d6c2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a70846bbd75f7f2f0c2453ac9446d6c2c">ExtractGlobalRowCopy</a> (int GlobalRow, int Length, int &amp;NumEntries, double *Values, int *Indices) const</td></tr>
<tr class="memdesc:a70846bbd75f7f2f0c2453ac9446d6c2c inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the specified global row in user-provided arrays.  <br /></td></tr>
<tr class="separator:a70846bbd75f7f2f0c2453ac9446d6c2c inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0413ec950204597c3a49fb2afa1004 inherit pub_methods_classEpetra__CrsMatrix" id="r_afd0413ec950204597c3a49fb2afa1004"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>ExtractGlobalRowCopy</b> (long long GlobalRow, int Length, int &amp;NumEntries, double *Values, long long *Indices) const</td></tr>
<tr class="separator:afd0413ec950204597c3a49fb2afa1004 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1d307174a8205ec5b1198f51c50bf8 inherit pub_methods_classEpetra__CrsMatrix" id="r_aae1d307174a8205ec5b1198f51c50bf8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#aae1d307174a8205ec5b1198f51c50bf8">ExtractMyRowCopy</a> (int MyRow, int Length, int &amp;NumEntries, double *Values, int *Indices) const</td></tr>
<tr class="memdesc:aae1d307174a8205ec5b1198f51c50bf8 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the specified local row in user-provided arrays.  <br /></td></tr>
<tr class="separator:aae1d307174a8205ec5b1198f51c50bf8 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f60443ed35e95869438ce2e21c5fec inherit pub_methods_classEpetra__CrsMatrix" id="r_a35f60443ed35e95869438ce2e21c5fec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a35f60443ed35e95869438ce2e21c5fec">ExtractGlobalRowCopy</a> (int GlobalRow, int Length, int &amp;NumEntries, double *Values) const</td></tr>
<tr class="memdesc:a35f60443ed35e95869438ce2e21c5fec inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the specified global row values in user-provided array.  <br /></td></tr>
<tr class="separator:a35f60443ed35e95869438ce2e21c5fec inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2ccff74f241b84360a5509d818ff7e inherit pub_methods_classEpetra__CrsMatrix" id="r_aed2ccff74f241b84360a5509d818ff7e"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>ExtractGlobalRowCopy</b> (long long GlobalRow, int Length, int &amp;NumEntries, double *Values) const</td></tr>
<tr class="separator:aed2ccff74f241b84360a5509d818ff7e inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989ae9e8183388a46873bd7e0b1e1bea inherit pub_methods_classEpetra__CrsMatrix" id="r_a989ae9e8183388a46873bd7e0b1e1bea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a989ae9e8183388a46873bd7e0b1e1bea">ExtractMyRowCopy</a> (int MyRow, int Length, int &amp;NumEntries, double *Values) const</td></tr>
<tr class="memdesc:a989ae9e8183388a46873bd7e0b1e1bea inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the specified local row values in user-provided array.  <br /></td></tr>
<tr class="separator:a989ae9e8183388a46873bd7e0b1e1bea inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d54454e29a235cc487c3de506bc295d inherit pub_methods_classEpetra__CrsMatrix" id="r_a0d54454e29a235cc487c3de506bc295d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a0d54454e29a235cc487c3de506bc295d">ExtractGlobalRowView</a> (int GlobalRow, int &amp;NumEntries, double *&amp;Values, int *&amp;Indices) const</td></tr>
<tr class="memdesc:a0d54454e29a235cc487c3de506bc295d inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a view of the specified global row values via pointers to internal data.  <br /></td></tr>
<tr class="separator:a0d54454e29a235cc487c3de506bc295d inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16750152466c7e48394da337c8d0d8f1 inherit pub_methods_classEpetra__CrsMatrix" id="r_a16750152466c7e48394da337c8d0d8f1"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>ExtractGlobalRowView</b> (long long GlobalRow, int &amp;NumEntries, double *&amp;Values, long long *&amp;Indices) const</td></tr>
<tr class="separator:a16750152466c7e48394da337c8d0d8f1 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bac0a8622458dc5eeb25fde0c96d774 inherit pub_methods_classEpetra__CrsMatrix" id="r_a2bac0a8622458dc5eeb25fde0c96d774"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a2bac0a8622458dc5eeb25fde0c96d774">ExtractMyRowView</a> (int MyRow, int &amp;NumEntries, double *&amp;Values, int *&amp;Indices) const</td></tr>
<tr class="memdesc:a2bac0a8622458dc5eeb25fde0c96d774 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a view of the specified local row values via pointers to internal data.  <br /></td></tr>
<tr class="separator:a2bac0a8622458dc5eeb25fde0c96d774 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee94425f2bce4365d472a3d32e3be382 inherit pub_methods_classEpetra__CrsMatrix" id="r_aee94425f2bce4365d472a3d32e3be382"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#aee94425f2bce4365d472a3d32e3be382">ExtractGlobalRowView</a> (int GlobalRow, int &amp;NumEntries, double *&amp;Values) const</td></tr>
<tr class="memdesc:aee94425f2bce4365d472a3d32e3be382 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a view of the specified global row values via pointers to internal data.  <br /></td></tr>
<tr class="separator:aee94425f2bce4365d472a3d32e3be382 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82463e8a392c1062d42c0057a4ec3231 inherit pub_methods_classEpetra__CrsMatrix" id="r_a82463e8a392c1062d42c0057a4ec3231"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>ExtractGlobalRowView</b> (long long GlobalRow, int &amp;NumEntries, double *&amp;Values) const</td></tr>
<tr class="separator:a82463e8a392c1062d42c0057a4ec3231 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c61ae4ad9bca823e459c3e7b88c0e94 inherit pub_methods_classEpetra__CrsMatrix" id="r_a0c61ae4ad9bca823e459c3e7b88c0e94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a0c61ae4ad9bca823e459c3e7b88c0e94">ExtractMyRowView</a> (int MyRow, int &amp;NumEntries, double *&amp;Values) const</td></tr>
<tr class="memdesc:a0c61ae4ad9bca823e459c3e7b88c0e94 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a view of the specified local row values via pointers to internal data.  <br /></td></tr>
<tr class="separator:a0c61ae4ad9bca823e459c3e7b88c0e94 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad028fbe37c3d2ce3f43e2acf2cbb29de inherit pub_methods_classEpetra__CrsMatrix" id="r_ad028fbe37c3d2ce3f43e2acf2cbb29de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ad028fbe37c3d2ce3f43e2acf2cbb29de">Multiply</a> (bool TransA, const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x, <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;y) const</td></tr>
<tr class="memdesc:ad028fbe37c3d2ce3f43e2acf2cbb29de inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of a <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> multiplied by a <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> x in y.  <br /></td></tr>
<tr class="separator:ad028fbe37c3d2ce3f43e2acf2cbb29de inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f75baa68b4784c47a304fb3681a71c1 inherit pub_methods_classEpetra__CrsMatrix" id="r_a5f75baa68b4784c47a304fb3681a71c1"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>Multiply1</b> (bool TransA, const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x, <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;y) const</td></tr>
<tr class="separator:a5f75baa68b4784c47a304fb3681a71c1 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87c8797a0d9b117e329ab6ac4295612 inherit pub_methods_classEpetra__CrsMatrix" id="r_ad87c8797a0d9b117e329ab6ac4295612"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>Multiply1</b> (bool TransA, const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;X, <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;Y) const</td></tr>
<tr class="separator:ad87c8797a0d9b117e329ab6ac4295612 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0d7c00870df3bf3a18db186a290e64 inherit pub_methods_classEpetra__CrsMatrix" id="r_a4b0d7c00870df3bf3a18db186a290e64"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a4b0d7c00870df3bf3a18db186a290e64">Solve</a> (bool Upper, bool Trans, bool UnitDiagonal, const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x, <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;y) const</td></tr>
<tr class="memdesc:a4b0d7c00870df3bf3a18db186a290e64 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of a local solve using the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> on a <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> x in y.  <br /></td></tr>
<tr class="separator:a4b0d7c00870df3bf3a18db186a290e64 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9ed2d21bfc16d0a0e153380a7441de inherit pub_methods_classEpetra__CrsMatrix" id="r_a0d9ed2d21bfc16d0a0e153380a7441de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a0d9ed2d21bfc16d0a0e153380a7441de">InvRowSums</a> (<a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x) const</td></tr>
<tr class="memdesc:a0d9ed2d21bfc16d0a0e153380a7441de inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse of the sum of absolute values of the rows of the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a>, results returned in x.  <br /></td></tr>
<tr class="separator:a0d9ed2d21bfc16d0a0e153380a7441de inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aee2aa1ae277efe9dcdfe0a9b77079a inherit pub_methods_classEpetra__CrsMatrix" id="r_a6aee2aa1ae277efe9dcdfe0a9b77079a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a6aee2aa1ae277efe9dcdfe0a9b77079a">InvRowMaxs</a> (<a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x) const</td></tr>
<tr class="memdesc:a6aee2aa1ae277efe9dcdfe0a9b77079a inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse of the max of absolute values of the rows of the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a>, results returned in x.  <br /></td></tr>
<tr class="separator:a6aee2aa1ae277efe9dcdfe0a9b77079a inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100330317094dc8a19f8feb73b5f0b87 inherit pub_methods_classEpetra__CrsMatrix" id="r_a100330317094dc8a19f8feb73b5f0b87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a100330317094dc8a19f8feb73b5f0b87">LeftScale</a> (const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x)</td></tr>
<tr class="memdesc:a100330317094dc8a19f8feb73b5f0b87 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> on the left with a <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> x.  <br /></td></tr>
<tr class="separator:a100330317094dc8a19f8feb73b5f0b87 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0ce45ccb757975e9ea69e251627663 inherit pub_methods_classEpetra__CrsMatrix" id="r_a8f0ce45ccb757975e9ea69e251627663"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a8f0ce45ccb757975e9ea69e251627663">InvColSums</a> (<a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x) const</td></tr>
<tr class="memdesc:a8f0ce45ccb757975e9ea69e251627663 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse of the sum of absolute values of the columns of the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a>, results returned in x.  <br /></td></tr>
<tr class="separator:a8f0ce45ccb757975e9ea69e251627663 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d373346c8d0941917fe2e5cd848e2a inherit pub_methods_classEpetra__CrsMatrix" id="r_a58d373346c8d0941917fe2e5cd848e2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a58d373346c8d0941917fe2e5cd848e2a">InvColMaxs</a> (<a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x) const</td></tr>
<tr class="memdesc:a58d373346c8d0941917fe2e5cd848e2a inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the max of absolute values of the columns of the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a>, results returned in x.  <br /></td></tr>
<tr class="separator:a58d373346c8d0941917fe2e5cd848e2a inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136bb231cfe4bb129c6754f224eb0889 inherit pub_methods_classEpetra__CrsMatrix" id="r_a136bb231cfe4bb129c6754f224eb0889"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a136bb231cfe4bb129c6754f224eb0889">RightScale</a> (const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x)</td></tr>
<tr class="memdesc:a136bb231cfe4bb129c6754f224eb0889 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> on the right with a <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> x.  <br /></td></tr>
<tr class="separator:a136bb231cfe4bb129c6754f224eb0889 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b8858f8fc28dcc45bf523ccad2cb50 inherit pub_methods_classEpetra__CrsMatrix" id="r_a08b8858f8fc28dcc45bf523ccad2cb50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50">Filled</a> () const</td></tr>
<tr class="memdesc:a08b8858f8fc28dcc45bf523ccad2cb50 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> has been called, this query returns true, otherwise it returns false.  <br /></td></tr>
<tr class="separator:a08b8858f8fc28dcc45bf523ccad2cb50 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab604df6545e7cb7c38eec982719d104 inherit pub_methods_classEpetra__CrsMatrix" id="r_aab604df6545e7cb7c38eec982719d104"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>StorageOptimized</b> () const</td></tr>
<tr class="memdesc:aab604df6545e7cb7c38eec982719d104 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="classEpetra__CrsMatrix.html#ac54a33eafbaa0a966cf2c0ce454a7d59" title="Make consecutive row index sections contiguous, minimize internal storage used for constructing graph...">OptimizeStorage()</a> has been called, this query returns true, otherwise it returns false. <br /></td></tr>
<tr class="separator:aab604df6545e7cb7c38eec982719d104 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1486df3fb52a638e43eb8aa896a1b4c inherit pub_methods_classEpetra__CrsMatrix" id="r_ae1486df3fb52a638e43eb8aa896a1b4c"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IndicesAreGlobal</b> () const</td></tr>
<tr class="memdesc:ae1486df3fb52a638e43eb8aa896a1b4c inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">If matrix indices has not been transformed to local, this query returns true, otherwise it returns false. <br /></td></tr>
<tr class="separator:ae1486df3fb52a638e43eb8aa896a1b4c inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae10c5b74759484342ed40ced9561f49 inherit pub_methods_classEpetra__CrsMatrix" id="r_aae10c5b74759484342ed40ced9561f49"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IndicesAreLocal</b> () const</td></tr>
<tr class="memdesc:aae10c5b74759484342ed40ced9561f49 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">If matrix indices has been transformed to local, this query returns true, otherwise it returns false. <br /></td></tr>
<tr class="separator:aae10c5b74759484342ed40ced9561f49 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f864987f9c83d3e8f02716d7540055 inherit pub_methods_classEpetra__CrsMatrix" id="r_ad9f864987f9c83d3e8f02716d7540055"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IndicesAreContiguous</b> () const</td></tr>
<tr class="memdesc:ad9f864987f9c83d3e8f02716d7540055 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">If matrix indices are packed into single array (done in <a class="el" href="classEpetra__CrsMatrix.html#ac54a33eafbaa0a966cf2c0ce454a7d59" title="Make consecutive row index sections contiguous, minimize internal storage used for constructing graph...">OptimizeStorage()</a>) return true, otherwise false. <br /></td></tr>
<tr class="separator:ad9f864987f9c83d3e8f02716d7540055 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b3492e9b2db7397d6d12a4fddf5ffc inherit pub_methods_classEpetra__CrsMatrix" id="r_ab6b3492e9b2db7397d6d12a4fddf5ffc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ab6b3492e9b2db7397d6d12a4fddf5ffc">LowerTriangular</a> () const</td></tr>
<tr class="memdesc:ab6b3492e9b2db7397d6d12a4fddf5ffc inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">If matrix is lower triangular in local index space, this query returns true, otherwise it returns false.  <br /></td></tr>
<tr class="separator:ab6b3492e9b2db7397d6d12a4fddf5ffc inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a4fac8da3d1e717b1fb500f9806e53 inherit pub_methods_classEpetra__CrsMatrix" id="r_ac6a4fac8da3d1e717b1fb500f9806e53"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ac6a4fac8da3d1e717b1fb500f9806e53">UpperTriangular</a> () const</td></tr>
<tr class="memdesc:ac6a4fac8da3d1e717b1fb500f9806e53 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">If matrix is upper triangular in local index space, this query returns true, otherwise it returns false.  <br /></td></tr>
<tr class="separator:ac6a4fac8da3d1e717b1fb500f9806e53 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6b258a0e7301a5fa31c51037622f1e inherit pub_methods_classEpetra__CrsMatrix" id="r_adf6b258a0e7301a5fa31c51037622f1e"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>NoDiagonal</b> () const</td></tr>
<tr class="memdesc:adf6b258a0e7301a5fa31c51037622f1e inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">If matrix has no diagonal entries in global index space, this query returns true, otherwise it returns false. <br /></td></tr>
<tr class="separator:adf6b258a0e7301a5fa31c51037622f1e inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea249176fc818ebde242b3a1054ecb34 inherit pub_methods_classEpetra__CrsMatrix" id="r_aea249176fc818ebde242b3a1054ecb34"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#aea249176fc818ebde242b3a1054ecb34">NormInf</a> () const</td></tr>
<tr class="memdesc:aea249176fc818ebde242b3a1054ecb34 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the infinity norm of the global matrix.  <br /></td></tr>
<tr class="separator:aea249176fc818ebde242b3a1054ecb34 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643dc754bea9373a9f26f9b2f095f677 inherit pub_methods_classEpetra__CrsMatrix" id="r_a643dc754bea9373a9f26f9b2f095f677"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a643dc754bea9373a9f26f9b2f095f677">NormOne</a> () const</td></tr>
<tr class="memdesc:a643dc754bea9373a9f26f9b2f095f677 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the one norm of the global matrix.  <br /></td></tr>
<tr class="separator:a643dc754bea9373a9f26f9b2f095f677 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6492f0286e04474efa300d9750e46166 inherit pub_methods_classEpetra__CrsMatrix" id="r_a6492f0286e04474efa300d9750e46166"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><b>NormFrobenius</b> () const</td></tr>
<tr class="memdesc:a6492f0286e04474efa300d9750e46166 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the frobenius norm of the global matrix. <br /></td></tr>
<tr class="separator:a6492f0286e04474efa300d9750e46166 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6420c1fb13a60a856a1fdcae549fae56 inherit pub_methods_classEpetra__CrsMatrix" id="r_a6420c1fb13a60a856a1fdcae549fae56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a6420c1fb13a60a856a1fdcae549fae56">NumGlobalNonzeros</a> () const</td></tr>
<tr class="memdesc:a6420c1fb13a60a856a1fdcae549fae56 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nonzero entries in the global matrix.  <br /></td></tr>
<tr class="separator:a6420c1fb13a60a856a1fdcae549fae56 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5450132a1523598f5487c7a25ef2a765 inherit pub_methods_classEpetra__CrsMatrix" id="r_a5450132a1523598f5487c7a25ef2a765"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a5450132a1523598f5487c7a25ef2a765">NumGlobalNonzeros64</a> () const</td></tr>
<tr class="separator:a5450132a1523598f5487c7a25ef2a765 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0da526e7a65fb75ecb356567e4945f0 inherit pub_methods_classEpetra__CrsMatrix" id="r_aa0da526e7a65fb75ecb356567e4945f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#aa0da526e7a65fb75ecb356567e4945f0">NumGlobalRows</a> () const</td></tr>
<tr class="memdesc:aa0da526e7a65fb75ecb356567e4945f0 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of global matrix rows.  <br /></td></tr>
<tr class="separator:aa0da526e7a65fb75ecb356567e4945f0 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d9decbc70d4ca103eb0eb0e5f4c89a inherit pub_methods_classEpetra__CrsMatrix" id="r_a42d9decbc70d4ca103eb0eb0e5f4c89a"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a42d9decbc70d4ca103eb0eb0e5f4c89a">NumGlobalRows64</a> () const</td></tr>
<tr class="separator:a42d9decbc70d4ca103eb0eb0e5f4c89a inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39970a8fee5716e012aa455306381e6b inherit pub_methods_classEpetra__CrsMatrix" id="r_a39970a8fee5716e012aa455306381e6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a39970a8fee5716e012aa455306381e6b">NumGlobalCols</a> () const</td></tr>
<tr class="memdesc:a39970a8fee5716e012aa455306381e6b inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of global matrix columns.  <br /></td></tr>
<tr class="separator:a39970a8fee5716e012aa455306381e6b inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c85e8a878e202db002d3e2240d9709 inherit pub_methods_classEpetra__CrsMatrix" id="r_af9c85e8a878e202db002d3e2240d9709"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#af9c85e8a878e202db002d3e2240d9709">NumGlobalCols64</a> () const</td></tr>
<tr class="separator:af9c85e8a878e202db002d3e2240d9709 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972eeec9930f6dfda76d9ec8f6f106d6 inherit pub_methods_classEpetra__CrsMatrix" id="r_a972eeec9930f6dfda76d9ec8f6f106d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a972eeec9930f6dfda76d9ec8f6f106d6">NumGlobalDiagonals</a> () const</td></tr>
<tr class="memdesc:a972eeec9930f6dfda76d9ec8f6f106d6 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of global nonzero diagonal entries, based on global row/column index comparisons.  <br /></td></tr>
<tr class="separator:a972eeec9930f6dfda76d9ec8f6f106d6 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3fcb9c5391ed9f688e2bad8da07773 inherit pub_methods_classEpetra__CrsMatrix" id="r_a2c3fcb9c5391ed9f688e2bad8da07773"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a2c3fcb9c5391ed9f688e2bad8da07773">NumGlobalDiagonals64</a> () const</td></tr>
<tr class="separator:a2c3fcb9c5391ed9f688e2bad8da07773 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77dec9df2d84dd502c02db9f37d8c5db inherit pub_methods_classEpetra__CrsMatrix" id="r_a77dec9df2d84dd502c02db9f37d8c5db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a77dec9df2d84dd502c02db9f37d8c5db">NumMyNonzeros</a> () const</td></tr>
<tr class="memdesc:a77dec9df2d84dd502c02db9f37d8c5db inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nonzero entries in the calling processor's portion of the matrix.  <br /></td></tr>
<tr class="separator:a77dec9df2d84dd502c02db9f37d8c5db inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6713140122dc58a27a79064705215e inherit pub_methods_classEpetra__CrsMatrix" id="r_ace6713140122dc58a27a79064705215e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ace6713140122dc58a27a79064705215e">NumMyRows</a> () const</td></tr>
<tr class="memdesc:ace6713140122dc58a27a79064705215e inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of matrix rows owned by the calling processor.  <br /></td></tr>
<tr class="separator:ace6713140122dc58a27a79064705215e inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa8e055646a0cddde3c45047d6502cf inherit pub_methods_classEpetra__CrsMatrix" id="r_a1aa8e055646a0cddde3c45047d6502cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a1aa8e055646a0cddde3c45047d6502cf">NumMyCols</a> () const</td></tr>
<tr class="memdesc:a1aa8e055646a0cddde3c45047d6502cf inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of entries in the set of column-indices that appear on this processor.  <br /></td></tr>
<tr class="separator:a1aa8e055646a0cddde3c45047d6502cf inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d875e6eb5f8c07567748805332867b inherit pub_methods_classEpetra__CrsMatrix" id="r_a93d875e6eb5f8c07567748805332867b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a93d875e6eb5f8c07567748805332867b">NumMyDiagonals</a> () const</td></tr>
<tr class="memdesc:a93d875e6eb5f8c07567748805332867b inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of local nonzero diagonal entries, based on global row/column index comparisons.  <br /></td></tr>
<tr class="separator:a93d875e6eb5f8c07567748805332867b inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffffac80bdd0a5e25de25cc9fb39f0f inherit pub_methods_classEpetra__CrsMatrix" id="r_a0ffffac80bdd0a5e25de25cc9fb39f0f"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>NumGlobalEntries</b> (long long Row) const</td></tr>
<tr class="memdesc:a0ffffac80bdd0a5e25de25cc9fb39f0f inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of nonzero entries in specified global row on this processor. <br /></td></tr>
<tr class="separator:a0ffffac80bdd0a5e25de25cc9fb39f0f inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02bb27c8361c9e4b7d74ed36f6829311 inherit pub_methods_classEpetra__CrsMatrix" id="r_a02bb27c8361c9e4b7d74ed36f6829311"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>NumAllocatedGlobalEntries</b> (int Row) const</td></tr>
<tr class="memdesc:a02bb27c8361c9e4b7d74ed36f6829311 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocated number of nonzero entries in specified global row on this processor. <br /></td></tr>
<tr class="separator:a02bb27c8361c9e4b7d74ed36f6829311 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16ae7b9de6c12a05fc3e7200e08acaf inherit pub_methods_classEpetra__CrsMatrix" id="r_ac16ae7b9de6c12a05fc3e7200e08acaf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ac16ae7b9de6c12a05fc3e7200e08acaf">MaxNumEntries</a> () const</td></tr>
<tr class="memdesc:ac16ae7b9de6c12a05fc3e7200e08acaf inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of nonzero entries across all rows on this processor.  <br /></td></tr>
<tr class="separator:ac16ae7b9de6c12a05fc3e7200e08acaf inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2506b65acc0862903f5d7d75cb12d1c0 inherit pub_methods_classEpetra__CrsMatrix" id="r_a2506b65acc0862903f5d7d75cb12d1c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a2506b65acc0862903f5d7d75cb12d1c0">GlobalMaxNumEntries</a> () const</td></tr>
<tr class="memdesc:a2506b65acc0862903f5d7d75cb12d1c0 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of nonzero entries across all rows on all processors.  <br /></td></tr>
<tr class="separator:a2506b65acc0862903f5d7d75cb12d1c0 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4030b25cb9be4c7e989481b460d24cf inherit pub_methods_classEpetra__CrsMatrix" id="r_ab4030b25cb9be4c7e989481b460d24cf"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>NumMyEntries</b> (int Row) const</td></tr>
<tr class="memdesc:ab4030b25cb9be4c7e989481b460d24cf inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of nonzero entries in specified local row on this processor. <br /></td></tr>
<tr class="separator:ab4030b25cb9be4c7e989481b460d24cf inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cb1f431a9e6e57bd78b5174f8a332b inherit pub_methods_classEpetra__CrsMatrix" id="r_ac2cb1f431a9e6e57bd78b5174f8a332b"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>NumAllocatedMyEntries</b> (int Row) const</td></tr>
<tr class="memdesc:ac2cb1f431a9e6e57bd78b5174f8a332b inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocated number of nonzero entries in specified local row on this processor. <br /></td></tr>
<tr class="separator:ac2cb1f431a9e6e57bd78b5174f8a332b inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e361f88ed2091196c888ad7d9c35b4 inherit pub_methods_classEpetra__CrsMatrix" id="r_aa5e361f88ed2091196c888ad7d9c35b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#aa5e361f88ed2091196c888ad7d9c35b4">IndexBase</a> () const</td></tr>
<tr class="memdesc:aa5e361f88ed2091196c888ad7d9c35b4 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index base for row and column indices for this graph.  <br /></td></tr>
<tr class="separator:aa5e361f88ed2091196c888ad7d9c35b4 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602dea8823b5e5423dc183eeadcdd5d3 inherit pub_methods_classEpetra__CrsMatrix" id="r_a602dea8823b5e5423dc183eeadcdd5d3"><td class="memItemLeft" align="right" valign="top">
long long&#160;</td><td class="memItemRight" valign="bottom"><b>IndexBase64</b> () const</td></tr>
<tr class="separator:a602dea8823b5e5423dc183eeadcdd5d3 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b159539dcbb15a1578c704e057e3b20 inherit pub_methods_classEpetra__CrsMatrix" id="r_a1b159539dcbb15a1578c704e057e3b20"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>StaticGraph</b> ()</td></tr>
<tr class="memdesc:a1b159539dcbb15a1578c704e057e3b20 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the graph associated with this matrix was pre-constructed and therefore not changeable. <br /></td></tr>
<tr class="separator:a1b159539dcbb15a1578c704e057e3b20 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ed3d3f3cb0ab79ffceb1974b9a8809 inherit pub_methods_classEpetra__CrsMatrix" id="r_a98ed3d3f3cb0ab79ffceb1974b9a8809"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classEpetra__CrsGraph.html">Epetra_CrsGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Graph</b> () const</td></tr>
<tr class="memdesc:a98ed3d3f3cb0ab79ffceb1974b9a8809 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the <a class="el" href="classEpetra__CrsGraph.html" title="Epetra_CrsGraph: A class for constructing and using sparse compressed row graphs.">Epetra_CrsGraph</a> object associated with this matrix. <br /></td></tr>
<tr class="separator:a98ed3d3f3cb0ab79ffceb1974b9a8809 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24855eec1cf6aeb201be88ba654d22bf inherit pub_methods_classEpetra__CrsMatrix" id="r_a24855eec1cf6aeb201be88ba654d22bf"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>RowMap</b> () const</td></tr>
<tr class="memdesc:a24855eec1cf6aeb201be88ba654d22bf inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> object associated with the rows of this matrix. <br /></td></tr>
<tr class="separator:a24855eec1cf6aeb201be88ba654d22bf inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c83fee95e71471e118fa91c15809aa2 inherit pub_methods_classEpetra__CrsMatrix" id="r_a3c83fee95e71471e118fa91c15809aa2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a3c83fee95e71471e118fa91c15809aa2">ReplaceRowMap</a> (const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;newmap)</td></tr>
<tr class="memdesc:a3c83fee95e71471e118fa91c15809aa2 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the current RowMap with the user-specified map object.  <br /></td></tr>
<tr class="separator:a3c83fee95e71471e118fa91c15809aa2 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4506a3e3975010fc801d915f7e6f08ba inherit pub_methods_classEpetra__CrsMatrix" id="r_a4506a3e3975010fc801d915f7e6f08ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a4506a3e3975010fc801d915f7e6f08ba">HaveColMap</a> () const</td></tr>
<tr class="memdesc:a4506a3e3975010fc801d915f7e6f08ba inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if we have a well-defined ColMap, and returns false otherwise.  <br /></td></tr>
<tr class="separator:a4506a3e3975010fc801d915f7e6f08ba inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c97a06e482fe0368fa4775e2a724109 inherit pub_methods_classEpetra__CrsMatrix" id="r_a7c97a06e482fe0368fa4775e2a724109"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a7c97a06e482fe0368fa4775e2a724109">ReplaceColMap</a> (const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;newmap)</td></tr>
<tr class="memdesc:a7c97a06e482fe0368fa4775e2a724109 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the current ColMap with the user-specified map object.  <br /></td></tr>
<tr class="separator:a7c97a06e482fe0368fa4775e2a724109 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0efbedcbd1c34ba7c3d61c7bd5bbf2 inherit pub_methods_classEpetra__CrsMatrix" id="r_a0d0efbedcbd1c34ba7c3d61c7bd5bbf2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a0d0efbedcbd1c34ba7c3d61c7bd5bbf2">ReplaceDomainMapAndImporter</a> (const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;NewDomainMap, const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> *NewImporter)</td></tr>
<tr class="memdesc:a0d0efbedcbd1c34ba7c3d61c7bd5bbf2 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the current DomainMap &amp; Importer with the user-specified map object.  <br /></td></tr>
<tr class="separator:a0d0efbedcbd1c34ba7c3d61c7bd5bbf2 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab338ef7689fdb5131c6624a6348e2fa5 inherit pub_methods_classEpetra__CrsMatrix" id="r_ab338ef7689fdb5131c6624a6348e2fa5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ab338ef7689fdb5131c6624a6348e2fa5">RemoveEmptyProcessesInPlace</a> (const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> *NewMap)</td></tr>
<tr class="memdesc:ab338ef7689fdb5131c6624a6348e2fa5 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove processes owning zero rows from the Maps and their communicator.  <br /></td></tr>
<tr class="separator:ab338ef7689fdb5131c6624a6348e2fa5 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3589bfaac41458ab698d3d53780e61 inherit pub_methods_classEpetra__CrsMatrix" id="r_aab3589bfaac41458ab698d3d53780e61"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#aab3589bfaac41458ab698d3d53780e61">ColMap</a> () const</td></tr>
<tr class="memdesc:aab3589bfaac41458ab698d3d53780e61 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> object that describes the set of column-indices that appear in each processor's locally owned matrix rows.  <br /></td></tr>
<tr class="separator:aab3589bfaac41458ab698d3d53780e61 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c6024783cb8f9a333f16b9ea5aa40c inherit pub_methods_classEpetra__CrsMatrix" id="r_ac8c6024783cb8f9a333f16b9ea5aa40c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c">DomainMap</a> () const</td></tr>
<tr class="memdesc:ac8c6024783cb8f9a333f16b9ea5aa40c inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> object associated with the domain of this matrix operator.  <br /></td></tr>
<tr class="separator:ac8c6024783cb8f9a333f16b9ea5aa40c inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9acf8281b9f9177f6271497fc4cd9222 inherit pub_methods_classEpetra__CrsMatrix" id="r_a9acf8281b9f9177f6271497fc4cd9222"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222">RangeMap</a> () const</td></tr>
<tr class="memdesc:a9acf8281b9f9177f6271497fc4cd9222 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> object associated with the range of this matrix operator.  <br /></td></tr>
<tr class="separator:a9acf8281b9f9177f6271497fc4cd9222 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4e28048f914a9b4f21382639c2246e inherit pub_methods_classEpetra__CrsMatrix" id="r_acf4e28048f914a9b4f21382639c2246e"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Importer</b> () const</td></tr>
<tr class="memdesc:acf4e28048f914a9b4f21382639c2246e inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classEpetra__Import.html" title="Epetra_Import: This class builds an import object for efficient importing of off-processor elements.">Epetra_Import</a> object that contains the import operations for distributed operations. <br /></td></tr>
<tr class="separator:acf4e28048f914a9b4f21382639c2246e inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16227ba1f3f3548e5b84568cd21f3e3b inherit pub_methods_classEpetra__CrsMatrix" id="r_a16227ba1f3f3548e5b84568cd21f3e3b"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Exporter</b> () const</td></tr>
<tr class="memdesc:a16227ba1f3f3548e5b84568cd21f3e3b inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classEpetra__Export.html" title="Epetra_Export: This class builds an export object for efficient exporting of off-processor elements.">Epetra_Export</a> object that contains the export operations for distributed operations. <br /></td></tr>
<tr class="separator:a16227ba1f3f3548e5b84568cd21f3e3b inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997eeee1d81be3d5b408b0bed58cd351 inherit pub_methods_classEpetra__CrsMatrix" id="r_a997eeee1d81be3d5b408b0bed58cd351"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a997eeee1d81be3d5b408b0bed58cd351">Comm</a> () const</td></tr>
<tr class="memdesc:a997eeee1d81be3d5b408b0bed58cd351 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> communicator associated with this matrix.  <br /></td></tr>
<tr class="separator:a997eeee1d81be3d5b408b0bed58cd351 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b0877e4b3af79213cb06a968fcec3f inherit pub_methods_classEpetra__CrsMatrix" id="r_a59b0877e4b3af79213cb06a968fcec3f"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>LRID</b> (int GRID_in) const</td></tr>
<tr class="memdesc:a59b0877e4b3af79213cb06a968fcec3f inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the local row index for given global row index, returns -1 if no local row for this global row. <br /></td></tr>
<tr class="separator:a59b0877e4b3af79213cb06a968fcec3f inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0982b9fbe77df91c904667829392008e inherit pub_methods_classEpetra__CrsMatrix" id="r_a0982b9fbe77df91c904667829392008e"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>LRID</b> (long long GRID_in) const</td></tr>
<tr class="separator:a0982b9fbe77df91c904667829392008e inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959f23496bde5d80cb074d66fbef5b1d inherit pub_methods_classEpetra__CrsMatrix" id="r_a959f23496bde5d80cb074d66fbef5b1d"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>GRID</b> (int LRID_in) const</td></tr>
<tr class="memdesc:a959f23496bde5d80cb074d66fbef5b1d inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the global row index for give local row index, returns IndexBase-1 if we don't have this local row. <br /></td></tr>
<tr class="separator:a959f23496bde5d80cb074d66fbef5b1d inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add34e8f40add2367814108153bb58e09 inherit pub_methods_classEpetra__CrsMatrix" id="r_add34e8f40add2367814108153bb58e09"><td class="memItemLeft" align="right" valign="top">
long long&#160;</td><td class="memItemRight" valign="bottom"><b>GRID64</b> (int LRID_in) const</td></tr>
<tr class="separator:add34e8f40add2367814108153bb58e09 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402c29f8059e4ed6c113c612e36006a3 inherit pub_methods_classEpetra__CrsMatrix" id="r_a402c29f8059e4ed6c113c612e36006a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a402c29f8059e4ed6c113c612e36006a3">LCID</a> (int GCID_in) const</td></tr>
<tr class="memdesc:a402c29f8059e4ed6c113c612e36006a3 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the local column index for given global column index, returns -1 if no local column for this global column.  <br /></td></tr>
<tr class="separator:a402c29f8059e4ed6c113c612e36006a3 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5baa4f10ec3d35ae910a72efcf26e16a inherit pub_methods_classEpetra__CrsMatrix" id="r_a5baa4f10ec3d35ae910a72efcf26e16a"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>LCID</b> (long long GCID_in) const</td></tr>
<tr class="separator:a5baa4f10ec3d35ae910a72efcf26e16a inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01cc7e29ab441e2bffc75acd487ee804 inherit pub_methods_classEpetra__CrsMatrix" id="r_a01cc7e29ab441e2bffc75acd487ee804"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a01cc7e29ab441e2bffc75acd487ee804">GCID</a> (int LCID_in) const</td></tr>
<tr class="memdesc:a01cc7e29ab441e2bffc75acd487ee804 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the global column index for give local column index, returns IndexBase-1 if we don't have this local column.  <br /></td></tr>
<tr class="separator:a01cc7e29ab441e2bffc75acd487ee804 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9939251e71fc2c755b41bf317999c9f inherit pub_methods_classEpetra__CrsMatrix" id="r_af9939251e71fc2c755b41bf317999c9f"><td class="memItemLeft" align="right" valign="top">
long long&#160;</td><td class="memItemRight" valign="bottom"><b>GCID64</b> (int LCID_in) const</td></tr>
<tr class="separator:af9939251e71fc2c755b41bf317999c9f inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ba0e25621d9bb7be02196a4dff2f78 inherit pub_methods_classEpetra__CrsMatrix" id="r_a25ba0e25621d9bb7be02196a4dff2f78"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MyGRID</b> (int GRID_in) const</td></tr>
<tr class="memdesc:a25ba0e25621d9bb7be02196a4dff2f78 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the GRID passed in belongs to the calling processor in this map, otherwise returns false. <br /></td></tr>
<tr class="separator:a25ba0e25621d9bb7be02196a4dff2f78 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57950cd066e9ca5e35673080a53240f inherit pub_methods_classEpetra__CrsMatrix" id="r_ac57950cd066e9ca5e35673080a53240f"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MyGRID</b> (long long GRID_in) const</td></tr>
<tr class="separator:ac57950cd066e9ca5e35673080a53240f inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0355c11c6f69df1b12e4df2408e71262 inherit pub_methods_classEpetra__CrsMatrix" id="r_a0355c11c6f69df1b12e4df2408e71262"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MyLRID</b> (int LRID_in) const</td></tr>
<tr class="memdesc:a0355c11c6f69df1b12e4df2408e71262 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the LRID passed in belongs to the calling processor in this map, otherwise returns false. <br /></td></tr>
<tr class="separator:a0355c11c6f69df1b12e4df2408e71262 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6da673b8d502adcc0501cf997f6986 inherit pub_methods_classEpetra__CrsMatrix" id="r_afc6da673b8d502adcc0501cf997f6986"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#afc6da673b8d502adcc0501cf997f6986">MyGCID</a> (int GCID_in) const</td></tr>
<tr class="memdesc:afc6da673b8d502adcc0501cf997f6986 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the GCID passed in belongs to the calling processor in this map, otherwise returns false.  <br /></td></tr>
<tr class="separator:afc6da673b8d502adcc0501cf997f6986 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02b3558022f1092c85de4410601208b inherit pub_methods_classEpetra__CrsMatrix" id="r_ac02b3558022f1092c85de4410601208b"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MyGCID</b> (long long GCID_in) const</td></tr>
<tr class="separator:ac02b3558022f1092c85de4410601208b inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c15615f37a288c4f45499f9ffd45ac9 inherit pub_methods_classEpetra__CrsMatrix" id="r_a7c15615f37a288c4f45499f9ffd45ac9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a7c15615f37a288c4f45499f9ffd45ac9">MyLCID</a> (int LCID_in) const</td></tr>
<tr class="memdesc:a7c15615f37a288c4f45499f9ffd45ac9 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the LRID passed in belongs to the calling processor in this map, otherwise returns false.  <br /></td></tr>
<tr class="separator:a7c15615f37a288c4f45499f9ffd45ac9 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350faf13052a5cc84fc65d0d54588ed5 inherit pub_methods_classEpetra__CrsMatrix" id="r_a350faf13052a5cc84fc65d0d54588ed5"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MyGlobalRow</b> (int GID) const</td></tr>
<tr class="memdesc:a350faf13052a5cc84fc65d0d54588ed5 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true of GID is owned by the calling processor, otherwise it returns false. <br /></td></tr>
<tr class="separator:a350faf13052a5cc84fc65d0d54588ed5 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e7c4c7dc409614651c240749a4dc8a inherit pub_methods_classEpetra__CrsMatrix" id="r_a90e7c4c7dc409614651c240749a4dc8a"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MyGlobalRow</b> (long long GID) const</td></tr>
<tr class="separator:a90e7c4c7dc409614651c240749a4dc8a inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e117569991b807df5386868da10a78 inherit pub_methods_classEpetra__CrsMatrix" id="r_af5e117569991b807df5386868da10a78"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#af5e117569991b807df5386868da10a78">Print</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:af5e117569991b807df5386868da10a78 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print method.  <br /></td></tr>
<tr class="separator:af5e117569991b807df5386868da10a78 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f19abe10ac0e5469292142c7c96f05 inherit pub_methods_classEpetra__CrsMatrix" id="r_a88f19abe10ac0e5469292142c7c96f05"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a88f19abe10ac0e5469292142c7c96f05">Label</a> () const</td></tr>
<tr class="memdesc:a88f19abe10ac0e5469292142c7c96f05 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a character string describing the operator.  <br /></td></tr>
<tr class="separator:a88f19abe10ac0e5469292142c7c96f05 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859bf40b4652b385d06235450dcda7d8 inherit pub_methods_classEpetra__CrsMatrix" id="r_a859bf40b4652b385d06235450dcda7d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a859bf40b4652b385d06235450dcda7d8">SetUseTranspose</a> (bool UseTranspose_in)</td></tr>
<tr class="memdesc:a859bf40b4652b385d06235450dcda7d8 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set true, transpose of this operator will be applied.  <br /></td></tr>
<tr class="separator:a859bf40b4652b385d06235450dcda7d8 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71714f462b0e0218cf6c0c9f6a65353 inherit pub_methods_classEpetra__CrsMatrix" id="r_aa71714f462b0e0218cf6c0c9f6a65353"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#aa71714f462b0e0218cf6c0c9f6a65353">Apply</a> (const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;X, <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;Y) const</td></tr>
<tr class="memdesc:aa71714f462b0e0218cf6c0c9f6a65353 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of a <a class="el" href="classEpetra__Operator.html" title="Epetra_Operator: A pure virtual class for using real-valued double-precision operators.">Epetra_Operator</a> applied to a <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> X in Y.  <br /></td></tr>
<tr class="separator:aa71714f462b0e0218cf6c0c9f6a65353 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df56e43070f908dec709b1a19348cee inherit pub_methods_classEpetra__CrsMatrix" id="r_a7df56e43070f908dec709b1a19348cee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a7df56e43070f908dec709b1a19348cee">ApplyInverse</a> (const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;X, <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;Y) const</td></tr>
<tr class="memdesc:a7df56e43070f908dec709b1a19348cee inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of a <a class="el" href="classEpetra__Operator.html" title="Epetra_Operator: A pure virtual class for using real-valued double-precision operators.">Epetra_Operator</a> inverse applied to an <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> X in Y.  <br /></td></tr>
<tr class="separator:a7df56e43070f908dec709b1a19348cee inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f03b8c321e530a55ebc2df1553dde9f inherit pub_methods_classEpetra__CrsMatrix" id="r_a5f03b8c321e530a55ebc2df1553dde9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a5f03b8c321e530a55ebc2df1553dde9f">HasNormInf</a> () const</td></tr>
<tr class="memdesc:a5f03b8c321e530a55ebc2df1553dde9f inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true because this class can compute an Inf-norm.  <br /></td></tr>
<tr class="separator:a5f03b8c321e530a55ebc2df1553dde9f inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd834231c77c941d11ce1d0f1ddb727 inherit pub_methods_classEpetra__CrsMatrix" id="r_a0cd834231c77c941d11ce1d0f1ddb727"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a0cd834231c77c941d11ce1d0f1ddb727">UseTranspose</a> () const</td></tr>
<tr class="memdesc:a0cd834231c77c941d11ce1d0f1ddb727 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current UseTranspose setting.  <br /></td></tr>
<tr class="separator:a0cd834231c77c941d11ce1d0f1ddb727 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc075f22e741f7d6c186eb20f2498bf9 inherit pub_methods_classEpetra__CrsMatrix" id="r_adc075f22e741f7d6c186eb20f2498bf9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#adc075f22e741f7d6c186eb20f2498bf9">OperatorDomainMap</a> () const</td></tr>
<tr class="memdesc:adc075f22e741f7d6c186eb20f2498bf9 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> object associated with the domain of this matrix operator.  <br /></td></tr>
<tr class="separator:adc075f22e741f7d6c186eb20f2498bf9 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b97f29a7febcea4d8926548a413c650 inherit pub_methods_classEpetra__CrsMatrix" id="r_a2b97f29a7febcea4d8926548a413c650"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a2b97f29a7febcea4d8926548a413c650">OperatorRangeMap</a> () const</td></tr>
<tr class="memdesc:a2b97f29a7febcea4d8926548a413c650 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> object associated with the range of this matrix operator.  <br /></td></tr>
<tr class="separator:a2b97f29a7febcea4d8926548a413c650 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6663818c7bb8867e87907666a1b41e inherit pub_methods_classEpetra__CrsMatrix" id="r_abd6663818c7bb8867e87907666a1b41e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#abd6663818c7bb8867e87907666a1b41e">NumMyRowEntries</a> (int MyRow, int &amp;NumEntries) const</td></tr>
<tr class="memdesc:abd6663818c7bb8867e87907666a1b41e inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current number of values stored for the specified local row.  <br /></td></tr>
<tr class="separator:abd6663818c7bb8867e87907666a1b41e inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb31423007dc9e3d005782861bcf35b1 inherit pub_methods_classEpetra__CrsMatrix" id="r_aeb31423007dc9e3d005782861bcf35b1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#aeb31423007dc9e3d005782861bcf35b1">Map</a> () const</td></tr>
<tr class="memdesc:aeb31423007dc9e3d005782861bcf35b1 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__CrsMatrix.html#aeb31423007dc9e3d005782861bcf35b1" title="Map() method inherited from Epetra_DistObject.">Map()</a> method inherited from <a class="el" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi-vectors, vectors and matrices in pa...">Epetra_DistObject</a>.  <br /></td></tr>
<tr class="separator:aeb31423007dc9e3d005782861bcf35b1 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cf38cfbefc8f9410ca65c35a65a130 inherit pub_methods_classEpetra__CrsMatrix" id="r_ae8cf38cfbefc8f9410ca65c35a65a130"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ae8cf38cfbefc8f9410ca65c35a65a130">RowMatrixRowMap</a> () const</td></tr>
<tr class="memdesc:ae8cf38cfbefc8f9410ca65c35a65a130 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> object associated with the rows of this matrix.  <br /></td></tr>
<tr class="separator:ae8cf38cfbefc8f9410ca65c35a65a130 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fc2afcabadee62112e6e51375fabdf inherit pub_methods_classEpetra__CrsMatrix" id="r_ac6fc2afcabadee62112e6e51375fabdf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ac6fc2afcabadee62112e6e51375fabdf">RowMatrixColMap</a> () const</td></tr>
<tr class="memdesc:ac6fc2afcabadee62112e6e51375fabdf inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> object associated with columns of this matrix.  <br /></td></tr>
<tr class="separator:ac6fc2afcabadee62112e6e51375fabdf inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d913cfd97ffa19fcdd062ae7098cff4 inherit pub_methods_classEpetra__CrsMatrix" id="r_a5d913cfd97ffa19fcdd062ae7098cff4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a5d913cfd97ffa19fcdd062ae7098cff4">RowMatrixImporter</a> () const</td></tr>
<tr class="memdesc:a5d913cfd97ffa19fcdd062ae7098cff4 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classEpetra__Import.html" title="Epetra_Import: This class builds an import object for efficient importing of off-processor elements.">Epetra_Import</a> object that contains the import operations for distributed operations.  <br /></td></tr>
<tr class="separator:a5d913cfd97ffa19fcdd062ae7098cff4 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a19b7a5857f7940bce56f86e73b73e inherit pub_methods_classEpetra__CrsMatrix" id="r_ae7a19b7a5857f7940bce56f86e73b73e"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ae7a19b7a5857f7940bce56f86e73b73e">operator[]</a> (int Loc)</td></tr>
<tr class="memdesc:ae7a19b7a5857f7940bce56f86e73b73e inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined bracket operator for fast access to data. (Const and Non-const versions)  <br /></td></tr>
<tr class="separator:ae7a19b7a5857f7940bce56f86e73b73e inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff446bf53ae4e14c2467336748e22f4 inherit pub_methods_classEpetra__CrsMatrix" id="r_a1ff446bf53ae4e14c2467336748e22f4"><td class="memItemLeft" align="right" valign="top">
double *&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (int Loc) const</td></tr>
<tr class="separator:a1ff446bf53ae4e14c2467336748e22f4 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc55fd3394fc25867ba0d2e8a730fdc inherit pub_methods_classEpetra__CrsMatrix" id="r_a9fc55fd3394fc25867ba0d2e8a730fdc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a9fc55fd3394fc25867ba0d2e8a730fdc">ExtractCrsDataPointers</a> (int *&amp;IndexOffset, int *&amp;Indices, double *&amp;Values_in) const</td></tr>
<tr class="memdesc:a9fc55fd3394fc25867ba0d2e8a730fdc inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns internal data pointers associated with Crs matrix format.  <br /></td></tr>
<tr class="separator:a9fc55fd3394fc25867ba0d2e8a730fdc inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace936ff3ff41b09aa79ec7ed070f960 inherit pub_methods_classEpetra__CrsMatrix" id="r_aace936ff3ff41b09aa79ec7ed070f960"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEpetra__IntSerialDenseVector.html">Epetra_IntSerialDenseVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#aace936ff3ff41b09aa79ec7ed070f960">ExpertExtractIndexOffset</a> ()</td></tr>
<tr class="memdesc:aace936ff3ff41b09aa79ec7ed070f960 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the <a class="el" href="classEpetra__IntSerialDenseVector.html" title="Epetra_IntSerialDenseVector: A class for constructing and using dense vectors.">Epetra_IntSerialDenseVector</a> used to hold the local IndexOffsets (CRS rowptr)  <br /></td></tr>
<tr class="separator:aace936ff3ff41b09aa79ec7ed070f960 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6548de37ad7852d2a0c391ebd0bec49 inherit pub_methods_classEpetra__CrsMatrix" id="r_ad6548de37ad7852d2a0c391ebd0bec49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEpetra__IntSerialDenseVector.html">Epetra_IntSerialDenseVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ad6548de37ad7852d2a0c391ebd0bec49">ExpertExtractIndices</a> ()</td></tr>
<tr class="memdesc:ad6548de37ad7852d2a0c391ebd0bec49 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the <a class="el" href="classEpetra__IntSerialDenseVector.html" title="Epetra_IntSerialDenseVector: A class for constructing and using dense vectors.">Epetra_IntSerialDenseVector</a> used to hold the local All_Indices (CRS colind)  <br /></td></tr>
<tr class="separator:ad6548de37ad7852d2a0c391ebd0bec49 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb04d17c51c3029e14031a90c0c0ef78 inherit pub_methods_classEpetra__CrsMatrix" id="r_afb04d17c51c3029e14031a90c0c0ef78"><td class="memItemLeft" align="right" valign="top">double *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#afb04d17c51c3029e14031a90c0c0ef78">ExpertExtractValues</a> ()</td></tr>
<tr class="memdesc:afb04d17c51c3029e14031a90c0c0ef78 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the double* used to hold the values array.  <br /></td></tr>
<tr class="separator:afb04d17c51c3029e14031a90c0c0ef78 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3753556d7dc03d2b66b1b1a3be5c1795 inherit pub_methods_classEpetra__CrsMatrix" id="r_a3753556d7dc03d2b66b1b1a3be5c1795"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a3753556d7dc03d2b66b1b1a3be5c1795">ExpertStaticFillComplete</a> (const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;<a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c">DomainMap</a>, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;<a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222">RangeMap</a>, const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> *<a class="el" href="classEpetra__CrsMatrix.html#acf4e28048f914a9b4f21382639c2246e">Importer</a>=0, const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> *<a class="el" href="classEpetra__CrsMatrix.html#a16227ba1f3f3548e5b84568cd21f3e3b">Exporter</a>=0, int <a class="el" href="classEpetra__CrsMatrix.html#a93d875e6eb5f8c07567748805332867b">NumMyDiagonals</a>=-1)</td></tr>
<tr class="memdesc:a3753556d7dc03d2b66b1b1a3be5c1795 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a FillComplete on an object that aready has filled CRS data.  <br /></td></tr>
<tr class="separator:a3753556d7dc03d2b66b1b1a3be5c1795 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab074df197e9d79057217bf7e8de4fa66 inherit pub_methods_classEpetra__CrsMatrix" id="r_ab074df197e9d79057217bf7e8de4fa66"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ab074df197e9d79057217bf7e8de4fa66">ExpertMakeUniqueCrsGraphData</a> ()</td></tr>
<tr class="memdesc:ab074df197e9d79057217bf7e8de4fa66 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes sure this matrix has a unique CrsGraphData object.  <br /></td></tr>
<tr class="separator:ab074df197e9d79057217bf7e8de4fa66 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5672eb590bbd4bf5f6124af1f66f3be inherit pub_methods_classEpetra__CrsMatrix" id="r_ae5672eb590bbd4bf5f6124af1f66f3be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ae5672eb590bbd4bf5f6124af1f66f3be">SortGhostsAssociatedWithEachProcessor</a> (bool Flag)</td></tr>
<tr class="memdesc:ae5672eb590bbd4bf5f6124af1f66f3be inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> to locally order ghostnodes associated with each remote processor in ascending order.  <br /></td></tr>
<tr class="separator:ae5672eb590bbd4bf5f6124af1f66f3be inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac804b60c8674adefaadcb664e9b450 inherit pub_methods_classEpetra__CrsMatrix" id="r_a7ac804b60c8674adefaadcb664e9b450"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ImportMap</b> () const</td></tr>
<tr class="memdesc:a7ac804b60c8674adefaadcb664e9b450 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <a class="el" href="classEpetra__CrsMatrix.html#aab3589bfaac41458ab698d3d53780e61" title="Returns the Epetra_Map object that describes the set of column-indices that appear in each processor&#39;...">ColMap()</a> instead. <br /></td></tr>
<tr class="separator:a7ac804b60c8674adefaadcb664e9b450 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0c8644018b39157b3db9e6acc0096a inherit pub_methods_classEpetra__CrsMatrix" id="r_a2d0c8644018b39157b3db9e6acc0096a"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>TransformToLocal</b> ()</td></tr>
<tr class="memdesc:a2d0c8644018b39157b3db9e6acc0096a inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> instead. <br /></td></tr>
<tr class="separator:a2d0c8644018b39157b3db9e6acc0096a inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af574d136505d21e5890894e8e39f4ca1 inherit pub_methods_classEpetra__CrsMatrix" id="r_af574d136505d21e5890894e8e39f4ca1"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>TransformToLocal</b> (const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c">DomainMap</a>, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222">RangeMap</a>)</td></tr>
<tr class="memdesc:af574d136505d21e5890894e8e39f4ca1 inherit pub_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use FillComplete(const Epetra_Map&amp; DomainMap, const Epetra_Map&amp; RangeMap) instead. <br /></td></tr>
<tr class="separator:af574d136505d21e5890894e8e39f4ca1 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961f60d827738942f79e4277dc82b1ee inherit pub_methods_classEpetra__CrsMatrix" id="r_a961f60d827738942f79e4277dc82b1ee"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>FusedImport</b> (const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;SourceMatrix, const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> &amp;RowImporter, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c">DomainMap</a>, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222">RangeMap</a>, bool RestrictCommunicator)</td></tr>
<tr class="separator:a961f60d827738942f79e4277dc82b1ee inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d22aa64c75c5a68fa8e7a23fa15a7b inherit pub_methods_classEpetra__CrsMatrix" id="r_ab3d22aa64c75c5a68fa8e7a23fa15a7b"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>FusedExport</b> (const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;SourceMatrix, const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> &amp;RowExporter, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c">DomainMap</a>, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222">RangeMap</a>, bool RestrictCommunicator)</td></tr>
<tr class="separator:ab3d22aa64c75c5a68fa8e7a23fa15a7b inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970ae0fbe162efea59cd633fb52558cb inherit pub_methods_classEpetra__CrsMatrix" id="r_a970ae0fbe162efea59cd633fb52558cb"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>FusedImport</b> (const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;SourceMatrix, const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> &amp;RowImporter, const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> *DomainImporter, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c">DomainMap</a>, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222">RangeMap</a>, bool RestrictCommunicator)</td></tr>
<tr class="separator:a970ae0fbe162efea59cd633fb52558cb inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9aeb544eff8540fd665106591ab930 inherit pub_methods_classEpetra__CrsMatrix" id="r_a1e9aeb544eff8540fd665106591ab930"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>FusedExport</b> (const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;SourceMatrix, const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> &amp;RowExporter, const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> *DomainExporter, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c">DomainMap</a>, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222">RangeMap</a>, bool RestrictCommunicator)</td></tr>
<tr class="separator:a1e9aeb544eff8540fd665106591ab930 inherit pub_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__DistObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__DistObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__DistObject.html">Epetra_DistObject</a></td></tr>
<tr class="memitem:aea928fbc32a281b5038a149bc7ff766a inherit pub_methods_classEpetra__DistObject" id="r_aea928fbc32a281b5038a149bc7ff766a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__DistObject.html#aea928fbc32a281b5038a149bc7ff766a">Epetra_DistObject</a> (const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;<a class="el" href="classEpetra__DistObject.html#a00702a53a4a8142f249639d254e760cd">Map</a>)</td></tr>
<tr class="memdesc:aea928fbc32a281b5038a149bc7ff766a inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic <a class="el" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi-vectors, vectors and matrices in pa...">Epetra_DistObject</a> constuctor.  <br /></td></tr>
<tr class="separator:aea928fbc32a281b5038a149bc7ff766a inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73d8a91a6389a526fc7e08a8a1b043b inherit pub_methods_classEpetra__DistObject" id="r_ac73d8a91a6389a526fc7e08a8a1b043b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__DistObject.html#ac73d8a91a6389a526fc7e08a8a1b043b">Epetra_DistObject</a> (const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;<a class="el" href="classEpetra__DistObject.html#a00702a53a4a8142f249639d254e760cd">Map</a>, const char *const <a class="el" href="classEpetra__Object.html#a1910d1c04e70ac482f7e377b271f6c26">Label</a>)</td></tr>
<tr class="separator:ac73d8a91a6389a526fc7e08a8a1b043b inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09204a59077097b73d3cf70e862feaf9 inherit pub_methods_classEpetra__DistObject" id="r_a09204a59077097b73d3cf70e862feaf9"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_DistObject</b> (const <a class="el" href="classEpetra__DistObject.html">Epetra_DistObject</a> &amp;Source)</td></tr>
<tr class="memdesc:a09204a59077097b73d3cf70e862feaf9 inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi-vectors, vectors and matrices in pa...">Epetra_DistObject</a> copy constructor. <br /></td></tr>
<tr class="separator:a09204a59077097b73d3cf70e862feaf9 inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41082a7526d3aa88f79d57805e5b9337 inherit pub_methods_classEpetra__DistObject" id="r_a41082a7526d3aa88f79d57805e5b9337"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_DistObject</b> ()</td></tr>
<tr class="memdesc:a41082a7526d3aa88f79d57805e5b9337 inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi-vectors, vectors and matrices in pa...">Epetra_DistObject</a> destructor. <br /></td></tr>
<tr class="separator:a41082a7526d3aa88f79d57805e5b9337 inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393f365177c485ab1c30f288514f9297 inherit pub_methods_classEpetra__DistObject" id="r_a393f365177c485ab1c30f288514f9297"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__DistObject.html#a393f365177c485ab1c30f288514f9297">Import</a> (const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;A, const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> &amp;Importer, <a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020f">Epetra_CombineMode</a> CombineMode, const <a class="el" href="classEpetra__OffsetIndex.html">Epetra_OffsetIndex</a> *Indexor=0)</td></tr>
<tr class="memdesc:a393f365177c485ab1c30f288514f9297 inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imports an <a class="el" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi-vectors, vectors and matrices in pa...">Epetra_DistObject</a> using the <a class="el" href="classEpetra__Import.html" title="Epetra_Import: This class builds an import object for efficient importing of off-processor elements.">Epetra_Import</a> object.  <br /></td></tr>
<tr class="separator:a393f365177c485ab1c30f288514f9297 inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac1b1da995e88db2ae67cc02ad37dc8 inherit pub_methods_classEpetra__DistObject" id="r_aeac1b1da995e88db2ae67cc02ad37dc8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__DistObject.html#aeac1b1da995e88db2ae67cc02ad37dc8">Import</a> (const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;A, const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> &amp;Exporter, <a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020f">Epetra_CombineMode</a> CombineMode, const <a class="el" href="classEpetra__OffsetIndex.html">Epetra_OffsetIndex</a> *Indexor=0)</td></tr>
<tr class="memdesc:aeac1b1da995e88db2ae67cc02ad37dc8 inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imports an <a class="el" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi-vectors, vectors and matrices in pa...">Epetra_DistObject</a> using the <a class="el" href="classEpetra__Export.html" title="Epetra_Export: This class builds an export object for efficient exporting of off-processor elements.">Epetra_Export</a> object.  <br /></td></tr>
<tr class="separator:aeac1b1da995e88db2ae67cc02ad37dc8 inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a69d5a64168c02fadfc6c55ecd5a1c inherit pub_methods_classEpetra__DistObject" id="r_a88a69d5a64168c02fadfc6c55ecd5a1c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__DistObject.html#a88a69d5a64168c02fadfc6c55ecd5a1c">Export</a> (const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;A, const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> &amp;Importer, <a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020f">Epetra_CombineMode</a> CombineMode, const <a class="el" href="classEpetra__OffsetIndex.html">Epetra_OffsetIndex</a> *Indexor=0)</td></tr>
<tr class="memdesc:a88a69d5a64168c02fadfc6c55ecd5a1c inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports an <a class="el" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi-vectors, vectors and matrices in pa...">Epetra_DistObject</a> using the <a class="el" href="classEpetra__Import.html" title="Epetra_Import: This class builds an import object for efficient importing of off-processor elements.">Epetra_Import</a> object.  <br /></td></tr>
<tr class="separator:a88a69d5a64168c02fadfc6c55ecd5a1c inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c537c6cbcf366a986227496c6aa79ee inherit pub_methods_classEpetra__DistObject" id="r_a8c537c6cbcf366a986227496c6aa79ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__DistObject.html#a8c537c6cbcf366a986227496c6aa79ee">Export</a> (const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;A, const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> &amp;Exporter, <a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020f">Epetra_CombineMode</a> CombineMode, const <a class="el" href="classEpetra__OffsetIndex.html">Epetra_OffsetIndex</a> *Indexor=0)</td></tr>
<tr class="memdesc:a8c537c6cbcf366a986227496c6aa79ee inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports an <a class="el" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi-vectors, vectors and matrices in pa...">Epetra_DistObject</a> using the <a class="el" href="classEpetra__Export.html" title="Epetra_Export: This class builds an export object for efficient exporting of off-processor elements.">Epetra_Export</a> object.  <br /></td></tr>
<tr class="separator:a8c537c6cbcf366a986227496c6aa79ee inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00702a53a4a8142f249639d254e760cd inherit pub_methods_classEpetra__DistObject" id="r_a00702a53a4a8142f249639d254e760cd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__DistObject.html#a00702a53a4a8142f249639d254e760cd">Map</a> () const</td></tr>
<tr class="memdesc:a00702a53a4a8142f249639d254e760cd inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the address of the <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> for this multi-vector.  <br /></td></tr>
<tr class="separator:a00702a53a4a8142f249639d254e760cd inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2e2c38a27e224f15fce659e00fc9c0 inherit pub_methods_classEpetra__DistObject" id="r_aad2e2c38a27e224f15fce659e00fc9c0"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Comm</b> () const</td></tr>
<tr class="memdesc:aad2e2c38a27e224f15fce659e00fc9c0 inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the address of the <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> for this multi-vector. <br /></td></tr>
<tr class="separator:aad2e2c38a27e224f15fce659e00fc9c0 inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c1fa2bf7389cf67ea23d1e84343046 inherit pub_methods_classEpetra__DistObject" id="r_a04c1fa2bf7389cf67ea23d1e84343046"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>DistributedGlobal</b> () const</td></tr>
<tr class="memdesc:a04c1fa2bf7389cf67ea23d1e84343046 inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this multi-vector is distributed global, i.e., not local replicated. <br /></td></tr>
<tr class="separator:a04c1fa2bf7389cf67ea23d1e84343046 inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__Object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__Object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__Object.html">Epetra_Object</a></td></tr>
<tr class="memitem:a7676631aca0d619c4e8d3e877c2b87a2 inherit pub_methods_classEpetra__Object" id="r_a7676631aca0d619c4e8d3e877c2b87a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a7676631aca0d619c4e8d3e877c2b87a2">Epetra_Object</a> (int TracebackModeIn=-1, bool set_label=true)</td></tr>
<tr class="memdesc:a7676631aca0d619c4e8d3e877c2b87a2 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Constructor.  <br /></td></tr>
<tr class="separator:a7676631aca0d619c4e8d3e877c2b87a2 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf156d9c8874a2a455ec305826c7313f inherit pub_methods_classEpetra__Object" id="r_acf156d9c8874a2a455ec305826c7313f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#acf156d9c8874a2a455ec305826c7313f">Epetra_Object</a> (const char *const <a class="el" href="classEpetra__Object.html#a1910d1c04e70ac482f7e377b271f6c26">Label</a>, int TracebackModeIn=-1)</td></tr>
<tr class="memdesc:acf156d9c8874a2a455ec305826c7313f inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Constructor.  <br /></td></tr>
<tr class="separator:acf156d9c8874a2a455ec305826c7313f inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f8bd631f2a97276ea07cea8c9c7057 inherit pub_methods_classEpetra__Object" id="r_ac5f8bd631f2a97276ea07cea8c9c7057"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#ac5f8bd631f2a97276ea07cea8c9c7057">Epetra_Object</a> (const <a class="el" href="classEpetra__Object.html">Epetra_Object</a> &amp;Object)</td></tr>
<tr class="memdesc:ac5f8bd631f2a97276ea07cea8c9c7057 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Copy Constructor.  <br /></td></tr>
<tr class="separator:ac5f8bd631f2a97276ea07cea8c9c7057 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742c256d523738e458d0256f72ba9e4b inherit pub_methods_classEpetra__Object" id="r_a742c256d523738e458d0256f72ba9e4b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a742c256d523738e458d0256f72ba9e4b">~Epetra_Object</a> ()</td></tr>
<tr class="memdesc:a742c256d523738e458d0256f72ba9e4b inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Destructor.  <br /></td></tr>
<tr class="separator:a742c256d523738e458d0256f72ba9e4b inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff5c5266120410acbe6ccb63734b5c8 inherit pub_methods_classEpetra__Object" id="r_a9ff5c5266120410acbe6ccb63734b5c8"><td class="memItemLeft" align="right" valign="top">
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>ReportError</b> (const std::string Message, int ErrorCode) const</td></tr>
<tr class="memdesc:a9ff5c5266120410acbe6ccb63734b5c8 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error reporting method. <br /></td></tr>
<tr class="separator:a9ff5c5266120410acbe6ccb63734b5c8 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049c5235b19bd286f95914b547b9f528 inherit pub_methods_classEpetra__Object" id="r_a049c5235b19bd286f95914b547b9f528"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a049c5235b19bd286f95914b547b9f528">SetLabel</a> (const char *const <a class="el" href="classEpetra__Object.html#a1910d1c04e70ac482f7e377b271f6c26">Label</a>)</td></tr>
<tr class="memdesc:a049c5235b19bd286f95914b547b9f528 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Label definition using char *.  <br /></td></tr>
<tr class="separator:a049c5235b19bd286f95914b547b9f528 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__SrcDistObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__SrcDistObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a></td></tr>
<tr class="memitem:a9f7ce0515cfecef2d90543d0c572d3bc inherit pub_methods_classEpetra__SrcDistObject" id="r_a9f7ce0515cfecef2d90543d0c572d3bc"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_SrcDistObject</b> ()</td></tr>
<tr class="memdesc:a9f7ce0515cfecef2d90543d0c572d3bc inherit pub_methods_classEpetra__SrcDistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__SrcDistObject.html" title="Epetra_SrcDistObject: A class for supporting flexible source distributed objects for import/export op...">Epetra_SrcDistObject</a> destructor. <br /></td></tr>
<tr class="separator:a9f7ce0515cfecef2d90543d0c572d3bc inherit pub_methods_classEpetra__SrcDistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__CompObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__CompObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__CompObject.html">Epetra_CompObject</a></td></tr>
<tr class="memitem:a72d50bb3df3487828adb4d4b8f9a282b inherit pub_methods_classEpetra__CompObject" id="r_a72d50bb3df3487828adb4d4b8f9a282b"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_CompObject</b> ()</td></tr>
<tr class="memdesc:a72d50bb3df3487828adb4d4b8f9a282b inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic <a class="el" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes.">Epetra_CompObject</a> constuctor. <br /></td></tr>
<tr class="separator:a72d50bb3df3487828adb4d4b8f9a282b inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1109b4825ca8fa5043c57c83227c56 inherit pub_methods_classEpetra__CompObject" id="r_a3d1109b4825ca8fa5043c57c83227c56"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_CompObject</b> (const <a class="el" href="classEpetra__CompObject.html">Epetra_CompObject</a> &amp;Source)</td></tr>
<tr class="memdesc:a3d1109b4825ca8fa5043c57c83227c56 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes.">Epetra_CompObject</a> copy constructor. <br /></td></tr>
<tr class="separator:a3d1109b4825ca8fa5043c57c83227c56 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af670a39b6993246fe87fc4c4b9f00971 inherit pub_methods_classEpetra__CompObject" id="r_af670a39b6993246fe87fc4c4b9f00971"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_CompObject</b> ()</td></tr>
<tr class="memdesc:af670a39b6993246fe87fc4c4b9f00971 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes.">Epetra_CompObject</a> destructor. <br /></td></tr>
<tr class="separator:af670a39b6993246fe87fc4c4b9f00971 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665dd8befefacf0e5f188ea8a011bd80 inherit pub_methods_classEpetra__CompObject" id="r_a665dd8befefacf0e5f188ea8a011bd80"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetFlopCounter</b> (const <a class="el" href="classEpetra__Flops.html">Epetra_Flops</a> &amp;FlopCounter_in)</td></tr>
<tr class="memdesc:a665dd8befefacf0e5f188ea8a011bd80 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal <a class="el" href="classEpetra__Flops.html" title="Epetra_Flops: The Epetra Floating Point Operations Class.">Epetra_Flops()</a> pointer. <br /></td></tr>
<tr class="separator:a665dd8befefacf0e5f188ea8a011bd80 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac5e8ba25d3ff75dd93ee5d85f46c5b inherit pub_methods_classEpetra__CompObject" id="r_a0ac5e8ba25d3ff75dd93ee5d85f46c5b"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetFlopCounter</b> (const <a class="el" href="classEpetra__CompObject.html">Epetra_CompObject</a> &amp;CompObject)</td></tr>
<tr class="memdesc:a0ac5e8ba25d3ff75dd93ee5d85f46c5b inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal <a class="el" href="classEpetra__Flops.html" title="Epetra_Flops: The Epetra Floating Point Operations Class.">Epetra_Flops()</a> pointer to the flop counter of another <a class="el" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes.">Epetra_CompObject</a>. <br /></td></tr>
<tr class="separator:a0ac5e8ba25d3ff75dd93ee5d85f46c5b inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78028e410947150bba43f206d0c0b0ef inherit pub_methods_classEpetra__CompObject" id="r_a78028e410947150bba43f206d0c0b0ef"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UnsetFlopCounter</b> ()</td></tr>
<tr class="memdesc:a78028e410947150bba43f206d0c0b0ef inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal <a class="el" href="classEpetra__Flops.html" title="Epetra_Flops: The Epetra Floating Point Operations Class.">Epetra_Flops()</a> pointer to 0 (no flops counted). <br /></td></tr>
<tr class="separator:a78028e410947150bba43f206d0c0b0ef inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e1619549eb9d1b62a04172fedc77b7 inherit pub_methods_classEpetra__CompObject" id="r_a31e1619549eb9d1b62a04172fedc77b7"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classEpetra__Flops.html">Epetra_Flops</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetFlopCounter</b> () const</td></tr>
<tr class="memdesc:a31e1619549eb9d1b62a04172fedc77b7 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pointer to the <a class="el" href="classEpetra__Flops.html" title="Epetra_Flops: The Epetra Floating Point Operations Class.">Epetra_Flops()</a> object associated with this object, returns 0 if none. <br /></td></tr>
<tr class="separator:a31e1619549eb9d1b62a04172fedc77b7 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adff4c34d61377709fc8a17e99e3eae inherit pub_methods_classEpetra__CompObject" id="r_a4adff4c34d61377709fc8a17e99e3eae"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>ResetFlops</b> () const</td></tr>
<tr class="memdesc:a4adff4c34d61377709fc8a17e99e3eae inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the number of floating point operations to zero for <em>this</em> multi-vector. <br /></td></tr>
<tr class="separator:a4adff4c34d61377709fc8a17e99e3eae inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8326f0873a8866ac9f15f08f5ef31b0d inherit pub_methods_classEpetra__CompObject" id="r_a8326f0873a8866ac9f15f08f5ef31b0d"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><b>Flops</b> () const</td></tr>
<tr class="memdesc:a8326f0873a8866ac9f15f08f5ef31b0d inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of floating point operations with <em>this</em> multi-vector. <br /></td></tr>
<tr class="separator:a8326f0873a8866ac9f15f08f5ef31b0d inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac776bf8d9e68e57951ef766ec16e636b inherit pub_methods_classEpetra__CompObject" id="r_ac776bf8d9e68e57951ef766ec16e636b"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateFlops</b> (int Flops_in) const</td></tr>
<tr class="memdesc:ac776bf8d9e68e57951ef766ec16e636b inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment Flop count for <em>this</em> object. <br /></td></tr>
<tr class="separator:ac776bf8d9e68e57951ef766ec16e636b inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4373b39e384b424078818c6774ffb59a inherit pub_methods_classEpetra__CompObject" id="r_a4373b39e384b424078818c6774ffb59a"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateFlops</b> (long int Flops_in) const</td></tr>
<tr class="memdesc:a4373b39e384b424078818c6774ffb59a inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment Flop count for <em>this</em> object. <br /></td></tr>
<tr class="separator:a4373b39e384b424078818c6774ffb59a inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a2cf1d3a37d9e486edc64202ed42b2 inherit pub_methods_classEpetra__CompObject" id="r_a77a2cf1d3a37d9e486edc64202ed42b2"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateFlops</b> (long long Flops_in) const</td></tr>
<tr class="memdesc:a77a2cf1d3a37d9e486edc64202ed42b2 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment Flop count for <em>this</em> object. <br /></td></tr>
<tr class="separator:a77a2cf1d3a37d9e486edc64202ed42b2 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6480e644cf6c9a524ef839add22952 inherit pub_methods_classEpetra__CompObject" id="r_a4c6480e644cf6c9a524ef839add22952"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateFlops</b> (double Flops_in) const</td></tr>
<tr class="memdesc:a4c6480e644cf6c9a524ef839add22952 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment Flop count for <em>this</em> object. <br /></td></tr>
<tr class="separator:a4c6480e644cf6c9a524ef839add22952 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe126845543d91403abf3a50333fb891 inherit pub_methods_classEpetra__CompObject" id="r_abe126845543d91403abf3a50333fb891"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateFlops</b> (float Flops_in) const</td></tr>
<tr class="memdesc:abe126845543d91403abf3a50333fb891 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment Flop count for <em>this</em> object. <br /></td></tr>
<tr class="separator:abe126845543d91403abf3a50333fb891 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb8e33c7b18538fa0c088a1dfe1216f inherit pub_methods_classEpetra__CompObject" id="r_a8bb8e33c7b18538fa0c088a1dfe1216f"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classEpetra__CompObject.html">Epetra_CompObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classEpetra__CompObject.html">Epetra_CompObject</a> &amp;src)</td></tr>
<tr class="separator:a8bb8e33c7b18538fa0c088a1dfe1216f inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__BLAS"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__BLAS')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__BLAS.html">Epetra_BLAS</a></td></tr>
<tr class="memitem:a8e4e2d564543a813e06462a599ed5b88 inherit pub_methods_classEpetra__BLAS" id="r_a8e4e2d564543a813e06462a599ed5b88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__BLAS.html#a8e4e2d564543a813e06462a599ed5b88">Epetra_BLAS</a> (void)</td></tr>
<tr class="memdesc:a8e4e2d564543a813e06462a599ed5b88 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> Constructor.  <br /></td></tr>
<tr class="separator:a8e4e2d564543a813e06462a599ed5b88 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a2dc7741eea3b947a11280c0ad7ba3 inherit pub_methods_classEpetra__BLAS" id="r_a40a2dc7741eea3b947a11280c0ad7ba3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__BLAS.html#a40a2dc7741eea3b947a11280c0ad7ba3">Epetra_BLAS</a> (const <a class="el" href="classEpetra__BLAS.html">Epetra_BLAS</a> &amp;BLAS)</td></tr>
<tr class="memdesc:a40a2dc7741eea3b947a11280c0ad7ba3 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> Copy Constructor.  <br /></td></tr>
<tr class="separator:a40a2dc7741eea3b947a11280c0ad7ba3 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cd61f7e045c7a41d75e4b073b116e2 inherit pub_methods_classEpetra__BLAS" id="r_a65cd61f7e045c7a41d75e4b073b116e2"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_BLAS</b> (void)</td></tr>
<tr class="memdesc:a65cd61f7e045c7a41d75e4b073b116e2 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> Destructor. <br /></td></tr>
<tr class="separator:a65cd61f7e045c7a41d75e4b073b116e2 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6e26cf6efd99af2a0a5090b732fab8 inherit pub_methods_classEpetra__BLAS" id="r_a2b6e26cf6efd99af2a0a5090b732fab8"><td class="memItemLeft" align="right" valign="top">
float&#160;</td><td class="memItemRight" valign="bottom"><b>ASUM</b> (const int N, const float *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a2b6e26cf6efd99af2a0a5090b732fab8 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> one norm function (SASUM). <br /></td></tr>
<tr class="separator:a2b6e26cf6efd99af2a0a5090b732fab8 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b10dd77bd77ae08ee2d4f797ccb38c inherit pub_methods_classEpetra__BLAS" id="r_a98b10dd77bd77ae08ee2d4f797ccb38c"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><b>ASUM</b> (const int N, const double *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a98b10dd77bd77ae08ee2d4f797ccb38c inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> one norm function (DASUM). <br /></td></tr>
<tr class="separator:a98b10dd77bd77ae08ee2d4f797ccb38c inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146020f20aa38d12a13a0240f4bd4d89 inherit pub_methods_classEpetra__BLAS" id="r_a146020f20aa38d12a13a0240f4bd4d89"><td class="memItemLeft" align="right" valign="top">
float&#160;</td><td class="memItemRight" valign="bottom"><b>DOT</b> (const int N, const float *X, const float *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:a146020f20aa38d12a13a0240f4bd4d89 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> dot product function (SDOT). <br /></td></tr>
<tr class="separator:a146020f20aa38d12a13a0240f4bd4d89 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d29ddf22e2dbc8cc4aa15920112ba6f inherit pub_methods_classEpetra__BLAS" id="r_a5d29ddf22e2dbc8cc4aa15920112ba6f"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><b>DOT</b> (const int N, const double *X, const double *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:a5d29ddf22e2dbc8cc4aa15920112ba6f inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> dot product function (DDOT). <br /></td></tr>
<tr class="separator:a5d29ddf22e2dbc8cc4aa15920112ba6f inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b602d1308905182ead57a14ce94dc4c inherit pub_methods_classEpetra__BLAS" id="r_a2b602d1308905182ead57a14ce94dc4c"><td class="memItemLeft" align="right" valign="top">
float&#160;</td><td class="memItemRight" valign="bottom"><b>NRM2</b> (const int N, const float *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a2b602d1308905182ead57a14ce94dc4c inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> norm function (SNRM2). <br /></td></tr>
<tr class="separator:a2b602d1308905182ead57a14ce94dc4c inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3915137d4a88e64be1b3b6fff0ae0ba8 inherit pub_methods_classEpetra__BLAS" id="r_a3915137d4a88e64be1b3b6fff0ae0ba8"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><b>NRM2</b> (const int N, const double *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a3915137d4a88e64be1b3b6fff0ae0ba8 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> norm function (DNRM2). <br /></td></tr>
<tr class="separator:a3915137d4a88e64be1b3b6fff0ae0ba8 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132159d7d231a9a9e36e9175cc9faf09 inherit pub_methods_classEpetra__BLAS" id="r_a132159d7d231a9a9e36e9175cc9faf09"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SCAL</b> (const int N, const float ALPHA, float *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a132159d7d231a9a9e36e9175cc9faf09 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> vector scale function (SSCAL) <br /></td></tr>
<tr class="separator:a132159d7d231a9a9e36e9175cc9faf09 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9cf3e5a447112125294b8988fe50124 inherit pub_methods_classEpetra__BLAS" id="r_ae9cf3e5a447112125294b8988fe50124"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SCAL</b> (const int N, const double ALPHA, double *X, const int INCX=1) const</td></tr>
<tr class="memdesc:ae9cf3e5a447112125294b8988fe50124 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> vector scale function (DSCAL) <br /></td></tr>
<tr class="separator:ae9cf3e5a447112125294b8988fe50124 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f43b364ff5e3627f983fe435b222ea5 inherit pub_methods_classEpetra__BLAS" id="r_a7f43b364ff5e3627f983fe435b222ea5"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>COPY</b> (const int N, const float *X, float *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:a7f43b364ff5e3627f983fe435b222ea5 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> vector copy function (SCOPY) <br /></td></tr>
<tr class="separator:a7f43b364ff5e3627f983fe435b222ea5 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f36b71efee7fc61fb8a3d5c8ce0cf0 inherit pub_methods_classEpetra__BLAS" id="r_a93f36b71efee7fc61fb8a3d5c8ce0cf0"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>COPY</b> (const int N, const double *X, double *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:a93f36b71efee7fc61fb8a3d5c8ce0cf0 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> vector scale function (DCOPY) <br /></td></tr>
<tr class="separator:a93f36b71efee7fc61fb8a3d5c8ce0cf0 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6412c2b4a56fbe2d0bbe94cc7a65e5f8 inherit pub_methods_classEpetra__BLAS" id="r_a6412c2b4a56fbe2d0bbe94cc7a65e5f8"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>IAMAX</b> (const int N, const float *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a6412c2b4a56fbe2d0bbe94cc7a65e5f8 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> arg maximum of absolute value function (ISAMAX) <br /></td></tr>
<tr class="separator:a6412c2b4a56fbe2d0bbe94cc7a65e5f8 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5532e66d0bd32b6ca19871bc007b6e16 inherit pub_methods_classEpetra__BLAS" id="r_a5532e66d0bd32b6ca19871bc007b6e16"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>IAMAX</b> (const int N, const double *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a5532e66d0bd32b6ca19871bc007b6e16 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> arg maximum of absolute value function (IDAMAX) <br /></td></tr>
<tr class="separator:a5532e66d0bd32b6ca19871bc007b6e16 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05c457263f160300f80c638525a5e19 inherit pub_methods_classEpetra__BLAS" id="r_af05c457263f160300f80c638525a5e19"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>AXPY</b> (const int N, const float ALPHA, const float *X, float *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:af05c457263f160300f80c638525a5e19 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> vector update function (SAXPY) <br /></td></tr>
<tr class="separator:af05c457263f160300f80c638525a5e19 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3042fd0acc417128584ce36483dc079 inherit pub_methods_classEpetra__BLAS" id="r_ac3042fd0acc417128584ce36483dc079"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>AXPY</b> (const int N, const double ALPHA, const double *X, double *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:ac3042fd0acc417128584ce36483dc079 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> vector update function (DAXPY) <br /></td></tr>
<tr class="separator:ac3042fd0acc417128584ce36483dc079 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ad7f5429608aba90723eb46a426575 inherit pub_methods_classEpetra__BLAS" id="r_ae9ad7f5429608aba90723eb46a426575"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEMV</b> (const char TRANS, const int M, const int N, const float ALPHA, const float *A, const int LDA, const float *X, const float BETA, float *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:ae9ad7f5429608aba90723eb46a426575 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> matrix-vector multiply function (SGEMV) <br /></td></tr>
<tr class="separator:ae9ad7f5429608aba90723eb46a426575 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa69dbfc706abc19f3d441ffc07683c inherit pub_methods_classEpetra__BLAS" id="r_a0aa69dbfc706abc19f3d441ffc07683c"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEMV</b> (const char TRANS, const int M, const int N, const double ALPHA, const double *A, const int LDA, const double *X, const double BETA, double *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:a0aa69dbfc706abc19f3d441ffc07683c inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> matrix-vector multiply function (DGEMV) <br /></td></tr>
<tr class="separator:a0aa69dbfc706abc19f3d441ffc07683c inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c5f255a3a03f9d3fa87aaa6cfb92ec inherit pub_methods_classEpetra__BLAS" id="r_a95c5f255a3a03f9d3fa87aaa6cfb92ec"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEMM</b> (const char TRANSA, const char TRANSB, const int M, const int N, const int K, const float ALPHA, const float *A, const int LDA, const float *B, const int LDB, const float BETA, float *C, const int LDC) const</td></tr>
<tr class="memdesc:a95c5f255a3a03f9d3fa87aaa6cfb92ec inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> matrix-matrix multiply function (SGEMM) <br /></td></tr>
<tr class="separator:a95c5f255a3a03f9d3fa87aaa6cfb92ec inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf93b9ef6ee2782cbbdc1e2ac00b5a2e inherit pub_methods_classEpetra__BLAS" id="r_acf93b9ef6ee2782cbbdc1e2ac00b5a2e"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEMM</b> (const char TRANSA, const char TRANSB, const int M, const int N, const int K, const double ALPHA, const double *A, const int LDA, const double *B, const int LDB, const double BETA, double *C, const int LDC) const</td></tr>
<tr class="memdesc:acf93b9ef6ee2782cbbdc1e2ac00b5a2e inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> matrix-matrix multiply function (DGEMM) <br /></td></tr>
<tr class="separator:acf93b9ef6ee2782cbbdc1e2ac00b5a2e inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa11c3c601b27c400568a60596434b4 inherit pub_methods_classEpetra__BLAS" id="r_a8fa11c3c601b27c400568a60596434b4"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYMM</b> (const char SIDE, const char UPLO, const int M, const int N, const float ALPHA, const float *A, const int LDA, const float *B, const int LDB, const float BETA, float *C, const int LDC) const</td></tr>
<tr class="memdesc:a8fa11c3c601b27c400568a60596434b4 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> symmetric matrix-matrix multiply function (SSYMM) <br /></td></tr>
<tr class="separator:a8fa11c3c601b27c400568a60596434b4 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ca61221b2acf0befef968748c6bb80 inherit pub_methods_classEpetra__BLAS" id="r_ad1ca61221b2acf0befef968748c6bb80"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYMM</b> (const char SIDE, const char UPLO, const int M, const int N, const double ALPHA, const double *A, const int LDA, const double *B, const int LDB, const double BETA, double *C, const int LDC) const</td></tr>
<tr class="memdesc:ad1ca61221b2acf0befef968748c6bb80 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> matrix-matrix multiply function (DSYMM) <br /></td></tr>
<tr class="separator:ad1ca61221b2acf0befef968748c6bb80 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2dcbf05331765f0ddb661460390a6e inherit pub_methods_classEpetra__BLAS" id="r_add2dcbf05331765f0ddb661460390a6e"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>TRMM</b> (const char SIDE, const char UPLO, const char TRANSA, const char DIAG, const int M, const int N, const float ALPHA, const float *A, const int LDA, float *B, const int LDB) const</td></tr>
<tr class="memdesc:add2dcbf05331765f0ddb661460390a6e inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> triangular matrix-matrix multiply function (STRMM) <br /></td></tr>
<tr class="separator:add2dcbf05331765f0ddb661460390a6e inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65212f8eee6597c24722b7bf2d54168b inherit pub_methods_classEpetra__BLAS" id="r_a65212f8eee6597c24722b7bf2d54168b"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>TRMM</b> (const char SIDE, const char UPLO, const char TRANSA, const char DIAG, const int M, const int N, const double ALPHA, const double *A, const int LDA, double *B, const int LDB) const</td></tr>
<tr class="memdesc:a65212f8eee6597c24722b7bf2d54168b inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> triangular matrix-matrix multiply function (DTRMM) <br /></td></tr>
<tr class="separator:a65212f8eee6597c24722b7bf2d54168b inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd9f6cd122a04b0544b62f26761b885 inherit pub_methods_classEpetra__BLAS" id="r_a6fd9f6cd122a04b0544b62f26761b885"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYRK</b> (const char UPLO, const char TRANS, const int N, const int K, const float ALPHA, const float *A, const int LDA, const float BETA, float *C, const int LDC) const</td></tr>
<tr class="memdesc:a6fd9f6cd122a04b0544b62f26761b885 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eperta_BLAS symetric rank k funtion (ssyrk) <br /></td></tr>
<tr class="separator:a6fd9f6cd122a04b0544b62f26761b885 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a2d21fe184982d57544b23b66ba522 inherit pub_methods_classEpetra__BLAS" id="r_a97a2d21fe184982d57544b23b66ba522"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYRK</b> (const char UPLO, const char TRANS, const int N, const int K, const double ALPHA, const double *A, const int LDA, const double BETA, double *C, const int LDC) const</td></tr>
<tr class="memdesc:a97a2d21fe184982d57544b23b66ba522 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eperta_BLAS symetric rank k funtion (dsyrk) <br /></td></tr>
<tr class="separator:a97a2d21fe184982d57544b23b66ba522 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__RowMatrix"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__RowMatrix')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__RowMatrix.html">Epetra_RowMatrix</a></td></tr>
<tr class="memitem:a1888703e63626eb9caac41662d612538 inherit pub_methods_classEpetra__RowMatrix" id="r_a1888703e63626eb9caac41662d612538"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_RowMatrix</b> ()</td></tr>
<tr class="memdesc:a1888703e63626eb9caac41662d612538 inherit pub_methods_classEpetra__RowMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a1888703e63626eb9caac41662d612538 inherit pub_methods_classEpetra__RowMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__Operator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__Operator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__Operator.html">Epetra_Operator</a></td></tr>
<tr class="memitem:a7d987fbd72e3920a8043f7861df7d242 inherit pub_methods_classEpetra__Operator" id="r_a7d987fbd72e3920a8043f7861df7d242"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_Operator</b> ()</td></tr>
<tr class="memdesc:a7d987fbd72e3920a8043f7861df7d242 inherit pub_methods_classEpetra__Operator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a7d987fbd72e3920a8043f7861df7d242 inherit pub_methods_classEpetra__Operator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Data Structure Transformation Methods</h2></td></tr>
<tr class="memitem:a1993c84d22a01c716a27d6d0d296ea1f" id="r_a1993c84d22a01c716a27d6d0d296ea1f"><td class="memItemLeft" align="right" valign="top"><a id="a1993c84d22a01c716a27d6d0d296ea1f" name="a1993c84d22a01c716a27d6d0d296ea1f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>IsMatrixTransformed</b> () const</td></tr>
<tr class="memdesc:a1993c84d22a01c716a27d6d0d296ea1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the matrix has been reordered by tuning, and 0 if it has not been. <br /></td></tr>
<tr class="separator:a1993c84d22a01c716a27d6d0d296ea1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abece90b15bd86430eb8fd75d751462b0" id="r_abece90b15bd86430eb8fd75d751462b0"><td class="memItemLeft" align="right" valign="top"><a id="abece90b15bd86430eb8fd75d751462b0" name="abece90b15bd86430eb8fd75d751462b0"></a>
const <a class="el" href="classEpetra__OskiMatrix.html">Epetra_OskiMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ViewTransformedMat</b> () const</td></tr>
<tr class="memdesc:abece90b15bd86430eb8fd75d751462b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transformed version of InMat if InMat has been transformed. If InMat has not been transformed then the return will equal InMat. <br /></td></tr>
<tr class="separator:abece90b15bd86430eb8fd75d751462b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a38fd48f21b4ab2d8614a9e7935649" id="r_ab3a38fd48f21b4ab2d8614a9e7935649"><td class="memItemLeft" align="right" valign="top"><a id="ab3a38fd48f21b4ab2d8614a9e7935649" name="ab3a38fd48f21b4ab2d8614a9e7935649"></a>
const <a class="el" href="classEpetra__OskiPermutation.html">Epetra_OskiPermutation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ViewRowPermutation</b> () const</td></tr>
<tr class="memdesc:ab3a38fd48f21b4ab2d8614a9e7935649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read only row/left permutation of the Matrix. <br /></td></tr>
<tr class="separator:ab3a38fd48f21b4ab2d8614a9e7935649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89555e73d85cace1e8919593c6641546" id="r_a89555e73d85cace1e8919593c6641546"><td class="memItemLeft" align="right" valign="top"><a id="a89555e73d85cace1e8919593c6641546" name="a89555e73d85cace1e8919593c6641546"></a>
const <a class="el" href="classEpetra__OskiPermutation.html">Epetra_OskiPermutation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ViewColumnPermutation</b> () const</td></tr>
<tr class="memdesc:a89555e73d85cace1e8919593c6641546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read only column/right permutation of the Matrix. <br /></td></tr>
<tr class="separator:a89555e73d85cace1e8919593c6641546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66724e93091cee394e2aa65b16bc759" id="r_ab66724e93091cee394e2aa65b16bc759"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#ab66724e93091cee394e2aa65b16bc759">GetMatrixTransforms</a> () const</td></tr>
<tr class="memdesc:ab66724e93091cee394e2aa65b16bc759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string holding the transformations performed on the matrix when it was tuned.  <br /></td></tr>
<tr class="separator:ab66724e93091cee394e2aa65b16bc759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df7c051681c50e745e5f1cf8c55b694" id="r_a6df7c051681c50e745e5f1cf8c55b694"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__OskiMatrix.html#a6df7c051681c50e745e5f1cf8c55b694">ApplyMatrixTransforms</a> (const char *Transforms)</td></tr>
<tr class="memdesc:a6df7c051681c50e745e5f1cf8c55b694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the current data structure of the matrix with the one specified in Transforms.  <br /></td></tr>
<tr class="separator:a6df7c051681c50e745e5f1cf8c55b694"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classEpetra__Object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classEpetra__Object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classEpetra__Object.html">Epetra_Object</a></td></tr>
<tr class="memitem:a3e039dae700d04726e0e78d73b69e7f6 inherit pub_static_methods_classEpetra__Object" id="r_a3e039dae700d04726e0e78d73b69e7f6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a3e039dae700d04726e0e78d73b69e7f6">SetTracebackMode</a> (int TracebackModeValue)</td></tr>
<tr class="memdesc:a3e039dae700d04726e0e78d73b69e7f6 inherit pub_static_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the <a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> error traceback report mode.  <br /></td></tr>
<tr class="separator:a3e039dae700d04726e0e78d73b69e7f6 inherit pub_static_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20914bd9b7bb7278ab332415c77ba999 inherit pub_static_methods_classEpetra__Object" id="r_a20914bd9b7bb7278ab332415c77ba999"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><b>GetTracebackMode</b> ()</td></tr>
<tr class="memdesc:a20914bd9b7bb7278ab332415c77ba999 inherit pub_static_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the <a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> error report mode. <br /></td></tr>
<tr class="separator:a20914bd9b7bb7278ab332415c77ba999 inherit pub_static_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661d6081fb13e1b4a4350faa88808f38 inherit pub_static_methods_classEpetra__Object" id="r_a661d6081fb13e1b4a4350faa88808f38"><td class="memItemLeft" align="right" valign="top">
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetTracebackStream</b> ()</td></tr>
<tr class="memdesc:a661d6081fb13e1b4a4350faa88808f38 inherit pub_static_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the output stream for error reporting. <br /></td></tr>
<tr class="separator:a661d6081fb13e1b4a4350faa88808f38 inherit pub_static_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classEpetra__Object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classEpetra__Object')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classEpetra__Object.html">Epetra_Object</a></td></tr>
<tr class="memitem:abcc693a0058b9910543df8c4ae76e5d9 inherit pub_static_attribs_classEpetra__Object" id="r_abcc693a0058b9910543df8c4ae76e5d9"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><b>TracebackMode</b></td></tr>
<tr class="separator:abcc693a0058b9910543df8c4ae76e5d9 inherit pub_static_attribs_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classEpetra__CrsMatrix"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classEpetra__CrsMatrix')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a></td></tr>
<tr class="memitem:a76a3a7747be10c9a5f98becd999544ed inherit pro_methods_classEpetra__CrsMatrix" id="r_a76a3a7747be10c9a5f98becd999544ed"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Allocated</b> () const</td></tr>
<tr class="separator:a76a3a7747be10c9a5f98becd999544ed inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f8d7ef9e0b26bca0f697096fad5c97 inherit pro_methods_classEpetra__CrsMatrix" id="r_a21f8d7ef9e0b26bca0f697096fad5c97"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>SetAllocated</b> (bool Flag)</td></tr>
<tr class="separator:a21f8d7ef9e0b26bca0f697096fad5c97 inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01b0493094e38b7cafcbb6416d34ee8 inherit pro_methods_classEpetra__CrsMatrix" id="r_ad01b0493094e38b7cafcbb6416d34ee8"><td class="memItemLeft" align="right" valign="top">
double **&#160;</td><td class="memItemRight" valign="bottom"><b>Values</b> () const</td></tr>
<tr class="separator:ad01b0493094e38b7cafcbb6416d34ee8 inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503f5a5ba837c18e025f7bad039afcc7 inherit pro_methods_classEpetra__CrsMatrix" id="r_a503f5a5ba837c18e025f7bad039afcc7"><td class="memItemLeft" align="right" valign="top">
double *&#160;</td><td class="memItemRight" valign="bottom"><b>All_Values</b> () const</td></tr>
<tr class="separator:a503f5a5ba837c18e025f7bad039afcc7 inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d7e3ba7dab0f1b05838177a68c21b1 inherit pro_methods_classEpetra__CrsMatrix" id="r_aa2d7e3ba7dab0f1b05838177a68c21b1"><td class="memItemLeft" align="right" valign="top">
double *&#160;</td><td class="memItemRight" valign="bottom"><b>Values</b> (int LocalRow) const</td></tr>
<tr class="separator:aa2d7e3ba7dab0f1b05838177a68c21b1 inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d193402fbcdbbb9b6e9f6d8dcb2454 inherit pro_methods_classEpetra__CrsMatrix" id="r_ab3d193402fbcdbbb9b6e9f6d8dcb2454"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>InitializeDefaults</b> ()</td></tr>
<tr class="separator:ab3d193402fbcdbbb9b6e9f6d8dcb2454 inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad156334d119f1e9437a96edcf00fea68 inherit pro_methods_classEpetra__CrsMatrix" id="r_ad156334d119f1e9437a96edcf00fea68"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>Allocate</b> ()</td></tr>
<tr class="separator:ad156334d119f1e9437a96edcf00fea68 inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ebea0ddc5c63d3318b725efd87215c inherit pro_methods_classEpetra__CrsMatrix" id="r_a79ebea0ddc5c63d3318b725efd87215c"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>InsertValues</b> (int LocalRow, int NumEntries, double *Values, int *Indices)</td></tr>
<tr class="separator:a79ebea0ddc5c63d3318b725efd87215c inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421fbb486c436da859a5b73537a25769 inherit pro_methods_classEpetra__CrsMatrix" id="r_a421fbb486c436da859a5b73537a25769"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>InsertValues</b> (int LocalRow, int NumEntries, const double *Values, const int *Indices)</td></tr>
<tr class="separator:a421fbb486c436da859a5b73537a25769 inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d183c718dcf56d99a9a82a20e7dc8fc inherit pro_methods_classEpetra__CrsMatrix" id="r_a6d183c718dcf56d99a9a82a20e7dc8fc"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>InsertValues</b> (int LocalRow, int NumEntries, double *Values, long long *Indices)</td></tr>
<tr class="separator:a6d183c718dcf56d99a9a82a20e7dc8fc inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa616a5083eccea323ece1edd7c3a22e1 inherit pro_methods_classEpetra__CrsMatrix" id="r_aa616a5083eccea323ece1edd7c3a22e1"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>InsertValues</b> (int LocalRow, int NumEntries, const double *Values, const long long *Indices)</td></tr>
<tr class="separator:aa616a5083eccea323ece1edd7c3a22e1 inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc56a809b3c66efa1b30e91728745b35 inherit pro_methods_classEpetra__CrsMatrix" id="r_abc56a809b3c66efa1b30e91728745b35"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>InsertOffsetValues</b> (long long GlobalRow, int NumEntries, double *Values, int *Indices)</td></tr>
<tr class="separator:abc56a809b3c66efa1b30e91728745b35 inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126c8b1b2e6f6468216bfaed1e69fe2f inherit pro_methods_classEpetra__CrsMatrix" id="r_a126c8b1b2e6f6468216bfaed1e69fe2f"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>InsertOffsetValues</b> (long long GlobalRow, int NumEntries, const double *Values, const int *Indices)</td></tr>
<tr class="separator:a126c8b1b2e6f6468216bfaed1e69fe2f inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4599c5c919053ab96dcd9235901577e5 inherit pro_methods_classEpetra__CrsMatrix" id="r_a4599c5c919053ab96dcd9235901577e5"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>ReplaceOffsetValues</b> (long long GlobalRow, int NumEntries, const double *Values, const int *Indices)</td></tr>
<tr class="separator:a4599c5c919053ab96dcd9235901577e5 inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fa210a1be998142c2aca08e83d7127 inherit pro_methods_classEpetra__CrsMatrix" id="r_a73fa210a1be998142c2aca08e83d7127"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>SumIntoOffsetValues</b> (long long GlobalRow, int NumEntries, const double *Values, const int *Indices)</td></tr>
<tr class="separator:a73fa210a1be998142c2aca08e83d7127 inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1feab87646a914a56a8317bb3046d605 inherit pro_methods_classEpetra__CrsMatrix" id="r_a1feab87646a914a56a8317bb3046d605"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateImportVector</b> (int NumVectors) const</td></tr>
<tr class="separator:a1feab87646a914a56a8317bb3046d605 inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4657950a6bd62c110567b01e0225f45c inherit pro_methods_classEpetra__CrsMatrix" id="r_a4657950a6bd62c110567b01e0225f45c"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateExportVector</b> (int NumVectors) const</td></tr>
<tr class="separator:a4657950a6bd62c110567b01e0225f45c inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab209cfae9ec075aa8bf11fcd5b2bb1ba inherit pro_methods_classEpetra__CrsMatrix" id="r_ab209cfae9ec075aa8bf11fcd5b2bb1ba"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GeneralMV</b> (double *x, double *y) const</td></tr>
<tr class="separator:ab209cfae9ec075aa8bf11fcd5b2bb1ba inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2de7b233916f74f73d74ee33370792 inherit pro_methods_classEpetra__CrsMatrix" id="r_a7f2de7b233916f74f73d74ee33370792"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GeneralMTV</b> (double *x, double *y) const</td></tr>
<tr class="separator:a7f2de7b233916f74f73d74ee33370792 inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3819f4dc26bce51d493603391e454304 inherit pro_methods_classEpetra__CrsMatrix" id="r_a3819f4dc26bce51d493603391e454304"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GeneralMM</b> (double **X, int LDX, double **Y, int LDY, int NumVectors) const</td></tr>
<tr class="separator:a3819f4dc26bce51d493603391e454304 inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c57cf7aa84ce375bb3f56301edefaa1 inherit pro_methods_classEpetra__CrsMatrix" id="r_a5c57cf7aa84ce375bb3f56301edefaa1"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GeneralMTM</b> (double **X, int LDX, double **Y, int LDY, int NumVectors) const</td></tr>
<tr class="separator:a5c57cf7aa84ce375bb3f56301edefaa1 inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac8cc02c7dbcae2771bb2f4400580de inherit pro_methods_classEpetra__CrsMatrix" id="r_acac8cc02c7dbcae2771bb2f4400580de"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GeneralSV</b> (bool Upper, bool Trans, bool UnitDiagonal, double *x, double *y) const</td></tr>
<tr class="separator:acac8cc02c7dbcae2771bb2f4400580de inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e579198447b923b271324ef84c1f170 inherit pro_methods_classEpetra__CrsMatrix" id="r_a0e579198447b923b271324ef84c1f170"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GeneralSM</b> (bool Upper, bool Trans, bool UnitDiagonal, double **X, int LDX, double **Y, int LDY, int NumVectors) const</td></tr>
<tr class="separator:a0e579198447b923b271324ef84c1f170 inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563f265db06ce6c30be9ef6bca6ea18a inherit pro_methods_classEpetra__CrsMatrix" id="r_a563f265db06ce6c30be9ef6bca6ea18a"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetStaticGraph</b> (bool Flag)</td></tr>
<tr class="separator:a563f265db06ce6c30be9ef6bca6ea18a inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1ad7e5a043bb17d2fb8c5fe0246c8c inherit pro_methods_classEpetra__CrsMatrix" id="r_a4c1ad7e5a043bb17d2fb8c5fe0246c8c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a4c1ad7e5a043bb17d2fb8c5fe0246c8c">CheckSizes</a> (const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;A)</td></tr>
<tr class="memdesc:a4c1ad7e5a043bb17d2fb8c5fe0246c8c inherit pro_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the source and target (<em>this</em>) objects to be compared for compatibility, return nonzero if not.  <br /></td></tr>
<tr class="separator:a4c1ad7e5a043bb17d2fb8c5fe0246c8c inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d7caaff9052f0e76f6353cdb7a2575 inherit pro_methods_classEpetra__CrsMatrix" id="r_ae7d7caaff9052f0e76f6353cdb7a2575"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ae7d7caaff9052f0e76f6353cdb7a2575">CopyAndPermute</a> (const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;Source, int NumSameIDs, int NumPermuteIDs, int *PermuteToLIDs, int *PermuteFromLIDs, const <a class="el" href="classEpetra__OffsetIndex.html">Epetra_OffsetIndex</a> *Indexor, <a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020f">Epetra_CombineMode</a> CombineMode=<a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020fab9f6920de535f04ccfe34d670fa2c8a8">Zero</a>)</td></tr>
<tr class="memdesc:ae7d7caaff9052f0e76f6353cdb7a2575 inherit pro_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform ID copies and permutations that are on processor.  <br /></td></tr>
<tr class="separator:ae7d7caaff9052f0e76f6353cdb7a2575 inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71b92f5abf1d12848febf0f5615e1d0 inherit pro_methods_classEpetra__CrsMatrix" id="r_ab71b92f5abf1d12848febf0f5615e1d0"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>CopyAndPermuteCrsMatrix</b> (const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;A, int NumSameIDs, int NumPermuteIDs, int *PermuteToLIDs, int *PermuteFromLIDs, const <a class="el" href="classEpetra__OffsetIndex.html">Epetra_OffsetIndex</a> *Indexor, <a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020f">Epetra_CombineMode</a> CombineMode)</td></tr>
<tr class="separator:ab71b92f5abf1d12848febf0f5615e1d0 inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320df270db482955d275672cd42f3dba inherit pro_methods_classEpetra__CrsMatrix" id="r_a320df270db482955d275672cd42f3dba"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>CopyAndPermuteRowMatrix</b> (const <a class="el" href="classEpetra__RowMatrix.html">Epetra_RowMatrix</a> &amp;A, int NumSameIDs, int NumPermuteIDs, int *PermuteToLIDs, int *PermuteFromLIDs, const <a class="el" href="classEpetra__OffsetIndex.html">Epetra_OffsetIndex</a> *Indexor, <a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020f">Epetra_CombineMode</a> CombineMode)</td></tr>
<tr class="separator:a320df270db482955d275672cd42f3dba inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca07ab2127fcc6e011f342f75d57593 inherit pro_methods_classEpetra__CrsMatrix" id="r_a2ca07ab2127fcc6e011f342f75d57593"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a2ca07ab2127fcc6e011f342f75d57593">PackAndPrepare</a> (const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;Source, int NumExportIDs, int *ExportLIDs, int &amp;LenExports, char *&amp;Exports, int &amp;SizeOfPacket, int *Sizes, bool &amp;VarSizes, <a class="el" href="classEpetra__Distributor.html">Epetra_Distributor</a> &amp;Distor)</td></tr>
<tr class="memdesc:a2ca07ab2127fcc6e011f342f75d57593 inherit pro_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any packing or preparation required for call to <a class="el" href="classEpetra__DistObject.html#ab26ca2d3f9d20a850734f4af633e4135" title="Perform actual transfer (redistribution) of data across memory images, using Epetra_Distributor objec...">DoTransfer()</a>.  <br /></td></tr>
<tr class="separator:a2ca07ab2127fcc6e011f342f75d57593 inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc77171308612e405e1427aeff35ad27 inherit pro_methods_classEpetra__CrsMatrix" id="r_adc77171308612e405e1427aeff35ad27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#adc77171308612e405e1427aeff35ad27">UnpackAndCombine</a> (const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;Source, int NumImportIDs, int *ImportLIDs, int LenImports, char *Imports, int &amp;SizeOfPacket, <a class="el" href="classEpetra__Distributor.html">Epetra_Distributor</a> &amp;Distor, <a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020f">Epetra_CombineMode</a> CombineMode, const <a class="el" href="classEpetra__OffsetIndex.html">Epetra_OffsetIndex</a> *Indexor)</td></tr>
<tr class="memdesc:adc77171308612e405e1427aeff35ad27 inherit pro_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any unpacking and combining after call to <a class="el" href="classEpetra__DistObject.html#ab26ca2d3f9d20a850734f4af633e4135" title="Perform actual transfer (redistribution) of data across memory images, using Epetra_Distributor objec...">DoTransfer()</a>.  <br /></td></tr>
<tr class="separator:adc77171308612e405e1427aeff35ad27 inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394853bfa571b2b263b1960fa183421a inherit pro_methods_classEpetra__CrsMatrix" id="r_a394853bfa571b2b263b1960fa183421a"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>SortEntries</b> ()</td></tr>
<tr class="memdesc:a394853bfa571b2b263b1960fa183421a inherit pro_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort column entries, row-by-row, in ascending order. <br /></td></tr>
<tr class="separator:a394853bfa571b2b263b1960fa183421a inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22088b0640b16ec28ccad5279bfe0c3c inherit pro_methods_classEpetra__CrsMatrix" id="r_a22088b0640b16ec28ccad5279bfe0c3c"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Sorted</b> () const</td></tr>
<tr class="memdesc:a22088b0640b16ec28ccad5279bfe0c3c inherit pro_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="classEpetra__CrsMatrix.html#a394853bfa571b2b263b1960fa183421a" title="Sort column entries, row-by-row, in ascending order.">SortEntries()</a> has been called, this query returns true, otherwise it returns false. <br /></td></tr>
<tr class="separator:a22088b0640b16ec28ccad5279bfe0c3c inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce1aeb79ec41dae8dec0160dd857944 inherit pro_methods_classEpetra__CrsMatrix" id="r_a5ce1aeb79ec41dae8dec0160dd857944"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>MergeRedundantEntries</b> ()</td></tr>
<tr class="memdesc:a5ce1aeb79ec41dae8dec0160dd857944 inherit pro_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add entries that have the same column index. Remove redundant entries from list. <br /></td></tr>
<tr class="separator:a5ce1aeb79ec41dae8dec0160dd857944 inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae93e07d91b89d5db3680d92ac23f1b1 inherit pro_methods_classEpetra__CrsMatrix" id="r_aae93e07d91b89d5db3680d92ac23f1b1"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>NoRedundancies</b> () const</td></tr>
<tr class="memdesc:aae93e07d91b89d5db3680d92ac23f1b1 inherit pro_methods_classEpetra__CrsMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="classEpetra__CrsMatrix.html#a5ce1aeb79ec41dae8dec0160dd857944" title="Add entries that have the same column index. Remove redundant entries from list.">MergeRedundantEntries()</a> has been called, this query returns true, otherwise it returns false. <br /></td></tr>
<tr class="separator:aae93e07d91b89d5db3680d92ac23f1b1 inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92d5ce75169b14c7a2439671f7a7c01 inherit pro_methods_classEpetra__CrsMatrix" id="r_ac92d5ce75169b14c7a2439671f7a7c01"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeleteMemory</b> ()</td></tr>
<tr class="separator:ac92d5ce75169b14c7a2439671f7a7c01 inherit pro_methods_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classEpetra__DistObject"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classEpetra__DistObject')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classEpetra__DistObject.html">Epetra_DistObject</a></td></tr>
<tr class="memitem:ab26ca2d3f9d20a850734f4af633e4135 inherit pro_methods_classEpetra__DistObject" id="r_ab26ca2d3f9d20a850734f4af633e4135"><td class="memItemLeft" align="right" valign="top">
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>DoTransfer</b> (const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;A, <a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020f">Epetra_CombineMode</a> CombineMode, int NumSameIDs, int NumPermuteIDs, int NumRemoteIDs, int NumExportIDs, int *PermuteToLIDs, int *PermuteFromLIDs, int *RemoteLIDs, int *ExportLIDs, int &amp;LenExports, char *&amp;Exports, int &amp;LenImports, char *&amp;Imports, <a class="el" href="classEpetra__Distributor.html">Epetra_Distributor</a> &amp;Distor, bool DoReverse, const <a class="el" href="classEpetra__OffsetIndex.html">Epetra_OffsetIndex</a> *Indexor)</td></tr>
<tr class="memdesc:ab26ca2d3f9d20a850734f4af633e4135 inherit pro_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform actual transfer (redistribution) of data across memory images, using <a class="el" href="classEpetra__Distributor.html" title="Epetra_Distributor: The Epetra Gather/Scatter Setup Base Class.">Epetra_Distributor</a> object. <br /></td></tr>
<tr class="separator:ab26ca2d3f9d20a850734f4af633e4135 inherit pro_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classEpetra__Object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classEpetra__Object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classEpetra__Object.html">Epetra_Object</a></td></tr>
<tr class="memitem:a4e3832c165d22a45d3dd6fecd16d91f4 inherit pro_methods_classEpetra__Object" id="r_a4e3832c165d22a45d3dd6fecd16d91f4"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (const int &amp;x) const</td></tr>
<tr class="separator:a4e3832c165d22a45d3dd6fecd16d91f4 inherit pro_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3f57c8b22b5b0df91400fca8447ab2 inherit pro_methods_classEpetra__Object" id="r_aaa3f57c8b22b5b0df91400fca8447ab2"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (const long long &amp;x) const</td></tr>
<tr class="separator:aaa3f57c8b22b5b0df91400fca8447ab2 inherit pro_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a2fa958fffb21a0479a19956185be1 inherit pro_methods_classEpetra__Object" id="r_ab8a2fa958fffb21a0479a19956185be1"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (const double &amp;x) const</td></tr>
<tr class="separator:ab8a2fa958fffb21a0479a19956185be1 inherit pro_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classEpetra__CrsMatrix"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classEpetra__CrsMatrix')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a></td></tr>
<tr class="memitem:a59fbfbad01653ac93a38369ca037a08e inherit pro_attribs_classEpetra__CrsMatrix" id="r_a59fbfbad01653ac93a38369ca037a08e"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classEpetra__CrsGraph.html">Epetra_CrsGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Graph_</b></td></tr>
<tr class="separator:a59fbfbad01653ac93a38369ca037a08e inherit pro_attribs_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3673b82f04c1b3e4457baea80f493470 inherit pro_attribs_classEpetra__CrsMatrix" id="r_a3673b82f04c1b3e4457baea80f493470"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Allocated_</b></td></tr>
<tr class="separator:a3673b82f04c1b3e4457baea80f493470 inherit pro_attribs_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e08a89dbf7945a8edd8ecf68e8dd79 inherit pro_attribs_classEpetra__CrsMatrix" id="r_a59e08a89dbf7945a8edd8ecf68e8dd79"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>StaticGraph_</b></td></tr>
<tr class="separator:a59e08a89dbf7945a8edd8ecf68e8dd79 inherit pro_attribs_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8487adad53420a77f7ce14be4507622f inherit pro_attribs_classEpetra__CrsMatrix" id="r_a8487adad53420a77f7ce14be4507622f"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>UseTranspose_</b></td></tr>
<tr class="separator:a8487adad53420a77f7ce14be4507622f inherit pro_attribs_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b9418f09ff343981bbefaa0c1d0e86 inherit pro_attribs_classEpetra__CrsMatrix" id="r_a27b9418f09ff343981bbefaa0c1d0e86"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>constructedWithFilledGraph_</b></td></tr>
<tr class="separator:a27b9418f09ff343981bbefaa0c1d0e86 inherit pro_attribs_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b98c4dea73c9eeaebe3d035dcb8d71 inherit pro_attribs_classEpetra__CrsMatrix" id="r_a00b98c4dea73c9eeaebe3d035dcb8d71"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>matrixFillCompleteCalled_</b></td></tr>
<tr class="separator:a00b98c4dea73c9eeaebe3d035dcb8d71 inherit pro_attribs_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3383a9f29087fed2e6df5219af873968 inherit pro_attribs_classEpetra__CrsMatrix" id="r_a3383a9f29087fed2e6df5219af873968"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>StorageOptimized_</b></td></tr>
<tr class="separator:a3383a9f29087fed2e6df5219af873968 inherit pro_attribs_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e1710f0932d4e62b8c9314a992874c inherit pro_attribs_classEpetra__CrsMatrix" id="r_a03e1710f0932d4e62b8c9314a992874c"><td class="memItemLeft" align="right" valign="top">
double **&#160;</td><td class="memItemRight" valign="bottom"><b>Values_</b></td></tr>
<tr class="separator:a03e1710f0932d4e62b8c9314a992874c inherit pro_attribs_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bff2670bc455330439d96c9675499a8 inherit pro_attribs_classEpetra__CrsMatrix" id="r_a3bff2670bc455330439d96c9675499a8"><td class="memItemLeft" align="right" valign="top">
int *&#160;</td><td class="memItemRight" valign="bottom"><b>Values_alloc_lengths_</b></td></tr>
<tr class="separator:a3bff2670bc455330439d96c9675499a8 inherit pro_attribs_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0b3a09f81c822a223a9e0e3050cf40 inherit pro_attribs_classEpetra__CrsMatrix" id="r_a4d0b3a09f81c822a223a9e0e3050cf40"><td class="memItemLeft" align="right" valign="top">
double *&#160;</td><td class="memItemRight" valign="bottom"><b>All_Values_</b></td></tr>
<tr class="separator:a4d0b3a09f81c822a223a9e0e3050cf40 inherit pro_attribs_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1aacf4426f3f9f78645cab6bdf57b5 inherit pro_attribs_classEpetra__CrsMatrix" id="r_a4b1aacf4426f3f9f78645cab6bdf57b5"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><b>NormInf_</b></td></tr>
<tr class="separator:a4b1aacf4426f3f9f78645cab6bdf57b5 inherit pro_attribs_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f03247ff68ecf5913e0a69013b52b9f inherit pro_attribs_classEpetra__CrsMatrix" id="r_a6f03247ff68ecf5913e0a69013b52b9f"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><b>NormOne_</b></td></tr>
<tr class="separator:a6f03247ff68ecf5913e0a69013b52b9f inherit pro_attribs_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42178fe127320d9e66aff2d2acf0bc66 inherit pro_attribs_classEpetra__CrsMatrix" id="r_a42178fe127320d9e66aff2d2acf0bc66"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><b>NormFrob_</b></td></tr>
<tr class="separator:a42178fe127320d9e66aff2d2acf0bc66 inherit pro_attribs_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5c499906b0e460903337f65514fcf3 inherit pro_attribs_classEpetra__CrsMatrix" id="r_a7a5c499906b0e460903337f65514fcf3"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>NumMyRows_</b></td></tr>
<tr class="separator:a7a5c499906b0e460903337f65514fcf3 inherit pro_attribs_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef99a42b4be2c197bacdb96981bd7dbd inherit pro_attribs_classEpetra__CrsMatrix" id="r_aef99a42b4be2c197bacdb96981bd7dbd"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ImportVector_</b></td></tr>
<tr class="separator:aef99a42b4be2c197bacdb96981bd7dbd inherit pro_attribs_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf57758cf469305008be107e26080f98 inherit pro_attribs_classEpetra__CrsMatrix" id="r_aaf57758cf469305008be107e26080f98"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ExportVector_</b></td></tr>
<tr class="separator:aaf57758cf469305008be107e26080f98 inherit pro_attribs_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e06753b477e15d3414ee6c569540627 inherit pro_attribs_classEpetra__CrsMatrix" id="r_a3e06753b477e15d3414ee6c569540627"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CV_</b></td></tr>
<tr class="separator:a3e06753b477e15d3414ee6c569540627 inherit pro_attribs_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0b26411f90a324fc84d45856400c57 inherit pro_attribs_classEpetra__CrsMatrix" id="r_acb0b26411f90a324fc84d45856400c57"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>squareFillCompleteCalled_</b></td></tr>
<tr class="separator:acb0b26411f90a324fc84d45856400c57 inherit pro_attribs_classEpetra__CrsMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classEpetra__DistObject"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classEpetra__DistObject')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classEpetra__DistObject.html">Epetra_DistObject</a></td></tr>
<tr class="memitem:afe0876212b0bc64248080c7949cc2fe8 inherit pro_attribs_classEpetra__DistObject" id="r_afe0876212b0bc64248080c7949cc2fe8"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Map_</b></td></tr>
<tr class="separator:afe0876212b0bc64248080c7949cc2fe8 inherit pro_attribs_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b10439013b488908a69faf197b3720 inherit pro_attribs_classEpetra__DistObject" id="r_af6b10439013b488908a69faf197b3720"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Comm_</b></td></tr>
<tr class="separator:af6b10439013b488908a69faf197b3720 inherit pro_attribs_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55db06ab43cc8633cc98bda807b75052 inherit pro_attribs_classEpetra__DistObject" id="r_a55db06ab43cc8633cc98bda807b75052"><td class="memItemLeft" align="right" valign="top">
char *&#160;</td><td class="memItemRight" valign="bottom"><b>Exports_</b></td></tr>
<tr class="separator:a55db06ab43cc8633cc98bda807b75052 inherit pro_attribs_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c0a956075d9df8f96480a64695afef inherit pro_attribs_classEpetra__DistObject" id="r_ac2c0a956075d9df8f96480a64695afef"><td class="memItemLeft" align="right" valign="top">
char *&#160;</td><td class="memItemRight" valign="bottom"><b>Imports_</b></td></tr>
<tr class="separator:ac2c0a956075d9df8f96480a64695afef inherit pro_attribs_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa299778b21bd3310bfa8b91b1435f1d2 inherit pro_attribs_classEpetra__DistObject" id="r_aa299778b21bd3310bfa8b91b1435f1d2"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>LenExports_</b></td></tr>
<tr class="separator:aa299778b21bd3310bfa8b91b1435f1d2 inherit pro_attribs_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d50d714698b235360d6c9b8c457df4 inherit pro_attribs_classEpetra__DistObject" id="r_ab3d50d714698b235360d6c9b8c457df4"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>LenImports_</b></td></tr>
<tr class="separator:ab3d50d714698b235360d6c9b8c457df4 inherit pro_attribs_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9bc03c6fef4031fe9358c9e855e174 inherit pro_attribs_classEpetra__DistObject" id="r_a2a9bc03c6fef4031fe9358c9e855e174"><td class="memItemLeft" align="right" valign="top">
int *&#160;</td><td class="memItemRight" valign="bottom"><b>Sizes_</b></td></tr>
<tr class="separator:a2a9bc03c6fef4031fe9358c9e855e174 inherit pro_attribs_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classEpetra__CompObject"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classEpetra__CompObject')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classEpetra__CompObject.html">Epetra_CompObject</a></td></tr>
<tr class="memitem:a4095552501f59c9dc407185a4944759f inherit pro_attribs_classEpetra__CompObject" id="r_a4095552501f59c9dc407185a4944759f"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classEpetra__Flops.html">Epetra_Flops</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>FlopCounter_</b></td></tr>
<tr class="separator:a4095552501f59c9dc407185a4944759f inherit pro_attribs_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classEpetra__OskiMatrix.html" title="Epetra_OskiMatrix: A class for constructing and using OSKI Matrices within Epetra....">Epetra_OskiMatrix</a>: A class for constructing and using OSKI Matrices within Epetra. For information on known issues with OSKI see the detailed description. </p>
<p>OSKI is a high-performance sparse matrix kernel package written by the UC Berkeley Benchmarking and Optimization Group. The <a class="el" href="classEpetra__OskiMatrix.html" title="Epetra_OskiMatrix: A class for constructing and using OSKI Matrices within Epetra....">Epetra_OskiMatrix</a> class is a lightweight interface to allow Epetra users access to OSKI functionality. This interface includes lightweight conversion of Epetra matrices to OSKI matrices, runtime tuning based on parameter list hints, and access to high-performance computational kernels to perform matrix-vector/matrix multi-vector calculations.</p>
<p>The <a class="el" href="classEpetra__OskiMatrix.html" title="Epetra_OskiMatrix: A class for constructing and using OSKI Matrices within Epetra....">Epetra_OskiMatrix</a> class provides access to the entire OSKI interface. However, the following features are not fully implemented in OSKI version oski-1.0.1h, and therefore are unsupported in the <a class="el" href="classEpetra__OskiMatrix.html" title="Epetra_OskiMatrix: A class for constructing and using OSKI Matrices within Epetra....">Epetra_OskiMatrix</a> class:</p>
<ul>
<li>OSKI does not provide stock composed kernels. Hence, the tune function must be called in order to see performance gains when using the MatTransMatMultiply and MultiplyAndMatTransMultiply kernels.</li>
<li>The MatPowMultiply kernel does not work.</li>
<li>Optimized multivector kernels are not created by default when installing OSKI.</li>
<li>The tune function cannot transform a (nearly) symmetric matrix to be stored as such.</li>
<li>In order to use the <picture><source srcset="form_8_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$A^TA$" src="form_8.png" width="28" height="11"/></picture> OSKI kernel (MatTransMatMultiply), in oski/src/MBCSR/ata.c you must replace the lines <div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *kernel_name = (opA == OP_AT_A)</div>
<div class="line">   ? <span class="stringliteral">&quot;SubmatRperTransSubmatRperMult&quot;</span> : <span class="stringliteral">&quot;SubmatRperHermSubmatRperMult&quot;</span>;</div>
</div><!-- fragment --> with <div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *kernel_name = (opA == OP_AT_A)</div>
<div class="line">   ? <span class="stringliteral">&quot;SubmatReprTransSubmatReprMult&quot;</span> : <span class="stringliteral">&quot;SubmatReprHermSubmatReprMult&quot;</span>;</div>
</div><!-- fragment --></li>
<li>OSKI does not convert between CSR and CSC when it could be profitable, such as when performing <picture><source srcset="form_9_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$AA^T$" src="form_9.png" width="28" height="11"/></picture> on a CSR matrix.</li>
<li>OSKI may be incompatible with the following architectures:<ul>
<li>Barcelona (quad-core Opteron): errors during "make install" (confirmed with OSKI developers)</li>
<li>single core Xeon: OSKI installs, but never transforms matrices. This includes cases where other machines will transform the same matrices, and where one would expect the matrix to be transformed, based on OSKI tuning data. </li>
</ul>
</li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac44a60151a8f228b93a425efba414307" name="ac44a60151a8f228b93a425efba414307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44a60151a8f228b93a425efba414307">&#9670;&#160;</a></span>Epetra_OskiMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_OskiMatrix::Epetra_OskiMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>Source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>List</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor creates an <a class="el" href="classEpetra__OskiMatrix.html" title="Epetra_OskiMatrix: A class for constructing and using OSKI Matrices within Epetra....">Epetra_OskiMatrix</a> from an <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Source</td><td>(In) An <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> that is to be wrapped as an <a class="el" href="classEpetra__OskiMatrix.html" title="Epetra_OskiMatrix: A class for constructing and using OSKI Matrices within Epetra....">Epetra_OskiMatrix</a>. </td></tr>
    <tr><td class="paramname">List</td><td>(In) Any options or data wanted or needed for the conversion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to an <a class="el" href="classEpetra__OskiMatrix.html" title="Epetra_OskiMatrix: A class for constructing and using OSKI Matrices within Epetra....">Epetra_OskiMatrix</a>.</dd></dl>
<p>Options that can be passed to the List are presented below. They are: "&lt;type&gt; &lt;option name&gt; &lt;default value&gt;: &lt;description of purpose&gt;"</p>
<ul>
<li>bool autotune false: If true, Epetra tries to set as many hints as possible based on its knowledge of the matrix.</li>
</ul>
<p>string matrixtype general: Other types that can be taken are: uppertri, lowertri, uppersymm, lowersymm, fullsymm, upperherm, lowerherm and fullherm.</p><ul>
<li>bool diagstored false: If true, the diagonal entries are not stored in the matrix and are all assumed to be 1.</li>
</ul>
<p>bool zerobased false: If true, the array is zero based, as in C. Otherwise, it is 1 based, as in Fortran.</p><ul>
<li>bool sorted false: If true, all elements in the passed in array are sorted.</li>
<li>bool unique false: If true, a value in a column only appears once in each row.</li>
<li>bool deepcopy false: If true, when the OSKI matrix is created it will be a deepcopy of the data in the function. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6df7c051681c50e745e5f1cf8c55b694" name="a6df7c051681c50e745e5f1cf8c55b694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df7c051681c50e745e5f1cf8c55b694">&#9670;&#160;</a></span>ApplyMatrixTransforms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::ApplyMatrixTransforms </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>Transforms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the current data structure of the matrix with the one specified in Transforms. </p>
<p>If a previously tuned copy of the Matrix existed it is now replaced by one specified in Transforms. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Transforms</td><td>(In) A string that holds the transformations to be applied to the matrix. If Transforms is NULL or the empty string then no changes to the data structure are made. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the transformation was successful 0 is returned. Otherwise an error code is returned. </dd></dl>

</div>
</div>
<a id="afe8d003780d497d0bc93c7b5ce13ca2c" name="afe8d003780d497d0bc93c7b5ce13ca2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8d003780d497d0bc93c7b5ce13ca2c">&#9670;&#160;</a></span>ExtractDiagonalCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::ExtractDiagonalCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>Diagonal</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the main diagonal in a user-provided vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Diagonal</td><td>- (Out) Extracted main diagonal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful and non-zero if not. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged. </dd></dl>

<p>Reimplemented from <a class="el" href="classEpetra__CrsMatrix.html#ae89f6150eed2c4be33c69bae6ac0a99f">Epetra_CrsMatrix</a>.</p>

</div>
</div>
<a id="ab66724e93091cee394e2aa65b16bc759" name="ab66724e93091cee394e2aa65b16bc759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66724e93091cee394e2aa65b16bc759">&#9670;&#160;</a></span>GetMatrixTransforms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * Epetra_OskiMatrix::GetMatrixTransforms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string holding the transformations performed on the matrix when it was tuned. </p>
<dl class="section return"><dt>Returns</dt><dd>Upon success returns a newly-allocated string that stores the transformations applied to the matrix during tuning. NULL is returned upon an error. It is the users responsibility to deallocate the returned string. </dd></dl>

</div>
</div>
<a id="a9cbd13e61ec5df6a2451f4879264aef0" name="a9cbd13e61ec5df6a2451f4879264aef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbd13e61ec5df6a2451f4879264aef0">&#9670;&#160;</a></span>MatPowMultiply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::MatPowMultiply </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Power</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Alpha</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Beta</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a matrix vector multiply of y = Alpha*(this^TransA)^Power*x + Beta*y. This is not implemented as described in the detailed description. </p>
<p>The vectors x and y can be either Epetra_Vectors or Epetra_OskiVectors. The vector T can be either an <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> or <a class="el" href="classEpetra__OskiMultiVector.html" title="Epetra_OskiMultiVector: A class for constructing and using dense Oski multi-vectors on a single proce...">Epetra_OskiMultiVector</a>. This composed routine is used in power and S-step methods. This routine is not implemented due a bug in the oski-1.01h kernel that makes testing of correctness impossible. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TransA</td><td>(In) If TransA = TRUE then use the transpose of the matrix in computing the product. </td></tr>
    <tr><td class="paramname">x</td><td>(In) The vector the matrix is multiplied by. </td></tr>
    <tr><td class="paramname">y</td><td>(In/Out) The vector where the calculation result is stored. </td></tr>
    <tr><td class="paramname">T</td><td>(Out) The multi-vector where the result of each subsequent multiplication this*x ... this^(Power-1)*x is stored. </td></tr>
    <tr><td class="paramname">Power</td><td>(In) The power to raise the matrix to in the calculation. </td></tr>
    <tr><td class="paramname">Alpha</td><td>(In) A scalar constant used to scale x. </td></tr>
    <tr><td class="paramname">Beta</td><td>(In) A scalar constant used to scale y. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged </dd></dl>

</div>
</div>
<a id="a27d2e116142f0ae610a5381959e0aadc" name="a27d2e116142f0ae610a5381959e0aadc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d2e116142f0ae610a5381959e0aadc">&#9670;&#160;</a></span>MatPowMultiply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::MatPowMultiply </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Power</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Alpha</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Beta</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a matrix vector multiply of y = Alpha*(this^TransA)^Power*x + Beta*y. This is not implemented as described in the detailed description. </p>
<p>The vectors x and y can be either Epetra_Vectors or Epetra_OskiVectors. This composed routine is used in power and S-step methods. This routine is not implemented due a bug in the oski-1.01h kernel that makes testing of correctness impossible. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TransA</td><td>(In) If TransA = TRUE then use the transpose of the matrix in computing the product. </td></tr>
    <tr><td class="paramname">x</td><td>(In) The vector the matrix is multiplied by. </td></tr>
    <tr><td class="paramname">y</td><td>(In/Out) The vector where the calculation result is stored. </td></tr>
    <tr><td class="paramname">Power</td><td>(In) The power to raise the matrix to in the calculation. </td></tr>
    <tr><td class="paramname">Alpha</td><td>(In) A scalar constant used to scale x. </td></tr>
    <tr><td class="paramname">Beta</td><td>(In) A scalar constant used to scale y. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged </dd></dl>

</div>
</div>
<a id="aa4082a9a243ef4eaefb72354130d0ef4" name="aa4082a9a243ef4eaefb72354130d0ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4082a9a243ef4eaefb72354130d0ef4">&#9670;&#160;</a></span>MatTransMatMultiply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::MatTransMatMultiply </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ATA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Alpha</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Beta</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs two matrix multi-vector multiplies of Y = Alpha*this^TransA*this*X + Beta*Y or Y = Alpha*this*this^TransA*X + Beta*Y. </p>
<p>The multi-vectors X, Y and T can be either Epetra_MultiVectors or Epetra_OskiMultiVectors. This composed routine is most commonly used in linear least squares and bidiagonalization methods. The parallel version of Y = Alpha*this*this^TransA*X + Beta*Y uses calls to the Multiply routine under the hood, as it is not possible to perform both multiplies automatically. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ATA</td><td>(In) If TransA = TRUE then compute this^T*this*X otherwise compute this*this^T*X. </td></tr>
    <tr><td class="paramname">X</td><td>(In) The vector the matrix is multiplied by. </td></tr>
    <tr><td class="paramname">Y</td><td>(In/Out) The vector where the calculation result is stored. </td></tr>
    <tr><td class="paramname">T</td><td>(Out) The multi-vector where the result of the this*X is stored if TransA = true and this^T*X is stored otherwise. </td></tr>
    <tr><td class="paramname">Alpha</td><td>(In) A scalar constant used to scale X. </td></tr>
    <tr><td class="paramname">Beta</td><td>(In) A scalar constant used to scale Y. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged </dd></dl>

</div>
</div>
<a id="adc866fcba5d81ff9cc0295682d891ffd" name="adc866fcba5d81ff9cc0295682d891ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc866fcba5d81ff9cc0295682d891ffd">&#9670;&#160;</a></span>MatTransMatMultiply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::MatTransMatMultiply </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ATA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Alpha</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Beta</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs two matrix vector multiplies of y = Alpha*this^TransA*this*x + Beta*y or y = Alpha*this*this^TransA*x + Beta*y. </p>
<p>The vectors x, y and t can be either Epetra_Vectors or Epetra_OskiVectors. This composed routine is most commonly used in linear least squares and bidiagonalization methods. The parallel version of y = Alpha*this*this^TransA*x + Beta*y uses calls to the Multiply routine under the hood, as it is not possible to perform both multiplies automatically. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ATA</td><td>(In) If TransA = TRUE then compute this^T*this*x otherwise compute this*this^T*x. </td></tr>
    <tr><td class="paramname">x</td><td>(In) The vector the matrix is multiplied by. </td></tr>
    <tr><td class="paramname">y</td><td>(In/Out) The vector where the calculation result is stored. </td></tr>
    <tr><td class="paramname">t</td><td>(Out) The vector where the result of the this*x is stored if TransA = true and this^T*x is stored otherwise. </td></tr>
    <tr><td class="paramname">Alpha</td><td>(In) A scalar constant used to scale x. </td></tr>
    <tr><td class="paramname">Beta</td><td>(In) A scalar constant used to scale y. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged </dd></dl>

</div>
</div>
<a id="ac000bc93d45717f12893b5921d01ac93" name="ac000bc93d45717f12893b5921d01ac93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac000bc93d45717f12893b5921d01ac93">&#9670;&#160;</a></span>Multiply() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::Multiply </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a matrix multi-vector multiply of Y = this^TransA*X. </p>
<p>The multi-vectors X and Y can be either Epetra_MultiVectors or Epetra_OskiMultiVectors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TransA</td><td>(In) If Trans = TRUE then use the transpose of the matrix in computing the product. </td></tr>
    <tr><td class="paramname">X</td><td>(In) The multi-vector the matrix is multiplied by. </td></tr>
    <tr><td class="paramname">Y</td><td>(Out) The multi-vector where the calculation result is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged </dd></dl>

<p>Reimplemented from <a class="el" href="classEpetra__CrsMatrix.html#a1c523205afded500fd81375483029fe6">Epetra_CrsMatrix</a>.</p>

</div>
</div>
<a id="a59881beeff02a1ed3d0a6df41d5442a2" name="a59881beeff02a1ed3d0a6df41d5442a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59881beeff02a1ed3d0a6df41d5442a2">&#9670;&#160;</a></span>Multiply() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::Multiply </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Beta</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a matrix multi-vector multiply of Y = Alpha*this^TransA*X + Beta*Y. </p>
<p>The multi-vectors X and Y can be either Epetra_MultiVectors or Epetra_OskiMultiVectors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TransA</td><td>(In) If Trans = TRUE then use the transpose of the matrix in computing the product. </td></tr>
    <tr><td class="paramname">X</td><td>(In) The multi-vector the matrix is multiplied by. </td></tr>
    <tr><td class="paramname">Y</td><td>(In/Out) The multi-vector where the calculation result is stored. </td></tr>
    <tr><td class="paramname">Alpha</td><td>(In) A scalar constant used to scale X. </td></tr>
    <tr><td class="paramname">Beta</td><td>(In) A scalar constant used to scale Y. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged </dd></dl>

</div>
</div>
<a id="a2f6d5086d176738f4c5f09a8dfaa4a69" name="a2f6d5086d176738f4c5f09a8dfaa4a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f6d5086d176738f4c5f09a8dfaa4a69">&#9670;&#160;</a></span>Multiply() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::Multiply </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a matrix vector multiply of y = this^TransA*x. </p>
<p>The vectors x and y can be either Epetra_Vectors or Epetra_OskiVectors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TransA</td><td>(In) If TransA = TRUE then use the transpose of the matrix in computing the product. </td></tr>
    <tr><td class="paramname">x</td><td>(In) The vector the matrix is multiplied by. </td></tr>
    <tr><td class="paramname">y</td><td>(Out) The vector where the calculation result is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged </dd></dl>

</div>
</div>
<a id="a6600118e669a8383fd24fdfaaf9a95c7" name="a6600118e669a8383fd24fdfaaf9a95c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6600118e669a8383fd24fdfaaf9a95c7">&#9670;&#160;</a></span>Multiply() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::Multiply </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Beta</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a matrix vector multiply of y = Alpha*this^TransA*x + Beta*y. </p>
<p>The vectors x and y can be either Epetra_Vectors or Epetra_OskiVectors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TransA</td><td>(In) If TransA = TRUE then use the transpose of the matrix in computing the product. </td></tr>
    <tr><td class="paramname">x</td><td>(In) The vector the matrix is multiplied by. </td></tr>
    <tr><td class="paramname">y</td><td>(In/Out) The vector where the calculation result is stored. </td></tr>
    <tr><td class="paramname">Alpha</td><td>(In) A scalar constant used to scale x. </td></tr>
    <tr><td class="paramname">Beta</td><td>(In) A scalar constant used to scale y. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged </dd></dl>

</div>
</div>
<a id="abe5157f31307b78d5cb6110105405b87" name="abe5157f31307b78d5cb6110105405b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5157f31307b78d5cb6110105405b87">&#9670;&#160;</a></span>MultiplyAndMatTransMultiply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::MultiplyAndMatTransMultiply </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Alpha</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Beta</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Omega</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Zeta</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the two matrix multi-vector multiplies of Y = Alpha*this*X + Beta*Y and Z = Omega*this^TransA*W + Zeta*Z. </p>
<p>The multi-vectors X, Y, W and Z can be either Epetra_MultiVectors or Epetra_OskiMultiVectors. This composed routine is most commonly used in bi-conjugate gradient calculations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TransA</td><td>(In) If TransA = TRUE then use the transpose of the matrix in computing the second product. </td></tr>
    <tr><td class="paramname">X</td><td>(In) A multi-vector the matrix is multiplied by. </td></tr>
    <tr><td class="paramname">Y</td><td>(In/Out) A multi-vector where the calculation result of the first multiply is stored. </td></tr>
    <tr><td class="paramname">W</td><td>(In) A multi-vector the matrix is multiplied by. </td></tr>
    <tr><td class="paramname">Z</td><td>(In/Out) A multi-vector where the calculation result of the second multiply is stored. </td></tr>
    <tr><td class="paramname">Alpha</td><td>(In) A scalar constant used to scale X. </td></tr>
    <tr><td class="paramname">Beta</td><td>(In) A scalar constant used to scale Y. </td></tr>
    <tr><td class="paramname">Omega</td><td>(In) A scalar constant used to scale W. </td></tr>
    <tr><td class="paramname">Zeta</td><td>(In) A scalar constant used to scale Z. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged </dd></dl>

</div>
</div>
<a id="a43bc42d2e7700e683bdf4a26f17cc9b7" name="a43bc42d2e7700e683bdf4a26f17cc9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43bc42d2e7700e683bdf4a26f17cc9b7">&#9670;&#160;</a></span>MultiplyAndMatTransMultiply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::MultiplyAndMatTransMultiply </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Alpha</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Beta</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Omega</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Zeta</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the two matrix vector multiplies of y = Alpha*this*x + Beta*y and z = Omega*this^TransA*w + Zeta*z. </p>
<p>The vectors x, y, w and z can be either Epetra_Vectors or Epetra_OskiVectors. This composed routine is most commonly used in bi-conjugate gradient calculations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TransA</td><td>(In) If TransA = TRUE then use the transpose of the matrix in computing the second product. </td></tr>
    <tr><td class="paramname">x</td><td>(In) A vector the matrix is multiplied by. </td></tr>
    <tr><td class="paramname">y</td><td>(In/Out) A vector where the calculation result of the first multiply is stored. </td></tr>
    <tr><td class="paramname">w</td><td>(In) A vector the matrix is multiplied by. </td></tr>
    <tr><td class="paramname">z</td><td>(In/Out) A vector where the calculation result of the second multiply is stored. </td></tr>
    <tr><td class="paramname">Alpha</td><td>(In) A scalar constant used to scale x. </td></tr>
    <tr><td class="paramname">Beta</td><td>(In) A scalar constant used to scale y. </td></tr>
    <tr><td class="paramname">Omega</td><td>(In) A scalar constant used to scale w. </td></tr>
    <tr><td class="paramname">Zeta</td><td>(In) A scalar constant used to scale z. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged </dd></dl>

</div>
</div>
<a id="a239ea34f07aa866de0d7e147ef855c86" name="a239ea34f07aa866de0d7e147ef855c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239ea34f07aa866de0d7e147ef855c86">&#9670;&#160;</a></span>ReplaceDiagonalValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::ReplaceDiagonalValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__OskiVector.html">Epetra_OskiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Diagonal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces diagonal values of the matrix with those in the user-provided vector. </p>
<p>This routine is meant to allow replacement of {\bf existing} diagonal values. If a diagonal value does not exist for a given row, the corresponding value in the input <a class="el" href="classEpetra__OskiVector.html" title="Epetra_OskiVector: A class for constructing and using dense OSKI vectors on a single processor or a s...">Epetra_OskiVector</a> will be ignored, and the return code will be set to 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Diagonal</td><td>- (In) New values to be placed in the main diagonal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful, set to 1 on the calling processor if one or more diagonal entries not present in matrix. Other error codes can be returned as well, indicating improperly constructed matrices or vectors. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Diagonal values have been replaced with the values of Diagonal. </dd></dl>

</div>
</div>
<a id="a9a84a63df971df7916e0fdbcb93e57e2" name="a9a84a63df971df7916e0fdbcb93e57e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a84a63df971df7916e0fdbcb93e57e2">&#9670;&#160;</a></span>ReplaceMyValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::ReplaceMyValues </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MyRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace current values with this list of entries for a given local row of the matrix. Warning this could be expensive. </p>
<p>The reason this function could be expensive is its underlying implementation. Both the OSKI and Epetra versions of the matrix must be changed when the matrix has been permuted. When this is the case, a call must be made to the Epetra ReplaceMyValues, and NumEntries calls must be made to a function that changes the OSKI matrix's values one at a time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MyRow</td><td>(In) Row number (in local coordinates) to put elements. </td></tr>
    <tr><td class="paramname">NumEntries</td><td>(In) Number of entries. </td></tr>
    <tr><td class="paramname">Values</td><td>(In) Values to enter. </td></tr>
    <tr><td class="paramname">Indices</td><td>(In) Local column indices corresponding to the values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. Note that if the allocated length of the row has to be expanded, Oski will fail. A positive warning code may be returned, but this should be treated as a fatal error; part of the data will be changed, and OSKI cannot support adding in new data values. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#aae10c5b74759484342ed40ced9561f49" title="If matrix indices has been transformed to local, this query returns true, otherwise it returns false.">IndicesAreLocal()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The given Values at the given Indices have been summed into the entries of MyRow. </dd></dl>

</div>
</div>
<a id="a2cdb2a4883683ed6e17166e00f1be37d" name="a2cdb2a4883683ed6e17166e00f1be37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cdb2a4883683ed6e17166e00f1be37d">&#9670;&#160;</a></span>SetHint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::SetHint </td>
          <td>(</td>
          <td class="paramtype">const Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>List</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the hints in List in the matrix structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">List</td><td>(In) A list of hints and options to register along with the matrix used for tuning purposes. The full list is given below. It may be moved to the user guide in the future. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On successful storage of the hint 0 is returned. On failure an error code is returned.</dd></dl>
<p>Options that can be passed to the List are presented below. They are: "&lt;type&gt; &lt;option name&gt;: &lt;description of purpose&gt;". The available hints are grouped by section, and only one hint from each section can be true for a given matrix. For options where multiple arguments can be passed in at once the interface only supports up to 5. This means only 5 block sizes or 5 diaganols can be passed in at once. If you have more changing the code to support your needs should be simple, but every case you use must be enumerated. Of course you can just say there are diagonals and blocks and not pass in specific sizes as wells. </p><pre class="fragment">    - bool noblocks: If true, the matrix has no block structure
    - bool singleblocksize: If true, the matrix structure is dominated by blocks of the size of the next two parameters.
          - int row: The number of rows in each block.
          - int col: The number of columns in each block.
    - bool multipleblocksize: If true, the matrix consists of multiple block sizes.  The next 3 parameters describe these and are optional.
      - int blocks: The number of block sizes in the matrix.
      - int row&lt;x&gt;: Where x is the block number, and x goes from 1 to blocks.  This is the number of rows in block x.
      - int col&lt;x&gt;: Where x is the block number, and x goes from 1 to blocks.  This is the number of cols in block x.

    - bool alignedblocks: If true, all blocks are aligned to a grid.
    - bool unalignedblocks: If true, blocks are not aligned to a grid.

    - bool symmetricpattern: If true, the matrix is either symmetric or nearly symmetric.
    - bool nonsymmetricpattern: If true, the matrix has a very unsymmetric pattern.

    - bool randompattern: If true, the matrix's non-zeros are distributed in a random pattern.
    - bool correlatedpattern: If true, the row and column indices for
      non-zeros are highly correlated.

    - bool nodiags : If true, the matrix has little or no diagonal structure.
    - bool diags: If true, the matrix consists of diagonal structure described the next two optional parameters.
          - int numdiags: The number of diagonal sizes known to be present others not listed could be present.
      - int diag&lt;x&gt;: Where x is the diagonal number, and x goes from 1 to numdiags.  This is the size of the diagonal.
</pre> 
</div>
</div>
<a id="a64a9521fa5d2058f53acad5dd9707d6d" name="a64a9521fa5d2058f53acad5dd9707d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a9521fa5d2058f53acad5dd9707d6d">&#9670;&#160;</a></span>SetHintMatTransMatMultiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::SetHintMatTransMatMultiply </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ATA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>InVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>OutVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Intermediate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumCalls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>List</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Workload hints for computing a two matrix-vector multiplies that are composed used by OskiTuneMat to optimize the data structure storage, and the routine to compute the calculation. </p>
<p>In parallel the routine uses symbolic vectors. This is done for two reasons. Doing this saves on data allocation and potentially communication overhead. For a matrix-vector routine there should be no advantage to having the actual vector, as its size must be the same as a matrix dimension. For a matrix-multivector routine there could be gains from knowing the number of vectors in the multi-vector. However, OSKI does not perform multi-vector optimizations, so there is no need to add the overhead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ATA</td><td>(In) If ATA = true then this^T*this*x will be computed otherwise this*this^T*x will be. </td></tr>
    <tr><td class="paramname">Alpha</td><td>(In) A scalar constant used to scale InVec. </td></tr>
    <tr><td class="paramname">InVec</td><td>(In) The vector the matrix is multiplied by or whether it is a single vector or multi-vector. </td></tr>
    <tr><td class="paramname">Beta</td><td>(In) A scalar constant used to scale OutVec. </td></tr>
    <tr><td class="paramname">OutVec</td><td>(In) The vector where the calculation result is stored or whether it is a single vector or multi-vector. </td></tr>
    <tr><td class="paramname">Intermediate</td><td>(In) The vector where result of the first product can be stored or whether it is a single vector or multi-vector. If this quantity is NULL then the intermediate product is not stored. </td></tr>
    <tr><td class="paramname">NumCalls</td><td>(In) The number of times the operation is called or the tuning level wanted. </td></tr>
    <tr><td class="paramname">List</td><td>(In) Used for denoting the use of symbolic vectors for InVec, OutVec and Intermediate, along with the level of aggressive tuning if either NumCalls not known or to be overridden. Options are shown below. It should be noted that by using these options the associated vector or NumCalls becomes invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stores the workload hint in the matrix if the operation is valid. If the operation is not valid an error code is returned.</dd></dl>
<p>Options that can be passed to the List are presented below. They are: "&lt;type&gt; &lt;option name&gt;: &lt;description of purpose&gt;". The available hints are grouped by section, and only one hint from each section can be true for a given matrix. </p><pre class="fragment">    These replace InVec.
    - bool symminvec: If true, use a symbolic vector rather than the vector passed in for tuning purposes.
    - bool symminmultivec: If true, use a symbolic multi-vector rather than the multi-vector passed in for tuning purposes.

        These replace OutVec.
    - bool symmoutvec: If true, use a symbolic vector rather than the vector passed in for tuning purposes.
    - bool symmoutmultivec: If true, use a symbolic multi-vector rather than the multi-vector passed in for tuning purposes.

        These replace Intermediate.
    - bool symmintervec: If true, use a symbolic vector rather than the vector passed in for tuning purposes.
    - bool symmintermultivec: If true, use a symbolic multi-vector rather than the multi-vector passed in for tuning purposes.

    - bool tune: If true, have OSKI tune moderately rather than using the number of calls passed in.
    - bool tuneaggressive: If true, have OSKI tune aggressively rather than using the number of calls passed in.
</pre> 
</div>
</div>
<a id="ad69e471aa245c327dfaed65f376f8193" name="ad69e471aa245c327dfaed65f376f8193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69e471aa245c327dfaed65f376f8193">&#9670;&#160;</a></span>SetHintMultiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::SetHintMultiply </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>InVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>OutVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumCalls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>List</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Workload hints for computing a matrix-vector multiply used by OskiTuneMat to optimize the data structure storage, and the routine to compute the calculation. </p>
<p>In parallel the routine uses symbolic vectors. This is done for two reasons. Doing this saves on data allocation and potentially communication overhead. For a matrix-vector routine there should be no advantage to having the actual vector, as its size must be the same as a matrix dimension. For a matrix-multivector routine there could be gains from knowing the number of vectors in the multi-vector. However, OSKI does not perform multi-vector optimizations, so there is no need to add the overhead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Trans</td><td>(In) If Trans = true then the transpose of the matrix will be used in computing the product. </td></tr>
    <tr><td class="paramname">Alpha</td><td>(In) A scalar constant used to scale InVec. </td></tr>
    <tr><td class="paramname">InVec</td><td>(In) The vector the matrix is multiplied by or whether it is a single vector or multi-vector. </td></tr>
    <tr><td class="paramname">Beta</td><td>(In) A scalar constant used to scale OutVec. </td></tr>
    <tr><td class="paramname">OutVec</td><td>(In) The vector where the calculation result is stored or whether it is a single vector or multi-vector. </td></tr>
    <tr><td class="paramname">NumCalls</td><td>(In) The number of times the operation is called or the tuning level wanted. </td></tr>
    <tr><td class="paramname">List</td><td>(In) Used for denoting the use of symbolic vectors for both InVec and OutVec, as well as for level of aggressive tuning if either NumCalls not known or to be overridden. Options are shown below. It should be noted that by using these options the associated vector or NumCalls becomes invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stores the workload hint in the matrix if the operation is valid. If the operation is not valid an error code is returned.</dd></dl>
<p>Options that can be passed to the List are presented below. They are: "&lt;type&gt; &lt;option name&gt;: &lt;description of purpose&gt;". The available hints are grouped by section, and only one hint from each section can be true for a given matrix. </p><pre class="fragment">    These replace InVec.
    - bool symminvec: If true, use a symbolic vector rather than the vector passed in for tuning purposes.
    - bool symminmultivec: If true, use a symbolic multi-vector rather than the multi-vector passed in for tuning purposes.

        These replace OutVec.
    - bool symmoutvec: If true, use a symbolic vector rather than the vector passed in for tuning purposes.
    - bool symmoutmultivec: If true, use a symbolic multi-vector rather than the multi-vector passed in for tuning purposes.

    - bool tune: If true, have OSKI tune moderately rather than using the number of calls passed in.
    - bool tuneaggressive: If true, have OSKI tune aggressively rather than using the number of calls passed in.
</pre> 
</div>
</div>
<a id="a984e426d6ebd3241c3efd24a3553fa4b" name="a984e426d6ebd3241c3efd24a3553fa4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984e426d6ebd3241c3efd24a3553fa4b">&#9670;&#160;</a></span>SetHintMultiplyAndMatTransMultiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::SetHintMultiplyAndMatTransMultiply </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>InVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>OutVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>InVec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Zeta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>OutVec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumCalls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>List</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Workload hints for computing two matrix-vector multiplies used by OskiTuneMat to optimize the data structure storage, and the routine to compute the calculation. </p>
<p>In parallel the routine uses symbolic vectors. This is done for two reasons. Doing this saves on data allocation and potentially communication overhead. For a matrix-vector routine there should be no advantage to having the actual vector, as its size must be the same as a matrix dimension. For a matrix-multivector routine there could be gains from knowing the number of vectors in the multi-vector. However, OSKI does not perform multi-vector optimizations, so there is no need to add the overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Trans</td><td>(In) If Trans = true then the transpose of the matrix will be used in computing the product. </td></tr>
    <tr><td class="paramname">Alpha</td><td>(In) A scalar constant used to scale InVec. </td></tr>
    <tr><td class="paramname">InVec</td><td>(In) The vector the matrix is multiplied by or whether it is a single vector or multi-vector. </td></tr>
    <tr><td class="paramname">Beta</td><td>(In) A scalar constant used to scale OutVec. </td></tr>
    <tr><td class="paramname">OutVec</td><td>(In) The vector where the calculation result is stored or whether it is a single vector or multi-vector. </td></tr>
    <tr><td class="paramname">Omega</td><td>(In) A scalar constant used to scale InVec2. </td></tr>
    <tr><td class="paramname">InVec2</td><td>(In) The vector the matrix is multiplied by or whether it is a single vector or multi-vector. </td></tr>
    <tr><td class="paramname">Zeta</td><td>(In) A scalar constant used to scale OutVec2. </td></tr>
    <tr><td class="paramname">OutVec2</td><td>(In) The vector where the calculation result is stored or whether it is a single vector or multi-vector. </td></tr>
    <tr><td class="paramname">NumCalls</td><td>(In) The number of times the operation is called or the tuning level wanted. </td></tr>
    <tr><td class="paramname">List</td><td>(In) Used for denoting the use of symbolic vectors for both InVec and OutVec, as well as for level of aggressive tuning if either NumCalls not known or to be overridden. Options are shown below. It should be noted that by using these options the associated vector or NumCalls becomes invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stores the workload hint in the matrix if the operation is valid. If the operation is not valid an error code is returned.</dd></dl>
<p>Options that can be passed to the List are presented below. They are: "&lt;type&gt; &lt;option name&gt;: &lt;description of purpose&gt;". The available hints are grouped by section, and only one hint from each section can be true for a given matrix. </p><pre class="fragment">    These replace InVec.
    - bool symminvec: If true, use a symbolic vector rather than the vector passed in for tuning purposes.
    - bool symminmultivec: If true, use a symbolic multi-vector rather than the multi-vector passed in for tuning purposes.

        These replace OutVec.
    - bool symmoutvec: If true, use a symbolic vector rather than the vector passed in for tuning purposes.
    - bool symmoutmultivec: If true, use a symbolic multi-vector rather than the multi-vector passed in for tuning purposes.

    These replace InVec2.
    - bool symminvec2: If true, use a symbolic vector rather than the vector passed in for tuning purposes.
    - bool symminmultivec2: If true, use a symbolic multi-vector rather than the multi-vector passed in for tuning purposes.

        These replace OutVec2.
    - bool symmoutvec2: If true, use a symbolic vector rather than the vector passed in for tuning purposes.
    - bool symmoutmultivec2: If true, use a symbolic multi-vector rather than the multi-vector passed in for tuning purposes.

    - bool tune: If true, have OSKI tune moderately rather than using the number of calls passed in.
    - bool tuneaggressive: If true, have OSKI tune aggressively rather than using the number of calls passed in.
</pre> 
</div>
</div>
<a id="aaec6ae371bde9abea93db54d00895bc4" name="aaec6ae371bde9abea93db54d00895bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec6ae371bde9abea93db54d00895bc4">&#9670;&#160;</a></span>SetHintPowMultiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::SetHintPowMultiply </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>InVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>OutVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Intermediate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Power</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumCalls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>List</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Workload hints for computing a matrix-vector multiply performed Power times used by OskiTuneMat to optimize the data structure storage and the routine to compute the calculation. </p>
<p>In parallel the routine uses symbolic vectors. This is done for two reasons. Doing this saves on data allocation and potentially communication overhead. For a matrix-vector routine there should be no advantage to having the actual vector, as its size must be the same as a matrix dimension. For a matrix-multivector routine there could be gains from knowing the number of vectors in the multi-vector. However, OSKI does not perform multi-vector optimizations, so there is no need to add the overhead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Trans</td><td>(In) If Trans = true then the transpose of the matrix will be used in computing the product. </td></tr>
    <tr><td class="paramname">Alpha</td><td>(In) A scalar constant used to scale InVec. </td></tr>
    <tr><td class="paramname">InVec</td><td>(In) The vector the matrix is multiplied by or whether it is a single vector or multi-vector. </td></tr>
    <tr><td class="paramname">Beta</td><td>(In) A scalar constant used to scale OutVec. </td></tr>
    <tr><td class="paramname">OutVec</td><td>(In) The vector where the calculation result is stored or whether it is a single vector or multi-vector. </td></tr>
    <tr><td class="paramname">Intermediate</td><td>(In) The multi-vector where result of the first product can be stored or whether it is a single vector or multi-vector. If this quantity is NULL then the intermediate product is not stored. </td></tr>
    <tr><td class="paramname">Power</td><td>(In) The power to raise the matrix to in the calculation. </td></tr>
    <tr><td class="paramname">NumCalls</td><td>(In) The number of times the operation is called or the tuning level wanted. </td></tr>
    <tr><td class="paramname">List</td><td>(In) Used for denoting the use of symbolic vectors for both InVec and OutVec, as well as for level of aggressive tuning if either NumCalls not known or to be overridden. Options are shown below. It should be noted that by using these options the associated vector or NumCalls becomes invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stores the workload hint in the matrix if the operation is valid. If the operation is not valid an error code is returned.</dd></dl>
<p>Options that can be passed to the List are presented below. They are: "&lt;type&gt; &lt;option name&gt;: &lt;description of purpose&gt;". The available hints are grouped by section, and only one hint from each section can be true for a given matrix. </p><pre class="fragment">    These replace InVec.
    - bool symminvec: If true, use a symbolic vector rather than the vector passed in for tuning purposes.
    - bool symminmultivec: If true, use a symbolic multi-vector rather than the multi-vector passed in for tuning purposes.

        These replace OutVec.
    - bool symmoutvec: If true, use a symbolic vector rather than the vector passed in for tuning purposes.
    - bool symmoutmultivec: If true, use a symbolic multi-vector rather than the multi-vector passed in for tuning purposes.

        This replaces Intermediate.
    - bool symmintermultivec: If true, use a symbolic multi-vector rather than the multi-vector passed in for tuning purposes.

    - bool tune: If true, have OSKI tune moderately rather than using the number of calls passed in.
    - bool tuneaggressive: If true, have OSKI tune aggressively rather than using the number of calls passed in.
</pre> 
</div>
</div>
<a id="abf907924477a099556ee005a1e06abcc" name="abf907924477a099556ee005a1e06abcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf907924477a099556ee005a1e06abcc">&#9670;&#160;</a></span>SetHintSolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::SetHintSolve </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__OskiMultiVector.html">Epetra_OskiMultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumCalls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Teuchos::ParameterList &amp;&#160;</td>
          <td class="paramname"><em>List</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Workload hints for computing a triangular solve used by OskiTuneMat to optimize the data structure storage, and the routine to compute the calculation. </p>
<p>In parallel the routine uses symbolic vectors. This is done for two reasons. Doing this saves on data allocation and potentially communication overhead. For a matrix-vector routine there should be no advantage to having the actual vector, as its size must be the same as a matrix dimension. For a matrix-multivector routine there could be gains from knowing the number of vectors in the multi-vector. However, OSKI does not perform multi-vector optimizations, so there is no need to add the overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Trans</td><td>(In) If Trans = true then the transpose of the matrix will be used in computing the product. </td></tr>
    <tr><td class="paramname">Alpha</td><td>(In) A scalar constant used to scale InVec. </td></tr>
    <tr><td class="paramname">Vector</td><td>(In) The vector being used in the solve and to store the solution. </td></tr>
    <tr><td class="paramname">NumCalls</td><td>(In) The number of times the operation is called or the tuning level wanted. </td></tr>
    <tr><td class="paramname">List</td><td>(In) Used for denoting the use of a symbolic vectors, as well as for level of aggressive tuning if either NumCalls not known or to be overridden. Options are shown below. It should be noted that by using these options the associated vector or NumCalls becomes invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stores the workload hint in the matrix if the operation is valid. If the operation is not valid an error code is returned.</dd></dl>
<p>Options that can be passed to the List are presented below. They are: "&lt;type&gt; &lt;option name&gt;: &lt;description of purpose&gt;". The available hints are grouped by section, and only one hint from each section can be true for a given matrix. </p><pre class="fragment">    These replace Vector.
    - bool symmvec: If true, use a symbolic vector rather than the vector passed in for tuning purposes.
    - bool symmmultivec: If true, use a symbolic multi-vector rather than the multi-vector passed in for tuning purposes.

    - bool tune: If true, have OSKI tune moderately rather than using the number of calls passed in.
    - bool tuneaggressive: If true, have OSKI tune aggressively rather than using the number of calls passed in.
</pre> 
</div>
</div>
<a id="ac50ee697e244e527a3acccf0ec4da905" name="ac50ee697e244e527a3acccf0ec4da905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50ee697e244e527a3acccf0ec4da905">&#9670;&#160;</a></span>Solve() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::Solve </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Alpha</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a triangular solve of Y = Alpha*(this^TransA)^-1*X where this is a triangular matrix. </p>
<p>The vector X can be either be an <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> or <a class="el" href="classEpetra__OskiMultiVector.html" title="Epetra_OskiMultiVector: A class for constructing and using dense Oski multi-vectors on a single proce...">Epetra_OskiMultiVector</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TransA</td><td>(In) If TransA = TRUE then use the transpose of the matrix in solving the equations. </td></tr>
    <tr><td class="paramname">X</td><td>(In) The multi-vector solved against. </td></tr>
    <tr><td class="paramname">Y</td><td>(Out) The solution multi-vector. </td></tr>
    <tr><td class="paramname">Alpha</td><td>(In) A scalar constant used to scale X. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged </dd></dl>

</div>
</div>
<a id="aad8538413a8a2f101bb96d1e3d737a96" name="aad8538413a8a2f101bb96d1e3d737a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8538413a8a2f101bb96d1e3d737a96">&#9670;&#160;</a></span>Solve() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::Solve </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Alpha</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a triangular solve of y = Alpha*(this^TransA)^-1*x where this is a triangular matrix. </p>
<p>The vector x can be either be an <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> or <a class="el" href="classEpetra__OskiVector.html" title="Epetra_OskiVector: A class for constructing and using dense OSKI vectors on a single processor or a s...">Epetra_OskiVector</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TransA</td><td>(In) If TransA = TRUE then use the transpose of the matrix in solving the equations. </td></tr>
    <tr><td class="paramname">x</td><td>(In) The vector solved against. </td></tr>
    <tr><td class="paramname">y</td><td>(Out) The solution vector. </td></tr>
    <tr><td class="paramname">Alpha</td><td>(In) A scalar constant used to scale x. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged </dd></dl>

</div>
</div>
<a id="acbd52a0fdbc6c92a2f38ed32d92d5fc8" name="acbd52a0fdbc6c92a2f38ed32d92d5fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd52a0fdbc6c92a2f38ed32d92d5fc8">&#9670;&#160;</a></span>Solve() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::Solve </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>Upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>UnitDiagonal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a triangular solve of Y = (this^TransA)^-1*X where this is a triangular matrix. </p>
<p>The vector X can be either be an <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> or <a class="el" href="classEpetra__OskiMultiVector.html" title="Epetra_OskiMultiVector: A class for constructing and using dense Oski multi-vectors on a single proce...">Epetra_OskiMultiVector</a>. The OskiMatrix must already be triangular, and the UnitDiagonal setting associated with it will be used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Upper</td><td>(In) This parameter is ignored only here to match the <a class="el" href="classEpetra__CrsMatrix.html#a4b0d7c00870df3bf3a18db186a290e64" title="Returns the result of a local solve using the Epetra_CrsMatrix on a Epetra_Vector x in y.">Epetra_CrsMatrix::Solve</a> syntax. </td></tr>
    <tr><td class="paramname">TransA</td><td>(In) If TransA = TRUE then use the transpose of the matrix in solving the equations. </td></tr>
    <tr><td class="paramname">UnitDiagonal</td><td>(In) This parameter is ignored only here to match the <a class="el" href="classEpetra__CrsMatrix.html#a4b0d7c00870df3bf3a18db186a290e64" title="Returns the result of a local solve using the Epetra_CrsMatrix on a Epetra_Vector x in y.">Epetra_CrsMatrix::Solve</a> syntax. </td></tr>
    <tr><td class="paramname">X</td><td>(In) The multi-vector solved against. </td></tr>
    <tr><td class="paramname">Y</td><td>(Out) The solution multi-vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged </dd></dl>

<p>Reimplemented from <a class="el" href="classEpetra__CrsMatrix.html#ac0717ceccbb3713daecdc3ed801f6fab">Epetra_CrsMatrix</a>.</p>

</div>
</div>
<a id="a081bca726094afb2277501a42c48e92a" name="a081bca726094afb2277501a42c48e92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081bca726094afb2277501a42c48e92a">&#9670;&#160;</a></span>Solve() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::Solve </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>Upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>UnitDiagonal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a triangular solve of y = (this^TransA)^-1*x where this is a triangular matrix. </p>
<p>The vector x can be either be an <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> or <a class="el" href="classEpetra__OskiVector.html" title="Epetra_OskiVector: A class for constructing and using dense OSKI vectors on a single processor or a s...">Epetra_OskiVector</a>. The OskiMatrix must already be triangular, and the UnitDiagonal setting associated with it will be used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Upper</td><td>(In) This parameter is ignored, and is here only to match the <a class="el" href="classEpetra__CrsMatrix.html#a4b0d7c00870df3bf3a18db186a290e64" title="Returns the result of a local solve using the Epetra_CrsMatrix on a Epetra_Vector x in y.">Epetra_CrsMatrix::Solve</a> syntax. </td></tr>
    <tr><td class="paramname">TransA</td><td>(In) If TransA = TRUE then use the transpose of the matrix in solving the equations. </td></tr>
    <tr><td class="paramname">UnitDiagonal</td><td>(In) This parameter is ignored only here to match the <a class="el" href="classEpetra__CrsMatrix.html#a4b0d7c00870df3bf3a18db186a290e64" title="Returns the result of a local solve using the Epetra_CrsMatrix on a Epetra_Vector x in y.">Epetra_CrsMatrix::Solve</a> syntax. </td></tr>
    <tr><td class="paramname">x</td><td>(In) The vector solved against. </td></tr>
    <tr><td class="paramname">y</td><td>(Out) The solution vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged </dd></dl>

</div>
</div>
<a id="ad3d7f7c6a1ab1ef30e36c9207a99ace9" name="ad3d7f7c6a1ab1ef30e36c9207a99ace9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d7f7c6a1ab1ef30e36c9207a99ace9">&#9670;&#160;</a></span>SumIntoMyValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::SumIntoMyValues </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MyRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add this list of entries to existing values for a given local row of the matrix. WARNING: this could be expensive. </p>
<p>The reason this function could be expensive is its underlying implementation. Both the OSKI and Epetra versions of the Matrix must be changed when the matrix has been permuted. When this is the case, a call must be made to the Epetra SumIntoMyValues, and NumEntries calls must be made to a function that changes the OSKI matrix's values one at a time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MyRow</td><td>- (In) Row number (in local coordinates) to put elements. </td></tr>
    <tr><td class="paramname">NumEntries</td><td>- (In) Number of entries. </td></tr>
    <tr><td class="paramname">Values</td><td>- (In) Values to enter. </td></tr>
    <tr><td class="paramname">Indices</td><td>- (In) Local column indices corresponding to values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. Note that if the allocated length of the row has to be expanded, a positive warning code may be returned. This should be treated as a fatal error, as part of the data will be changed, and OSKI cannot support adding in new data values. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#aae10c5b74759484342ed40ced9561f49" title="If matrix indices has been transformed to local, this query returns true, otherwise it returns false.">IndicesAreLocal()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The given Values at the given Indices have been summed into the entries of MyRow. </dd></dl>

</div>
</div>
<a id="a335af3df905a0b748eb7d8381c9301de" name="a335af3df905a0b748eb7d8381c9301de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335af3df905a0b748eb7d8381c9301de">&#9670;&#160;</a></span>TuneMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_OskiMatrix::TuneMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tunes the matrix multiply if its deemed profitable. </p>
<p>The routine tunes based upon user provided hints if given. If hints are not given the tuning is performed based on expected future workload for the calculation. </p><dl class="section return"><dt>Returns</dt><dd>On success returns a non-negative status code of the transformations performed. On failure an error code is returned. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><b>Epetra_OskiMatrix.h</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
