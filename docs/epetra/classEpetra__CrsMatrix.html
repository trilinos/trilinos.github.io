<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Epetra: Epetra_CrsMatrix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Epetra<span id="projectnumber">&#160;Development</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classEpetra__CrsMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Epetra_CrsMatrix Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a>: A class for constructing and using real-valued double-precision sparse compressed row matrices.  
 <a href="classEpetra__CrsMatrix.html#details">More...</a></p>

<p><code>#include &lt;Epetra_CrsMatrix.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Epetra_CrsMatrix:</div>
<div class="dyncontent">
<div class="center"><img src="classEpetra__CrsMatrix__inherit__graph.gif" border="0" usemap="#aEpetra__CrsMatrix_inherit__map" alt="Inheritance graph"/></div>
<map name="aEpetra__CrsMatrix_inherit__map" id="aEpetra__CrsMatrix_inherit__map">
<area shape="rect" title="Epetra_CrsMatrix: A class for constructing and using real&#45;valued double&#45;precision sparse compressed r..." alt="" coords="324,152,459,177"/>
<area shape="rect" href="classEpetra__FECrsMatrix.html" title=" " alt="" coords="231,225,381,251"/>
<area shape="poly" title=" " alt="" coords="369,188,322,227,318,223,366,184"/>
<area shape="rect" href="classEpetra__OskiMatrix.html" title="Epetra_OskiMatrix: A class for constructing and using OSKI Matrices within Epetra...." alt="" coords="405,225,548,251"/>
<area shape="poly" title=" " alt="" coords="417,184,464,223,461,227,414,188"/>
<area shape="rect" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi&#45;vectors, vectors and matrices in pa..." alt="" coords="73,79,211,104"/>
<area shape="poly" title=" " alt="" coords="196,105,352,149,350,154,195,110"/>
<area shape="rect" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class." alt="" coords="5,5,119,31"/>
<area shape="poly" title=" " alt="" coords="87,38,131,76,127,80,83,42"/>
<area shape="rect" href="classEpetra__SrcDistObject.html" title="Epetra_SrcDistObject: A class for supporting flexible source distributed objects for import/export op..." alt="" coords="143,5,301,31"/>
<area shape="poly" title=" " alt="" coords="201,42,157,80,153,76,197,38"/>
<area shape="rect" href="classEpetra__RowMatrix.html" title="Epetra_RowMatrix: A pure virtual class for using real&#45;valued double&#45;precision row matrices." alt="" coords="235,79,377,104"/>
<area shape="poly" title=" " alt="" coords="248,38,294,76,291,80,244,42"/>
<area shape="rect" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes." alt="" coords="401,79,552,104"/>
<area shape="poly" title=" " alt="" coords="454,115,407,154,404,150,451,110"/>
<area shape="rect" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class." alt="" coords="576,79,681,104"/>
<area shape="poly" title=" " alt="" coords="578,110,431,154,429,149,577,105"/>
<area shape="poly" title=" " alt="" coords="332,110,379,150,376,154,328,115"/>
<area shape="rect" href="classEpetra__Operator.html" title="Epetra_Operator: A pure virtual class for using real&#45;valued double&#45;precision operators." alt="" coords="326,5,454,31"/>
<area shape="poly" title=" " alt="" coords="368,42,321,80,318,76,364,38"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Epetra_CrsMatrix:</div>
<div class="dyncontent">
<div class="center"><img src="classEpetra__CrsMatrix__coll__graph.gif" border="0" usemap="#aEpetra__CrsMatrix_coll__map" alt="Collaboration graph"/></div>
<map name="aEpetra__CrsMatrix_coll__map" id="aEpetra__CrsMatrix_coll__map">
<area shape="rect" title="Epetra_CrsMatrix: A class for constructing and using real&#45;valued double&#45;precision sparse compressed r..." alt="" coords="1264,133,1399,159"/>
<area shape="rect" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi&#45;vectors, vectors and matrices in pa..." alt="" coords="782,167,921,192"/>
<area shape="poly" title=" " alt="" coords="935,171,1263,148,1264,153,935,176"/>
<area shape="rect" href="classEpetra__CrsGraph.html" title="Epetra_CrsGraph: A class for constructing and using sparse compressed row graphs." alt="" coords="983,209,1114,235"/>
<area shape="poly" title=" " alt="" coords="924,192,990,207,989,212,923,197"/>
<area shape="rect" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi&#45;vectors, vectors and matrices in p..." alt="" coords="976,51,1121,76"/>
<area shape="poly" title=" " alt="" coords="884,157,1024,74,1027,78,887,162"/>
<area shape="rect" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class." alt="" coords="184,85,297,111"/>
<area shape="poly" title=" " alt="" coords="311,90,401,88,512,91,633,104,694,116,753,131,793,147,828,164,826,169,791,152,751,136,693,121,633,109,512,96,401,93,311,96"/>
<area shape="rect" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices." alt="" coords="491,127,625,152"/>
<area shape="poly" title=" " alt="" coords="311,104,491,128,490,133,311,110"/>
<area shape="rect" href="classEpetra__SrcDistObject.html" title="Epetra_SrcDistObject: A class for supporting flexible source distributed objects for import/export op..." alt="" coords="479,229,637,255"/>
<area shape="poly" title=" " alt="" coords="631,224,790,189,791,195,632,229"/>
<area shape="rect" href="classEpetra__RowMatrix.html" title="Epetra_RowMatrix: A pure virtual class for using real&#45;valued double&#45;precision row matrices." alt="" coords="781,260,922,285"/>
<area shape="poly" title=" " alt="" coords="651,249,781,263,780,268,651,254"/>
<area shape="poly" title=" " alt="" coords="640,148,782,167,782,172,639,153"/>
<area shape="rect" href="classEpetra__BlockMapData.html" title="Epetra_BlockMapData: The Epetra BlockMap Data Class." alt="" coords="157,144,324,169"/>
<area shape="poly" title=" " alt="" coords="338,156,454,153,490,148,491,154,455,158,338,162"/>
<area shape="rect" href="classEpetra__Data.html" title="Epetra_Data: The Epetra Base Data Class." alt="" coords="5,144,108,169"/>
<area shape="poly" title=" " alt="" coords="122,154,157,154,157,159,122,159"/>
<area shape="rect" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class." alt="" coords="501,176,615,201"/>
<area shape="poly" title=" " alt="" coords="629,185,752,182,781,181,782,186,752,187,629,190"/>
<area shape="rect" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes." alt="" coords="776,24,927,49"/>
<area shape="poly" title=" " alt="" coords="916,18,986,8,1069,3,1113,5,1157,10,1200,21,1241,37,1271,57,1295,83,1326,132,1322,134,1291,86,1267,61,1239,42,1199,26,1156,16,1113,10,1069,8,987,13,917,24"/>
<area shape="poly" title=" " alt="" coords="941,46,976,51,976,56,940,51"/>
<area shape="rect" href="classEpetra__Flops.html" title="Epetra_Flops: The Epetra Floating Point Operations Class." alt="" coords="505,24,611,49"/>
<area shape="poly" title=" " alt="" coords="625,34,776,34,776,39,625,39"/>
<area shape="rect" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class." alt="" coords="799,89,904,115"/>
<area shape="poly" title=" " alt="" coords="918,105,1264,137,1264,142,917,111"/>
<area shape="poly" title=" " alt="" coords="917,86,983,73,984,79,918,92"/>
<area shape="poly" title=" " alt="" coords="936,276,1004,276,1082,269,1162,254,1202,242,1239,226,1263,211,1285,193,1318,157,1322,161,1289,197,1266,215,1241,231,1203,247,1164,259,1083,275,1004,281,936,281"/>
<area shape="rect" href="classEpetra__Operator.html" title="Epetra_Operator: A pure virtual class for using real&#45;valued double&#45;precision operators." alt="" coords="494,285,622,311"/>
<area shape="poly" title=" " alt="" coords="635,289,780,276,781,281,636,294"/>
<area shape="poly" title=" " alt="" coords="1127,221,1183,215,1239,202,1281,181,1314,157,1317,161,1284,185,1241,207,1184,221,1128,226"/>
<area shape="poly" title=" " alt="" coords="1135,69,1188,78,1241,93,1280,111,1313,131,1310,135,1278,116,1239,98,1187,83,1134,74"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors/Destructor</div></td></tr>
<tr class="memitem:af174457dccd1ff7612126172863614c0" id="r_af174457dccd1ff7612126172863614c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#af174457dccd1ff7612126172863614c0">Epetra_CrsMatrix</a> (<a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a> CV, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;<a class="el" href="classEpetra__CrsMatrix.html#a24855eec1cf6aeb201be88ba654d22bf">RowMap</a>, const int *NumEntriesPerRow, bool StaticProfile=false)</td></tr>
<tr class="memdesc:af174457dccd1ff7612126172863614c0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> constructor with variable number of indices per row.  <br /></td></tr>
<tr class="separator:af174457dccd1ff7612126172863614c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d9a06553f57f94b1f294356a91823b" id="r_ad4d9a06553f57f94b1f294356a91823b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ad4d9a06553f57f94b1f294356a91823b">Epetra_CrsMatrix</a> (<a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a> CV, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;<a class="el" href="classEpetra__CrsMatrix.html#a24855eec1cf6aeb201be88ba654d22bf">RowMap</a>, int NumEntriesPerRow, bool StaticProfile=false)</td></tr>
<tr class="memdesc:ad4d9a06553f57f94b1f294356a91823b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> constructor with fixed number of indices per row.  <br /></td></tr>
<tr class="separator:ad4d9a06553f57f94b1f294356a91823b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e3f3a7c450a7443bd3b41580d11513" id="r_a83e3f3a7c450a7443bd3b41580d11513"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a83e3f3a7c450a7443bd3b41580d11513">Epetra_CrsMatrix</a> (<a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a> CV, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;<a class="el" href="classEpetra__CrsMatrix.html#a24855eec1cf6aeb201be88ba654d22bf">RowMap</a>, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;<a class="el" href="classEpetra__CrsMatrix.html#aab3589bfaac41458ab698d3d53780e61">ColMap</a>, const int *NumEntriesPerRow, bool StaticProfile=false)</td></tr>
<tr class="memdesc:a83e3f3a7c450a7443bd3b41580d11513"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> constructor with variable number of indices per row.  <br /></td></tr>
<tr class="separator:a83e3f3a7c450a7443bd3b41580d11513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976b94f3d9dbfe17aa425d29a3b0c0d7" id="r_a976b94f3d9dbfe17aa425d29a3b0c0d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a976b94f3d9dbfe17aa425d29a3b0c0d7">Epetra_CrsMatrix</a> (<a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a> CV, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;<a class="el" href="classEpetra__CrsMatrix.html#a24855eec1cf6aeb201be88ba654d22bf">RowMap</a>, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;<a class="el" href="classEpetra__CrsMatrix.html#aab3589bfaac41458ab698d3d53780e61">ColMap</a>, int NumEntriesPerRow, bool StaticProfile=false)</td></tr>
<tr class="memdesc:a976b94f3d9dbfe17aa425d29a3b0c0d7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> constuctor with fixed number of indices per row.  <br /></td></tr>
<tr class="separator:a976b94f3d9dbfe17aa425d29a3b0c0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea2e6fa0f05885ec6bb758283777251" id="r_abea2e6fa0f05885ec6bb758283777251"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#abea2e6fa0f05885ec6bb758283777251">Epetra_CrsMatrix</a> (<a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a> CV, const <a class="el" href="classEpetra__CrsGraph.html">Epetra_CrsGraph</a> &amp;<a class="el" href="classEpetra__CrsMatrix.html#a98ed3d3f3cb0ab79ffceb1974b9a8809">Graph</a>)</td></tr>
<tr class="memdesc:abea2e6fa0f05885ec6bb758283777251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix using an existing <a class="el" href="classEpetra__CrsGraph.html" title="Epetra_CrsGraph: A class for constructing and using sparse compressed row graphs.">Epetra_CrsGraph</a> object.  <br /></td></tr>
<tr class="separator:abea2e6fa0f05885ec6bb758283777251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7002382b0e988660cc450a8453987e" id="r_a8b7002382b0e988660cc450a8453987e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a8b7002382b0e988660cc450a8453987e">Epetra_CrsMatrix</a> (const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;SourceMatrix, const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> &amp;RowImporter, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c">DomainMap</a>=0, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222">RangeMap</a>=0, bool RestrictCommunicator=false)</td></tr>
<tr class="memdesc:a8b7002382b0e988660cc450a8453987e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epetra CrsMatrix constructor that also fuses Import and <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a>.  <br /></td></tr>
<tr class="separator:a8b7002382b0e988660cc450a8453987e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa47469f36f75bc7147e443cc045685d" id="r_afa47469f36f75bc7147e443cc045685d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#afa47469f36f75bc7147e443cc045685d">Epetra_CrsMatrix</a> (const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;SourceMatrix, const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> &amp;RowImporter, const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> *DomainImporter, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c">DomainMap</a>, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222">RangeMap</a>, bool RestrictCommunicator)</td></tr>
<tr class="memdesc:afa47469f36f75bc7147e443cc045685d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epetra CrsMatrix constructor that also fuses Import and <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a>.  <br /></td></tr>
<tr class="separator:afa47469f36f75bc7147e443cc045685d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9e9a8fc2eb865889c9e090528f6215" id="r_a8a9e9a8fc2eb865889c9e090528f6215"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a8a9e9a8fc2eb865889c9e090528f6215">Epetra_CrsMatrix</a> (const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;SourceMatrix, const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> &amp;RowExporter, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c">DomainMap</a>=0, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222">RangeMap</a>=0, bool RestrictCommunicator=false)</td></tr>
<tr class="memdesc:a8a9e9a8fc2eb865889c9e090528f6215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epetra CrsMatrix constructor that also fuses Ex[prt and <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a>.  <br /></td></tr>
<tr class="separator:a8a9e9a8fc2eb865889c9e090528f6215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93a987aa9463831451960dc462c5985" id="r_ad93a987aa9463831451960dc462c5985"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ad93a987aa9463831451960dc462c5985">Epetra_CrsMatrix</a> (const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;SourceMatrix, const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> &amp;RowExporter, const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> *DomainExporter, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c">DomainMap</a>, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222">RangeMap</a>, bool RestrictCommunicator)</td></tr>
<tr class="memdesc:ad93a987aa9463831451960dc462c5985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epetra CrsMatrix constructor that also fuses Ex[prt and <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a>.  <br /></td></tr>
<tr class="separator:ad93a987aa9463831451960dc462c5985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7e88dafd4636c054c36c1ccbb1a5fb" id="r_a4a7e88dafd4636c054c36c1ccbb1a5fb"><td class="memItemLeft" align="right" valign="top"><a id="a4a7e88dafd4636c054c36c1ccbb1a5fb" name="a4a7e88dafd4636c054c36c1ccbb1a5fb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_CrsMatrix</b> (const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;Matrix)</td></tr>
<tr class="memdesc:a4a7e88dafd4636c054c36c1ccbb1a5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:a4a7e88dafd4636c054c36c1ccbb1a5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af947e9ec91d35d85a7a3d410d391b878" id="r_af947e9ec91d35d85a7a3d410d391b878"><td class="memItemLeft" align="right" valign="top"><a id="af947e9ec91d35d85a7a3d410d391b878" name="af947e9ec91d35d85a7a3d410d391b878"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_CrsMatrix</b> ()</td></tr>
<tr class="memdesc:af947e9ec91d35d85a7a3d410d391b878"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> Destructor. <br /></td></tr>
<tr class="separator:af947e9ec91d35d85a7a3d410d391b878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Insertion/Replace/SumInto methods</div></td></tr>
<tr class="memitem:aac12887d3d6c815496702ee9c07d097b" id="r_aac12887d3d6c815496702ee9c07d097b"><td class="memItemLeft" align="right" valign="top"><a id="aac12887d3d6c815496702ee9c07d097b" name="aac12887d3d6c815496702ee9c07d097b"></a>
<a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;src)</td></tr>
<tr class="memdesc:aac12887d3d6c815496702ee9c07d097b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br /></td></tr>
<tr class="separator:aac12887d3d6c815496702ee9c07d097b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2eb1fc1151fef071b29a37bff8822b" id="r_a3c2eb1fc1151fef071b29a37bff8822b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a3c2eb1fc1151fef071b29a37bff8822b">PutScalar</a> (double ScalarConstant)</td></tr>
<tr class="memdesc:a3c2eb1fc1151fef071b29a37bff8822b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize all values in the matrix with constant value.  <br /></td></tr>
<tr class="separator:a3c2eb1fc1151fef071b29a37bff8822b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89dca01cc1dcf5c46cd34ecba9a0c6d1" id="r_a89dca01cc1dcf5c46cd34ecba9a0c6d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a89dca01cc1dcf5c46cd34ecba9a0c6d1">Scale</a> (double ScalarConstant)</td></tr>
<tr class="memdesc:a89dca01cc1dcf5c46cd34ecba9a0c6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply all values in the matrix by a constant value (in place: A &lt;- ScalarConstant * A).  <br /></td></tr>
<tr class="separator:a89dca01cc1dcf5c46cd34ecba9a0c6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7ff1b3a9be1c41fe218538af97cfdb" id="r_a2f7ff1b3a9be1c41fe218538af97cfdb"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a2f7ff1b3a9be1c41fe218538af97cfdb">InsertGlobalValues</a> (int GlobalRow, int NumEntries, const double *Values, const int *Indices)</td></tr>
<tr class="memdesc:a2f7ff1b3a9be1c41fe218538af97cfdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a list of elements in a given global row of the matrix.  <br /></td></tr>
<tr class="separator:a2f7ff1b3a9be1c41fe218538af97cfdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179573693006a56a83006815f238e6a8" id="r_a179573693006a56a83006815f238e6a8"><td class="memItemLeft" align="right" valign="top"><a id="a179573693006a56a83006815f238e6a8" name="a179573693006a56a83006815f238e6a8"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>InsertGlobalValues</b> (long long GlobalRow, int NumEntries, const double *Values, const long long *Indices)</td></tr>
<tr class="separator:a179573693006a56a83006815f238e6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c56a411752216cae73ca1fa04239c28" id="r_a8c56a411752216cae73ca1fa04239c28"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a8c56a411752216cae73ca1fa04239c28">InsertGlobalValues</a> (int GlobalRow, int NumEntries, double *Values, int *Indices)</td></tr>
<tr class="memdesc:a8c56a411752216cae73ca1fa04239c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a list of elements in a given global row of the matrix.  <br /></td></tr>
<tr class="separator:a8c56a411752216cae73ca1fa04239c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f5217b07252ea2aed727737dbe0003" id="r_a42f5217b07252ea2aed727737dbe0003"><td class="memItemLeft" align="right" valign="top"><a id="a42f5217b07252ea2aed727737dbe0003" name="a42f5217b07252ea2aed727737dbe0003"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>InsertGlobalValues</b> (long long GlobalRow, int NumEntries, double *Values, long long *Indices)</td></tr>
<tr class="separator:a42f5217b07252ea2aed727737dbe0003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36048758bcfe082ca07090569607d574" id="r_a36048758bcfe082ca07090569607d574"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a36048758bcfe082ca07090569607d574">ReplaceGlobalValues</a> (int GlobalRow, int NumEntries, const double *Values, const int *Indices)</td></tr>
<tr class="memdesc:a36048758bcfe082ca07090569607d574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace specified existing values with this list of entries for a given global row of the matrix.  <br /></td></tr>
<tr class="separator:a36048758bcfe082ca07090569607d574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5644462862e06698585cafa7d3eddd0" id="r_af5644462862e06698585cafa7d3eddd0"><td class="memItemLeft" align="right" valign="top"><a id="af5644462862e06698585cafa7d3eddd0" name="af5644462862e06698585cafa7d3eddd0"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>ReplaceGlobalValues</b> (long long GlobalRow, int NumEntries, const double *Values, const long long *Indices)</td></tr>
<tr class="separator:af5644462862e06698585cafa7d3eddd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1291bfb498b94ac4f1563b48d11dfae5" id="r_a1291bfb498b94ac4f1563b48d11dfae5"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a1291bfb498b94ac4f1563b48d11dfae5">SumIntoGlobalValues</a> (int GlobalRow, int NumEntries, const double *Values, const int *Indices)</td></tr>
<tr class="memdesc:a1291bfb498b94ac4f1563b48d11dfae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add this list of entries to existing values for a given global row of the matrix.  <br /></td></tr>
<tr class="separator:a1291bfb498b94ac4f1563b48d11dfae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd087c54f1e5a75a2ae6beb41b7e7d5" id="r_a2fd087c54f1e5a75a2ae6beb41b7e7d5"><td class="memItemLeft" align="right" valign="top"><a id="a2fd087c54f1e5a75a2ae6beb41b7e7d5" name="a2fd087c54f1e5a75a2ae6beb41b7e7d5"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>SumIntoGlobalValues</b> (long long GlobalRow, int NumEntries, const double *Values, const long long *Indices)</td></tr>
<tr class="separator:a2fd087c54f1e5a75a2ae6beb41b7e7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0a4c3e447466758bd8608b077e90a0" id="r_ada0a4c3e447466758bd8608b077e90a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ada0a4c3e447466758bd8608b077e90a0">InsertMyValues</a> (int MyRow, int NumEntries, const double *Values, const int *Indices)</td></tr>
<tr class="memdesc:ada0a4c3e447466758bd8608b077e90a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a list of elements in a given local row of the matrix.  <br /></td></tr>
<tr class="separator:ada0a4c3e447466758bd8608b077e90a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3aff1cbaa86e32fc971f3613b350d2" id="r_abc3aff1cbaa86e32fc971f3613b350d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#abc3aff1cbaa86e32fc971f3613b350d2">InsertMyValues</a> (int MyRow, int NumEntries, double *Values, int *Indices)</td></tr>
<tr class="memdesc:abc3aff1cbaa86e32fc971f3613b350d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a list of elements in a given local row of the matrix.  <br /></td></tr>
<tr class="separator:abc3aff1cbaa86e32fc971f3613b350d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecf7e5bf939b56644e25c57f67e137d" id="r_acecf7e5bf939b56644e25c57f67e137d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#acecf7e5bf939b56644e25c57f67e137d">ReplaceMyValues</a> (int MyRow, int NumEntries, const double *Values, const int *Indices)</td></tr>
<tr class="memdesc:acecf7e5bf939b56644e25c57f67e137d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace current values with this list of entries for a given local row of the matrix.  <br /></td></tr>
<tr class="separator:acecf7e5bf939b56644e25c57f67e137d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e93959017a68cb0103110d80b124c82" id="r_a8e93959017a68cb0103110d80b124c82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a8e93959017a68cb0103110d80b124c82">SumIntoMyValues</a> (int MyRow, int NumEntries, const double *Values, const int *Indices)</td></tr>
<tr class="memdesc:a8e93959017a68cb0103110d80b124c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add this list of entries to existing values for a given local row of the matrix.  <br /></td></tr>
<tr class="separator:a8e93959017a68cb0103110d80b124c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecb739b8f837a91406050f6f8bd7b9a" id="r_aeecb739b8f837a91406050f6f8bd7b9a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#aeecb739b8f837a91406050f6f8bd7b9a">ReplaceDiagonalValues</a> (const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;Diagonal)</td></tr>
<tr class="memdesc:aeecb739b8f837a91406050f6f8bd7b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces diagonal values of the matrix with those in the user-provided vector.  <br /></td></tr>
<tr class="separator:aeecb739b8f837a91406050f6f8bd7b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Transformation methods</div></td></tr>
<tr class="memitem:a355b4e8d1e28b16bacf37ab637ac0c3f" id="r_a355b4e8d1e28b16bacf37ab637ac0c3f"><td class="memItemLeft" align="right" valign="top"><a id="a355b4e8d1e28b16bacf37ab637ac0c3f" name="a355b4e8d1e28b16bacf37ab637ac0c3f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>FillComplete</b> (bool OptimizeDataStorage=true)</td></tr>
<tr class="memdesc:a355b4e8d1e28b16bacf37ab637ac0c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal that data entry is complete. Perform transformations to local index space. <br /></td></tr>
<tr class="separator:a355b4e8d1e28b16bacf37ab637ac0c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3c13275e8dbe80826e820abbb8e49c" id="r_aac3c13275e8dbe80826e820abbb8e49c"><td class="memItemLeft" align="right" valign="top"><a id="aac3c13275e8dbe80826e820abbb8e49c" name="aac3c13275e8dbe80826e820abbb8e49c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>FillComplete</b> (const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;<a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c">DomainMap</a>, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;<a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222">RangeMap</a>, bool OptimizeDataStorage=true)</td></tr>
<tr class="memdesc:aac3c13275e8dbe80826e820abbb8e49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal that data entry is complete. Perform transformations to local index space. <br /></td></tr>
<tr class="separator:aac3c13275e8dbe80826e820abbb8e49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54a33eafbaa0a966cf2c0ce454a7d59" id="r_ac54a33eafbaa0a966cf2c0ce454a7d59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ac54a33eafbaa0a966cf2c0ce454a7d59">OptimizeStorage</a> ()</td></tr>
<tr class="memdesc:ac54a33eafbaa0a966cf2c0ce454a7d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make consecutive row index sections contiguous, minimize internal storage used for constructing graph.  <br /></td></tr>
<tr class="separator:ac54a33eafbaa0a966cf2c0ce454a7d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5d779243fdca3b068cdc4cf5781f86" id="r_a1d5d779243fdca3b068cdc4cf5781f86"><td class="memItemLeft" align="right" valign="top"><a id="a1d5d779243fdca3b068cdc4cf5781f86" name="a1d5d779243fdca3b068cdc4cf5781f86"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MakeDataContiguous</b> ()</td></tr>
<tr class="memdesc:a1d5d779243fdca3b068cdc4cf5781f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates memory that is used for construction. Make consecutive row index sections contiguous. <br /></td></tr>
<tr class="separator:a1d5d779243fdca3b068cdc4cf5781f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Extraction methods</div></td></tr>
<tr class="memitem:a70846bbd75f7f2f0c2453ac9446d6c2c" id="r_a70846bbd75f7f2f0c2453ac9446d6c2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a70846bbd75f7f2f0c2453ac9446d6c2c">ExtractGlobalRowCopy</a> (int GlobalRow, int Length, int &amp;NumEntries, double *Values, int *Indices) const</td></tr>
<tr class="memdesc:a70846bbd75f7f2f0c2453ac9446d6c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the specified global row in user-provided arrays.  <br /></td></tr>
<tr class="separator:a70846bbd75f7f2f0c2453ac9446d6c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0413ec950204597c3a49fb2afa1004" id="r_afd0413ec950204597c3a49fb2afa1004"><td class="memItemLeft" align="right" valign="top"><a id="afd0413ec950204597c3a49fb2afa1004" name="afd0413ec950204597c3a49fb2afa1004"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ExtractGlobalRowCopy</b> (long long GlobalRow, int Length, int &amp;NumEntries, double *Values, long long *Indices) const</td></tr>
<tr class="separator:afd0413ec950204597c3a49fb2afa1004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1d307174a8205ec5b1198f51c50bf8" id="r_aae1d307174a8205ec5b1198f51c50bf8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#aae1d307174a8205ec5b1198f51c50bf8">ExtractMyRowCopy</a> (int MyRow, int Length, int &amp;NumEntries, double *Values, int *Indices) const</td></tr>
<tr class="memdesc:aae1d307174a8205ec5b1198f51c50bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the specified local row in user-provided arrays.  <br /></td></tr>
<tr class="separator:aae1d307174a8205ec5b1198f51c50bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f60443ed35e95869438ce2e21c5fec" id="r_a35f60443ed35e95869438ce2e21c5fec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a35f60443ed35e95869438ce2e21c5fec">ExtractGlobalRowCopy</a> (int GlobalRow, int Length, int &amp;NumEntries, double *Values) const</td></tr>
<tr class="memdesc:a35f60443ed35e95869438ce2e21c5fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the specified global row values in user-provided array.  <br /></td></tr>
<tr class="separator:a35f60443ed35e95869438ce2e21c5fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2ccff74f241b84360a5509d818ff7e" id="r_aed2ccff74f241b84360a5509d818ff7e"><td class="memItemLeft" align="right" valign="top"><a id="aed2ccff74f241b84360a5509d818ff7e" name="aed2ccff74f241b84360a5509d818ff7e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ExtractGlobalRowCopy</b> (long long GlobalRow, int Length, int &amp;NumEntries, double *Values) const</td></tr>
<tr class="separator:aed2ccff74f241b84360a5509d818ff7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989ae9e8183388a46873bd7e0b1e1bea" id="r_a989ae9e8183388a46873bd7e0b1e1bea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a989ae9e8183388a46873bd7e0b1e1bea">ExtractMyRowCopy</a> (int MyRow, int Length, int &amp;NumEntries, double *Values) const</td></tr>
<tr class="memdesc:a989ae9e8183388a46873bd7e0b1e1bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the specified local row values in user-provided array.  <br /></td></tr>
<tr class="separator:a989ae9e8183388a46873bd7e0b1e1bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89f6150eed2c4be33c69bae6ac0a99f" id="r_ae89f6150eed2c4be33c69bae6ac0a99f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ae89f6150eed2c4be33c69bae6ac0a99f">ExtractDiagonalCopy</a> (<a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;Diagonal) const</td></tr>
<tr class="memdesc:ae89f6150eed2c4be33c69bae6ac0a99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the main diagonal in a user-provided vector.  <br /></td></tr>
<tr class="separator:ae89f6150eed2c4be33c69bae6ac0a99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d54454e29a235cc487c3de506bc295d" id="r_a0d54454e29a235cc487c3de506bc295d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a0d54454e29a235cc487c3de506bc295d">ExtractGlobalRowView</a> (int GlobalRow, int &amp;NumEntries, double *&amp;Values, int *&amp;Indices) const</td></tr>
<tr class="memdesc:a0d54454e29a235cc487c3de506bc295d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a view of the specified global row values via pointers to internal data.  <br /></td></tr>
<tr class="separator:a0d54454e29a235cc487c3de506bc295d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16750152466c7e48394da337c8d0d8f1" id="r_a16750152466c7e48394da337c8d0d8f1"><td class="memItemLeft" align="right" valign="top"><a id="a16750152466c7e48394da337c8d0d8f1" name="a16750152466c7e48394da337c8d0d8f1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ExtractGlobalRowView</b> (long long GlobalRow, int &amp;NumEntries, double *&amp;Values, long long *&amp;Indices) const</td></tr>
<tr class="separator:a16750152466c7e48394da337c8d0d8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bac0a8622458dc5eeb25fde0c96d774" id="r_a2bac0a8622458dc5eeb25fde0c96d774"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a2bac0a8622458dc5eeb25fde0c96d774">ExtractMyRowView</a> (int MyRow, int &amp;NumEntries, double *&amp;Values, int *&amp;Indices) const</td></tr>
<tr class="memdesc:a2bac0a8622458dc5eeb25fde0c96d774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a view of the specified local row values via pointers to internal data.  <br /></td></tr>
<tr class="separator:a2bac0a8622458dc5eeb25fde0c96d774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee94425f2bce4365d472a3d32e3be382" id="r_aee94425f2bce4365d472a3d32e3be382"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#aee94425f2bce4365d472a3d32e3be382">ExtractGlobalRowView</a> (int GlobalRow, int &amp;NumEntries, double *&amp;Values) const</td></tr>
<tr class="memdesc:aee94425f2bce4365d472a3d32e3be382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a view of the specified global row values via pointers to internal data.  <br /></td></tr>
<tr class="separator:aee94425f2bce4365d472a3d32e3be382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82463e8a392c1062d42c0057a4ec3231" id="r_a82463e8a392c1062d42c0057a4ec3231"><td class="memItemLeft" align="right" valign="top"><a id="a82463e8a392c1062d42c0057a4ec3231" name="a82463e8a392c1062d42c0057a4ec3231"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ExtractGlobalRowView</b> (long long GlobalRow, int &amp;NumEntries, double *&amp;Values) const</td></tr>
<tr class="separator:a82463e8a392c1062d42c0057a4ec3231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c61ae4ad9bca823e459c3e7b88c0e94" id="r_a0c61ae4ad9bca823e459c3e7b88c0e94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a0c61ae4ad9bca823e459c3e7b88c0e94">ExtractMyRowView</a> (int MyRow, int &amp;NumEntries, double *&amp;Values) const</td></tr>
<tr class="memdesc:a0c61ae4ad9bca823e459c3e7b88c0e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a view of the specified local row values via pointers to internal data.  <br /></td></tr>
<tr class="separator:a0c61ae4ad9bca823e459c3e7b88c0e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computational methods</div></td></tr>
<tr class="memitem:ad028fbe37c3d2ce3f43e2acf2cbb29de" id="r_ad028fbe37c3d2ce3f43e2acf2cbb29de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ad028fbe37c3d2ce3f43e2acf2cbb29de">Multiply</a> (bool TransA, const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x, <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;y) const</td></tr>
<tr class="memdesc:ad028fbe37c3d2ce3f43e2acf2cbb29de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of a <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> multiplied by a <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> x in y.  <br /></td></tr>
<tr class="separator:ad028fbe37c3d2ce3f43e2acf2cbb29de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f75baa68b4784c47a304fb3681a71c1" id="r_a5f75baa68b4784c47a304fb3681a71c1"><td class="memItemLeft" align="right" valign="top"><a id="a5f75baa68b4784c47a304fb3681a71c1" name="a5f75baa68b4784c47a304fb3681a71c1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Multiply1</b> (bool TransA, const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x, <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;y) const</td></tr>
<tr class="separator:a5f75baa68b4784c47a304fb3681a71c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c523205afded500fd81375483029fe6" id="r_a1c523205afded500fd81375483029fe6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a1c523205afded500fd81375483029fe6">Multiply</a> (bool TransA, const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;X, <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;Y) const</td></tr>
<tr class="memdesc:a1c523205afded500fd81375483029fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of a <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> multiplied by a <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> X in Y.  <br /></td></tr>
<tr class="separator:a1c523205afded500fd81375483029fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87c8797a0d9b117e329ab6ac4295612" id="r_ad87c8797a0d9b117e329ab6ac4295612"><td class="memItemLeft" align="right" valign="top"><a id="ad87c8797a0d9b117e329ab6ac4295612" name="ad87c8797a0d9b117e329ab6ac4295612"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Multiply1</b> (bool TransA, const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;X, <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;Y) const</td></tr>
<tr class="separator:ad87c8797a0d9b117e329ab6ac4295612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0d7c00870df3bf3a18db186a290e64" id="r_a4b0d7c00870df3bf3a18db186a290e64"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a4b0d7c00870df3bf3a18db186a290e64">Solve</a> (bool Upper, bool Trans, bool UnitDiagonal, const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x, <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;y) const</td></tr>
<tr class="memdesc:a4b0d7c00870df3bf3a18db186a290e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of a local solve using the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> on a <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> x in y.  <br /></td></tr>
<tr class="separator:a4b0d7c00870df3bf3a18db186a290e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0717ceccbb3713daecdc3ed801f6fab" id="r_ac0717ceccbb3713daecdc3ed801f6fab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ac0717ceccbb3713daecdc3ed801f6fab">Solve</a> (bool Upper, bool Trans, bool UnitDiagonal, const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;X, <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;Y) const</td></tr>
<tr class="memdesc:ac0717ceccbb3713daecdc3ed801f6fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of a local solve using the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> a <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> X in Y.  <br /></td></tr>
<tr class="separator:ac0717ceccbb3713daecdc3ed801f6fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9ed2d21bfc16d0a0e153380a7441de" id="r_a0d9ed2d21bfc16d0a0e153380a7441de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a0d9ed2d21bfc16d0a0e153380a7441de">InvRowSums</a> (<a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x) const</td></tr>
<tr class="memdesc:a0d9ed2d21bfc16d0a0e153380a7441de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse of the sum of absolute values of the rows of the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a>, results returned in x.  <br /></td></tr>
<tr class="separator:a0d9ed2d21bfc16d0a0e153380a7441de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aee2aa1ae277efe9dcdfe0a9b77079a" id="r_a6aee2aa1ae277efe9dcdfe0a9b77079a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a6aee2aa1ae277efe9dcdfe0a9b77079a">InvRowMaxs</a> (<a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x) const</td></tr>
<tr class="memdesc:a6aee2aa1ae277efe9dcdfe0a9b77079a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse of the max of absolute values of the rows of the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a>, results returned in x.  <br /></td></tr>
<tr class="separator:a6aee2aa1ae277efe9dcdfe0a9b77079a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100330317094dc8a19f8feb73b5f0b87" id="r_a100330317094dc8a19f8feb73b5f0b87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a100330317094dc8a19f8feb73b5f0b87">LeftScale</a> (const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x)</td></tr>
<tr class="memdesc:a100330317094dc8a19f8feb73b5f0b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> on the left with a <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> x.  <br /></td></tr>
<tr class="separator:a100330317094dc8a19f8feb73b5f0b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0ce45ccb757975e9ea69e251627663" id="r_a8f0ce45ccb757975e9ea69e251627663"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a8f0ce45ccb757975e9ea69e251627663">InvColSums</a> (<a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x) const</td></tr>
<tr class="memdesc:a8f0ce45ccb757975e9ea69e251627663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse of the sum of absolute values of the columns of the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a>, results returned in x.  <br /></td></tr>
<tr class="separator:a8f0ce45ccb757975e9ea69e251627663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d373346c8d0941917fe2e5cd848e2a" id="r_a58d373346c8d0941917fe2e5cd848e2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a58d373346c8d0941917fe2e5cd848e2a">InvColMaxs</a> (<a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x) const</td></tr>
<tr class="memdesc:a58d373346c8d0941917fe2e5cd848e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the max of absolute values of the columns of the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a>, results returned in x.  <br /></td></tr>
<tr class="separator:a58d373346c8d0941917fe2e5cd848e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136bb231cfe4bb129c6754f224eb0889" id="r_a136bb231cfe4bb129c6754f224eb0889"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a136bb231cfe4bb129c6754f224eb0889">RightScale</a> (const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;x)</td></tr>
<tr class="memdesc:a136bb231cfe4bb129c6754f224eb0889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> on the right with a <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> x.  <br /></td></tr>
<tr class="separator:a136bb231cfe4bb129c6754f224eb0889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix Properties Query Methods</div></td></tr>
<tr class="memitem:a08b8858f8fc28dcc45bf523ccad2cb50" id="r_a08b8858f8fc28dcc45bf523ccad2cb50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50">Filled</a> () const</td></tr>
<tr class="memdesc:a08b8858f8fc28dcc45bf523ccad2cb50"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> has been called, this query returns true, otherwise it returns false.  <br /></td></tr>
<tr class="separator:a08b8858f8fc28dcc45bf523ccad2cb50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab604df6545e7cb7c38eec982719d104" id="r_aab604df6545e7cb7c38eec982719d104"><td class="memItemLeft" align="right" valign="top"><a id="aab604df6545e7cb7c38eec982719d104" name="aab604df6545e7cb7c38eec982719d104"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>StorageOptimized</b> () const</td></tr>
<tr class="memdesc:aab604df6545e7cb7c38eec982719d104"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="classEpetra__CrsMatrix.html#ac54a33eafbaa0a966cf2c0ce454a7d59" title="Make consecutive row index sections contiguous, minimize internal storage used for constructing graph...">OptimizeStorage()</a> has been called, this query returns true, otherwise it returns false. <br /></td></tr>
<tr class="separator:aab604df6545e7cb7c38eec982719d104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1486df3fb52a638e43eb8aa896a1b4c" id="r_ae1486df3fb52a638e43eb8aa896a1b4c"><td class="memItemLeft" align="right" valign="top"><a id="ae1486df3fb52a638e43eb8aa896a1b4c" name="ae1486df3fb52a638e43eb8aa896a1b4c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IndicesAreGlobal</b> () const</td></tr>
<tr class="memdesc:ae1486df3fb52a638e43eb8aa896a1b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If matrix indices has not been transformed to local, this query returns true, otherwise it returns false. <br /></td></tr>
<tr class="separator:ae1486df3fb52a638e43eb8aa896a1b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae10c5b74759484342ed40ced9561f49" id="r_aae10c5b74759484342ed40ced9561f49"><td class="memItemLeft" align="right" valign="top"><a id="aae10c5b74759484342ed40ced9561f49" name="aae10c5b74759484342ed40ced9561f49"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IndicesAreLocal</b> () const</td></tr>
<tr class="memdesc:aae10c5b74759484342ed40ced9561f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">If matrix indices has been transformed to local, this query returns true, otherwise it returns false. <br /></td></tr>
<tr class="separator:aae10c5b74759484342ed40ced9561f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f864987f9c83d3e8f02716d7540055" id="r_ad9f864987f9c83d3e8f02716d7540055"><td class="memItemLeft" align="right" valign="top"><a id="ad9f864987f9c83d3e8f02716d7540055" name="ad9f864987f9c83d3e8f02716d7540055"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IndicesAreContiguous</b> () const</td></tr>
<tr class="memdesc:ad9f864987f9c83d3e8f02716d7540055"><td class="mdescLeft">&#160;</td><td class="mdescRight">If matrix indices are packed into single array (done in <a class="el" href="classEpetra__CrsMatrix.html#ac54a33eafbaa0a966cf2c0ce454a7d59" title="Make consecutive row index sections contiguous, minimize internal storage used for constructing graph...">OptimizeStorage()</a>) return true, otherwise false. <br /></td></tr>
<tr class="separator:ad9f864987f9c83d3e8f02716d7540055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b3492e9b2db7397d6d12a4fddf5ffc" id="r_ab6b3492e9b2db7397d6d12a4fddf5ffc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ab6b3492e9b2db7397d6d12a4fddf5ffc">LowerTriangular</a> () const</td></tr>
<tr class="memdesc:ab6b3492e9b2db7397d6d12a4fddf5ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">If matrix is lower triangular in local index space, this query returns true, otherwise it returns false.  <br /></td></tr>
<tr class="separator:ab6b3492e9b2db7397d6d12a4fddf5ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a4fac8da3d1e717b1fb500f9806e53" id="r_ac6a4fac8da3d1e717b1fb500f9806e53"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ac6a4fac8da3d1e717b1fb500f9806e53">UpperTriangular</a> () const</td></tr>
<tr class="memdesc:ac6a4fac8da3d1e717b1fb500f9806e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">If matrix is upper triangular in local index space, this query returns true, otherwise it returns false.  <br /></td></tr>
<tr class="separator:ac6a4fac8da3d1e717b1fb500f9806e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6b258a0e7301a5fa31c51037622f1e" id="r_adf6b258a0e7301a5fa31c51037622f1e"><td class="memItemLeft" align="right" valign="top"><a id="adf6b258a0e7301a5fa31c51037622f1e" name="adf6b258a0e7301a5fa31c51037622f1e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>NoDiagonal</b> () const</td></tr>
<tr class="memdesc:adf6b258a0e7301a5fa31c51037622f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If matrix has no diagonal entries in global index space, this query returns true, otherwise it returns false. <br /></td></tr>
<tr class="separator:adf6b258a0e7301a5fa31c51037622f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Attribute access functions</div></td></tr>
<tr class="memitem:aea249176fc818ebde242b3a1054ecb34" id="r_aea249176fc818ebde242b3a1054ecb34"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#aea249176fc818ebde242b3a1054ecb34">NormInf</a> () const</td></tr>
<tr class="memdesc:aea249176fc818ebde242b3a1054ecb34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the infinity norm of the global matrix.  <br /></td></tr>
<tr class="separator:aea249176fc818ebde242b3a1054ecb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643dc754bea9373a9f26f9b2f095f677" id="r_a643dc754bea9373a9f26f9b2f095f677"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a643dc754bea9373a9f26f9b2f095f677">NormOne</a> () const</td></tr>
<tr class="memdesc:a643dc754bea9373a9f26f9b2f095f677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the one norm of the global matrix.  <br /></td></tr>
<tr class="separator:a643dc754bea9373a9f26f9b2f095f677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6492f0286e04474efa300d9750e46166" id="r_a6492f0286e04474efa300d9750e46166"><td class="memItemLeft" align="right" valign="top"><a id="a6492f0286e04474efa300d9750e46166" name="a6492f0286e04474efa300d9750e46166"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>NormFrobenius</b> () const</td></tr>
<tr class="memdesc:a6492f0286e04474efa300d9750e46166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the frobenius norm of the global matrix. <br /></td></tr>
<tr class="separator:a6492f0286e04474efa300d9750e46166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6420c1fb13a60a856a1fdcae549fae56" id="r_a6420c1fb13a60a856a1fdcae549fae56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a6420c1fb13a60a856a1fdcae549fae56">NumGlobalNonzeros</a> () const</td></tr>
<tr class="memdesc:a6420c1fb13a60a856a1fdcae549fae56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nonzero entries in the global matrix.  <br /></td></tr>
<tr class="separator:a6420c1fb13a60a856a1fdcae549fae56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5450132a1523598f5487c7a25ef2a765" id="r_a5450132a1523598f5487c7a25ef2a765"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a5450132a1523598f5487c7a25ef2a765">NumGlobalNonzeros64</a> () const</td></tr>
<tr class="separator:a5450132a1523598f5487c7a25ef2a765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0da526e7a65fb75ecb356567e4945f0" id="r_aa0da526e7a65fb75ecb356567e4945f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#aa0da526e7a65fb75ecb356567e4945f0">NumGlobalRows</a> () const</td></tr>
<tr class="memdesc:aa0da526e7a65fb75ecb356567e4945f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of global matrix rows.  <br /></td></tr>
<tr class="separator:aa0da526e7a65fb75ecb356567e4945f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d9decbc70d4ca103eb0eb0e5f4c89a" id="r_a42d9decbc70d4ca103eb0eb0e5f4c89a"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a42d9decbc70d4ca103eb0eb0e5f4c89a">NumGlobalRows64</a> () const</td></tr>
<tr class="separator:a42d9decbc70d4ca103eb0eb0e5f4c89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39970a8fee5716e012aa455306381e6b" id="r_a39970a8fee5716e012aa455306381e6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a39970a8fee5716e012aa455306381e6b">NumGlobalCols</a> () const</td></tr>
<tr class="memdesc:a39970a8fee5716e012aa455306381e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of global matrix columns.  <br /></td></tr>
<tr class="separator:a39970a8fee5716e012aa455306381e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c85e8a878e202db002d3e2240d9709" id="r_af9c85e8a878e202db002d3e2240d9709"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#af9c85e8a878e202db002d3e2240d9709">NumGlobalCols64</a> () const</td></tr>
<tr class="separator:af9c85e8a878e202db002d3e2240d9709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972eeec9930f6dfda76d9ec8f6f106d6" id="r_a972eeec9930f6dfda76d9ec8f6f106d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a972eeec9930f6dfda76d9ec8f6f106d6">NumGlobalDiagonals</a> () const</td></tr>
<tr class="memdesc:a972eeec9930f6dfda76d9ec8f6f106d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of global nonzero diagonal entries, based on global row/column index comparisons.  <br /></td></tr>
<tr class="separator:a972eeec9930f6dfda76d9ec8f6f106d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3fcb9c5391ed9f688e2bad8da07773" id="r_a2c3fcb9c5391ed9f688e2bad8da07773"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a2c3fcb9c5391ed9f688e2bad8da07773">NumGlobalDiagonals64</a> () const</td></tr>
<tr class="separator:a2c3fcb9c5391ed9f688e2bad8da07773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77dec9df2d84dd502c02db9f37d8c5db" id="r_a77dec9df2d84dd502c02db9f37d8c5db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a77dec9df2d84dd502c02db9f37d8c5db">NumMyNonzeros</a> () const</td></tr>
<tr class="memdesc:a77dec9df2d84dd502c02db9f37d8c5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nonzero entries in the calling processor's portion of the matrix.  <br /></td></tr>
<tr class="separator:a77dec9df2d84dd502c02db9f37d8c5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6713140122dc58a27a79064705215e" id="r_ace6713140122dc58a27a79064705215e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ace6713140122dc58a27a79064705215e">NumMyRows</a> () const</td></tr>
<tr class="memdesc:ace6713140122dc58a27a79064705215e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of matrix rows owned by the calling processor.  <br /></td></tr>
<tr class="separator:ace6713140122dc58a27a79064705215e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa8e055646a0cddde3c45047d6502cf" id="r_a1aa8e055646a0cddde3c45047d6502cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a1aa8e055646a0cddde3c45047d6502cf">NumMyCols</a> () const</td></tr>
<tr class="memdesc:a1aa8e055646a0cddde3c45047d6502cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of entries in the set of column-indices that appear on this processor.  <br /></td></tr>
<tr class="separator:a1aa8e055646a0cddde3c45047d6502cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d875e6eb5f8c07567748805332867b" id="r_a93d875e6eb5f8c07567748805332867b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a93d875e6eb5f8c07567748805332867b">NumMyDiagonals</a> () const</td></tr>
<tr class="memdesc:a93d875e6eb5f8c07567748805332867b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of local nonzero diagonal entries, based on global row/column index comparisons.  <br /></td></tr>
<tr class="separator:a93d875e6eb5f8c07567748805332867b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffffac80bdd0a5e25de25cc9fb39f0f" id="r_a0ffffac80bdd0a5e25de25cc9fb39f0f"><td class="memItemLeft" align="right" valign="top"><a id="a0ffffac80bdd0a5e25de25cc9fb39f0f" name="a0ffffac80bdd0a5e25de25cc9fb39f0f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>NumGlobalEntries</b> (long long Row) const</td></tr>
<tr class="memdesc:a0ffffac80bdd0a5e25de25cc9fb39f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of nonzero entries in specified global row on this processor. <br /></td></tr>
<tr class="separator:a0ffffac80bdd0a5e25de25cc9fb39f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02bb27c8361c9e4b7d74ed36f6829311" id="r_a02bb27c8361c9e4b7d74ed36f6829311"><td class="memItemLeft" align="right" valign="top"><a id="a02bb27c8361c9e4b7d74ed36f6829311" name="a02bb27c8361c9e4b7d74ed36f6829311"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>NumAllocatedGlobalEntries</b> (int Row) const</td></tr>
<tr class="memdesc:a02bb27c8361c9e4b7d74ed36f6829311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocated number of nonzero entries in specified global row on this processor. <br /></td></tr>
<tr class="separator:a02bb27c8361c9e4b7d74ed36f6829311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16ae7b9de6c12a05fc3e7200e08acaf" id="r_ac16ae7b9de6c12a05fc3e7200e08acaf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ac16ae7b9de6c12a05fc3e7200e08acaf">MaxNumEntries</a> () const</td></tr>
<tr class="memdesc:ac16ae7b9de6c12a05fc3e7200e08acaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of nonzero entries across all rows on this processor.  <br /></td></tr>
<tr class="separator:ac16ae7b9de6c12a05fc3e7200e08acaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2506b65acc0862903f5d7d75cb12d1c0" id="r_a2506b65acc0862903f5d7d75cb12d1c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a2506b65acc0862903f5d7d75cb12d1c0">GlobalMaxNumEntries</a> () const</td></tr>
<tr class="memdesc:a2506b65acc0862903f5d7d75cb12d1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of nonzero entries across all rows on all processors.  <br /></td></tr>
<tr class="separator:a2506b65acc0862903f5d7d75cb12d1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4030b25cb9be4c7e989481b460d24cf" id="r_ab4030b25cb9be4c7e989481b460d24cf"><td class="memItemLeft" align="right" valign="top"><a id="ab4030b25cb9be4c7e989481b460d24cf" name="ab4030b25cb9be4c7e989481b460d24cf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>NumMyEntries</b> (int Row) const</td></tr>
<tr class="memdesc:ab4030b25cb9be4c7e989481b460d24cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of nonzero entries in specified local row on this processor. <br /></td></tr>
<tr class="separator:ab4030b25cb9be4c7e989481b460d24cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cb1f431a9e6e57bd78b5174f8a332b" id="r_ac2cb1f431a9e6e57bd78b5174f8a332b"><td class="memItemLeft" align="right" valign="top"><a id="ac2cb1f431a9e6e57bd78b5174f8a332b" name="ac2cb1f431a9e6e57bd78b5174f8a332b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>NumAllocatedMyEntries</b> (int Row) const</td></tr>
<tr class="memdesc:ac2cb1f431a9e6e57bd78b5174f8a332b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocated number of nonzero entries in specified local row on this processor. <br /></td></tr>
<tr class="separator:ac2cb1f431a9e6e57bd78b5174f8a332b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e361f88ed2091196c888ad7d9c35b4" id="r_aa5e361f88ed2091196c888ad7d9c35b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#aa5e361f88ed2091196c888ad7d9c35b4">IndexBase</a> () const</td></tr>
<tr class="memdesc:aa5e361f88ed2091196c888ad7d9c35b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index base for row and column indices for this graph.  <br /></td></tr>
<tr class="separator:aa5e361f88ed2091196c888ad7d9c35b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602dea8823b5e5423dc183eeadcdd5d3" id="r_a602dea8823b5e5423dc183eeadcdd5d3"><td class="memItemLeft" align="right" valign="top"><a id="a602dea8823b5e5423dc183eeadcdd5d3" name="a602dea8823b5e5423dc183eeadcdd5d3"></a>
long long&#160;</td><td class="memItemRight" valign="bottom"><b>IndexBase64</b> () const</td></tr>
<tr class="separator:a602dea8823b5e5423dc183eeadcdd5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b159539dcbb15a1578c704e057e3b20" id="r_a1b159539dcbb15a1578c704e057e3b20"><td class="memItemLeft" align="right" valign="top"><a id="a1b159539dcbb15a1578c704e057e3b20" name="a1b159539dcbb15a1578c704e057e3b20"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>StaticGraph</b> ()</td></tr>
<tr class="memdesc:a1b159539dcbb15a1578c704e057e3b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the graph associated with this matrix was pre-constructed and therefore not changeable. <br /></td></tr>
<tr class="separator:a1b159539dcbb15a1578c704e057e3b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ed3d3f3cb0ab79ffceb1974b9a8809" id="r_a98ed3d3f3cb0ab79ffceb1974b9a8809"><td class="memItemLeft" align="right" valign="top"><a id="a98ed3d3f3cb0ab79ffceb1974b9a8809" name="a98ed3d3f3cb0ab79ffceb1974b9a8809"></a>
const <a class="el" href="classEpetra__CrsGraph.html">Epetra_CrsGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Graph</b> () const</td></tr>
<tr class="memdesc:a98ed3d3f3cb0ab79ffceb1974b9a8809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the <a class="el" href="classEpetra__CrsGraph.html" title="Epetra_CrsGraph: A class for constructing and using sparse compressed row graphs.">Epetra_CrsGraph</a> object associated with this matrix. <br /></td></tr>
<tr class="separator:a98ed3d3f3cb0ab79ffceb1974b9a8809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24855eec1cf6aeb201be88ba654d22bf" id="r_a24855eec1cf6aeb201be88ba654d22bf"><td class="memItemLeft" align="right" valign="top"><a id="a24855eec1cf6aeb201be88ba654d22bf" name="a24855eec1cf6aeb201be88ba654d22bf"></a>
const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>RowMap</b> () const</td></tr>
<tr class="memdesc:a24855eec1cf6aeb201be88ba654d22bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> object associated with the rows of this matrix. <br /></td></tr>
<tr class="separator:a24855eec1cf6aeb201be88ba654d22bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c83fee95e71471e118fa91c15809aa2" id="r_a3c83fee95e71471e118fa91c15809aa2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a3c83fee95e71471e118fa91c15809aa2">ReplaceRowMap</a> (const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;newmap)</td></tr>
<tr class="memdesc:a3c83fee95e71471e118fa91c15809aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the current RowMap with the user-specified map object.  <br /></td></tr>
<tr class="separator:a3c83fee95e71471e118fa91c15809aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4506a3e3975010fc801d915f7e6f08ba" id="r_a4506a3e3975010fc801d915f7e6f08ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a4506a3e3975010fc801d915f7e6f08ba">HaveColMap</a> () const</td></tr>
<tr class="memdesc:a4506a3e3975010fc801d915f7e6f08ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if we have a well-defined ColMap, and returns false otherwise.  <br /></td></tr>
<tr class="separator:a4506a3e3975010fc801d915f7e6f08ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c97a06e482fe0368fa4775e2a724109" id="r_a7c97a06e482fe0368fa4775e2a724109"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a7c97a06e482fe0368fa4775e2a724109">ReplaceColMap</a> (const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;newmap)</td></tr>
<tr class="memdesc:a7c97a06e482fe0368fa4775e2a724109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the current ColMap with the user-specified map object.  <br /></td></tr>
<tr class="separator:a7c97a06e482fe0368fa4775e2a724109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0efbedcbd1c34ba7c3d61c7bd5bbf2" id="r_a0d0efbedcbd1c34ba7c3d61c7bd5bbf2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a0d0efbedcbd1c34ba7c3d61c7bd5bbf2">ReplaceDomainMapAndImporter</a> (const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;NewDomainMap, const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> *NewImporter)</td></tr>
<tr class="memdesc:a0d0efbedcbd1c34ba7c3d61c7bd5bbf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the current DomainMap &amp; Importer with the user-specified map object.  <br /></td></tr>
<tr class="separator:a0d0efbedcbd1c34ba7c3d61c7bd5bbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab338ef7689fdb5131c6624a6348e2fa5" id="r_ab338ef7689fdb5131c6624a6348e2fa5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ab338ef7689fdb5131c6624a6348e2fa5">RemoveEmptyProcessesInPlace</a> (const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> *NewMap)</td></tr>
<tr class="memdesc:ab338ef7689fdb5131c6624a6348e2fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove processes owning zero rows from the Maps and their communicator.  <br /></td></tr>
<tr class="separator:ab338ef7689fdb5131c6624a6348e2fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3589bfaac41458ab698d3d53780e61" id="r_aab3589bfaac41458ab698d3d53780e61"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#aab3589bfaac41458ab698d3d53780e61">ColMap</a> () const</td></tr>
<tr class="memdesc:aab3589bfaac41458ab698d3d53780e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> object that describes the set of column-indices that appear in each processor's locally owned matrix rows.  <br /></td></tr>
<tr class="separator:aab3589bfaac41458ab698d3d53780e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c6024783cb8f9a333f16b9ea5aa40c" id="r_ac8c6024783cb8f9a333f16b9ea5aa40c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c">DomainMap</a> () const</td></tr>
<tr class="memdesc:ac8c6024783cb8f9a333f16b9ea5aa40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> object associated with the domain of this matrix operator.  <br /></td></tr>
<tr class="separator:ac8c6024783cb8f9a333f16b9ea5aa40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9acf8281b9f9177f6271497fc4cd9222" id="r_a9acf8281b9f9177f6271497fc4cd9222"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222">RangeMap</a> () const</td></tr>
<tr class="memdesc:a9acf8281b9f9177f6271497fc4cd9222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> object associated with the range of this matrix operator.  <br /></td></tr>
<tr class="separator:a9acf8281b9f9177f6271497fc4cd9222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4e28048f914a9b4f21382639c2246e" id="r_acf4e28048f914a9b4f21382639c2246e"><td class="memItemLeft" align="right" valign="top"><a id="acf4e28048f914a9b4f21382639c2246e" name="acf4e28048f914a9b4f21382639c2246e"></a>
const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Importer</b> () const</td></tr>
<tr class="memdesc:acf4e28048f914a9b4f21382639c2246e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classEpetra__Import.html" title="Epetra_Import: This class builds an import object for efficient importing of off-processor elements.">Epetra_Import</a> object that contains the import operations for distributed operations. <br /></td></tr>
<tr class="separator:acf4e28048f914a9b4f21382639c2246e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16227ba1f3f3548e5b84568cd21f3e3b" id="r_a16227ba1f3f3548e5b84568cd21f3e3b"><td class="memItemLeft" align="right" valign="top"><a id="a16227ba1f3f3548e5b84568cd21f3e3b" name="a16227ba1f3f3548e5b84568cd21f3e3b"></a>
const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Exporter</b> () const</td></tr>
<tr class="memdesc:a16227ba1f3f3548e5b84568cd21f3e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classEpetra__Export.html" title="Epetra_Export: This class builds an export object for efficient exporting of off-processor elements.">Epetra_Export</a> object that contains the export operations for distributed operations. <br /></td></tr>
<tr class="separator:a16227ba1f3f3548e5b84568cd21f3e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997eeee1d81be3d5b408b0bed58cd351" id="r_a997eeee1d81be3d5b408b0bed58cd351"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a997eeee1d81be3d5b408b0bed58cd351">Comm</a> () const</td></tr>
<tr class="memdesc:a997eeee1d81be3d5b408b0bed58cd351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> communicator associated with this matrix.  <br /></td></tr>
<tr class="separator:a997eeee1d81be3d5b408b0bed58cd351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Local/Global ID methods</div></td></tr>
<tr class="memitem:a59b0877e4b3af79213cb06a968fcec3f" id="r_a59b0877e4b3af79213cb06a968fcec3f"><td class="memItemLeft" align="right" valign="top"><a id="a59b0877e4b3af79213cb06a968fcec3f" name="a59b0877e4b3af79213cb06a968fcec3f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>LRID</b> (int GRID_in) const</td></tr>
<tr class="memdesc:a59b0877e4b3af79213cb06a968fcec3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the local row index for given global row index, returns -1 if no local row for this global row. <br /></td></tr>
<tr class="separator:a59b0877e4b3af79213cb06a968fcec3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0982b9fbe77df91c904667829392008e" id="r_a0982b9fbe77df91c904667829392008e"><td class="memItemLeft" align="right" valign="top"><a id="a0982b9fbe77df91c904667829392008e" name="a0982b9fbe77df91c904667829392008e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>LRID</b> (long long GRID_in) const</td></tr>
<tr class="separator:a0982b9fbe77df91c904667829392008e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959f23496bde5d80cb074d66fbef5b1d" id="r_a959f23496bde5d80cb074d66fbef5b1d"><td class="memItemLeft" align="right" valign="top"><a id="a959f23496bde5d80cb074d66fbef5b1d" name="a959f23496bde5d80cb074d66fbef5b1d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>GRID</b> (int LRID_in) const</td></tr>
<tr class="memdesc:a959f23496bde5d80cb074d66fbef5b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the global row index for give local row index, returns IndexBase-1 if we don't have this local row. <br /></td></tr>
<tr class="separator:a959f23496bde5d80cb074d66fbef5b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add34e8f40add2367814108153bb58e09" id="r_add34e8f40add2367814108153bb58e09"><td class="memItemLeft" align="right" valign="top"><a id="add34e8f40add2367814108153bb58e09" name="add34e8f40add2367814108153bb58e09"></a>
long long&#160;</td><td class="memItemRight" valign="bottom"><b>GRID64</b> (int LRID_in) const</td></tr>
<tr class="separator:add34e8f40add2367814108153bb58e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402c29f8059e4ed6c113c612e36006a3" id="r_a402c29f8059e4ed6c113c612e36006a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a402c29f8059e4ed6c113c612e36006a3">LCID</a> (int GCID_in) const</td></tr>
<tr class="memdesc:a402c29f8059e4ed6c113c612e36006a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the local column index for given global column index, returns -1 if no local column for this global column.  <br /></td></tr>
<tr class="separator:a402c29f8059e4ed6c113c612e36006a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5baa4f10ec3d35ae910a72efcf26e16a" id="r_a5baa4f10ec3d35ae910a72efcf26e16a"><td class="memItemLeft" align="right" valign="top"><a id="a5baa4f10ec3d35ae910a72efcf26e16a" name="a5baa4f10ec3d35ae910a72efcf26e16a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>LCID</b> (long long GCID_in) const</td></tr>
<tr class="separator:a5baa4f10ec3d35ae910a72efcf26e16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01cc7e29ab441e2bffc75acd487ee804" id="r_a01cc7e29ab441e2bffc75acd487ee804"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a01cc7e29ab441e2bffc75acd487ee804">GCID</a> (int LCID_in) const</td></tr>
<tr class="memdesc:a01cc7e29ab441e2bffc75acd487ee804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the global column index for give local column index, returns IndexBase-1 if we don't have this local column.  <br /></td></tr>
<tr class="separator:a01cc7e29ab441e2bffc75acd487ee804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9939251e71fc2c755b41bf317999c9f" id="r_af9939251e71fc2c755b41bf317999c9f"><td class="memItemLeft" align="right" valign="top"><a id="af9939251e71fc2c755b41bf317999c9f" name="af9939251e71fc2c755b41bf317999c9f"></a>
long long&#160;</td><td class="memItemRight" valign="bottom"><b>GCID64</b> (int LCID_in) const</td></tr>
<tr class="separator:af9939251e71fc2c755b41bf317999c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ba0e25621d9bb7be02196a4dff2f78" id="r_a25ba0e25621d9bb7be02196a4dff2f78"><td class="memItemLeft" align="right" valign="top"><a id="a25ba0e25621d9bb7be02196a4dff2f78" name="a25ba0e25621d9bb7be02196a4dff2f78"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MyGRID</b> (int GRID_in) const</td></tr>
<tr class="memdesc:a25ba0e25621d9bb7be02196a4dff2f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the GRID passed in belongs to the calling processor in this map, otherwise returns false. <br /></td></tr>
<tr class="separator:a25ba0e25621d9bb7be02196a4dff2f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57950cd066e9ca5e35673080a53240f" id="r_ac57950cd066e9ca5e35673080a53240f"><td class="memItemLeft" align="right" valign="top"><a id="ac57950cd066e9ca5e35673080a53240f" name="ac57950cd066e9ca5e35673080a53240f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MyGRID</b> (long long GRID_in) const</td></tr>
<tr class="separator:ac57950cd066e9ca5e35673080a53240f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0355c11c6f69df1b12e4df2408e71262" id="r_a0355c11c6f69df1b12e4df2408e71262"><td class="memItemLeft" align="right" valign="top"><a id="a0355c11c6f69df1b12e4df2408e71262" name="a0355c11c6f69df1b12e4df2408e71262"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MyLRID</b> (int LRID_in) const</td></tr>
<tr class="memdesc:a0355c11c6f69df1b12e4df2408e71262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the LRID passed in belongs to the calling processor in this map, otherwise returns false. <br /></td></tr>
<tr class="separator:a0355c11c6f69df1b12e4df2408e71262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6da673b8d502adcc0501cf997f6986" id="r_afc6da673b8d502adcc0501cf997f6986"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#afc6da673b8d502adcc0501cf997f6986">MyGCID</a> (int GCID_in) const</td></tr>
<tr class="memdesc:afc6da673b8d502adcc0501cf997f6986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the GCID passed in belongs to the calling processor in this map, otherwise returns false.  <br /></td></tr>
<tr class="separator:afc6da673b8d502adcc0501cf997f6986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02b3558022f1092c85de4410601208b" id="r_ac02b3558022f1092c85de4410601208b"><td class="memItemLeft" align="right" valign="top"><a id="ac02b3558022f1092c85de4410601208b" name="ac02b3558022f1092c85de4410601208b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MyGCID</b> (long long GCID_in) const</td></tr>
<tr class="separator:ac02b3558022f1092c85de4410601208b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c15615f37a288c4f45499f9ffd45ac9" id="r_a7c15615f37a288c4f45499f9ffd45ac9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a7c15615f37a288c4f45499f9ffd45ac9">MyLCID</a> (int LCID_in) const</td></tr>
<tr class="memdesc:a7c15615f37a288c4f45499f9ffd45ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the LRID passed in belongs to the calling processor in this map, otherwise returns false.  <br /></td></tr>
<tr class="separator:a7c15615f37a288c4f45499f9ffd45ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350faf13052a5cc84fc65d0d54588ed5" id="r_a350faf13052a5cc84fc65d0d54588ed5"><td class="memItemLeft" align="right" valign="top"><a id="a350faf13052a5cc84fc65d0d54588ed5" name="a350faf13052a5cc84fc65d0d54588ed5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MyGlobalRow</b> (int GID) const</td></tr>
<tr class="memdesc:a350faf13052a5cc84fc65d0d54588ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true of GID is owned by the calling processor, otherwise it returns false. <br /></td></tr>
<tr class="separator:a350faf13052a5cc84fc65d0d54588ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e7c4c7dc409614651c240749a4dc8a" id="r_a90e7c4c7dc409614651c240749a4dc8a"><td class="memItemLeft" align="right" valign="top"><a id="a90e7c4c7dc409614651c240749a4dc8a" name="a90e7c4c7dc409614651c240749a4dc8a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MyGlobalRow</b> (long long GID) const</td></tr>
<tr class="separator:a90e7c4c7dc409614651c240749a4dc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">I/O Methods</div></td></tr>
<tr class="memitem:af5e117569991b807df5386868da10a78" id="r_af5e117569991b807df5386868da10a78"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#af5e117569991b807df5386868da10a78">Print</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:af5e117569991b807df5386868da10a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print method.  <br /></td></tr>
<tr class="separator:af5e117569991b807df5386868da10a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Additional methods required to support the Epetra_Operator interface</div></td></tr>
<tr class="memitem:a88f19abe10ac0e5469292142c7c96f05" id="r_a88f19abe10ac0e5469292142c7c96f05"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a88f19abe10ac0e5469292142c7c96f05">Label</a> () const</td></tr>
<tr class="memdesc:a88f19abe10ac0e5469292142c7c96f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a character string describing the operator.  <br /></td></tr>
<tr class="separator:a88f19abe10ac0e5469292142c7c96f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859bf40b4652b385d06235450dcda7d8" id="r_a859bf40b4652b385d06235450dcda7d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a859bf40b4652b385d06235450dcda7d8">SetUseTranspose</a> (bool UseTranspose_in)</td></tr>
<tr class="memdesc:a859bf40b4652b385d06235450dcda7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set true, transpose of this operator will be applied.  <br /></td></tr>
<tr class="separator:a859bf40b4652b385d06235450dcda7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71714f462b0e0218cf6c0c9f6a65353" id="r_aa71714f462b0e0218cf6c0c9f6a65353"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#aa71714f462b0e0218cf6c0c9f6a65353">Apply</a> (const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;X, <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;Y) const</td></tr>
<tr class="memdesc:aa71714f462b0e0218cf6c0c9f6a65353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of a <a class="el" href="classEpetra__Operator.html" title="Epetra_Operator: A pure virtual class for using real-valued double-precision operators.">Epetra_Operator</a> applied to a <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> X in Y.  <br /></td></tr>
<tr class="separator:aa71714f462b0e0218cf6c0c9f6a65353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df56e43070f908dec709b1a19348cee" id="r_a7df56e43070f908dec709b1a19348cee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a7df56e43070f908dec709b1a19348cee">ApplyInverse</a> (const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;X, <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;Y) const</td></tr>
<tr class="memdesc:a7df56e43070f908dec709b1a19348cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of a <a class="el" href="classEpetra__Operator.html" title="Epetra_Operator: A pure virtual class for using real-valued double-precision operators.">Epetra_Operator</a> inverse applied to an <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> X in Y.  <br /></td></tr>
<tr class="separator:a7df56e43070f908dec709b1a19348cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f03b8c321e530a55ebc2df1553dde9f" id="r_a5f03b8c321e530a55ebc2df1553dde9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a5f03b8c321e530a55ebc2df1553dde9f">HasNormInf</a> () const</td></tr>
<tr class="memdesc:a5f03b8c321e530a55ebc2df1553dde9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true because this class can compute an Inf-norm.  <br /></td></tr>
<tr class="separator:a5f03b8c321e530a55ebc2df1553dde9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd834231c77c941d11ce1d0f1ddb727" id="r_a0cd834231c77c941d11ce1d0f1ddb727"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a0cd834231c77c941d11ce1d0f1ddb727">UseTranspose</a> () const</td></tr>
<tr class="memdesc:a0cd834231c77c941d11ce1d0f1ddb727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current UseTranspose setting.  <br /></td></tr>
<tr class="separator:a0cd834231c77c941d11ce1d0f1ddb727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc075f22e741f7d6c186eb20f2498bf9" id="r_adc075f22e741f7d6c186eb20f2498bf9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#adc075f22e741f7d6c186eb20f2498bf9">OperatorDomainMap</a> () const</td></tr>
<tr class="memdesc:adc075f22e741f7d6c186eb20f2498bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> object associated with the domain of this matrix operator.  <br /></td></tr>
<tr class="separator:adc075f22e741f7d6c186eb20f2498bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b97f29a7febcea4d8926548a413c650" id="r_a2b97f29a7febcea4d8926548a413c650"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a2b97f29a7febcea4d8926548a413c650">OperatorRangeMap</a> () const</td></tr>
<tr class="memdesc:a2b97f29a7febcea4d8926548a413c650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> object associated with the range of this matrix operator.  <br /></td></tr>
<tr class="separator:a2b97f29a7febcea4d8926548a413c650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Additional methods required to implement Epetra_RowMatrix interface</div></td></tr>
<tr class="memitem:abd6663818c7bb8867e87907666a1b41e" id="r_abd6663818c7bb8867e87907666a1b41e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#abd6663818c7bb8867e87907666a1b41e">NumMyRowEntries</a> (int MyRow, int &amp;NumEntries) const</td></tr>
<tr class="memdesc:abd6663818c7bb8867e87907666a1b41e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current number of values stored for the specified local row.  <br /></td></tr>
<tr class="separator:abd6663818c7bb8867e87907666a1b41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb31423007dc9e3d005782861bcf35b1" id="r_aeb31423007dc9e3d005782861bcf35b1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#aeb31423007dc9e3d005782861bcf35b1">Map</a> () const</td></tr>
<tr class="memdesc:aeb31423007dc9e3d005782861bcf35b1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__CrsMatrix.html#aeb31423007dc9e3d005782861bcf35b1" title="Map() method inherited from Epetra_DistObject.">Map()</a> method inherited from <a class="el" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi-vectors, vectors and matrices in pa...">Epetra_DistObject</a>.  <br /></td></tr>
<tr class="separator:aeb31423007dc9e3d005782861bcf35b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cf38cfbefc8f9410ca65c35a65a130" id="r_ae8cf38cfbefc8f9410ca65c35a65a130"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ae8cf38cfbefc8f9410ca65c35a65a130">RowMatrixRowMap</a> () const</td></tr>
<tr class="memdesc:ae8cf38cfbefc8f9410ca65c35a65a130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> object associated with the rows of this matrix.  <br /></td></tr>
<tr class="separator:ae8cf38cfbefc8f9410ca65c35a65a130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fc2afcabadee62112e6e51375fabdf" id="r_ac6fc2afcabadee62112e6e51375fabdf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ac6fc2afcabadee62112e6e51375fabdf">RowMatrixColMap</a> () const</td></tr>
<tr class="memdesc:ac6fc2afcabadee62112e6e51375fabdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> object associated with columns of this matrix.  <br /></td></tr>
<tr class="separator:ac6fc2afcabadee62112e6e51375fabdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d913cfd97ffa19fcdd062ae7098cff4" id="r_a5d913cfd97ffa19fcdd062ae7098cff4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a5d913cfd97ffa19fcdd062ae7098cff4">RowMatrixImporter</a> () const</td></tr>
<tr class="memdesc:a5d913cfd97ffa19fcdd062ae7098cff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classEpetra__Import.html" title="Epetra_Import: This class builds an import object for efficient importing of off-processor elements.">Epetra_Import</a> object that contains the import operations for distributed operations.  <br /></td></tr>
<tr class="separator:a5d913cfd97ffa19fcdd062ae7098cff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Inlined Operator Methods</div></td></tr>
<tr class="memitem:ae7a19b7a5857f7940bce56f86e73b73e" id="r_ae7a19b7a5857f7940bce56f86e73b73e"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ae7a19b7a5857f7940bce56f86e73b73e">operator[]</a> (int Loc)</td></tr>
<tr class="memdesc:ae7a19b7a5857f7940bce56f86e73b73e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined bracket operator for fast access to data. (Const and Non-const versions)  <br /></td></tr>
<tr class="separator:ae7a19b7a5857f7940bce56f86e73b73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff446bf53ae4e14c2467336748e22f4" id="r_a1ff446bf53ae4e14c2467336748e22f4"><td class="memItemLeft" align="right" valign="top"><a id="a1ff446bf53ae4e14c2467336748e22f4" name="a1ff446bf53ae4e14c2467336748e22f4"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (int Loc) const</td></tr>
<tr class="separator:a1ff446bf53ae4e14c2467336748e22f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Expert-only methods: These methods are intended for experts only and have some risk of changing in the future, since they rely on underlying data structure assumptions</div></td></tr>
<tr class="memitem:a9fc55fd3394fc25867ba0d2e8a730fdc" id="r_a9fc55fd3394fc25867ba0d2e8a730fdc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a9fc55fd3394fc25867ba0d2e8a730fdc">ExtractCrsDataPointers</a> (int *&amp;IndexOffset, int *&amp;Indices, double *&amp;Values_in) const</td></tr>
<tr class="memdesc:a9fc55fd3394fc25867ba0d2e8a730fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns internal data pointers associated with Crs matrix format.  <br /></td></tr>
<tr class="separator:a9fc55fd3394fc25867ba0d2e8a730fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace936ff3ff41b09aa79ec7ed070f960" id="r_aace936ff3ff41b09aa79ec7ed070f960"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEpetra__IntSerialDenseVector.html">Epetra_IntSerialDenseVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#aace936ff3ff41b09aa79ec7ed070f960">ExpertExtractIndexOffset</a> ()</td></tr>
<tr class="memdesc:aace936ff3ff41b09aa79ec7ed070f960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the <a class="el" href="classEpetra__IntSerialDenseVector.html" title="Epetra_IntSerialDenseVector: A class for constructing and using dense vectors.">Epetra_IntSerialDenseVector</a> used to hold the local IndexOffsets (CRS rowptr)  <br /></td></tr>
<tr class="separator:aace936ff3ff41b09aa79ec7ed070f960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6548de37ad7852d2a0c391ebd0bec49" id="r_ad6548de37ad7852d2a0c391ebd0bec49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEpetra__IntSerialDenseVector.html">Epetra_IntSerialDenseVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ad6548de37ad7852d2a0c391ebd0bec49">ExpertExtractIndices</a> ()</td></tr>
<tr class="memdesc:ad6548de37ad7852d2a0c391ebd0bec49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the <a class="el" href="classEpetra__IntSerialDenseVector.html" title="Epetra_IntSerialDenseVector: A class for constructing and using dense vectors.">Epetra_IntSerialDenseVector</a> used to hold the local All_Indices (CRS colind)  <br /></td></tr>
<tr class="separator:ad6548de37ad7852d2a0c391ebd0bec49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb04d17c51c3029e14031a90c0c0ef78" id="r_afb04d17c51c3029e14031a90c0c0ef78"><td class="memItemLeft" align="right" valign="top">double *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#afb04d17c51c3029e14031a90c0c0ef78">ExpertExtractValues</a> ()</td></tr>
<tr class="memdesc:afb04d17c51c3029e14031a90c0c0ef78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the double* used to hold the values array.  <br /></td></tr>
<tr class="separator:afb04d17c51c3029e14031a90c0c0ef78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3753556d7dc03d2b66b1b1a3be5c1795" id="r_a3753556d7dc03d2b66b1b1a3be5c1795"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a3753556d7dc03d2b66b1b1a3be5c1795">ExpertStaticFillComplete</a> (const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;<a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c">DomainMap</a>, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;<a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222">RangeMap</a>, const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> *<a class="el" href="classEpetra__CrsMatrix.html#acf4e28048f914a9b4f21382639c2246e">Importer</a>=0, const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> *<a class="el" href="classEpetra__CrsMatrix.html#a16227ba1f3f3548e5b84568cd21f3e3b">Exporter</a>=0, int <a class="el" href="classEpetra__CrsMatrix.html#a93d875e6eb5f8c07567748805332867b">NumMyDiagonals</a>=-1)</td></tr>
<tr class="memdesc:a3753556d7dc03d2b66b1b1a3be5c1795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a FillComplete on an object that aready has filled CRS data.  <br /></td></tr>
<tr class="separator:a3753556d7dc03d2b66b1b1a3be5c1795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab074df197e9d79057217bf7e8de4fa66" id="r_ab074df197e9d79057217bf7e8de4fa66"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ab074df197e9d79057217bf7e8de4fa66">ExpertMakeUniqueCrsGraphData</a> ()</td></tr>
<tr class="memdesc:ab074df197e9d79057217bf7e8de4fa66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes sure this matrix has a unique CrsGraphData object.  <br /></td></tr>
<tr class="separator:ab074df197e9d79057217bf7e8de4fa66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5672eb590bbd4bf5f6124af1f66f3be" id="r_ae5672eb590bbd4bf5f6124af1f66f3be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ae5672eb590bbd4bf5f6124af1f66f3be">SortGhostsAssociatedWithEachProcessor</a> (bool Flag)</td></tr>
<tr class="memdesc:ae5672eb590bbd4bf5f6124af1f66f3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> to locally order ghostnodes associated with each remote processor in ascending order.  <br /></td></tr>
<tr class="separator:ae5672eb590bbd4bf5f6124af1f66f3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__DistObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__DistObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__DistObject.html">Epetra_DistObject</a></td></tr>
<tr class="memitem:aea928fbc32a281b5038a149bc7ff766a inherit pub_methods_classEpetra__DistObject" id="r_aea928fbc32a281b5038a149bc7ff766a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__DistObject.html#aea928fbc32a281b5038a149bc7ff766a">Epetra_DistObject</a> (const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;<a class="el" href="classEpetra__DistObject.html#a00702a53a4a8142f249639d254e760cd">Map</a>)</td></tr>
<tr class="memdesc:aea928fbc32a281b5038a149bc7ff766a inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic <a class="el" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi-vectors, vectors and matrices in pa...">Epetra_DistObject</a> constuctor.  <br /></td></tr>
<tr class="separator:aea928fbc32a281b5038a149bc7ff766a inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73d8a91a6389a526fc7e08a8a1b043b inherit pub_methods_classEpetra__DistObject" id="r_ac73d8a91a6389a526fc7e08a8a1b043b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__DistObject.html#ac73d8a91a6389a526fc7e08a8a1b043b">Epetra_DistObject</a> (const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;<a class="el" href="classEpetra__DistObject.html#a00702a53a4a8142f249639d254e760cd">Map</a>, const char *const <a class="el" href="classEpetra__Object.html#a1910d1c04e70ac482f7e377b271f6c26">Label</a>)</td></tr>
<tr class="separator:ac73d8a91a6389a526fc7e08a8a1b043b inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09204a59077097b73d3cf70e862feaf9 inherit pub_methods_classEpetra__DistObject" id="r_a09204a59077097b73d3cf70e862feaf9"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_DistObject</b> (const <a class="el" href="classEpetra__DistObject.html">Epetra_DistObject</a> &amp;Source)</td></tr>
<tr class="memdesc:a09204a59077097b73d3cf70e862feaf9 inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi-vectors, vectors and matrices in pa...">Epetra_DistObject</a> copy constructor. <br /></td></tr>
<tr class="separator:a09204a59077097b73d3cf70e862feaf9 inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41082a7526d3aa88f79d57805e5b9337 inherit pub_methods_classEpetra__DistObject" id="r_a41082a7526d3aa88f79d57805e5b9337"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_DistObject</b> ()</td></tr>
<tr class="memdesc:a41082a7526d3aa88f79d57805e5b9337 inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi-vectors, vectors and matrices in pa...">Epetra_DistObject</a> destructor. <br /></td></tr>
<tr class="separator:a41082a7526d3aa88f79d57805e5b9337 inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393f365177c485ab1c30f288514f9297 inherit pub_methods_classEpetra__DistObject" id="r_a393f365177c485ab1c30f288514f9297"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__DistObject.html#a393f365177c485ab1c30f288514f9297">Import</a> (const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;A, const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> &amp;Importer, <a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020f">Epetra_CombineMode</a> CombineMode, const <a class="el" href="classEpetra__OffsetIndex.html">Epetra_OffsetIndex</a> *Indexor=0)</td></tr>
<tr class="memdesc:a393f365177c485ab1c30f288514f9297 inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imports an <a class="el" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi-vectors, vectors and matrices in pa...">Epetra_DistObject</a> using the <a class="el" href="classEpetra__Import.html" title="Epetra_Import: This class builds an import object for efficient importing of off-processor elements.">Epetra_Import</a> object.  <br /></td></tr>
<tr class="separator:a393f365177c485ab1c30f288514f9297 inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac1b1da995e88db2ae67cc02ad37dc8 inherit pub_methods_classEpetra__DistObject" id="r_aeac1b1da995e88db2ae67cc02ad37dc8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__DistObject.html#aeac1b1da995e88db2ae67cc02ad37dc8">Import</a> (const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;A, const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> &amp;Exporter, <a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020f">Epetra_CombineMode</a> CombineMode, const <a class="el" href="classEpetra__OffsetIndex.html">Epetra_OffsetIndex</a> *Indexor=0)</td></tr>
<tr class="memdesc:aeac1b1da995e88db2ae67cc02ad37dc8 inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imports an <a class="el" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi-vectors, vectors and matrices in pa...">Epetra_DistObject</a> using the <a class="el" href="classEpetra__Export.html" title="Epetra_Export: This class builds an export object for efficient exporting of off-processor elements.">Epetra_Export</a> object.  <br /></td></tr>
<tr class="separator:aeac1b1da995e88db2ae67cc02ad37dc8 inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a69d5a64168c02fadfc6c55ecd5a1c inherit pub_methods_classEpetra__DistObject" id="r_a88a69d5a64168c02fadfc6c55ecd5a1c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__DistObject.html#a88a69d5a64168c02fadfc6c55ecd5a1c">Export</a> (const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;A, const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> &amp;Importer, <a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020f">Epetra_CombineMode</a> CombineMode, const <a class="el" href="classEpetra__OffsetIndex.html">Epetra_OffsetIndex</a> *Indexor=0)</td></tr>
<tr class="memdesc:a88a69d5a64168c02fadfc6c55ecd5a1c inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports an <a class="el" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi-vectors, vectors and matrices in pa...">Epetra_DistObject</a> using the <a class="el" href="classEpetra__Import.html" title="Epetra_Import: This class builds an import object for efficient importing of off-processor elements.">Epetra_Import</a> object.  <br /></td></tr>
<tr class="separator:a88a69d5a64168c02fadfc6c55ecd5a1c inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c537c6cbcf366a986227496c6aa79ee inherit pub_methods_classEpetra__DistObject" id="r_a8c537c6cbcf366a986227496c6aa79ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__DistObject.html#a8c537c6cbcf366a986227496c6aa79ee">Export</a> (const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;A, const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> &amp;Exporter, <a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020f">Epetra_CombineMode</a> CombineMode, const <a class="el" href="classEpetra__OffsetIndex.html">Epetra_OffsetIndex</a> *Indexor=0)</td></tr>
<tr class="memdesc:a8c537c6cbcf366a986227496c6aa79ee inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports an <a class="el" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi-vectors, vectors and matrices in pa...">Epetra_DistObject</a> using the <a class="el" href="classEpetra__Export.html" title="Epetra_Export: This class builds an export object for efficient exporting of off-processor elements.">Epetra_Export</a> object.  <br /></td></tr>
<tr class="separator:a8c537c6cbcf366a986227496c6aa79ee inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00702a53a4a8142f249639d254e760cd inherit pub_methods_classEpetra__DistObject" id="r_a00702a53a4a8142f249639d254e760cd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__DistObject.html#a00702a53a4a8142f249639d254e760cd">Map</a> () const</td></tr>
<tr class="memdesc:a00702a53a4a8142f249639d254e760cd inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the address of the <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> for this multi-vector.  <br /></td></tr>
<tr class="separator:a00702a53a4a8142f249639d254e760cd inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2e2c38a27e224f15fce659e00fc9c0 inherit pub_methods_classEpetra__DistObject" id="r_aad2e2c38a27e224f15fce659e00fc9c0"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Comm</b> () const</td></tr>
<tr class="memdesc:aad2e2c38a27e224f15fce659e00fc9c0 inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the address of the <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> for this multi-vector. <br /></td></tr>
<tr class="separator:aad2e2c38a27e224f15fce659e00fc9c0 inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c1fa2bf7389cf67ea23d1e84343046 inherit pub_methods_classEpetra__DistObject" id="r_a04c1fa2bf7389cf67ea23d1e84343046"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>DistributedGlobal</b> () const</td></tr>
<tr class="memdesc:a04c1fa2bf7389cf67ea23d1e84343046 inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this multi-vector is distributed global, i.e., not local replicated. <br /></td></tr>
<tr class="separator:a04c1fa2bf7389cf67ea23d1e84343046 inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__Object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__Object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__Object.html">Epetra_Object</a></td></tr>
<tr class="memitem:a7676631aca0d619c4e8d3e877c2b87a2 inherit pub_methods_classEpetra__Object" id="r_a7676631aca0d619c4e8d3e877c2b87a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a7676631aca0d619c4e8d3e877c2b87a2">Epetra_Object</a> (int TracebackModeIn=-1, bool set_label=true)</td></tr>
<tr class="memdesc:a7676631aca0d619c4e8d3e877c2b87a2 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Constructor.  <br /></td></tr>
<tr class="separator:a7676631aca0d619c4e8d3e877c2b87a2 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf156d9c8874a2a455ec305826c7313f inherit pub_methods_classEpetra__Object" id="r_acf156d9c8874a2a455ec305826c7313f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#acf156d9c8874a2a455ec305826c7313f">Epetra_Object</a> (const char *const <a class="el" href="classEpetra__Object.html#a1910d1c04e70ac482f7e377b271f6c26">Label</a>, int TracebackModeIn=-1)</td></tr>
<tr class="memdesc:acf156d9c8874a2a455ec305826c7313f inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Constructor.  <br /></td></tr>
<tr class="separator:acf156d9c8874a2a455ec305826c7313f inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f8bd631f2a97276ea07cea8c9c7057 inherit pub_methods_classEpetra__Object" id="r_ac5f8bd631f2a97276ea07cea8c9c7057"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#ac5f8bd631f2a97276ea07cea8c9c7057">Epetra_Object</a> (const <a class="el" href="classEpetra__Object.html">Epetra_Object</a> &amp;Object)</td></tr>
<tr class="memdesc:ac5f8bd631f2a97276ea07cea8c9c7057 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Copy Constructor.  <br /></td></tr>
<tr class="separator:ac5f8bd631f2a97276ea07cea8c9c7057 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742c256d523738e458d0256f72ba9e4b inherit pub_methods_classEpetra__Object" id="r_a742c256d523738e458d0256f72ba9e4b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a742c256d523738e458d0256f72ba9e4b">~Epetra_Object</a> ()</td></tr>
<tr class="memdesc:a742c256d523738e458d0256f72ba9e4b inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Destructor.  <br /></td></tr>
<tr class="separator:a742c256d523738e458d0256f72ba9e4b inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff5c5266120410acbe6ccb63734b5c8 inherit pub_methods_classEpetra__Object" id="r_a9ff5c5266120410acbe6ccb63734b5c8"><td class="memItemLeft" align="right" valign="top">
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>ReportError</b> (const std::string Message, int ErrorCode) const</td></tr>
<tr class="memdesc:a9ff5c5266120410acbe6ccb63734b5c8 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error reporting method. <br /></td></tr>
<tr class="separator:a9ff5c5266120410acbe6ccb63734b5c8 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049c5235b19bd286f95914b547b9f528 inherit pub_methods_classEpetra__Object" id="r_a049c5235b19bd286f95914b547b9f528"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a049c5235b19bd286f95914b547b9f528">SetLabel</a> (const char *const <a class="el" href="classEpetra__Object.html#a1910d1c04e70ac482f7e377b271f6c26">Label</a>)</td></tr>
<tr class="memdesc:a049c5235b19bd286f95914b547b9f528 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Label definition using char *.  <br /></td></tr>
<tr class="separator:a049c5235b19bd286f95914b547b9f528 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__SrcDistObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__SrcDistObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a></td></tr>
<tr class="memitem:a9f7ce0515cfecef2d90543d0c572d3bc inherit pub_methods_classEpetra__SrcDistObject" id="r_a9f7ce0515cfecef2d90543d0c572d3bc"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_SrcDistObject</b> ()</td></tr>
<tr class="memdesc:a9f7ce0515cfecef2d90543d0c572d3bc inherit pub_methods_classEpetra__SrcDistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__SrcDistObject.html" title="Epetra_SrcDistObject: A class for supporting flexible source distributed objects for import/export op...">Epetra_SrcDistObject</a> destructor. <br /></td></tr>
<tr class="separator:a9f7ce0515cfecef2d90543d0c572d3bc inherit pub_methods_classEpetra__SrcDistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__CompObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__CompObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__CompObject.html">Epetra_CompObject</a></td></tr>
<tr class="memitem:a72d50bb3df3487828adb4d4b8f9a282b inherit pub_methods_classEpetra__CompObject" id="r_a72d50bb3df3487828adb4d4b8f9a282b"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_CompObject</b> ()</td></tr>
<tr class="memdesc:a72d50bb3df3487828adb4d4b8f9a282b inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic <a class="el" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes.">Epetra_CompObject</a> constuctor. <br /></td></tr>
<tr class="separator:a72d50bb3df3487828adb4d4b8f9a282b inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1109b4825ca8fa5043c57c83227c56 inherit pub_methods_classEpetra__CompObject" id="r_a3d1109b4825ca8fa5043c57c83227c56"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_CompObject</b> (const <a class="el" href="classEpetra__CompObject.html">Epetra_CompObject</a> &amp;Source)</td></tr>
<tr class="memdesc:a3d1109b4825ca8fa5043c57c83227c56 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes.">Epetra_CompObject</a> copy constructor. <br /></td></tr>
<tr class="separator:a3d1109b4825ca8fa5043c57c83227c56 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af670a39b6993246fe87fc4c4b9f00971 inherit pub_methods_classEpetra__CompObject" id="r_af670a39b6993246fe87fc4c4b9f00971"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_CompObject</b> ()</td></tr>
<tr class="memdesc:af670a39b6993246fe87fc4c4b9f00971 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes.">Epetra_CompObject</a> destructor. <br /></td></tr>
<tr class="separator:af670a39b6993246fe87fc4c4b9f00971 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665dd8befefacf0e5f188ea8a011bd80 inherit pub_methods_classEpetra__CompObject" id="r_a665dd8befefacf0e5f188ea8a011bd80"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetFlopCounter</b> (const <a class="el" href="classEpetra__Flops.html">Epetra_Flops</a> &amp;FlopCounter_in)</td></tr>
<tr class="memdesc:a665dd8befefacf0e5f188ea8a011bd80 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal <a class="el" href="classEpetra__Flops.html" title="Epetra_Flops: The Epetra Floating Point Operations Class.">Epetra_Flops()</a> pointer. <br /></td></tr>
<tr class="separator:a665dd8befefacf0e5f188ea8a011bd80 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac5e8ba25d3ff75dd93ee5d85f46c5b inherit pub_methods_classEpetra__CompObject" id="r_a0ac5e8ba25d3ff75dd93ee5d85f46c5b"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetFlopCounter</b> (const <a class="el" href="classEpetra__CompObject.html">Epetra_CompObject</a> &amp;CompObject)</td></tr>
<tr class="memdesc:a0ac5e8ba25d3ff75dd93ee5d85f46c5b inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal <a class="el" href="classEpetra__Flops.html" title="Epetra_Flops: The Epetra Floating Point Operations Class.">Epetra_Flops()</a> pointer to the flop counter of another <a class="el" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes.">Epetra_CompObject</a>. <br /></td></tr>
<tr class="separator:a0ac5e8ba25d3ff75dd93ee5d85f46c5b inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78028e410947150bba43f206d0c0b0ef inherit pub_methods_classEpetra__CompObject" id="r_a78028e410947150bba43f206d0c0b0ef"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UnsetFlopCounter</b> ()</td></tr>
<tr class="memdesc:a78028e410947150bba43f206d0c0b0ef inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal <a class="el" href="classEpetra__Flops.html" title="Epetra_Flops: The Epetra Floating Point Operations Class.">Epetra_Flops()</a> pointer to 0 (no flops counted). <br /></td></tr>
<tr class="separator:a78028e410947150bba43f206d0c0b0ef inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e1619549eb9d1b62a04172fedc77b7 inherit pub_methods_classEpetra__CompObject" id="r_a31e1619549eb9d1b62a04172fedc77b7"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classEpetra__Flops.html">Epetra_Flops</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetFlopCounter</b> () const</td></tr>
<tr class="memdesc:a31e1619549eb9d1b62a04172fedc77b7 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pointer to the <a class="el" href="classEpetra__Flops.html" title="Epetra_Flops: The Epetra Floating Point Operations Class.">Epetra_Flops()</a> object associated with this object, returns 0 if none. <br /></td></tr>
<tr class="separator:a31e1619549eb9d1b62a04172fedc77b7 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adff4c34d61377709fc8a17e99e3eae inherit pub_methods_classEpetra__CompObject" id="r_a4adff4c34d61377709fc8a17e99e3eae"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>ResetFlops</b> () const</td></tr>
<tr class="memdesc:a4adff4c34d61377709fc8a17e99e3eae inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the number of floating point operations to zero for <em>this</em> multi-vector. <br /></td></tr>
<tr class="separator:a4adff4c34d61377709fc8a17e99e3eae inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8326f0873a8866ac9f15f08f5ef31b0d inherit pub_methods_classEpetra__CompObject" id="r_a8326f0873a8866ac9f15f08f5ef31b0d"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><b>Flops</b> () const</td></tr>
<tr class="memdesc:a8326f0873a8866ac9f15f08f5ef31b0d inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of floating point operations with <em>this</em> multi-vector. <br /></td></tr>
<tr class="separator:a8326f0873a8866ac9f15f08f5ef31b0d inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac776bf8d9e68e57951ef766ec16e636b inherit pub_methods_classEpetra__CompObject" id="r_ac776bf8d9e68e57951ef766ec16e636b"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateFlops</b> (int Flops_in) const</td></tr>
<tr class="memdesc:ac776bf8d9e68e57951ef766ec16e636b inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment Flop count for <em>this</em> object. <br /></td></tr>
<tr class="separator:ac776bf8d9e68e57951ef766ec16e636b inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4373b39e384b424078818c6774ffb59a inherit pub_methods_classEpetra__CompObject" id="r_a4373b39e384b424078818c6774ffb59a"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateFlops</b> (long int Flops_in) const</td></tr>
<tr class="memdesc:a4373b39e384b424078818c6774ffb59a inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment Flop count for <em>this</em> object. <br /></td></tr>
<tr class="separator:a4373b39e384b424078818c6774ffb59a inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a2cf1d3a37d9e486edc64202ed42b2 inherit pub_methods_classEpetra__CompObject" id="r_a77a2cf1d3a37d9e486edc64202ed42b2"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateFlops</b> (long long Flops_in) const</td></tr>
<tr class="memdesc:a77a2cf1d3a37d9e486edc64202ed42b2 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment Flop count for <em>this</em> object. <br /></td></tr>
<tr class="separator:a77a2cf1d3a37d9e486edc64202ed42b2 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6480e644cf6c9a524ef839add22952 inherit pub_methods_classEpetra__CompObject" id="r_a4c6480e644cf6c9a524ef839add22952"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateFlops</b> (double Flops_in) const</td></tr>
<tr class="memdesc:a4c6480e644cf6c9a524ef839add22952 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment Flop count for <em>this</em> object. <br /></td></tr>
<tr class="separator:a4c6480e644cf6c9a524ef839add22952 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe126845543d91403abf3a50333fb891 inherit pub_methods_classEpetra__CompObject" id="r_abe126845543d91403abf3a50333fb891"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateFlops</b> (float Flops_in) const</td></tr>
<tr class="memdesc:abe126845543d91403abf3a50333fb891 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment Flop count for <em>this</em> object. <br /></td></tr>
<tr class="separator:abe126845543d91403abf3a50333fb891 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb8e33c7b18538fa0c088a1dfe1216f inherit pub_methods_classEpetra__CompObject" id="r_a8bb8e33c7b18538fa0c088a1dfe1216f"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classEpetra__CompObject.html">Epetra_CompObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classEpetra__CompObject.html">Epetra_CompObject</a> &amp;src)</td></tr>
<tr class="separator:a8bb8e33c7b18538fa0c088a1dfe1216f inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__BLAS"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__BLAS')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__BLAS.html">Epetra_BLAS</a></td></tr>
<tr class="memitem:a8e4e2d564543a813e06462a599ed5b88 inherit pub_methods_classEpetra__BLAS" id="r_a8e4e2d564543a813e06462a599ed5b88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__BLAS.html#a8e4e2d564543a813e06462a599ed5b88">Epetra_BLAS</a> (void)</td></tr>
<tr class="memdesc:a8e4e2d564543a813e06462a599ed5b88 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> Constructor.  <br /></td></tr>
<tr class="separator:a8e4e2d564543a813e06462a599ed5b88 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a2dc7741eea3b947a11280c0ad7ba3 inherit pub_methods_classEpetra__BLAS" id="r_a40a2dc7741eea3b947a11280c0ad7ba3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__BLAS.html#a40a2dc7741eea3b947a11280c0ad7ba3">Epetra_BLAS</a> (const <a class="el" href="classEpetra__BLAS.html">Epetra_BLAS</a> &amp;BLAS)</td></tr>
<tr class="memdesc:a40a2dc7741eea3b947a11280c0ad7ba3 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> Copy Constructor.  <br /></td></tr>
<tr class="separator:a40a2dc7741eea3b947a11280c0ad7ba3 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cd61f7e045c7a41d75e4b073b116e2 inherit pub_methods_classEpetra__BLAS" id="r_a65cd61f7e045c7a41d75e4b073b116e2"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_BLAS</b> (void)</td></tr>
<tr class="memdesc:a65cd61f7e045c7a41d75e4b073b116e2 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> Destructor. <br /></td></tr>
<tr class="separator:a65cd61f7e045c7a41d75e4b073b116e2 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6e26cf6efd99af2a0a5090b732fab8 inherit pub_methods_classEpetra__BLAS" id="r_a2b6e26cf6efd99af2a0a5090b732fab8"><td class="memItemLeft" align="right" valign="top">
float&#160;</td><td class="memItemRight" valign="bottom"><b>ASUM</b> (const int N, const float *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a2b6e26cf6efd99af2a0a5090b732fab8 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> one norm function (SASUM). <br /></td></tr>
<tr class="separator:a2b6e26cf6efd99af2a0a5090b732fab8 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b10dd77bd77ae08ee2d4f797ccb38c inherit pub_methods_classEpetra__BLAS" id="r_a98b10dd77bd77ae08ee2d4f797ccb38c"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><b>ASUM</b> (const int N, const double *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a98b10dd77bd77ae08ee2d4f797ccb38c inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> one norm function (DASUM). <br /></td></tr>
<tr class="separator:a98b10dd77bd77ae08ee2d4f797ccb38c inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146020f20aa38d12a13a0240f4bd4d89 inherit pub_methods_classEpetra__BLAS" id="r_a146020f20aa38d12a13a0240f4bd4d89"><td class="memItemLeft" align="right" valign="top">
float&#160;</td><td class="memItemRight" valign="bottom"><b>DOT</b> (const int N, const float *X, const float *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:a146020f20aa38d12a13a0240f4bd4d89 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> dot product function (SDOT). <br /></td></tr>
<tr class="separator:a146020f20aa38d12a13a0240f4bd4d89 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d29ddf22e2dbc8cc4aa15920112ba6f inherit pub_methods_classEpetra__BLAS" id="r_a5d29ddf22e2dbc8cc4aa15920112ba6f"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><b>DOT</b> (const int N, const double *X, const double *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:a5d29ddf22e2dbc8cc4aa15920112ba6f inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> dot product function (DDOT). <br /></td></tr>
<tr class="separator:a5d29ddf22e2dbc8cc4aa15920112ba6f inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b602d1308905182ead57a14ce94dc4c inherit pub_methods_classEpetra__BLAS" id="r_a2b602d1308905182ead57a14ce94dc4c"><td class="memItemLeft" align="right" valign="top">
float&#160;</td><td class="memItemRight" valign="bottom"><b>NRM2</b> (const int N, const float *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a2b602d1308905182ead57a14ce94dc4c inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> norm function (SNRM2). <br /></td></tr>
<tr class="separator:a2b602d1308905182ead57a14ce94dc4c inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3915137d4a88e64be1b3b6fff0ae0ba8 inherit pub_methods_classEpetra__BLAS" id="r_a3915137d4a88e64be1b3b6fff0ae0ba8"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><b>NRM2</b> (const int N, const double *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a3915137d4a88e64be1b3b6fff0ae0ba8 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> norm function (DNRM2). <br /></td></tr>
<tr class="separator:a3915137d4a88e64be1b3b6fff0ae0ba8 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132159d7d231a9a9e36e9175cc9faf09 inherit pub_methods_classEpetra__BLAS" id="r_a132159d7d231a9a9e36e9175cc9faf09"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SCAL</b> (const int N, const float ALPHA, float *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a132159d7d231a9a9e36e9175cc9faf09 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> vector scale function (SSCAL) <br /></td></tr>
<tr class="separator:a132159d7d231a9a9e36e9175cc9faf09 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9cf3e5a447112125294b8988fe50124 inherit pub_methods_classEpetra__BLAS" id="r_ae9cf3e5a447112125294b8988fe50124"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SCAL</b> (const int N, const double ALPHA, double *X, const int INCX=1) const</td></tr>
<tr class="memdesc:ae9cf3e5a447112125294b8988fe50124 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> vector scale function (DSCAL) <br /></td></tr>
<tr class="separator:ae9cf3e5a447112125294b8988fe50124 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f43b364ff5e3627f983fe435b222ea5 inherit pub_methods_classEpetra__BLAS" id="r_a7f43b364ff5e3627f983fe435b222ea5"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>COPY</b> (const int N, const float *X, float *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:a7f43b364ff5e3627f983fe435b222ea5 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> vector copy function (SCOPY) <br /></td></tr>
<tr class="separator:a7f43b364ff5e3627f983fe435b222ea5 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f36b71efee7fc61fb8a3d5c8ce0cf0 inherit pub_methods_classEpetra__BLAS" id="r_a93f36b71efee7fc61fb8a3d5c8ce0cf0"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>COPY</b> (const int N, const double *X, double *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:a93f36b71efee7fc61fb8a3d5c8ce0cf0 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> vector scale function (DCOPY) <br /></td></tr>
<tr class="separator:a93f36b71efee7fc61fb8a3d5c8ce0cf0 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6412c2b4a56fbe2d0bbe94cc7a65e5f8 inherit pub_methods_classEpetra__BLAS" id="r_a6412c2b4a56fbe2d0bbe94cc7a65e5f8"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>IAMAX</b> (const int N, const float *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a6412c2b4a56fbe2d0bbe94cc7a65e5f8 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> arg maximum of absolute value function (ISAMAX) <br /></td></tr>
<tr class="separator:a6412c2b4a56fbe2d0bbe94cc7a65e5f8 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5532e66d0bd32b6ca19871bc007b6e16 inherit pub_methods_classEpetra__BLAS" id="r_a5532e66d0bd32b6ca19871bc007b6e16"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>IAMAX</b> (const int N, const double *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a5532e66d0bd32b6ca19871bc007b6e16 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> arg maximum of absolute value function (IDAMAX) <br /></td></tr>
<tr class="separator:a5532e66d0bd32b6ca19871bc007b6e16 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05c457263f160300f80c638525a5e19 inherit pub_methods_classEpetra__BLAS" id="r_af05c457263f160300f80c638525a5e19"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>AXPY</b> (const int N, const float ALPHA, const float *X, float *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:af05c457263f160300f80c638525a5e19 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> vector update function (SAXPY) <br /></td></tr>
<tr class="separator:af05c457263f160300f80c638525a5e19 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3042fd0acc417128584ce36483dc079 inherit pub_methods_classEpetra__BLAS" id="r_ac3042fd0acc417128584ce36483dc079"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>AXPY</b> (const int N, const double ALPHA, const double *X, double *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:ac3042fd0acc417128584ce36483dc079 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> vector update function (DAXPY) <br /></td></tr>
<tr class="separator:ac3042fd0acc417128584ce36483dc079 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ad7f5429608aba90723eb46a426575 inherit pub_methods_classEpetra__BLAS" id="r_ae9ad7f5429608aba90723eb46a426575"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEMV</b> (const char TRANS, const int M, const int N, const float ALPHA, const float *A, const int LDA, const float *X, const float BETA, float *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:ae9ad7f5429608aba90723eb46a426575 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> matrix-vector multiply function (SGEMV) <br /></td></tr>
<tr class="separator:ae9ad7f5429608aba90723eb46a426575 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa69dbfc706abc19f3d441ffc07683c inherit pub_methods_classEpetra__BLAS" id="r_a0aa69dbfc706abc19f3d441ffc07683c"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEMV</b> (const char TRANS, const int M, const int N, const double ALPHA, const double *A, const int LDA, const double *X, const double BETA, double *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:a0aa69dbfc706abc19f3d441ffc07683c inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> matrix-vector multiply function (DGEMV) <br /></td></tr>
<tr class="separator:a0aa69dbfc706abc19f3d441ffc07683c inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c5f255a3a03f9d3fa87aaa6cfb92ec inherit pub_methods_classEpetra__BLAS" id="r_a95c5f255a3a03f9d3fa87aaa6cfb92ec"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEMM</b> (const char TRANSA, const char TRANSB, const int M, const int N, const int K, const float ALPHA, const float *A, const int LDA, const float *B, const int LDB, const float BETA, float *C, const int LDC) const</td></tr>
<tr class="memdesc:a95c5f255a3a03f9d3fa87aaa6cfb92ec inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> matrix-matrix multiply function (SGEMM) <br /></td></tr>
<tr class="separator:a95c5f255a3a03f9d3fa87aaa6cfb92ec inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf93b9ef6ee2782cbbdc1e2ac00b5a2e inherit pub_methods_classEpetra__BLAS" id="r_acf93b9ef6ee2782cbbdc1e2ac00b5a2e"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEMM</b> (const char TRANSA, const char TRANSB, const int M, const int N, const int K, const double ALPHA, const double *A, const int LDA, const double *B, const int LDB, const double BETA, double *C, const int LDC) const</td></tr>
<tr class="memdesc:acf93b9ef6ee2782cbbdc1e2ac00b5a2e inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> matrix-matrix multiply function (DGEMM) <br /></td></tr>
<tr class="separator:acf93b9ef6ee2782cbbdc1e2ac00b5a2e inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa11c3c601b27c400568a60596434b4 inherit pub_methods_classEpetra__BLAS" id="r_a8fa11c3c601b27c400568a60596434b4"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYMM</b> (const char SIDE, const char UPLO, const int M, const int N, const float ALPHA, const float *A, const int LDA, const float *B, const int LDB, const float BETA, float *C, const int LDC) const</td></tr>
<tr class="memdesc:a8fa11c3c601b27c400568a60596434b4 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> symmetric matrix-matrix multiply function (SSYMM) <br /></td></tr>
<tr class="separator:a8fa11c3c601b27c400568a60596434b4 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ca61221b2acf0befef968748c6bb80 inherit pub_methods_classEpetra__BLAS" id="r_ad1ca61221b2acf0befef968748c6bb80"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYMM</b> (const char SIDE, const char UPLO, const int M, const int N, const double ALPHA, const double *A, const int LDA, const double *B, const int LDB, const double BETA, double *C, const int LDC) const</td></tr>
<tr class="memdesc:ad1ca61221b2acf0befef968748c6bb80 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> matrix-matrix multiply function (DSYMM) <br /></td></tr>
<tr class="separator:ad1ca61221b2acf0befef968748c6bb80 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2dcbf05331765f0ddb661460390a6e inherit pub_methods_classEpetra__BLAS" id="r_add2dcbf05331765f0ddb661460390a6e"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>TRMM</b> (const char SIDE, const char UPLO, const char TRANSA, const char DIAG, const int M, const int N, const float ALPHA, const float *A, const int LDA, float *B, const int LDB) const</td></tr>
<tr class="memdesc:add2dcbf05331765f0ddb661460390a6e inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> triangular matrix-matrix multiply function (STRMM) <br /></td></tr>
<tr class="separator:add2dcbf05331765f0ddb661460390a6e inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65212f8eee6597c24722b7bf2d54168b inherit pub_methods_classEpetra__BLAS" id="r_a65212f8eee6597c24722b7bf2d54168b"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>TRMM</b> (const char SIDE, const char UPLO, const char TRANSA, const char DIAG, const int M, const int N, const double ALPHA, const double *A, const int LDA, double *B, const int LDB) const</td></tr>
<tr class="memdesc:a65212f8eee6597c24722b7bf2d54168b inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> triangular matrix-matrix multiply function (DTRMM) <br /></td></tr>
<tr class="separator:a65212f8eee6597c24722b7bf2d54168b inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd9f6cd122a04b0544b62f26761b885 inherit pub_methods_classEpetra__BLAS" id="r_a6fd9f6cd122a04b0544b62f26761b885"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYRK</b> (const char UPLO, const char TRANS, const int N, const int K, const float ALPHA, const float *A, const int LDA, const float BETA, float *C, const int LDC) const</td></tr>
<tr class="memdesc:a6fd9f6cd122a04b0544b62f26761b885 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eperta_BLAS symetric rank k funtion (ssyrk) <br /></td></tr>
<tr class="separator:a6fd9f6cd122a04b0544b62f26761b885 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a2d21fe184982d57544b23b66ba522 inherit pub_methods_classEpetra__BLAS" id="r_a97a2d21fe184982d57544b23b66ba522"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYRK</b> (const char UPLO, const char TRANS, const int N, const int K, const double ALPHA, const double *A, const int LDA, const double BETA, double *C, const int LDC) const</td></tr>
<tr class="memdesc:a97a2d21fe184982d57544b23b66ba522 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eperta_BLAS symetric rank k funtion (dsyrk) <br /></td></tr>
<tr class="separator:a97a2d21fe184982d57544b23b66ba522 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__RowMatrix"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__RowMatrix')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__RowMatrix.html">Epetra_RowMatrix</a></td></tr>
<tr class="memitem:a1888703e63626eb9caac41662d612538 inherit pub_methods_classEpetra__RowMatrix" id="r_a1888703e63626eb9caac41662d612538"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_RowMatrix</b> ()</td></tr>
<tr class="memdesc:a1888703e63626eb9caac41662d612538 inherit pub_methods_classEpetra__RowMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a1888703e63626eb9caac41662d612538 inherit pub_methods_classEpetra__RowMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__Operator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__Operator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__Operator.html">Epetra_Operator</a></td></tr>
<tr class="memitem:a7d987fbd72e3920a8043f7861df7d242 inherit pub_methods_classEpetra__Operator" id="r_a7d987fbd72e3920a8043f7861df7d242"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_Operator</b> ()</td></tr>
<tr class="memdesc:a7d987fbd72e3920a8043f7861df7d242 inherit pub_methods_classEpetra__Operator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a7d987fbd72e3920a8043f7861df7d242 inherit pub_methods_classEpetra__Operator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Deprecated methods: These methods still work, but will be removed in a future version</h2></td></tr>
<tr class="memitem:a59fbfbad01653ac93a38369ca037a08e" id="r_a59fbfbad01653ac93a38369ca037a08e"><td class="memItemLeft" align="right" valign="top"><a id="a59fbfbad01653ac93a38369ca037a08e" name="a59fbfbad01653ac93a38369ca037a08e"></a>
<a class="el" href="classEpetra__CrsGraph.html">Epetra_CrsGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Graph_</b></td></tr>
<tr class="separator:a59fbfbad01653ac93a38369ca037a08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3673b82f04c1b3e4457baea80f493470" id="r_a3673b82f04c1b3e4457baea80f493470"><td class="memItemLeft" align="right" valign="top"><a id="a3673b82f04c1b3e4457baea80f493470" name="a3673b82f04c1b3e4457baea80f493470"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Allocated_</b></td></tr>
<tr class="separator:a3673b82f04c1b3e4457baea80f493470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e08a89dbf7945a8edd8ecf68e8dd79" id="r_a59e08a89dbf7945a8edd8ecf68e8dd79"><td class="memItemLeft" align="right" valign="top"><a id="a59e08a89dbf7945a8edd8ecf68e8dd79" name="a59e08a89dbf7945a8edd8ecf68e8dd79"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>StaticGraph_</b></td></tr>
<tr class="separator:a59e08a89dbf7945a8edd8ecf68e8dd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8487adad53420a77f7ce14be4507622f" id="r_a8487adad53420a77f7ce14be4507622f"><td class="memItemLeft" align="right" valign="top"><a id="a8487adad53420a77f7ce14be4507622f" name="a8487adad53420a77f7ce14be4507622f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>UseTranspose_</b></td></tr>
<tr class="separator:a8487adad53420a77f7ce14be4507622f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b9418f09ff343981bbefaa0c1d0e86" id="r_a27b9418f09ff343981bbefaa0c1d0e86"><td class="memItemLeft" align="right" valign="top"><a id="a27b9418f09ff343981bbefaa0c1d0e86" name="a27b9418f09ff343981bbefaa0c1d0e86"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>constructedWithFilledGraph_</b></td></tr>
<tr class="separator:a27b9418f09ff343981bbefaa0c1d0e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b98c4dea73c9eeaebe3d035dcb8d71" id="r_a00b98c4dea73c9eeaebe3d035dcb8d71"><td class="memItemLeft" align="right" valign="top"><a id="a00b98c4dea73c9eeaebe3d035dcb8d71" name="a00b98c4dea73c9eeaebe3d035dcb8d71"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>matrixFillCompleteCalled_</b></td></tr>
<tr class="separator:a00b98c4dea73c9eeaebe3d035dcb8d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3383a9f29087fed2e6df5219af873968" id="r_a3383a9f29087fed2e6df5219af873968"><td class="memItemLeft" align="right" valign="top"><a id="a3383a9f29087fed2e6df5219af873968" name="a3383a9f29087fed2e6df5219af873968"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>StorageOptimized_</b></td></tr>
<tr class="separator:a3383a9f29087fed2e6df5219af873968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e1710f0932d4e62b8c9314a992874c" id="r_a03e1710f0932d4e62b8c9314a992874c"><td class="memItemLeft" align="right" valign="top"><a id="a03e1710f0932d4e62b8c9314a992874c" name="a03e1710f0932d4e62b8c9314a992874c"></a>
double **&#160;</td><td class="memItemRight" valign="bottom"><b>Values_</b></td></tr>
<tr class="separator:a03e1710f0932d4e62b8c9314a992874c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bff2670bc455330439d96c9675499a8" id="r_a3bff2670bc455330439d96c9675499a8"><td class="memItemLeft" align="right" valign="top"><a id="a3bff2670bc455330439d96c9675499a8" name="a3bff2670bc455330439d96c9675499a8"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><b>Values_alloc_lengths_</b></td></tr>
<tr class="separator:a3bff2670bc455330439d96c9675499a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0b3a09f81c822a223a9e0e3050cf40" id="r_a4d0b3a09f81c822a223a9e0e3050cf40"><td class="memItemLeft" align="right" valign="top"><a id="a4d0b3a09f81c822a223a9e0e3050cf40" name="a4d0b3a09f81c822a223a9e0e3050cf40"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>All_Values_</b></td></tr>
<tr class="separator:a4d0b3a09f81c822a223a9e0e3050cf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1aacf4426f3f9f78645cab6bdf57b5" id="r_a4b1aacf4426f3f9f78645cab6bdf57b5"><td class="memItemLeft" align="right" valign="top"><a id="a4b1aacf4426f3f9f78645cab6bdf57b5" name="a4b1aacf4426f3f9f78645cab6bdf57b5"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>NormInf_</b></td></tr>
<tr class="separator:a4b1aacf4426f3f9f78645cab6bdf57b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f03247ff68ecf5913e0a69013b52b9f" id="r_a6f03247ff68ecf5913e0a69013b52b9f"><td class="memItemLeft" align="right" valign="top"><a id="a6f03247ff68ecf5913e0a69013b52b9f" name="a6f03247ff68ecf5913e0a69013b52b9f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>NormOne_</b></td></tr>
<tr class="separator:a6f03247ff68ecf5913e0a69013b52b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42178fe127320d9e66aff2d2acf0bc66" id="r_a42178fe127320d9e66aff2d2acf0bc66"><td class="memItemLeft" align="right" valign="top"><a id="a42178fe127320d9e66aff2d2acf0bc66" name="a42178fe127320d9e66aff2d2acf0bc66"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>NormFrob_</b></td></tr>
<tr class="separator:a42178fe127320d9e66aff2d2acf0bc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5c499906b0e460903337f65514fcf3" id="r_a7a5c499906b0e460903337f65514fcf3"><td class="memItemLeft" align="right" valign="top"><a id="a7a5c499906b0e460903337f65514fcf3" name="a7a5c499906b0e460903337f65514fcf3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>NumMyRows_</b></td></tr>
<tr class="separator:a7a5c499906b0e460903337f65514fcf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef99a42b4be2c197bacdb96981bd7dbd" id="r_aef99a42b4be2c197bacdb96981bd7dbd"><td class="memItemLeft" align="right" valign="top"><a id="aef99a42b4be2c197bacdb96981bd7dbd" name="aef99a42b4be2c197bacdb96981bd7dbd"></a>
<a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ImportVector_</b></td></tr>
<tr class="separator:aef99a42b4be2c197bacdb96981bd7dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf57758cf469305008be107e26080f98" id="r_aaf57758cf469305008be107e26080f98"><td class="memItemLeft" align="right" valign="top"><a id="aaf57758cf469305008be107e26080f98" name="aaf57758cf469305008be107e26080f98"></a>
<a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ExportVector_</b></td></tr>
<tr class="separator:aaf57758cf469305008be107e26080f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e06753b477e15d3414ee6c569540627" id="r_a3e06753b477e15d3414ee6c569540627"><td class="memItemLeft" align="right" valign="top"><a id="a3e06753b477e15d3414ee6c569540627" name="a3e06753b477e15d3414ee6c569540627"></a>
<a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CV_</b></td></tr>
<tr class="separator:a3e06753b477e15d3414ee6c569540627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0b26411f90a324fc84d45856400c57" id="r_acb0b26411f90a324fc84d45856400c57"><td class="memItemLeft" align="right" valign="top"><a id="acb0b26411f90a324fc84d45856400c57" name="acb0b26411f90a324fc84d45856400c57"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>squareFillCompleteCalled_</b></td></tr>
<tr class="separator:acb0b26411f90a324fc84d45856400c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac804b60c8674adefaadcb664e9b450" id="r_a7ac804b60c8674adefaadcb664e9b450"><td class="memItemLeft" align="right" valign="top"><a id="a7ac804b60c8674adefaadcb664e9b450" name="a7ac804b60c8674adefaadcb664e9b450"></a>
const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ImportMap</b> () const</td></tr>
<tr class="memdesc:a7ac804b60c8674adefaadcb664e9b450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <a class="el" href="classEpetra__CrsMatrix.html#aab3589bfaac41458ab698d3d53780e61" title="Returns the Epetra_Map object that describes the set of column-indices that appear in each processor&#39;...">ColMap()</a> instead. <br /></td></tr>
<tr class="separator:a7ac804b60c8674adefaadcb664e9b450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0c8644018b39157b3db9e6acc0096a" id="r_a2d0c8644018b39157b3db9e6acc0096a"><td class="memItemLeft" align="right" valign="top"><a id="a2d0c8644018b39157b3db9e6acc0096a" name="a2d0c8644018b39157b3db9e6acc0096a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>TransformToLocal</b> ()</td></tr>
<tr class="memdesc:a2d0c8644018b39157b3db9e6acc0096a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> instead. <br /></td></tr>
<tr class="separator:a2d0c8644018b39157b3db9e6acc0096a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af574d136505d21e5890894e8e39f4ca1" id="r_af574d136505d21e5890894e8e39f4ca1"><td class="memItemLeft" align="right" valign="top"><a id="af574d136505d21e5890894e8e39f4ca1" name="af574d136505d21e5890894e8e39f4ca1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>TransformToLocal</b> (const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c">DomainMap</a>, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222">RangeMap</a>)</td></tr>
<tr class="memdesc:af574d136505d21e5890894e8e39f4ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use FillComplete(const Epetra_Map&amp; DomainMap, const Epetra_Map&amp; RangeMap) instead. <br /></td></tr>
<tr class="separator:af574d136505d21e5890894e8e39f4ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961f60d827738942f79e4277dc82b1ee" id="r_a961f60d827738942f79e4277dc82b1ee"><td class="memItemLeft" align="right" valign="top"><a id="a961f60d827738942f79e4277dc82b1ee" name="a961f60d827738942f79e4277dc82b1ee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>FusedImport</b> (const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;SourceMatrix, const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> &amp;RowImporter, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c">DomainMap</a>, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222">RangeMap</a>, bool RestrictCommunicator)</td></tr>
<tr class="separator:a961f60d827738942f79e4277dc82b1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d22aa64c75c5a68fa8e7a23fa15a7b" id="r_ab3d22aa64c75c5a68fa8e7a23fa15a7b"><td class="memItemLeft" align="right" valign="top"><a id="ab3d22aa64c75c5a68fa8e7a23fa15a7b" name="ab3d22aa64c75c5a68fa8e7a23fa15a7b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>FusedExport</b> (const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;SourceMatrix, const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> &amp;RowExporter, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c">DomainMap</a>, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222">RangeMap</a>, bool RestrictCommunicator)</td></tr>
<tr class="separator:ab3d22aa64c75c5a68fa8e7a23fa15a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970ae0fbe162efea59cd633fb52558cb" id="r_a970ae0fbe162efea59cd633fb52558cb"><td class="memItemLeft" align="right" valign="top"><a id="a970ae0fbe162efea59cd633fb52558cb" name="a970ae0fbe162efea59cd633fb52558cb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>FusedImport</b> (const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;SourceMatrix, const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> &amp;RowImporter, const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> *DomainImporter, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c">DomainMap</a>, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222">RangeMap</a>, bool RestrictCommunicator)</td></tr>
<tr class="separator:a970ae0fbe162efea59cd633fb52558cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9aeb544eff8540fd665106591ab930" id="r_a1e9aeb544eff8540fd665106591ab930"><td class="memItemLeft" align="right" valign="top"><a id="a1e9aeb544eff8540fd665106591ab930" name="a1e9aeb544eff8540fd665106591ab930"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>FusedExport</b> (const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;SourceMatrix, const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> &amp;RowExporter, const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> *DomainExporter, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c">DomainMap</a>, const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *<a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222">RangeMap</a>, bool RestrictCommunicator)</td></tr>
<tr class="separator:a1e9aeb544eff8540fd665106591ab930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a3a7747be10c9a5f98becd999544ed" id="r_a76a3a7747be10c9a5f98becd999544ed"><td class="memItemLeft" align="right" valign="top"><a id="a76a3a7747be10c9a5f98becd999544ed" name="a76a3a7747be10c9a5f98becd999544ed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Allocated</b> () const</td></tr>
<tr class="separator:a76a3a7747be10c9a5f98becd999544ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f8d7ef9e0b26bca0f697096fad5c97" id="r_a21f8d7ef9e0b26bca0f697096fad5c97"><td class="memItemLeft" align="right" valign="top"><a id="a21f8d7ef9e0b26bca0f697096fad5c97" name="a21f8d7ef9e0b26bca0f697096fad5c97"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>SetAllocated</b> (bool Flag)</td></tr>
<tr class="separator:a21f8d7ef9e0b26bca0f697096fad5c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01b0493094e38b7cafcbb6416d34ee8" id="r_ad01b0493094e38b7cafcbb6416d34ee8"><td class="memItemLeft" align="right" valign="top"><a id="ad01b0493094e38b7cafcbb6416d34ee8" name="ad01b0493094e38b7cafcbb6416d34ee8"></a>
double **&#160;</td><td class="memItemRight" valign="bottom"><b>Values</b> () const</td></tr>
<tr class="separator:ad01b0493094e38b7cafcbb6416d34ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503f5a5ba837c18e025f7bad039afcc7" id="r_a503f5a5ba837c18e025f7bad039afcc7"><td class="memItemLeft" align="right" valign="top"><a id="a503f5a5ba837c18e025f7bad039afcc7" name="a503f5a5ba837c18e025f7bad039afcc7"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>All_Values</b> () const</td></tr>
<tr class="separator:a503f5a5ba837c18e025f7bad039afcc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d7e3ba7dab0f1b05838177a68c21b1" id="r_aa2d7e3ba7dab0f1b05838177a68c21b1"><td class="memItemLeft" align="right" valign="top"><a id="aa2d7e3ba7dab0f1b05838177a68c21b1" name="aa2d7e3ba7dab0f1b05838177a68c21b1"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>Values</b> (int LocalRow) const</td></tr>
<tr class="separator:aa2d7e3ba7dab0f1b05838177a68c21b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d193402fbcdbbb9b6e9f6d8dcb2454" id="r_ab3d193402fbcdbbb9b6e9f6d8dcb2454"><td class="memItemLeft" align="right" valign="top"><a id="ab3d193402fbcdbbb9b6e9f6d8dcb2454" name="ab3d193402fbcdbbb9b6e9f6d8dcb2454"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>InitializeDefaults</b> ()</td></tr>
<tr class="separator:ab3d193402fbcdbbb9b6e9f6d8dcb2454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad156334d119f1e9437a96edcf00fea68" id="r_ad156334d119f1e9437a96edcf00fea68"><td class="memItemLeft" align="right" valign="top"><a id="ad156334d119f1e9437a96edcf00fea68" name="ad156334d119f1e9437a96edcf00fea68"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Allocate</b> ()</td></tr>
<tr class="separator:ad156334d119f1e9437a96edcf00fea68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ebea0ddc5c63d3318b725efd87215c" id="r_a79ebea0ddc5c63d3318b725efd87215c"><td class="memItemLeft" align="right" valign="top"><a id="a79ebea0ddc5c63d3318b725efd87215c" name="a79ebea0ddc5c63d3318b725efd87215c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>InsertValues</b> (int LocalRow, int NumEntries, double *Values, int *Indices)</td></tr>
<tr class="separator:a79ebea0ddc5c63d3318b725efd87215c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421fbb486c436da859a5b73537a25769" id="r_a421fbb486c436da859a5b73537a25769"><td class="memItemLeft" align="right" valign="top"><a id="a421fbb486c436da859a5b73537a25769" name="a421fbb486c436da859a5b73537a25769"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>InsertValues</b> (int LocalRow, int NumEntries, const double *Values, const int *Indices)</td></tr>
<tr class="separator:a421fbb486c436da859a5b73537a25769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d183c718dcf56d99a9a82a20e7dc8fc" id="r_a6d183c718dcf56d99a9a82a20e7dc8fc"><td class="memItemLeft" align="right" valign="top"><a id="a6d183c718dcf56d99a9a82a20e7dc8fc" name="a6d183c718dcf56d99a9a82a20e7dc8fc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>InsertValues</b> (int LocalRow, int NumEntries, double *Values, long long *Indices)</td></tr>
<tr class="separator:a6d183c718dcf56d99a9a82a20e7dc8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa616a5083eccea323ece1edd7c3a22e1" id="r_aa616a5083eccea323ece1edd7c3a22e1"><td class="memItemLeft" align="right" valign="top"><a id="aa616a5083eccea323ece1edd7c3a22e1" name="aa616a5083eccea323ece1edd7c3a22e1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>InsertValues</b> (int LocalRow, int NumEntries, const double *Values, const long long *Indices)</td></tr>
<tr class="separator:aa616a5083eccea323ece1edd7c3a22e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc56a809b3c66efa1b30e91728745b35" id="r_abc56a809b3c66efa1b30e91728745b35"><td class="memItemLeft" align="right" valign="top"><a id="abc56a809b3c66efa1b30e91728745b35" name="abc56a809b3c66efa1b30e91728745b35"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>InsertOffsetValues</b> (long long GlobalRow, int NumEntries, double *Values, int *Indices)</td></tr>
<tr class="separator:abc56a809b3c66efa1b30e91728745b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126c8b1b2e6f6468216bfaed1e69fe2f" id="r_a126c8b1b2e6f6468216bfaed1e69fe2f"><td class="memItemLeft" align="right" valign="top"><a id="a126c8b1b2e6f6468216bfaed1e69fe2f" name="a126c8b1b2e6f6468216bfaed1e69fe2f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>InsertOffsetValues</b> (long long GlobalRow, int NumEntries, const double *Values, const int *Indices)</td></tr>
<tr class="separator:a126c8b1b2e6f6468216bfaed1e69fe2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4599c5c919053ab96dcd9235901577e5" id="r_a4599c5c919053ab96dcd9235901577e5"><td class="memItemLeft" align="right" valign="top"><a id="a4599c5c919053ab96dcd9235901577e5" name="a4599c5c919053ab96dcd9235901577e5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ReplaceOffsetValues</b> (long long GlobalRow, int NumEntries, const double *Values, const int *Indices)</td></tr>
<tr class="separator:a4599c5c919053ab96dcd9235901577e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fa210a1be998142c2aca08e83d7127" id="r_a73fa210a1be998142c2aca08e83d7127"><td class="memItemLeft" align="right" valign="top"><a id="a73fa210a1be998142c2aca08e83d7127" name="a73fa210a1be998142c2aca08e83d7127"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>SumIntoOffsetValues</b> (long long GlobalRow, int NumEntries, const double *Values, const int *Indices)</td></tr>
<tr class="separator:a73fa210a1be998142c2aca08e83d7127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1feab87646a914a56a8317bb3046d605" id="r_a1feab87646a914a56a8317bb3046d605"><td class="memItemLeft" align="right" valign="top"><a id="a1feab87646a914a56a8317bb3046d605" name="a1feab87646a914a56a8317bb3046d605"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateImportVector</b> (int NumVectors) const</td></tr>
<tr class="separator:a1feab87646a914a56a8317bb3046d605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4657950a6bd62c110567b01e0225f45c" id="r_a4657950a6bd62c110567b01e0225f45c"><td class="memItemLeft" align="right" valign="top"><a id="a4657950a6bd62c110567b01e0225f45c" name="a4657950a6bd62c110567b01e0225f45c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateExportVector</b> (int NumVectors) const</td></tr>
<tr class="separator:a4657950a6bd62c110567b01e0225f45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab209cfae9ec075aa8bf11fcd5b2bb1ba" id="r_ab209cfae9ec075aa8bf11fcd5b2bb1ba"><td class="memItemLeft" align="right" valign="top"><a id="ab209cfae9ec075aa8bf11fcd5b2bb1ba" name="ab209cfae9ec075aa8bf11fcd5b2bb1ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GeneralMV</b> (double *x, double *y) const</td></tr>
<tr class="separator:ab209cfae9ec075aa8bf11fcd5b2bb1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2de7b233916f74f73d74ee33370792" id="r_a7f2de7b233916f74f73d74ee33370792"><td class="memItemLeft" align="right" valign="top"><a id="a7f2de7b233916f74f73d74ee33370792" name="a7f2de7b233916f74f73d74ee33370792"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GeneralMTV</b> (double *x, double *y) const</td></tr>
<tr class="separator:a7f2de7b233916f74f73d74ee33370792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3819f4dc26bce51d493603391e454304" id="r_a3819f4dc26bce51d493603391e454304"><td class="memItemLeft" align="right" valign="top"><a id="a3819f4dc26bce51d493603391e454304" name="a3819f4dc26bce51d493603391e454304"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GeneralMM</b> (double **X, int LDX, double **Y, int LDY, int NumVectors) const</td></tr>
<tr class="separator:a3819f4dc26bce51d493603391e454304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c57cf7aa84ce375bb3f56301edefaa1" id="r_a5c57cf7aa84ce375bb3f56301edefaa1"><td class="memItemLeft" align="right" valign="top"><a id="a5c57cf7aa84ce375bb3f56301edefaa1" name="a5c57cf7aa84ce375bb3f56301edefaa1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GeneralMTM</b> (double **X, int LDX, double **Y, int LDY, int NumVectors) const</td></tr>
<tr class="separator:a5c57cf7aa84ce375bb3f56301edefaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac8cc02c7dbcae2771bb2f4400580de" id="r_acac8cc02c7dbcae2771bb2f4400580de"><td class="memItemLeft" align="right" valign="top"><a id="acac8cc02c7dbcae2771bb2f4400580de" name="acac8cc02c7dbcae2771bb2f4400580de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GeneralSV</b> (bool Upper, bool Trans, bool UnitDiagonal, double *x, double *y) const</td></tr>
<tr class="separator:acac8cc02c7dbcae2771bb2f4400580de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e579198447b923b271324ef84c1f170" id="r_a0e579198447b923b271324ef84c1f170"><td class="memItemLeft" align="right" valign="top"><a id="a0e579198447b923b271324ef84c1f170" name="a0e579198447b923b271324ef84c1f170"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GeneralSM</b> (bool Upper, bool Trans, bool UnitDiagonal, double **X, int LDX, double **Y, int LDY, int NumVectors) const</td></tr>
<tr class="separator:a0e579198447b923b271324ef84c1f170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563f265db06ce6c30be9ef6bca6ea18a" id="r_a563f265db06ce6c30be9ef6bca6ea18a"><td class="memItemLeft" align="right" valign="top"><a id="a563f265db06ce6c30be9ef6bca6ea18a" name="a563f265db06ce6c30be9ef6bca6ea18a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetStaticGraph</b> (bool Flag)</td></tr>
<tr class="separator:a563f265db06ce6c30be9ef6bca6ea18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1ad7e5a043bb17d2fb8c5fe0246c8c" id="r_a4c1ad7e5a043bb17d2fb8c5fe0246c8c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a4c1ad7e5a043bb17d2fb8c5fe0246c8c">CheckSizes</a> (const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;A)</td></tr>
<tr class="memdesc:a4c1ad7e5a043bb17d2fb8c5fe0246c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the source and target (<em>this</em>) objects to be compared for compatibility, return nonzero if not.  <br /></td></tr>
<tr class="separator:a4c1ad7e5a043bb17d2fb8c5fe0246c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d7caaff9052f0e76f6353cdb7a2575" id="r_ae7d7caaff9052f0e76f6353cdb7a2575"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#ae7d7caaff9052f0e76f6353cdb7a2575">CopyAndPermute</a> (const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;Source, int NumSameIDs, int NumPermuteIDs, int *PermuteToLIDs, int *PermuteFromLIDs, const <a class="el" href="classEpetra__OffsetIndex.html">Epetra_OffsetIndex</a> *Indexor, <a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020f">Epetra_CombineMode</a> CombineMode=<a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020fab9f6920de535f04ccfe34d670fa2c8a8">Zero</a>)</td></tr>
<tr class="memdesc:ae7d7caaff9052f0e76f6353cdb7a2575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform ID copies and permutations that are on processor.  <br /></td></tr>
<tr class="separator:ae7d7caaff9052f0e76f6353cdb7a2575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71b92f5abf1d12848febf0f5615e1d0" id="r_ab71b92f5abf1d12848febf0f5615e1d0"><td class="memItemLeft" align="right" valign="top"><a id="ab71b92f5abf1d12848febf0f5615e1d0" name="ab71b92f5abf1d12848febf0f5615e1d0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>CopyAndPermuteCrsMatrix</b> (const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;A, int NumSameIDs, int NumPermuteIDs, int *PermuteToLIDs, int *PermuteFromLIDs, const <a class="el" href="classEpetra__OffsetIndex.html">Epetra_OffsetIndex</a> *Indexor, <a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020f">Epetra_CombineMode</a> CombineMode)</td></tr>
<tr class="separator:ab71b92f5abf1d12848febf0f5615e1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320df270db482955d275672cd42f3dba" id="r_a320df270db482955d275672cd42f3dba"><td class="memItemLeft" align="right" valign="top"><a id="a320df270db482955d275672cd42f3dba" name="a320df270db482955d275672cd42f3dba"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>CopyAndPermuteRowMatrix</b> (const <a class="el" href="classEpetra__RowMatrix.html">Epetra_RowMatrix</a> &amp;A, int NumSameIDs, int NumPermuteIDs, int *PermuteToLIDs, int *PermuteFromLIDs, const <a class="el" href="classEpetra__OffsetIndex.html">Epetra_OffsetIndex</a> *Indexor, <a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020f">Epetra_CombineMode</a> CombineMode)</td></tr>
<tr class="separator:a320df270db482955d275672cd42f3dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca07ab2127fcc6e011f342f75d57593" id="r_a2ca07ab2127fcc6e011f342f75d57593"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#a2ca07ab2127fcc6e011f342f75d57593">PackAndPrepare</a> (const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;Source, int NumExportIDs, int *ExportLIDs, int &amp;LenExports, char *&amp;Exports, int &amp;SizeOfPacket, int *Sizes, bool &amp;VarSizes, <a class="el" href="classEpetra__Distributor.html">Epetra_Distributor</a> &amp;Distor)</td></tr>
<tr class="memdesc:a2ca07ab2127fcc6e011f342f75d57593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any packing or preparation required for call to <a class="el" href="classEpetra__DistObject.html#ab26ca2d3f9d20a850734f4af633e4135" title="Perform actual transfer (redistribution) of data across memory images, using Epetra_Distributor objec...">DoTransfer()</a>.  <br /></td></tr>
<tr class="separator:a2ca07ab2127fcc6e011f342f75d57593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc77171308612e405e1427aeff35ad27" id="r_adc77171308612e405e1427aeff35ad27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__CrsMatrix.html#adc77171308612e405e1427aeff35ad27">UnpackAndCombine</a> (const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;Source, int NumImportIDs, int *ImportLIDs, int LenImports, char *Imports, int &amp;SizeOfPacket, <a class="el" href="classEpetra__Distributor.html">Epetra_Distributor</a> &amp;Distor, <a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020f">Epetra_CombineMode</a> CombineMode, const <a class="el" href="classEpetra__OffsetIndex.html">Epetra_OffsetIndex</a> *Indexor)</td></tr>
<tr class="memdesc:adc77171308612e405e1427aeff35ad27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any unpacking and combining after call to <a class="el" href="classEpetra__DistObject.html#ab26ca2d3f9d20a850734f4af633e4135" title="Perform actual transfer (redistribution) of data across memory images, using Epetra_Distributor objec...">DoTransfer()</a>.  <br /></td></tr>
<tr class="separator:adc77171308612e405e1427aeff35ad27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394853bfa571b2b263b1960fa183421a" id="r_a394853bfa571b2b263b1960fa183421a"><td class="memItemLeft" align="right" valign="top"><a id="a394853bfa571b2b263b1960fa183421a" name="a394853bfa571b2b263b1960fa183421a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>SortEntries</b> ()</td></tr>
<tr class="memdesc:a394853bfa571b2b263b1960fa183421a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort column entries, row-by-row, in ascending order. <br /></td></tr>
<tr class="separator:a394853bfa571b2b263b1960fa183421a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22088b0640b16ec28ccad5279bfe0c3c" id="r_a22088b0640b16ec28ccad5279bfe0c3c"><td class="memItemLeft" align="right" valign="top"><a id="a22088b0640b16ec28ccad5279bfe0c3c" name="a22088b0640b16ec28ccad5279bfe0c3c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Sorted</b> () const</td></tr>
<tr class="memdesc:a22088b0640b16ec28ccad5279bfe0c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="classEpetra__CrsMatrix.html#a394853bfa571b2b263b1960fa183421a" title="Sort column entries, row-by-row, in ascending order.">SortEntries()</a> has been called, this query returns true, otherwise it returns false. <br /></td></tr>
<tr class="separator:a22088b0640b16ec28ccad5279bfe0c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce1aeb79ec41dae8dec0160dd857944" id="r_a5ce1aeb79ec41dae8dec0160dd857944"><td class="memItemLeft" align="right" valign="top"><a id="a5ce1aeb79ec41dae8dec0160dd857944" name="a5ce1aeb79ec41dae8dec0160dd857944"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MergeRedundantEntries</b> ()</td></tr>
<tr class="memdesc:a5ce1aeb79ec41dae8dec0160dd857944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add entries that have the same column index. Remove redundant entries from list. <br /></td></tr>
<tr class="separator:a5ce1aeb79ec41dae8dec0160dd857944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae93e07d91b89d5db3680d92ac23f1b1" id="r_aae93e07d91b89d5db3680d92ac23f1b1"><td class="memItemLeft" align="right" valign="top"><a id="aae93e07d91b89d5db3680d92ac23f1b1" name="aae93e07d91b89d5db3680d92ac23f1b1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>NoRedundancies</b> () const</td></tr>
<tr class="memdesc:aae93e07d91b89d5db3680d92ac23f1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="classEpetra__CrsMatrix.html#a5ce1aeb79ec41dae8dec0160dd857944" title="Add entries that have the same column index. Remove redundant entries from list.">MergeRedundantEntries()</a> has been called, this query returns true, otherwise it returns false. <br /></td></tr>
<tr class="separator:aae93e07d91b89d5db3680d92ac23f1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92d5ce75169b14c7a2439671f7a7c01" id="r_ac92d5ce75169b14c7a2439671f7a7c01"><td class="memItemLeft" align="right" valign="top"><a id="ac92d5ce75169b14c7a2439671f7a7c01" name="ac92d5ce75169b14c7a2439671f7a7c01"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeleteMemory</b> ()</td></tr>
<tr class="separator:ac92d5ce75169b14c7a2439671f7a7c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classEpetra__Object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classEpetra__Object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classEpetra__Object.html">Epetra_Object</a></td></tr>
<tr class="memitem:a3e039dae700d04726e0e78d73b69e7f6 inherit pub_static_methods_classEpetra__Object" id="r_a3e039dae700d04726e0e78d73b69e7f6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a3e039dae700d04726e0e78d73b69e7f6">SetTracebackMode</a> (int TracebackModeValue)</td></tr>
<tr class="memdesc:a3e039dae700d04726e0e78d73b69e7f6 inherit pub_static_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the <a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> error traceback report mode.  <br /></td></tr>
<tr class="separator:a3e039dae700d04726e0e78d73b69e7f6 inherit pub_static_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20914bd9b7bb7278ab332415c77ba999 inherit pub_static_methods_classEpetra__Object" id="r_a20914bd9b7bb7278ab332415c77ba999"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><b>GetTracebackMode</b> ()</td></tr>
<tr class="memdesc:a20914bd9b7bb7278ab332415c77ba999 inherit pub_static_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the <a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> error report mode. <br /></td></tr>
<tr class="separator:a20914bd9b7bb7278ab332415c77ba999 inherit pub_static_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661d6081fb13e1b4a4350faa88808f38 inherit pub_static_methods_classEpetra__Object" id="r_a661d6081fb13e1b4a4350faa88808f38"><td class="memItemLeft" align="right" valign="top">
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetTracebackStream</b> ()</td></tr>
<tr class="memdesc:a661d6081fb13e1b4a4350faa88808f38 inherit pub_static_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the output stream for error reporting. <br /></td></tr>
<tr class="separator:a661d6081fb13e1b4a4350faa88808f38 inherit pub_static_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classEpetra__Object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classEpetra__Object')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classEpetra__Object.html">Epetra_Object</a></td></tr>
<tr class="memitem:abcc693a0058b9910543df8c4ae76e5d9 inherit pub_static_attribs_classEpetra__Object" id="r_abcc693a0058b9910543df8c4ae76e5d9"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><b>TracebackMode</b></td></tr>
<tr class="separator:abcc693a0058b9910543df8c4ae76e5d9 inherit pub_static_attribs_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classEpetra__DistObject"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classEpetra__DistObject')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classEpetra__DistObject.html">Epetra_DistObject</a></td></tr>
<tr class="memitem:ab26ca2d3f9d20a850734f4af633e4135 inherit pro_methods_classEpetra__DistObject" id="r_ab26ca2d3f9d20a850734f4af633e4135"><td class="memItemLeft" align="right" valign="top">
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>DoTransfer</b> (const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;A, <a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020f">Epetra_CombineMode</a> CombineMode, int NumSameIDs, int NumPermuteIDs, int NumRemoteIDs, int NumExportIDs, int *PermuteToLIDs, int *PermuteFromLIDs, int *RemoteLIDs, int *ExportLIDs, int &amp;LenExports, char *&amp;Exports, int &amp;LenImports, char *&amp;Imports, <a class="el" href="classEpetra__Distributor.html">Epetra_Distributor</a> &amp;Distor, bool DoReverse, const <a class="el" href="classEpetra__OffsetIndex.html">Epetra_OffsetIndex</a> *Indexor)</td></tr>
<tr class="memdesc:ab26ca2d3f9d20a850734f4af633e4135 inherit pro_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform actual transfer (redistribution) of data across memory images, using <a class="el" href="classEpetra__Distributor.html" title="Epetra_Distributor: The Epetra Gather/Scatter Setup Base Class.">Epetra_Distributor</a> object. <br /></td></tr>
<tr class="separator:ab26ca2d3f9d20a850734f4af633e4135 inherit pro_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classEpetra__Object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classEpetra__Object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classEpetra__Object.html">Epetra_Object</a></td></tr>
<tr class="memitem:a4e3832c165d22a45d3dd6fecd16d91f4 inherit pro_methods_classEpetra__Object" id="r_a4e3832c165d22a45d3dd6fecd16d91f4"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (const int &amp;x) const</td></tr>
<tr class="separator:a4e3832c165d22a45d3dd6fecd16d91f4 inherit pro_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3f57c8b22b5b0df91400fca8447ab2 inherit pro_methods_classEpetra__Object" id="r_aaa3f57c8b22b5b0df91400fca8447ab2"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (const long long &amp;x) const</td></tr>
<tr class="separator:aaa3f57c8b22b5b0df91400fca8447ab2 inherit pro_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a2fa958fffb21a0479a19956185be1 inherit pro_methods_classEpetra__Object" id="r_ab8a2fa958fffb21a0479a19956185be1"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (const double &amp;x) const</td></tr>
<tr class="separator:ab8a2fa958fffb21a0479a19956185be1 inherit pro_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classEpetra__DistObject"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classEpetra__DistObject')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classEpetra__DistObject.html">Epetra_DistObject</a></td></tr>
<tr class="memitem:afe0876212b0bc64248080c7949cc2fe8 inherit pro_attribs_classEpetra__DistObject" id="r_afe0876212b0bc64248080c7949cc2fe8"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Map_</b></td></tr>
<tr class="separator:afe0876212b0bc64248080c7949cc2fe8 inherit pro_attribs_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b10439013b488908a69faf197b3720 inherit pro_attribs_classEpetra__DistObject" id="r_af6b10439013b488908a69faf197b3720"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Comm_</b></td></tr>
<tr class="separator:af6b10439013b488908a69faf197b3720 inherit pro_attribs_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55db06ab43cc8633cc98bda807b75052 inherit pro_attribs_classEpetra__DistObject" id="r_a55db06ab43cc8633cc98bda807b75052"><td class="memItemLeft" align="right" valign="top">
char *&#160;</td><td class="memItemRight" valign="bottom"><b>Exports_</b></td></tr>
<tr class="separator:a55db06ab43cc8633cc98bda807b75052 inherit pro_attribs_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c0a956075d9df8f96480a64695afef inherit pro_attribs_classEpetra__DistObject" id="r_ac2c0a956075d9df8f96480a64695afef"><td class="memItemLeft" align="right" valign="top">
char *&#160;</td><td class="memItemRight" valign="bottom"><b>Imports_</b></td></tr>
<tr class="separator:ac2c0a956075d9df8f96480a64695afef inherit pro_attribs_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa299778b21bd3310bfa8b91b1435f1d2 inherit pro_attribs_classEpetra__DistObject" id="r_aa299778b21bd3310bfa8b91b1435f1d2"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>LenExports_</b></td></tr>
<tr class="separator:aa299778b21bd3310bfa8b91b1435f1d2 inherit pro_attribs_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d50d714698b235360d6c9b8c457df4 inherit pro_attribs_classEpetra__DistObject" id="r_ab3d50d714698b235360d6c9b8c457df4"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>LenImports_</b></td></tr>
<tr class="separator:ab3d50d714698b235360d6c9b8c457df4 inherit pro_attribs_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9bc03c6fef4031fe9358c9e855e174 inherit pro_attribs_classEpetra__DistObject" id="r_a2a9bc03c6fef4031fe9358c9e855e174"><td class="memItemLeft" align="right" valign="top">
int *&#160;</td><td class="memItemRight" valign="bottom"><b>Sizes_</b></td></tr>
<tr class="separator:a2a9bc03c6fef4031fe9358c9e855e174 inherit pro_attribs_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classEpetra__CompObject"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classEpetra__CompObject')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classEpetra__CompObject.html">Epetra_CompObject</a></td></tr>
<tr class="memitem:a4095552501f59c9dc407185a4944759f inherit pro_attribs_classEpetra__CompObject" id="r_a4095552501f59c9dc407185a4944759f"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classEpetra__Flops.html">Epetra_Flops</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>FlopCounter_</b></td></tr>
<tr class="separator:a4095552501f59c9dc407185a4944759f inherit pro_attribs_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a>: A class for constructing and using real-valued double-precision sparse compressed row matrices. </p>
<p>The <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> class is a sparse compressed row matrix object. This matrix can be used in a parallel setting, with data distribution described by <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> attributes. The structure or graph of the matrix is defined by an <a class="el" href="classEpetra__CrsGraph.html" title="Epetra_CrsGraph: A class for constructing and using sparse compressed row graphs.">Epetra_CrsGraph</a> attribute.</p>
<p>In addition to coefficient access, the primary operations provided by <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> are matrix times vector and matrix times multi-vector multiplication.</p>
<p><a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> matrices can be square or rectangular.</p>
<p><b>Creating and filling <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> objects</b></p>
<p>Constructing <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> objects is a multi-step process. The basic steps are as follows: </p><ol>
<li>
Create <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> instance, including storage, via one of the constructors: <ul>
<li>
Constructor that accepts one <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> object, a row-map defining the distribution of matrix rows. </li>
<li>
Constructor that accepts two <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> objects. (The second map is a column-map, and describes the set of column-indices that appear in each processor's portion of the matrix. Generally these are overlapping sets &ndash; column-indices may appear on more than one processor.) </li>
<li>
Constructor that accepts an <a class="el" href="classEpetra__CrsGraph.html" title="Epetra_CrsGraph: A class for constructing and using sparse compressed row graphs.">Epetra_CrsGraph</a> object, defining the non-zero structure of the matrix. </li>
</ul>
Note that the constructors which accept <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> arguments also accept an argument that gives an estimate of the number of nonzeros per row. This allows storage to be pre-allocated and can improve the performance of the data input methods. The estimate need not be accurate, as additional storage is allocated automatically when needed. However, a more accurate estimate helps performance by reducing the amount of extra memory allocation. </li>
<li>
Enter values via one or more Insert/Replace/SumInto functions. </li>
<li>
Complete construction by calling FillComplete. </li>
</ol>
<p>Note that, even after a matrix is constructed (FillComplete has been called), it is possible to update existing matrix entries. It is <em>not</em> possible to create new entries.</p>
<p><b><a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> attributes</b></p>
<p><a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> objects have four <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> attributes, which are held by the <a class="el" href="classEpetra__CrsGraph.html" title="Epetra_CrsGraph: A class for constructing and using sparse compressed row graphs.">Epetra_CrsGraph</a> attribute.</p>
<p>The <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> attributes can be obtained via these accessor methods: </p><ul>
<li>
<a class="el" href="classEpetra__CrsMatrix.html#a24855eec1cf6aeb201be88ba654d22bf" title="Returns the Epetra_Map object associated with the rows of this matrix.">RowMap()</a> Describes the numbering and distribution of the rows of the matrix. The row-map exists and is valid for the entire life of the matrix. The set of matrix rows is defined by the row-map and may not be changed. Rows may not be inserted or deleted by the user. The only change that may be made is that the user can replace the row-map with a compatible row-map (which is the same except for re-numbering) by calling the <a class="el" href="classEpetra__CrsMatrix.html#a3c83fee95e71471e118fa91c15809aa2" title="Replaces the current RowMap with the user-specified map object.">ReplaceRowMap()</a> method. </li>
<li>
<a class="el" href="classEpetra__CrsMatrix.html#aab3589bfaac41458ab698d3d53780e61" title="Returns the Epetra_Map object that describes the set of column-indices that appear in each processor&#39;...">ColMap()</a> Describes the set of column-indices that appear in the rows in each processor's portion of the matrix. Unless provided by the user at construction time, a valid column-map doesn't exist until <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> is called. </li>
<li>
<a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222" title="Returns the Epetra_Map object associated with the range of this matrix operator.">RangeMap()</a> Describes the range of the matrix operator. e.g., for a matrix-vector product operation, the result vector's map must be compatible with the range-map of this matrix. The range-map is usually the same as the row-map. The range-map is set equal to the row-map at matrix creation time, but may be specified by the user when <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> is called. </li>
<li>
<a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c" title="Returns the Epetra_Map object associated with the domain of this matrix operator.">DomainMap()</a> Describes the domain of the matrix operator. The domain-map can be specified by the user when <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> is called. Until then, it is set equal to the row-map. </li>
</ul>
<p>It is important to note that while the row-map and the range-map are often the same, the column-map and the domain-map are almost never the same. The set of entries in a distributed column-map almost always form overlapping sets, with entries being associated with more than one processor. A domain-map, on the other hand, must be a 1-to-1 map, with entries being associated with only a single processor.</p>
<p><b>Local versus Global Indices</b></p>
<p><a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> has query functions <a class="el" href="classEpetra__CrsMatrix.html#aae10c5b74759484342ed40ced9561f49" title="If matrix indices has been transformed to local, this query returns true, otherwise it returns false.">IndicesAreLocal()</a> and <a class="el" href="classEpetra__CrsMatrix.html#ae1486df3fb52a638e43eb8aa896a1b4c" title="If matrix indices has not been transformed to local, this query returns true, otherwise it returns fa...">IndicesAreGlobal()</a>, which are used to determine whether the underlying <a class="el" href="classEpetra__CrsGraph.html" title="Epetra_CrsGraph: A class for constructing and using sparse compressed row graphs.">Epetra_CrsGraph</a> attribute's column-indices have been transformed into a local index space or not. (This transformation occurs when the method <a class="el" href="classEpetra__CrsGraph.html#a7a77f6a61a80ce90943988ee3aa537ae" title="Tranform to local index space. Perform other operations to allow optimal matrix operations.">Epetra_CrsGraph::FillComplete()</a> is called, which happens when the method <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">Epetra_CrsMatrix::FillComplete()</a> is called.) The state of the indices in the graph determines the behavior of many <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> methods. If an <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> instance is constructed using one of the constructors that does not accept a pre-existing <a class="el" href="classEpetra__CrsGraph.html" title="Epetra_CrsGraph: A class for constructing and using sparse compressed row graphs.">Epetra_CrsGraph</a> object, then an <a class="el" href="classEpetra__CrsGraph.html" title="Epetra_CrsGraph: A class for constructing and using sparse compressed row graphs.">Epetra_CrsGraph</a> attribute is created internally and its indices remain untransformed (<a class="el" href="classEpetra__CrsMatrix.html#ae1486df3fb52a638e43eb8aa896a1b4c" title="If matrix indices has not been transformed to local, this query returns true, otherwise it returns fa...">IndicesAreGlobal()</a>==true) until <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">Epetra_CrsMatrix::FillComplete()</a> is called. The query function <a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Epetra_CrsMatrix::Filled()</a> returns true if <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">Epetra_CrsMatrix::FillComplete()</a> has been called.</p>
<p>Note the following method characteristics:</p>
<ul>
<li>
<a class="el" href="classEpetra__CrsMatrix.html#a2f7ff1b3a9be1c41fe218538af97cfdb" title="Insert a list of elements in a given global row of the matrix.">InsertGlobalValues()</a> may only be used to insert new nonzeros in the matrix if indices are global. </li>
<li>
<a class="el" href="classEpetra__CrsMatrix.html#a1291bfb498b94ac4f1563b48d11dfae5" title="Add this list of entries to existing values for a given global row of the matrix.">SumIntoGlobalValues()</a> may be used regardless of whether indices are global or local, but can only be used to update matrix locations that already exist; it can never be used to establish new nonzero locations. </li>
<li>
<a class="el" href="classEpetra__CrsMatrix.html#a36048758bcfe082ca07090569607d574" title="Replace specified existing values with this list of entries for a given global row of the matrix.">ReplaceGlobalValues()</a> may also be used only to update matrix locations that already exist, and works regardless of whether indices are local or global. </li>
<li>
<a class="el" href="classEpetra__CrsMatrix.html#a8e93959017a68cb0103110d80b124c82" title="Add this list of entries to existing values for a given local row of the matrix.">SumIntoMyValues()</a> and <a class="el" href="classEpetra__CrsMatrix.html#acecf7e5bf939b56644e25c57f67e137d" title="Replace current values with this list of entries for a given local row of the matrix.">ReplaceMyValues()</a> may only be used if indices are local. </li>
<li>
<a class="el" href="classEpetra__CrsMatrix.html#ad028fbe37c3d2ce3f43e2acf2cbb29de" title="Returns the result of a Epetra_CrsMatrix multiplied by a Epetra_Vector x in y.">Multiply()</a> may only be used after <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> has been called. </li>
</ul>
<p>Most methods have preconditions documented, check documentation for specific methods not mentioned here.</p>
<p><b> Counting Floating Point Operations </b></p>
<p>Each <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> object keeps track of the number of <em>serial</em> floating point operations performed using the specified object as the <em>this</em> argument to the function. The <a class="el" href="classEpetra__CompObject.html#a8326f0873a8866ac9f15f08f5ef31b0d" title="Returns the number of floating point operations with this multi-vector.">Flops()</a> function returns this number as a double precision number. Using this information, in conjunction with the <a class="el" href="classEpetra__Time.html" title="Epetra_Time: The Epetra Timing Class.">Epetra_Time</a> class, one can get accurate parallel performance numbers. The <a class="el" href="classEpetra__CompObject.html#a4adff4c34d61377709fc8a17e99e3eae" title="Resets the number of floating point operations to zero for this multi-vector.">ResetFlops()</a> function resets the floating point counter.</p>
<dl class="section warning"><dt>Warning</dt><dd>A <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> is required for the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> constructor. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af174457dccd1ff7612126172863614c0" name="af174457dccd1ff7612126172863614c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af174457dccd1ff7612126172863614c0">&#9670;&#160;</a></span>Epetra_CrsMatrix() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_CrsMatrix::Epetra_CrsMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a>&#160;</td>
          <td class="paramname"><em>CV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td>
          <td class="paramname"><em>RowMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>NumEntriesPerRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>StaticProfile</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> constructor with variable number of indices per row. </p>
<p>Creates a <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> object and allocates storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CV</td><td>- (In) An Epetra_DataAccess enumerated type set to Copy or View. </td></tr>
    <tr><td class="paramname">RowMap</td><td>- (In) An <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> defining the numbering and distribution of matrix rows. </td></tr>
    <tr><td class="paramname">NumEntriesPerRow</td><td>- (In) An integer array of length NumRows such that NumEntriesPerRow[i] indicates the (approximate if StaticProfile=false) number of entries in the ith row. </td></tr>
    <tr><td class="paramname">StaticProfile</td><td>- (In) Optional argument that indicates whether or not NumIndicesPerRow should be interpreted as an exact count of nonzeros, or should be used as an approximation. By default this value is false, allowing the profile to be determined dynamically. If the user sets it to true, then the memory allocation for the <a class="el" href="classEpetra__CrsGraph.html" title="Epetra_CrsGraph: A class for constructing and using sparse compressed row graphs.">Epetra_CrsGraph</a> object will be done in one large block, saving on memory fragmentation and generally improving the performance of matrix multiplication and solve kernels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4d9a06553f57f94b1f294356a91823b" name="ad4d9a06553f57f94b1f294356a91823b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d9a06553f57f94b1f294356a91823b">&#9670;&#160;</a></span>Epetra_CrsMatrix() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_CrsMatrix::Epetra_CrsMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a>&#160;</td>
          <td class="paramname"><em>CV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td>
          <td class="paramname"><em>RowMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumEntriesPerRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>StaticProfile</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> constructor with fixed number of indices per row. </p>
<p>Creates a <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> object and allocates storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CV</td><td>- (In) An Epetra_DataAccess enumerated type set to Copy or View. </td></tr>
    <tr><td class="paramname">RowMap</td><td>- (In) An <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> defining the numbering and distribution of matrix rows. </td></tr>
    <tr><td class="paramname">NumEntriesPerRow</td><td>- (In) An integer that indicates the (approximate) number of entries in the each row. Note that it is possible to use 0 for this value and let fill occur during the insertion phase. </td></tr>
    <tr><td class="paramname">StaticProfile</td><td>- (In) Optional argument that indicates whether or not NumIndicesPerRow should be interpreted as an exact count of nonzeros, or should be used as an approximation. By default this value is false, allowing the profile to be determined dynamically. If the user sets it to true, then the memory allocation for the <a class="el" href="classEpetra__CrsGraph.html" title="Epetra_CrsGraph: A class for constructing and using sparse compressed row graphs.">Epetra_CrsGraph</a> object will be done in one large block, saving on memory fragmentation and generally improving the performance of matrix multiplication and solve kernels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83e3f3a7c450a7443bd3b41580d11513" name="a83e3f3a7c450a7443bd3b41580d11513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e3f3a7c450a7443bd3b41580d11513">&#9670;&#160;</a></span>Epetra_CrsMatrix() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_CrsMatrix::Epetra_CrsMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a>&#160;</td>
          <td class="paramname"><em>CV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td>
          <td class="paramname"><em>RowMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td>
          <td class="paramname"><em>ColMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>NumEntriesPerRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>StaticProfile</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> constructor with variable number of indices per row. </p>
<p>Creates a <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> object and allocates storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CV</td><td>- (In) An Epetra_DataAccess enumerated type set to Copy or View. </td></tr>
    <tr><td class="paramname">RowMap</td><td>- (In) An <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> defining the numbering and distribution of matrix rows. </td></tr>
    <tr><td class="paramname">ColMap</td><td>- (In) An <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> defining the set of column-indices that appear in each processor's locally owned matrix rows. </td></tr>
    <tr><td class="paramname">NumEntriesPerRow</td><td>- (In) An integer array of length NumRows such that NumEntriesPerRow[i] indicates the (approximate if StaticProfile=false) number of entries in the ith row. </td></tr>
    <tr><td class="paramname">StaticProfile</td><td>- (In) Optional argument that indicates whether or not NumIndicesPerRow should be interpreted as an exact count of nonzeros, or should be used as an approximation. By default this value is false, allowing the profile to be determined dynamically. If the user sets it to true, then the memory allocation for the <a class="el" href="classEpetra__CrsGraph.html" title="Epetra_CrsGraph: A class for constructing and using sparse compressed row graphs.">Epetra_CrsGraph</a> object will be done in one large block, saving on memory fragmentation and generally improving the performance of matrix multiplication and solve kernels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a976b94f3d9dbfe17aa425d29a3b0c0d7" name="a976b94f3d9dbfe17aa425d29a3b0c0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976b94f3d9dbfe17aa425d29a3b0c0d7">&#9670;&#160;</a></span>Epetra_CrsMatrix() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_CrsMatrix::Epetra_CrsMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a>&#160;</td>
          <td class="paramname"><em>CV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td>
          <td class="paramname"><em>RowMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td>
          <td class="paramname"><em>ColMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumEntriesPerRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>StaticProfile</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> constuctor with fixed number of indices per row. </p>
<p>Creates a <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> object and allocates storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CV</td><td>- (In) An Epetra_DataAccess enumerated type set to Copy or View. </td></tr>
    <tr><td class="paramname">RowMap</td><td>- (In) An <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> defining the numbering and distribution of matrix rows. </td></tr>
    <tr><td class="paramname">ColMap</td><td>- (In) An <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> defining the set of column-indices that appear in each processor's locally owned matrix rows. </td></tr>
    <tr><td class="paramname">NumEntriesPerRow</td><td>- (In) An integer that indicates the (approximate if StaticProfile=false) number of entries in the each row. Note that it is possible to use 0 for this value and let fill occur during the insertion phase. </td></tr>
    <tr><td class="paramname">StaticProfile</td><td>- (In) Optional argument that indicates whether or not NumIndicesPerRow should be interpreted as an exact count of nonzeros, or should be used as an approximation. By default this value is false, allowing the profile to be determined dynamically. If the user sets it to true, then the memory allocation for the <a class="el" href="classEpetra__CrsGraph.html" title="Epetra_CrsGraph: A class for constructing and using sparse compressed row graphs.">Epetra_CrsGraph</a> object will be done in one large block, saving on memory fragmentation and generally improving the performance of matrix multiplication and solve kernels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abea2e6fa0f05885ec6bb758283777251" name="abea2e6fa0f05885ec6bb758283777251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea2e6fa0f05885ec6bb758283777251">&#9670;&#160;</a></span>Epetra_CrsMatrix() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_CrsMatrix::Epetra_CrsMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a>&#160;</td>
          <td class="paramname"><em>CV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__CrsGraph.html">Epetra_CrsGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>Graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a matrix using an existing <a class="el" href="classEpetra__CrsGraph.html" title="Epetra_CrsGraph: A class for constructing and using sparse compressed row graphs.">Epetra_CrsGraph</a> object. </p>
<p>Allows the nonzero structure from another matrix, or a structure that was constructed independently, to be used for this matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CV</td><td>- (In) An Epetra_DataAccess enumerated type set to Copy or View. </td></tr>
    <tr><td class="paramname">Graph</td><td>- (In) A <a class="el" href="classEpetra__CrsGraph.html" title="Epetra_CrsGraph: A class for constructing and using sparse compressed row graphs.">Epetra_CrsGraph</a> object, constructed directly or extracted from another Epetra matrix object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b7002382b0e988660cc450a8453987e" name="a8b7002382b0e988660cc450a8453987e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7002382b0e988660cc450a8453987e">&#9670;&#160;</a></span>Epetra_CrsMatrix() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_CrsMatrix::Epetra_CrsMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>SourceMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> &amp;&#160;</td>
          <td class="paramname"><em>RowImporter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *&#160;</td>
          <td class="paramname"><em>DomainMap</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *&#160;</td>
          <td class="paramname"><em>RangeMap</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>RestrictCommunicator</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Epetra CrsMatrix constructor that also fuses Import and <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a>. </p>
<p>A common use case is to create an empty destination <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a>, redistribute from a source CrsMatrix (by an Import or Export operation), then call <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> on the destination CrsMatrix. This constructor fuses these three cases, for an Import redistribution.</p>
<p>Fusing redistribution and <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> exposes potential optimizations. For example, it may make constructing the column map faster, and it may avoid intermediate unoptimized storage in the destination <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a>. These optimizations may improve performance for specialized kernels like sparse matrix-matrix multiply, as well as for redistributing data after doing load balancing.</p>
<p>The resulting matrix is fill complete (in the sense of <a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>) and has optimized storage (in the sense of <a class="el" href="classEpetra__CrsMatrix.html#aab604df6545e7cb7c38eec982719d104" title="If OptimizeStorage() has been called, this query returns true, otherwise it returns false.">StorageOptimized()</a>). It the DomainMap is taken from the SourceMatrix, the RangeMap is presumed to be RowImporter.TargetMap() if not specified</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SourceMatrix</td><td>[in] The source matrix from which to import. The source of an Import must have a nonoverlapping distribution.</td></tr>
    <tr><td class="paramname">RowImporter</td><td>[in] The Import instance containing a precomputed redistribution plan. The source Map of the Import must be the same as the row Map of sourceMatrix.</td></tr>
    <tr><td class="paramname">DomainMap</td><td>[in] The new domainMap for the new matrix. If not specified, then the DomainMap of the SourceMatrix is used.</td></tr>
    <tr><td class="paramname">RangeMap</td><td>[in] The new rangeMap for the new matrix. If not specified, then RowImporter.TargetMap() is used.</td></tr>
    <tr><td class="paramname">RestrictCommunicator</td><td>[in] Restricts the resulting communicator to active processes only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa47469f36f75bc7147e443cc045685d" name="afa47469f36f75bc7147e443cc045685d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa47469f36f75bc7147e443cc045685d">&#9670;&#160;</a></span>Epetra_CrsMatrix() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_CrsMatrix::Epetra_CrsMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>SourceMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> &amp;&#160;</td>
          <td class="paramname"><em>RowImporter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> *&#160;</td>
          <td class="paramname"><em>DomainImporter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *&#160;</td>
          <td class="paramname"><em>DomainMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *&#160;</td>
          <td class="paramname"><em>RangeMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>RestrictCommunicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Epetra CrsMatrix constructor that also fuses Import and <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a>. </p>
<p>A common use case is to create an empty destination <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a>, redistribute from a source CrsMatrix (by an Import or Export operation), then call <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> on the destination CrsMatrix. This constructor fuses these three cases, for an Import redistribution.</p>
<p>Fusing redistribution and <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> exposes potential optimizations. For example, it may make constructing the column map faster, and it may avoid intermediate unoptimized storage in the destination <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a>. These optimizations may improve performance for specialized kernels like sparse matrix-matrix multiply, as well as for redistributing data after doing load balancing.</p>
<p>The resulting matrix is fill complete (in the sense of <a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>) and has optimized storage (in the sense of <a class="el" href="classEpetra__CrsMatrix.html#aab604df6545e7cb7c38eec982719d104" title="If OptimizeStorage() has been called, this query returns true, otherwise it returns false.">StorageOptimized()</a>). It the DomainMap is taken from the SourceMatrix, the RangeMap is presumed to be RowImporter.TargetMap() if not specified</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SourceMatrix</td><td>[in] The source matrix from which to import. The source of an Import must have a nonoverlapping distribution.</td></tr>
    <tr><td class="paramname">RowImporter</td><td>[in] The Import instance containing a precomputed redistribution plan. The source Map of the Import must be the same as the row Map of sourceMatrix.</td></tr>
    <tr><td class="paramname">DomainImporter</td><td>[in] The Import instance containing a precomputed redistribution plan (for the domain maps). The source Map of the Import must be the same as the domain Map of sourceMatrix.</td></tr>
    <tr><td class="paramname">DomainMap</td><td>[in] The new domainMap for the new matrix.</td></tr>
    <tr><td class="paramname">RangeMap</td><td>[in] The new rangeMap for the new matrix.</td></tr>
    <tr><td class="paramname">RestrictCommunicator</td><td>[in] Restricts the resulting communicator to active processes only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a9e9a8fc2eb865889c9e090528f6215" name="a8a9e9a8fc2eb865889c9e090528f6215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9e9a8fc2eb865889c9e090528f6215">&#9670;&#160;</a></span>Epetra_CrsMatrix() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_CrsMatrix::Epetra_CrsMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>SourceMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> &amp;&#160;</td>
          <td class="paramname"><em>RowExporter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *&#160;</td>
          <td class="paramname"><em>DomainMap</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *&#160;</td>
          <td class="paramname"><em>RangeMap</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>RestrictCommunicator</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Epetra CrsMatrix constructor that also fuses Ex[prt and <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a>. </p>
<p>A common use case is to create an empty destination <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a>, redistribute from a source CrsMatrix (by an Import or Export operation), then call <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> on the destination CrsMatrix. This constructor fuses these three cases, for an Import redistribution.</p>
<p>Fusing redistribution and <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> exposes potential optimizations. For example, it may make constructing the column map faster, and it may avoid intermediate unoptimized storage in the destination <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a>. These optimizations may improve performance for specialized kernels like sparse matrix-matrix multiply, as well as for redistributing data after doing load balancing.</p>
<p>The resulting matrix is fill complete (in the sense of <a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>) and has optimized storage (in the sense of <a class="el" href="classEpetra__CrsMatrix.html#aab604df6545e7cb7c38eec982719d104" title="If OptimizeStorage() has been called, this query returns true, otherwise it returns false.">StorageOptimized()</a>). It the DomainMap is taken from the SourceMatrix, the RangeMap is presumed to be RowImporter.TargetMap() if not specified</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SourceMatrix</td><td>[in] The source matrix from which to import. The source of an Import must have a nonoverlapping distribution.</td></tr>
    <tr><td class="paramname">RowExporter</td><td>[in] The Export instance containing a precomputed redistribution plan. The source Map of the Import must be the same as the row Map of sourceMatrix.</td></tr>
    <tr><td class="paramname">DomainMap</td><td>[in] The new domainMap for the new matrix. If not specified, then the DomainMap of the SourceMatrix is used.</td></tr>
    <tr><td class="paramname">RangeMap</td><td>[in] The new rangeMap for the new matrix. If not specified, then RowExporter.TargetMap() is used.</td></tr>
    <tr><td class="paramname">RestrictCommunicator</td><td>[in] Restricts the resulting communicator to active processes only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad93a987aa9463831451960dc462c5985" name="ad93a987aa9463831451960dc462c5985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93a987aa9463831451960dc462c5985">&#9670;&#160;</a></span>Epetra_CrsMatrix() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_CrsMatrix::Epetra_CrsMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>SourceMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> &amp;&#160;</td>
          <td class="paramname"><em>RowExporter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> *&#160;</td>
          <td class="paramname"><em>DomainExporter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *&#160;</td>
          <td class="paramname"><em>DomainMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> *&#160;</td>
          <td class="paramname"><em>RangeMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>RestrictCommunicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Epetra CrsMatrix constructor that also fuses Ex[prt and <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a>. </p>
<p>A common use case is to create an empty destination <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a>, redistribute from a source CrsMatrix (by an Import or Export operation), then call <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> on the destination CrsMatrix. This constructor fuses these three cases, for an Import redistribution.</p>
<p>Fusing redistribution and <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> exposes potential optimizations. For example, it may make constructing the column map faster, and it may avoid intermediate unoptimized storage in the destination <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a>. These optimizations may improve performance for specialized kernels like sparse matrix-matrix multiply, as well as for redistributing data after doing load balancing.</p>
<p>The resulting matrix is fill complete (in the sense of <a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>) and has optimized storage (in the sense of <a class="el" href="classEpetra__CrsMatrix.html#aab604df6545e7cb7c38eec982719d104" title="If OptimizeStorage() has been called, this query returns true, otherwise it returns false.">StorageOptimized()</a>). It the DomainMap is taken from the SourceMatrix, the RangeMap is presumed to be RowImporter.TargetMap() if not specified</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SourceMatrix</td><td>[in] The source matrix from which to import. The source of an Import must have a nonoverlapping distribution.</td></tr>
    <tr><td class="paramname">RowExporter</td><td>[in] The Export instance containing a precomputed redistribution plan. The source Map of the Import must be the same as the row Map of sourceMatrix.</td></tr>
    <tr><td class="paramname">DomainExporter</td><td>[in] The Export instance containing a precomputed redistribution plan (for the domain map. The source Map of the Import must be the same as the domain Map of sourceMatrix.</td></tr>
    <tr><td class="paramname">DomainMap</td><td>[in] The new domainMap for the new matrix.</td></tr>
    <tr><td class="paramname">RangeMap</td><td>[in] The new rangeMap for the new matrix.</td></tr>
    <tr><td class="paramname">RestrictCommunicator</td><td>[in] Restricts the resulting communicator to active processes only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa71714f462b0e0218cf6c0c9f6a65353" name="aa71714f462b0e0218cf6c0c9f6a65353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71714f462b0e0218cf6c0c9f6a65353">&#9670;&#160;</a></span>Apply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::Apply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of a <a class="el" href="classEpetra__Operator.html" title="Epetra_Operator: A pure virtual class for using real-valued double-precision operators.">Epetra_Operator</a> applied to a <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> X in Y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>- (In) An <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> of dimension NumVectors to multiply with matrix. </td></tr>
    <tr><td class="paramname">Y</td><td>-(Out) An <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> of dimension NumVectors containing result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged. </dd></dl>

<p>Implements <a class="el" href="classEpetra__Operator.html#a44ff0c479186b0e3db841404dbd80491">Epetra_Operator</a>.</p>

<p class="reference">References <a class="el" href="classEpetra__CrsMatrix.html#ad028fbe37c3d2ce3f43e2acf2cbb29de">Multiply()</a>, and <a class="el" href="classEpetra__CrsMatrix.html#a0cd834231c77c941d11ce1d0f1ddb727">UseTranspose()</a>.</p>

</div>
</div>
<a id="a7df56e43070f908dec709b1a19348cee" name="a7df56e43070f908dec709b1a19348cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df56e43070f908dec709b1a19348cee">&#9670;&#160;</a></span>ApplyInverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::ApplyInverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of a <a class="el" href="classEpetra__Operator.html" title="Epetra_Operator: A pure virtual class for using real-valued double-precision operators.">Epetra_Operator</a> inverse applied to an <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> X in Y. </p>
<p>In this implementation, we use several existing attributes to determine how virtual method <a class="el" href="classEpetra__CrsMatrix.html#a7df56e43070f908dec709b1a19348cee" title="Returns the result of a Epetra_Operator inverse applied to an Epetra_MultiVector X in Y.">ApplyInverse()</a> should call the concrete method <a class="el" href="classEpetra__CrsMatrix.html#a4b0d7c00870df3bf3a18db186a290e64" title="Returns the result of a local solve using the Epetra_CrsMatrix on a Epetra_Vector x in y.">Solve()</a>. We pass in the <a class="el" href="classEpetra__CrsMatrix.html#ac6a4fac8da3d1e717b1fb500f9806e53" title="If matrix is upper triangular in local index space, this query returns true, otherwise it returns fal...">UpperTriangular()</a>, the <a class="el" href="classEpetra__CrsMatrix.html#a0cd834231c77c941d11ce1d0f1ddb727" title="Returns the current UseTranspose setting.">Epetra_CrsMatrix::UseTranspose()</a>, and <a class="el" href="classEpetra__CrsMatrix.html#adf6b258a0e7301a5fa31c51037622f1e" title="If matrix has no diagonal entries in global index space, this query returns true, otherwise it return...">NoDiagonal()</a> methods. The most notable warning is that if a matrix has no diagonal values we assume that there is an implicit unit diagonal that should be accounted for when doing a triangular solve.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>- (In) An <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> of dimension NumVectors to solve for. </td></tr>
    <tr><td class="paramname">Y</td><td>- (Out) An <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> of dimension NumVectors containing result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged. </dd></dl>

<p>Implements <a class="el" href="classEpetra__Operator.html#aac0eb3b0061a6e67a5666194e744c343">Epetra_Operator</a>.</p>

<p class="reference">References <a class="el" href="classEpetra__RowMatrix.html#a63cec4057182c076033d004ca3724f53">Epetra_RowMatrix::Solve()</a>, <a class="el" href="classEpetra__RowMatrix.html#ab30657243609dfca86645934ce223400">Epetra_RowMatrix::UpperTriangular()</a>, and <a class="el" href="classEpetra__CrsMatrix.html#a0cd834231c77c941d11ce1d0f1ddb727">UseTranspose()</a>.</p>

</div>
</div>
<a id="a4c1ad7e5a043bb17d2fb8c5fe0246c8c" name="a4c1ad7e5a043bb17d2fb8c5fe0246c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1ad7e5a043bb17d2fb8c5fe0246c8c">&#9670;&#160;</a></span>CheckSizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::CheckSizes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;&#160;</td>
          <td class="paramname"><em>Source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows the source and target (<em>this</em>) objects to be compared for compatibility, return nonzero if not. </p>

<p>Implements <a class="el" href="classEpetra__DistObject.html#a0574905a78333b8b1901cf463cd1b248">Epetra_DistObject</a>.</p>

</div>
</div>
<a id="aab3589bfaac41458ab698d3d53780e61" name="aab3589bfaac41458ab698d3d53780e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3589bfaac41458ab698d3d53780e61">&#9670;&#160;</a></span>ColMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp; Epetra_CrsMatrix::ColMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> object that describes the set of column-indices that appear in each processor's locally owned matrix rows. </p>
<p>Note that if the matrix was constructed with only a row-map, then until <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> is called, this method returns a column-map that is a copy of the row-map. That 'initial' column-map is replaced with a computed column-map (that contains the set of column-indices appearing in each processor's local portion of the matrix) when <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> is called.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a4506a3e3975010fc801d915f7e6f08ba" title="Returns true if we have a well-defined ColMap, and returns false otherwise.">HaveColMap()</a>==true </dd></dl>

</div>
</div>
<a id="a997eeee1d81be3d5b408b0bed58cd351" name="a997eeee1d81be3d5b408b0bed58cd351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997eeee1d81be3d5b408b0bed58cd351">&#9670;&#160;</a></span>Comm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp; Epetra_CrsMatrix::Comm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> communicator associated with this matrix. </p>

<p>Implements <a class="el" href="classEpetra__Operator.html#a7a49f63f905838687a623e6438c3d760">Epetra_Operator</a>.</p>

<p class="reference">References <a class="el" href="classEpetra__DistObject.html#aad2e2c38a27e224f15fce659e00fc9c0">Epetra_DistObject::Comm()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classEpetra__FastCrsOperator.html#af7f4ad239464b95b225e8072710b4143">Epetra_FastCrsOperator::Comm()</a>.</p>

</div>
</div>
<a id="ae7d7caaff9052f0e76f6353cdb7a2575" name="ae7d7caaff9052f0e76f6353cdb7a2575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d7caaff9052f0e76f6353cdb7a2575">&#9670;&#160;</a></span>CopyAndPermute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::CopyAndPermute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;&#160;</td>
          <td class="paramname"><em>Source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumSameIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumPermuteIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>PermuteToLIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>PermuteFromLIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__OffsetIndex.html">Epetra_OffsetIndex</a> *&#160;</td>
          <td class="paramname"><em>Indexor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020f">Epetra_CombineMode</a>&#160;</td>
          <td class="paramname"><em>CombineMode</em> = <code><a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020fab9f6920de535f04ccfe34d670fa2c8a8">Zero</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform ID copies and permutations that are on processor. </p>

<p>Implements <a class="el" href="classEpetra__DistObject.html#a976ba99d0144fbc5a2ac6e09068948f4">Epetra_DistObject</a>.</p>

</div>
</div>
<a id="ac8c6024783cb8f9a333f16b9ea5aa40c" name="ac8c6024783cb8f9a333f16b9ea5aa40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c6024783cb8f9a333f16b9ea5aa40c">&#9670;&#160;</a></span>DomainMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp; Epetra_CrsMatrix::DomainMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> object associated with the domain of this matrix operator. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>

</div>
</div>
<a id="aace936ff3ff41b09aa79ec7ed070f960" name="aace936ff3ff41b09aa79ec7ed070f960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace936ff3ff41b09aa79ec7ed070f960">&#9670;&#160;</a></span>ExpertExtractIndexOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEpetra__IntSerialDenseVector.html">Epetra_IntSerialDenseVector</a> &amp; Epetra_CrsMatrix::ExpertExtractIndexOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the <a class="el" href="classEpetra__IntSerialDenseVector.html" title="Epetra_IntSerialDenseVector: A class for constructing and using dense vectors.">Epetra_IntSerialDenseVector</a> used to hold the local IndexOffsets (CRS rowptr) </p>
<dl class="section warning"><dt>Warning</dt><dd>This method is intended for experts only, its use may require user code modifications in future versions of Epetra. </dd></dl>

</div>
</div>
<a id="ad6548de37ad7852d2a0c391ebd0bec49" name="ad6548de37ad7852d2a0c391ebd0bec49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6548de37ad7852d2a0c391ebd0bec49">&#9670;&#160;</a></span>ExpertExtractIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEpetra__IntSerialDenseVector.html">Epetra_IntSerialDenseVector</a> &amp; Epetra_CrsMatrix::ExpertExtractIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the <a class="el" href="classEpetra__IntSerialDenseVector.html" title="Epetra_IntSerialDenseVector: A class for constructing and using dense vectors.">Epetra_IntSerialDenseVector</a> used to hold the local All_Indices (CRS colind) </p>
<dl class="section warning"><dt>Warning</dt><dd>This method is intended for experts only, its use may require user code modifications in future versions of Epetra. </dd></dl>

</div>
</div>
<a id="afb04d17c51c3029e14031a90c0c0ef78" name="afb04d17c51c3029e14031a90c0c0ef78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb04d17c51c3029e14031a90c0c0ef78">&#9670;&#160;</a></span>ExpertExtractValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double *&amp; Epetra_CrsMatrix::ExpertExtractValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the double* used to hold the values array. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method is intended for experts only, its use may require user code modifications in future versions of Epetra. </dd></dl>

</div>
</div>
<a id="ab074df197e9d79057217bf7e8de4fa66" name="ab074df197e9d79057217bf7e8de4fa66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab074df197e9d79057217bf7e8de4fa66">&#9670;&#160;</a></span>ExpertMakeUniqueCrsGraphData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::ExpertMakeUniqueCrsGraphData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes sure this matrix has a unique CrsGraphData object. </p>
<p>This routine is needed to support the EpetraExt::MatrixMatrix::Multiply and should not be called by users. </p><dl class="section warning"><dt>Warning</dt><dd>This method is intended for expert developer use only, and should never be called by user code. </dd></dl>

</div>
</div>
<a id="a3753556d7dc03d2b66b1b1a3be5c1795" name="a3753556d7dc03d2b66b1b1a3be5c1795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3753556d7dc03d2b66b1b1a3be5c1795">&#9670;&#160;</a></span>ExpertStaticFillComplete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::ExpertStaticFillComplete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td>
          <td class="paramname"><em>DomainMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td>
          <td class="paramname"><em>RangeMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> *&#160;</td>
          <td class="paramname"><em>Importer</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> *&#160;</td>
          <td class="paramname"><em>Exporter</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumMyDiagonals</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a FillComplete on an object that aready has filled CRS data. </p>
<p>Performs a lightweight FillComplete on an object that already has filled IndexOffsets, All_Indices and All_Values. This routine is needed to support the EpetraExt::MatrixMatrix::Multiply and should not be called by users. </p><dl class="section warning"><dt>Warning</dt><dd><a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> will assume ownership of the Importer/Exporter you pass in. You should not deallocate it afterwards. </dd>
<dd>
This method is intended for expert developer use only, and should never be called by user code. </dd></dl>

</div>
</div>
<a id="a9fc55fd3394fc25867ba0d2e8a730fdc" name="a9fc55fd3394fc25867ba0d2e8a730fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc55fd3394fc25867ba0d2e8a730fdc">&#9670;&#160;</a></span>ExtractCrsDataPointers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::ExtractCrsDataPointers </td>
          <td>(</td>
          <td class="paramtype">int *&amp;&#160;</td>
          <td class="paramname"><em>IndexOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&amp;&#160;</td>
          <td class="paramname"><em>Indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>Values_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns internal data pointers associated with Crs matrix format. </p>
<p>Returns data pointers to facilitate optimized code within external packages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IndexOffset</td><td>- (Out) Extracted array of indices into Values[] and Indices[]. Local row k is stored in Values[IndexOffset[k]:IndexOffset[k+1]-1] and Indices[IndexOffset[k]:IndexOffset[k+1]-1]. </td></tr>
    <tr><td class="paramname">Values</td><td>- (Out) Extracted values for all local rows. </td></tr>
    <tr><td class="paramname">Indices</td><td>- (Out) Extracted local column indices for the corresponding values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. Returns -1 if FillComplete has not been performed or Storage has not been Optimized.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method is intended for expert only, its use may require user code modifications in future versions of Epetra. </dd></dl>

</div>
</div>
<a id="ae89f6150eed2c4be33c69bae6ac0a99f" name="ae89f6150eed2c4be33c69bae6ac0a99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89f6150eed2c4be33c69bae6ac0a99f">&#9670;&#160;</a></span>ExtractDiagonalCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::ExtractDiagonalCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>Diagonal</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the main diagonal in a user-provided vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Diagonal</td><td>- (Out) Extracted main diagonal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged. </dd></dl>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#a2fb8cf11381e4daf33dcd7f213395066">Epetra_RowMatrix</a>.</p>

<p>Reimplemented in <a class="el" href="classEpetra__OskiMatrix.html#afe8d003780d497d0bc93c7b5ce13ca2c">Epetra_OskiMatrix</a>.</p>

</div>
</div>
<a id="a35f60443ed35e95869438ce2e21c5fec" name="a35f60443ed35e95869438ce2e21c5fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f60443ed35e95869438ce2e21c5fec">&#9670;&#160;</a></span>ExtractGlobalRowCopy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::ExtractGlobalRowCopy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>GlobalRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>NumEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of the specified global row values in user-provided array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">GlobalRow</td><td>- (In) Global row to extract. </td></tr>
    <tr><td class="paramname">Length</td><td>- (In) Length of Values. </td></tr>
    <tr><td class="paramname">NumEntries</td><td>- (Out) Number of nonzero entries extracted. </td></tr>
    <tr><td class="paramname">Values</td><td>- (Out) Extracted values for this row.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="a70846bbd75f7f2f0c2453ac9446d6c2c" name="a70846bbd75f7f2f0c2453ac9446d6c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70846bbd75f7f2f0c2453ac9446d6c2c">&#9670;&#160;</a></span>ExtractGlobalRowCopy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::ExtractGlobalRowCopy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>GlobalRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>NumEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of the specified global row in user-provided arrays. </p>
<pre class="fragment">\param GlobalRow - (In) Global row to extract.
\param ILength - (In) Length of Values and Indices.
\param NumEntries - (Out) Number of nonzero entries extracted.
\param Values - (Out) Extracted values for this row.
\param Indices - (Out) Extracted global column indices for the corresponding values.

\return Integer error code, set to 0 if successful, non-zero if global row is not owned by calling process
</pre><p> or if the number of entries in this row exceed the Length parameter. </p>

</div>
</div>
<a id="aee94425f2bce4365d472a3d32e3be382" name="aee94425f2bce4365d472a3d32e3be382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee94425f2bce4365d472a3d32e3be382">&#9670;&#160;</a></span>ExtractGlobalRowView() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::ExtractGlobalRowView </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>GlobalRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>NumEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>Values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a view of the specified global row values via pointers to internal data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">GlobalRow</td><td>- (In) Global row to extract. </td></tr>
    <tr><td class="paramname">NumEntries</td><td>- (Out) Number of nonzero entries extracted. </td></tr>
    <tr><td class="paramname">Values</td><td>- (Out) Extracted values for this row.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="a0d54454e29a235cc487c3de506bc295d" name="a0d54454e29a235cc487c3de506bc295d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d54454e29a235cc487c3de506bc295d">&#9670;&#160;</a></span>ExtractGlobalRowView() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::ExtractGlobalRowView </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>GlobalRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>NumEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>Values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&amp;&#160;</td>
          <td class="paramname"><em>Indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a view of the specified global row values via pointers to internal data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">GlobalRow</td><td>- (In) Global row to view. </td></tr>
    <tr><td class="paramname">NumEntries</td><td>- (Out) Number of nonzero entries extracted. </td></tr>
    <tr><td class="paramname">Values</td><td>- (Out) Extracted values for this row. </td></tr>
    <tr><td class="paramname">Indices</td><td>- (Out) Extracted global column indices for the corresponding values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. Returns -1 of row not on this processor. Returns -2 if matrix is not in global form (if <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> has already been called).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#ae1486df3fb52a638e43eb8aa896a1b4c" title="If matrix indices has not been transformed to local, this query returns true, otherwise it returns fa...">IndicesAreGlobal()</a>==true </dd></dl>

</div>
</div>
<a id="a989ae9e8183388a46873bd7e0b1e1bea" name="a989ae9e8183388a46873bd7e0b1e1bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a989ae9e8183388a46873bd7e0b1e1bea">&#9670;&#160;</a></span>ExtractMyRowCopy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::ExtractMyRowCopy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MyRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>NumEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of the specified local row values in user-provided array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MyRow</td><td>- (In) Local row to extract. </td></tr>
    <tr><td class="paramname">Length</td><td>- (In) Length of Values. </td></tr>
    <tr><td class="paramname">NumEntries</td><td>- (Out) Number of nonzero entries extracted. </td></tr>
    <tr><td class="paramname">Values</td><td>- (Out) Extracted values for this row.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="aae1d307174a8205ec5b1198f51c50bf8" name="aae1d307174a8205ec5b1198f51c50bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae1d307174a8205ec5b1198f51c50bf8">&#9670;&#160;</a></span>ExtractMyRowCopy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::ExtractMyRowCopy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MyRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>NumEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the specified local row in user-provided arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MyRow</td><td>- (In) Local row to extract. </td></tr>
    <tr><td class="paramname">Length</td><td>- (In) Length of Values and Indices. </td></tr>
    <tr><td class="paramname">NumEntries</td><td>- (Out) Number of nonzero entries extracted. </td></tr>
    <tr><td class="paramname">Values</td><td>- (Out) Extracted values for this row. </td></tr>
    <tr><td class="paramname">Indices</td><td>- (Out) Extracted local column indices for the corresponding values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#aae10c5b74759484342ed40ced9561f49" title="If matrix indices has been transformed to local, this query returns true, otherwise it returns false.">IndicesAreLocal()</a>==true </dd></dl>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#a7f5e5098936e34560c147b312c55b212">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="a0c61ae4ad9bca823e459c3e7b88c0e94" name="a0c61ae4ad9bca823e459c3e7b88c0e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c61ae4ad9bca823e459c3e7b88c0e94">&#9670;&#160;</a></span>ExtractMyRowView() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::ExtractMyRowView </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MyRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>NumEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>Values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a view of the specified local row values via pointers to internal data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MyRow</td><td>- (In) Local row to extract. </td></tr>
    <tr><td class="paramname">NumEntries</td><td>- (Out) Number of nonzero entries extracted. </td></tr>
    <tr><td class="paramname">Values</td><td>- (Out) Extracted values for this row.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="a2bac0a8622458dc5eeb25fde0c96d774" name="a2bac0a8622458dc5eeb25fde0c96d774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bac0a8622458dc5eeb25fde0c96d774">&#9670;&#160;</a></span>ExtractMyRowView() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::ExtractMyRowView </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MyRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>NumEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>Values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&amp;&#160;</td>
          <td class="paramname"><em>Indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a view of the specified local row values via pointers to internal data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MyRow</td><td>- (In) Local row to view. </td></tr>
    <tr><td class="paramname">NumEntries</td><td>- (Out) Number of nonzero entries extracted. </td></tr>
    <tr><td class="paramname">Values</td><td>- (Out) Extracted values for this row. </td></tr>
    <tr><td class="paramname">Indices</td><td>- (Out) Extracted local column indices for the corresponding values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. Returns -1 of row not on this processor. Returns -2 if matrix is not in local form (if <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> has <em>not</em> been called).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#aae10c5b74759484342ed40ced9561f49" title="If matrix indices has been transformed to local, this query returns true, otherwise it returns false.">IndicesAreLocal()</a>==true </dd></dl>

</div>
</div>
<a id="a08b8858f8fc28dcc45bf523ccad2cb50" name="a08b8858f8fc28dcc45bf523ccad2cb50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b8858f8fc28dcc45bf523ccad2cb50">&#9670;&#160;</a></span>Filled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Epetra_CrsMatrix::Filled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> has been called, this query returns true, otherwise it returns false. </p>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#ac97ccf32269dbefd7a7c21b44a993cb9">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="a01cc7e29ab441e2bffc75acd487ee804" name="a01cc7e29ab441e2bffc75acd487ee804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01cc7e29ab441e2bffc75acd487ee804">&#9670;&#160;</a></span>GCID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::GCID </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>LCID_in</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the global column index for give local column index, returns IndexBase-1 if we don't have this local column. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a4506a3e3975010fc801d915f7e6f08ba" title="Returns true if we have a well-defined ColMap, and returns false otherwise.">HaveColMap()</a>==true (If <a class="el" href="classEpetra__CrsMatrix.html#a4506a3e3975010fc801d915f7e6f08ba" title="Returns true if we have a well-defined ColMap, and returns false otherwise.">HaveColMap()</a>==false, returns -1) </dd></dl>

</div>
</div>
<a id="a2506b65acc0862903f5d7d75cb12d1c0" name="a2506b65acc0862903f5d7d75cb12d1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2506b65acc0862903f5d7d75cb12d1c0">&#9670;&#160;</a></span>GlobalMaxNumEntries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::GlobalMaxNumEntries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of nonzero entries across all rows on all processors. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>

</div>
</div>
<a id="a5f03b8c321e530a55ebc2df1553dde9f" name="a5f03b8c321e530a55ebc2df1553dde9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f03b8c321e530a55ebc2df1553dde9f">&#9670;&#160;</a></span>HasNormInf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Epetra_CrsMatrix::HasNormInf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true because this class can compute an Inf-norm. </p>

<p>Implements <a class="el" href="classEpetra__Operator.html#abc8b47f905c2183fa0da93bd5b13bd0f">Epetra_Operator</a>.</p>

<p class="reference">Referenced by <a class="el" href="classEpetra__FastCrsOperator.html#a5633fa0b17c18eafbdfae8ff7842ab8f">Epetra_FastCrsOperator::HasNormInf()</a>.</p>

</div>
</div>
<a id="a4506a3e3975010fc801d915f7e6f08ba" name="a4506a3e3975010fc801d915f7e6f08ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4506a3e3975010fc801d915f7e6f08ba">&#9670;&#160;</a></span>HaveColMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Epetra_CrsMatrix::HaveColMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if we have a well-defined ColMap, and returns false otherwise. </p>
<dl class="section pre"><dt>Precondition</dt><dd>We have a well-defined ColMap if a) a ColMap was passed in at construction, or b) the MakeColMap function has been called. (Calling either of the FillComplete functions will result in MakeColMap being called.) </dd></dl>

</div>
</div>
<a id="aa5e361f88ed2091196c888ad7d9c35b4" name="aa5e361f88ed2091196c888ad7d9c35b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e361f88ed2091196c888ad7d9c35b4">&#9670;&#160;</a></span>IndexBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::IndexBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index base for row and column indices for this graph. </p>
<p>Index base for this map. </p>

</div>
</div>
<a id="a2f7ff1b3a9be1c41fe218538af97cfdb" name="a2f7ff1b3a9be1c41fe218538af97cfdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7ff1b3a9be1c41fe218538af97cfdb">&#9670;&#160;</a></span>InsertGlobalValues() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Epetra_CrsMatrix::InsertGlobalValues </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>GlobalRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>Values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>Indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a list of elements in a given global row of the matrix. </p>
<p>This method is used to construct a matrix for the first time. It cannot be used if the matrix structure has already been fixed (via a call to <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a>). If multiple values are inserted for the same matrix entry, the values are initially stored separately, so memory use will grow as a result. However, when FillComplete is called the values will be summed together and the additional memory will be released.</p>
<p>For example, if the values 2.0, 3.0 and 4.0 are all inserted in Row 1, Column 2, extra storage is used to store each of the three values separately. In this way, the insert process does not require any searching and can be faster. However, when <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> is called, the values will be summed together to equal 9.0 and only a single entry will remain in the matrix for Row 1, Column 2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">GlobalRow</td><td>- (In) Row number (in global coordinates) to put elements. </td></tr>
    <tr><td class="paramname">NumEntries</td><td>- (In) Number of entries. </td></tr>
    <tr><td class="paramname">Values</td><td>- (In) Values to enter. </td></tr>
    <tr><td class="paramname">Indices</td><td>- (In) Global column indices corresponding to values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. Note that if the allocated length of the row has to be expanded, a positive warning code will be returned.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method may not be called once <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> has been called.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#aae10c5b74759484342ed40ced9561f49" title="If matrix indices has been transformed to local, this query returns true, otherwise it returns false.">IndicesAreLocal()</a>==false &amp;&amp; <a class="el" href="classEpetra__CrsMatrix.html#ad9f864987f9c83d3e8f02716d7540055" title="If matrix indices are packed into single array (done in OptimizeStorage()) return true,...">IndicesAreContiguous()</a>==false </dd></dl>

<p>Reimplemented in <a class="el" href="classEpetra__FECrsMatrix.html#a2f7ff1b3a9be1c41fe218538af97cfdb">Epetra_FECrsMatrix</a>, and <a class="el" href="classEpetra__FECrsMatrix.html#a54820e91fb84c7c594c4e6f3ea290fe4">Epetra_FECrsMatrix</a>.</p>

</div>
</div>
<a id="a8c56a411752216cae73ca1fa04239c28" name="a8c56a411752216cae73ca1fa04239c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c56a411752216cae73ca1fa04239c28">&#9670;&#160;</a></span>InsertGlobalValues() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Epetra_CrsMatrix::InsertGlobalValues </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>GlobalRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a list of elements in a given global row of the matrix. </p>
<p>This method is used to construct a matrix for the first time. It cannot be used if the matrix structure has already been fixed (via a call to <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a>). If multiple values are inserted for the same matrix entry, the values are initially stored separately, so memory use will grow as a result. However, when FillComplete is called the values will be summed together and the additional memory will be released.</p>
<p>For example, if the values 2.0, 3.0 and 4.0 are all inserted in Row 1, Column 2, extra storage is used to store each of the three values separately. In this way, the insert process does not require any searching and can be faster. However, when <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> is called, the values will be summed together to equal 9.0 and only a single entry will remain in the matrix for Row 1, Column 2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">GlobalRow</td><td>- (In) Row number (in global coordinates) to put elements. </td></tr>
    <tr><td class="paramname">NumEntries</td><td>- (In) Number of entries. </td></tr>
    <tr><td class="paramname">Values</td><td>- (In) Values to enter. </td></tr>
    <tr><td class="paramname">Indices</td><td>- (In) Global column indices corresponding to values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. Note that if the allocated length of the row has to be expanded, a positive warning code will be returned.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method may not be called once <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> has been called.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#aae10c5b74759484342ed40ced9561f49" title="If matrix indices has been transformed to local, this query returns true, otherwise it returns false.">IndicesAreLocal()</a>==false &amp;&amp; <a class="el" href="classEpetra__CrsMatrix.html#ad9f864987f9c83d3e8f02716d7540055" title="If matrix indices are packed into single array (done in OptimizeStorage()) return true,...">IndicesAreContiguous()</a>==false </dd></dl>

<p>Reimplemented in <a class="el" href="classEpetra__FECrsMatrix.html#a8c56a411752216cae73ca1fa04239c28">Epetra_FECrsMatrix</a>, and <a class="el" href="classEpetra__FECrsMatrix.html#a625900888f61b04c4df0efa05f32290c">Epetra_FECrsMatrix</a>.</p>

</div>
</div>
<a id="ada0a4c3e447466758bd8608b077e90a0" name="ada0a4c3e447466758bd8608b077e90a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0a4c3e447466758bd8608b077e90a0">&#9670;&#160;</a></span>InsertMyValues() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::InsertMyValues </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MyRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>Values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>Indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a list of elements in a given local row of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MyRow</td><td>- (In) Row number (in local coordinates) to put elements. </td></tr>
    <tr><td class="paramname">NumEntries</td><td>- (In) Number of entries. </td></tr>
    <tr><td class="paramname">Values</td><td>- (In) Values to enter. </td></tr>
    <tr><td class="paramname">Indices</td><td>- (In) Local column indices corresponding to values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. Note that if the allocated length of the row has to be expanded, a positive warning code will be returned. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#ae1486df3fb52a638e43eb8aa896a1b4c" title="If matrix indices has not been transformed to local, this query returns true, otherwise it returns fa...">IndicesAreGlobal()</a>==false &amp;&amp; (<a class="el" href="classEpetra__CrsMatrix.html#ad9f864987f9c83d3e8f02716d7540055" title="If matrix indices are packed into single array (done in OptimizeStorage()) return true,...">IndicesAreContiguous()</a>==false || CV_==View) </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The given local row of the matrix has been updated as described above. </dd></dl>

</div>
</div>
<a id="abc3aff1cbaa86e32fc971f3613b350d2" name="abc3aff1cbaa86e32fc971f3613b350d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3aff1cbaa86e32fc971f3613b350d2">&#9670;&#160;</a></span>InsertMyValues() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::InsertMyValues </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MyRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a list of elements in a given local row of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MyRow</td><td>- (In) Row number (in local coordinates) to put elements. </td></tr>
    <tr><td class="paramname">NumEntries</td><td>- (In) Number of entries. </td></tr>
    <tr><td class="paramname">Values</td><td>- (In) Values to enter. </td></tr>
    <tr><td class="paramname">Indices</td><td>- (In) Local column indices corresponding to values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. Note that if the allocated length of the row has to be expanded, a positive warning code will be returned. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#ae1486df3fb52a638e43eb8aa896a1b4c" title="If matrix indices has not been transformed to local, this query returns true, otherwise it returns fa...">IndicesAreGlobal()</a>==false &amp;&amp; (<a class="el" href="classEpetra__CrsMatrix.html#ad9f864987f9c83d3e8f02716d7540055" title="If matrix indices are packed into single array (done in OptimizeStorage()) return true,...">IndicesAreContiguous()</a>==false || CV_==View) </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The given local row of the matrix has been updated as described above. </dd></dl>

</div>
</div>
<a id="a58d373346c8d0941917fe2e5cd848e2a" name="a58d373346c8d0941917fe2e5cd848e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d373346c8d0941917fe2e5cd848e2a">&#9670;&#160;</a></span>InvColMaxs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::InvColMaxs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the max of absolute values of the columns of the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a>, results returned in x. </p>
<p>The vector x will return such that x[j] will contain the inverse of max of the absolute values of the entries in the jth row of the <em>this</em> matrix. </p><dl class="section warning"><dt>Warning</dt><dd>This method will not work when multiple processors contain partial sums for individual entries. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>- (Out) An <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> containing the column maxs of the <em>this</em> matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>When columns are fully replicated on multiple processors, it is assumed that the distribution of x is the same as the columns (<a class="el" href="classEpetra__CrsMatrix.html#aab3589bfaac41458ab698d3d53780e61" title="Returns the Epetra_Map object that describes the set of column-indices that appear in each processor&#39;...">ColMap()</a>) of <em>this</em>. When each column of <em>this</em> is uniquely owned, the distribution of x can be that of the <a class="el" href="classEpetra__CrsMatrix.html#aab3589bfaac41458ab698d3d53780e61" title="Returns the Epetra_Map object that describes the set of column-indices that appear in each processor&#39;...">ColMap()</a> or the <a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c" title="Returns the Epetra_Map object associated with the domain of this matrix operator.">DomainMap()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged. </dd></dl>

</div>
</div>
<a id="a8f0ce45ccb757975e9ea69e251627663" name="a8f0ce45ccb757975e9ea69e251627663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0ce45ccb757975e9ea69e251627663">&#9670;&#160;</a></span>InvColSums()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::InvColSums </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse of the sum of absolute values of the columns of the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a>, results returned in x. </p>
<p>The vector x will return such that x[j] will contain the inverse of the sum of the absolute values of the entries in the jth column of the <em>this</em> matrix. Using the resulting vector from this function as input to <a class="el" href="classEpetra__CrsMatrix.html#a136bb231cfe4bb129c6754f224eb0889" title="Scales the Epetra_CrsMatrix on the right with a Epetra_Vector x.">RightScale()</a> will make the one norm of the resulting matrix exactly 1. </p><dl class="section warning"><dt>Warning</dt><dd>The <a class="el" href="classEpetra__CrsMatrix.html#a643dc754bea9373a9f26f9b2f095f677" title="Returns the one norm of the global matrix.">NormOne()</a> method will not properly calculate the one norm for a matrix that has entries that are replicated on multiple processors. In this case, if the columns are fully replicated, <a class="el" href="classEpetra__CrsMatrix.html#a643dc754bea9373a9f26f9b2f095f677" title="Returns the one norm of the global matrix.">NormOne()</a> will return a value equal to the maximum number of processors that any individual column of the matrix is repliated on.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>- (Out) An <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> containing the column sums of the <em>this</em> matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>When columns are fully replicated on multiple processors, it is assumed that the distribution of x is the same as the columns (<a class="el" href="classEpetra__CrsMatrix.html#aab3589bfaac41458ab698d3d53780e61" title="Returns the Epetra_Map object that describes the set of column-indices that appear in each processor&#39;...">ColMap()</a>) of <em>this</em>. When multiple processors contain partial sums for entries, the distribution of x is assumed to be the same as the <a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c" title="Returns the Epetra_Map object associated with the domain of this matrix operator.">DomainMap()</a> of <em>this</em>. When each column of <em>this</em> is uniquely owned, the distribution of x can be that of the <a class="el" href="classEpetra__CrsMatrix.html#aab3589bfaac41458ab698d3d53780e61" title="Returns the Epetra_Map object that describes the set of column-indices that appear in each processor&#39;...">ColMap()</a> or the <a class="el" href="classEpetra__CrsMatrix.html#ac8c6024783cb8f9a333f16b9ea5aa40c" title="Returns the Epetra_Map object associated with the domain of this matrix operator.">DomainMap()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged. </dd></dl>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#acea667645b5e4d81585394a1c626d8c3">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="a6aee2aa1ae277efe9dcdfe0a9b77079a" name="a6aee2aa1ae277efe9dcdfe0a9b77079a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aee2aa1ae277efe9dcdfe0a9b77079a">&#9670;&#160;</a></span>InvRowMaxs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::InvRowMaxs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the inverse of the max of absolute values of the rows of the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a>, results returned in x. </p>
<p>The vector x will return such that x[i] will contain the inverse of max of the absolute values of the entries in the ith row of the <em>this</em> matrix. </p><dl class="section warning"><dt>Warning</dt><dd>This method will not work when multiple processors contain partial sums for individual entries. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>- (Out) An <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> containing the inverse of the row maxs of the <em>this</em> matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>When rows are fully replicated on multiple processors, it is assumed that the distribution of x is the same as the rows (<a class="el" href="classEpetra__CrsMatrix.html#a24855eec1cf6aeb201be88ba654d22bf" title="Returns the Epetra_Map object associated with the rows of this matrix.">RowMap()</a>)of <em>this</em>. When each row of <em>this</em> is uniquely owned, the distribution of x can be that of the <a class="el" href="classEpetra__CrsMatrix.html#a24855eec1cf6aeb201be88ba654d22bf" title="Returns the Epetra_Map object associated with the rows of this matrix.">RowMap()</a> or the <a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222" title="Returns the Epetra_Map object associated with the range of this matrix operator.">RangeMap()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged. </dd></dl>

</div>
</div>
<a id="a0d9ed2d21bfc16d0a0e153380a7441de" name="a0d9ed2d21bfc16d0a0e153380a7441de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9ed2d21bfc16d0a0e153380a7441de">&#9670;&#160;</a></span>InvRowSums()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::InvRowSums </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse of the sum of absolute values of the rows of the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a>, results returned in x. </p>
<p>The vector x will return such that x[i] will contain the inverse of the sum of the absolute values of the entries in the ith row of the <em>this</em> matrix. Using the resulting vector from this function as input to <a class="el" href="classEpetra__CrsMatrix.html#a100330317094dc8a19f8feb73b5f0b87" title="Scales the Epetra_CrsMatrix on the left with a Epetra_Vector x.">LeftScale()</a> will make the infinity norm of the resulting matrix exactly 1. </p><dl class="section warning"><dt>Warning</dt><dd>The <a class="el" href="classEpetra__CrsMatrix.html#aea249176fc818ebde242b3a1054ecb34" title="Returns the infinity norm of the global matrix.">NormInf()</a> method will not properly calculate the infinity norm for a matrix that has entries that are replicated on multiple processors. In this case, if the rows are fully replicated, <a class="el" href="classEpetra__CrsMatrix.html#aea249176fc818ebde242b3a1054ecb34" title="Returns the infinity norm of the global matrix.">NormInf()</a> will return a value equal to the maximum number of processors that any individual row of the matrix is replicated on. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>- (Out) An <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> containing the inverse of the row sums of the <em>this</em> matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>When rows are fully replicated on multiple processors, it is assumed that the distribution of x is the same as the rows (<a class="el" href="classEpetra__CrsMatrix.html#a24855eec1cf6aeb201be88ba654d22bf" title="Returns the Epetra_Map object associated with the rows of this matrix.">RowMap()</a>)of <em>this</em>. When multiple processors contain partial sums for individual entries, the distribution of x is assumed to be the same as the <a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222" title="Returns the Epetra_Map object associated with the range of this matrix operator.">RangeMap()</a> of <em>this</em>. When each row of <em>this</em> is uniquely owned, the distribution of x can be that of the <a class="el" href="classEpetra__CrsMatrix.html#a24855eec1cf6aeb201be88ba654d22bf" title="Returns the Epetra_Map object associated with the rows of this matrix.">RowMap()</a> or the <a class="el" href="classEpetra__CrsMatrix.html#a9acf8281b9f9177f6271497fc4cd9222" title="Returns the Epetra_Map object associated with the range of this matrix operator.">RangeMap()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged. </dd></dl>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#a942bb3a6c36b36da134158fc58d5eba0">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="a88f19abe10ac0e5469292142c7c96f05" name="a88f19abe10ac0e5469292142c7c96f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f19abe10ac0e5469292142c7c96f05">&#9670;&#160;</a></span>Label()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * Epetra_CrsMatrix::Label </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a character string describing the operator. </p>

<p>Reimplemented from <a class="el" href="classEpetra__Object.html#a1910d1c04e70ac482f7e377b271f6c26">Epetra_Object</a>.</p>

<p class="reference">References <a class="el" href="classEpetra__Object.html#a1910d1c04e70ac482f7e377b271f6c26">Epetra_Object::Label()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classEpetra__FastCrsOperator.html#a716116b252ac64eeee27f37b1a262f1e">Epetra_FastCrsOperator::Label()</a>.</p>

</div>
</div>
<a id="a402c29f8059e4ed6c113c612e36006a3" name="a402c29f8059e4ed6c113c612e36006a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402c29f8059e4ed6c113c612e36006a3">&#9670;&#160;</a></span>LCID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::LCID </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>GCID_in</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the local column index for given global column index, returns -1 if no local column for this global column. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a4506a3e3975010fc801d915f7e6f08ba" title="Returns true if we have a well-defined ColMap, and returns false otherwise.">HaveColMap()</a>==true (If <a class="el" href="classEpetra__CrsMatrix.html#a4506a3e3975010fc801d915f7e6f08ba" title="Returns true if we have a well-defined ColMap, and returns false otherwise.">HaveColMap()</a>==false, returns -1) </dd></dl>

</div>
</div>
<a id="a100330317094dc8a19f8feb73b5f0b87" name="a100330317094dc8a19f8feb73b5f0b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100330317094dc8a19f8feb73b5f0b87">&#9670;&#160;</a></span>LeftScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::LeftScale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> on the left with a <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> x. </p>
<p>The <em>this</em> matrix will be scaled such that A(i,j) = x(i)*A(i,j) where i denotes the row number of A and j denotes the column number of A. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>- (In) An <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> to scale with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The matrix will be scaled as described above. </dd></dl>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#ade7cc01b51adbb0fa4f2c9ec19687c09">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="ab6b3492e9b2db7397d6d12a4fddf5ffc" name="ab6b3492e9b2db7397d6d12a4fddf5ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b3492e9b2db7397d6d12a4fddf5ffc">&#9670;&#160;</a></span>LowerTriangular()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Epetra_CrsMatrix::LowerTriangular </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If matrix is lower triangular in local index space, this query returns true, otherwise it returns false. </p>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#a785212d07e93e7f13c9b843483b98132">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="aeb31423007dc9e3d005782861bcf35b1" name="aeb31423007dc9e3d005782861bcf35b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb31423007dc9e3d005782861bcf35b1">&#9670;&#160;</a></span>Map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp; Epetra_CrsMatrix::Map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classEpetra__CrsMatrix.html#aeb31423007dc9e3d005782861bcf35b1" title="Map() method inherited from Epetra_DistObject.">Map()</a> method inherited from <a class="el" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi-vectors, vectors and matrices in pa...">Epetra_DistObject</a>. </p>

<p>Implements <a class="el" href="classEpetra__SrcDistObject.html#a55549912dd0598ee49ea3bd21eb32fff">Epetra_SrcDistObject</a>.</p>

<p class="reference">References <a class="el" href="classEpetra__DistObject.html#a00702a53a4a8142f249639d254e760cd">Epetra_DistObject::Map()</a>.</p>

</div>
</div>
<a id="ac16ae7b9de6c12a05fc3e7200e08acaf" name="ac16ae7b9de6c12a05fc3e7200e08acaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16ae7b9de6c12a05fc3e7200e08acaf">&#9670;&#160;</a></span>MaxNumEntries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::MaxNumEntries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of nonzero entries across all rows on this processor. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#a7c43984da5080bf2cf439bc86292d336">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="a1c523205afded500fd81375483029fe6" name="a1c523205afded500fd81375483029fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c523205afded500fd81375483029fe6">&#9670;&#160;</a></span>Multiply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::Multiply </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of a <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> multiplied by a <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> X in Y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TransA</td><td>- (In) If true, multiply by the transpose of matrix, otherwise just use matrix. </td></tr>
    <tr><td class="paramname">X</td><td>- (In) An <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> of dimension NumVectors to multiply with matrix. </td></tr>
    <tr><td class="paramname">Y</td><td>- (Out) An <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> of dimension NumVectorscontaining result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged. </dd></dl>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#a2d14d57f2261387782d747fb6ecba24b">Epetra_RowMatrix</a>.</p>

<p>Reimplemented in <a class="el" href="classEpetra__OskiMatrix.html#ac000bc93d45717f12893b5921d01ac93">Epetra_OskiMatrix</a>.</p>

</div>
</div>
<a id="ad028fbe37c3d2ce3f43e2acf2cbb29de" name="ad028fbe37c3d2ce3f43e2acf2cbb29de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad028fbe37c3d2ce3f43e2acf2cbb29de">&#9670;&#160;</a></span>Multiply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::Multiply </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the result of a <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> multiplied by a <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> x in y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TransA</td><td>- (In) If true, multiply by the transpose of matrix, otherwise just use matrix. </td></tr>
    <tr><td class="paramname">x</td><td>- (In) An <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> to multiply by. </td></tr>
    <tr><td class="paramname">y</td><td>- (Out) An <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> containing result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classEpetra__CrsMatrix.html#aa71714f462b0e0218cf6c0c9f6a65353">Apply()</a>.</p>

</div>
</div>
<a id="afc6da673b8d502adcc0501cf997f6986" name="afc6da673b8d502adcc0501cf997f6986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6da673b8d502adcc0501cf997f6986">&#9670;&#160;</a></span>MyGCID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Epetra_CrsMatrix::MyGCID </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>GCID_in</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the GCID passed in belongs to the calling processor in this map, otherwise returns false. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a4506a3e3975010fc801d915f7e6f08ba" title="Returns true if we have a well-defined ColMap, and returns false otherwise.">HaveColMap()</a>==true (If <a class="el" href="classEpetra__CrsMatrix.html#a4506a3e3975010fc801d915f7e6f08ba" title="Returns true if we have a well-defined ColMap, and returns false otherwise.">HaveColMap()</a>==false, returns -1) </dd></dl>

</div>
</div>
<a id="a7c15615f37a288c4f45499f9ffd45ac9" name="a7c15615f37a288c4f45499f9ffd45ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c15615f37a288c4f45499f9ffd45ac9">&#9670;&#160;</a></span>MyLCID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Epetra_CrsMatrix::MyLCID </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>LCID_in</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the LRID passed in belongs to the calling processor in this map, otherwise returns false. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a4506a3e3975010fc801d915f7e6f08ba" title="Returns true if we have a well-defined ColMap, and returns false otherwise.">HaveColMap()</a>==true (If <a class="el" href="classEpetra__CrsMatrix.html#a4506a3e3975010fc801d915f7e6f08ba" title="Returns true if we have a well-defined ColMap, and returns false otherwise.">HaveColMap()</a>==false, returns -1) </dd></dl>

</div>
</div>
<a id="aea249176fc818ebde242b3a1054ecb34" name="aea249176fc818ebde242b3a1054ecb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea249176fc818ebde242b3a1054ecb34">&#9670;&#160;</a></span>NormInf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Epetra_CrsMatrix::NormInf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the infinity norm of the global matrix. </p>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#ac7ee0e7cb31881b42f839fef52bd65bd">Epetra_RowMatrix</a>.</p>

<p class="reference">Referenced by <a class="el" href="classEpetra__FastCrsOperator.html#ae99a9dc5fefe5f7c69ad2033ef6c5d20">Epetra_FastCrsOperator::NormInf()</a>.</p>

</div>
</div>
<a id="a643dc754bea9373a9f26f9b2f095f677" name="a643dc754bea9373a9f26f9b2f095f677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643dc754bea9373a9f26f9b2f095f677">&#9670;&#160;</a></span>NormOne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Epetra_CrsMatrix::NormOne </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the one norm of the global matrix. </p>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#ac796bde28e6e5ca21a4cafb2f131213c">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="a39970a8fee5716e012aa455306381e6b" name="a39970a8fee5716e012aa455306381e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39970a8fee5716e012aa455306381e6b">&#9670;&#160;</a></span>NumGlobalCols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::NumGlobalCols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of global matrix columns. </p>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#a3473ca21bd0f89011d3a585f976a9f66">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="af9c85e8a878e202db002d3e2240d9709" name="af9c85e8a878e202db002d3e2240d9709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c85e8a878e202db002d3e2240d9709">&#9670;&#160;</a></span>NumGlobalCols64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long Epetra_CrsMatrix::NumGlobalCols64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classEpetra__RowMatrix.html">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="a972eeec9930f6dfda76d9ec8f6f106d6" name="a972eeec9930f6dfda76d9ec8f6f106d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972eeec9930f6dfda76d9ec8f6f106d6">&#9670;&#160;</a></span>NumGlobalDiagonals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::NumGlobalDiagonals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of global nonzero diagonal entries, based on global row/column index comparisons. </p>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#a79e2bce0ad989eee733ae5ba7caae4bc">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="a2c3fcb9c5391ed9f688e2bad8da07773" name="a2c3fcb9c5391ed9f688e2bad8da07773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3fcb9c5391ed9f688e2bad8da07773">&#9670;&#160;</a></span>NumGlobalDiagonals64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long Epetra_CrsMatrix::NumGlobalDiagonals64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classEpetra__RowMatrix.html">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="a6420c1fb13a60a856a1fdcae549fae56" name="a6420c1fb13a60a856a1fdcae549fae56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6420c1fb13a60a856a1fdcae549fae56">&#9670;&#160;</a></span>NumGlobalNonzeros()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::NumGlobalNonzeros </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of nonzero entries in the global matrix. </p>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#a3c054eebc17880e0e9de9b10c2ac0287">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="a5450132a1523598f5487c7a25ef2a765" name="a5450132a1523598f5487c7a25ef2a765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5450132a1523598f5487c7a25ef2a765">&#9670;&#160;</a></span>NumGlobalNonzeros64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long Epetra_CrsMatrix::NumGlobalNonzeros64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classEpetra__RowMatrix.html">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="aa0da526e7a65fb75ecb356567e4945f0" name="aa0da526e7a65fb75ecb356567e4945f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0da526e7a65fb75ecb356567e4945f0">&#9670;&#160;</a></span>NumGlobalRows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::NumGlobalRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of global matrix rows. </p>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#a658b21444c89b8b6fa4bbfcfa862a202">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="a42d9decbc70d4ca103eb0eb0e5f4c89a" name="a42d9decbc70d4ca103eb0eb0e5f4c89a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d9decbc70d4ca103eb0eb0e5f4c89a">&#9670;&#160;</a></span>NumGlobalRows64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long Epetra_CrsMatrix::NumGlobalRows64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classEpetra__RowMatrix.html">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="a1aa8e055646a0cddde3c45047d6502cf" name="a1aa8e055646a0cddde3c45047d6502cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa8e055646a0cddde3c45047d6502cf">&#9670;&#160;</a></span>NumMyCols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::NumMyCols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of entries in the set of column-indices that appear on this processor. </p>
<p>The set of column-indices that appear on this processor is the union of column-indices that appear in all local rows. The size of this set isn't available until <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> has been called. </p><dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#a095e346c289d9b05b9fc3071d6133a28">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="a93d875e6eb5f8c07567748805332867b" name="a93d875e6eb5f8c07567748805332867b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d875e6eb5f8c07567748805332867b">&#9670;&#160;</a></span>NumMyDiagonals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::NumMyDiagonals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of local nonzero diagonal entries, based on global row/column index comparisons. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#a4ee1b0a35e7ec1f2b4997120727a6874">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="a77dec9df2d84dd502c02db9f37d8c5db" name="a77dec9df2d84dd502c02db9f37d8c5db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77dec9df2d84dd502c02db9f37d8c5db">&#9670;&#160;</a></span>NumMyNonzeros()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::NumMyNonzeros </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of nonzero entries in the calling processor's portion of the matrix. </p>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#a485e8e4d967776aa17e401b6126f4515">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="abd6663818c7bb8867e87907666a1b41e" name="abd6663818c7bb8867e87907666a1b41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6663818c7bb8867e87907666a1b41e">&#9670;&#160;</a></span>NumMyRowEntries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::NumMyRowEntries </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MyRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>NumEntries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current number of values stored for the specified local row. </p>
<p>Similar to <a class="el" href="classEpetra__CrsMatrix.html#ab4030b25cb9be4c7e989481b460d24cf" title="Returns the current number of nonzero entries in specified local row on this processor.">NumMyEntries()</a> except NumEntries is returned as an argument and error checking is done on the input value MyRow. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MyRow</td><td>- (In) Local row. </td></tr>
    <tr><td class="paramname">NumEntries</td><td>- (Out) Number of nonzero values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>None. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged. </dd></dl>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#a564fd460ba4d5912dacf654783e20048">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="ace6713140122dc58a27a79064705215e" name="ace6713140122dc58a27a79064705215e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6713140122dc58a27a79064705215e">&#9670;&#160;</a></span>NumMyRows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::NumMyRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of matrix rows owned by the calling processor. </p>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#a07627f11a5a980ed99efc63b58a61ade">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="ae7a19b7a5857f7940bce56f86e73b73e" name="ae7a19b7a5857f7940bce56f86e73b73e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a19b7a5857f7940bce56f86e73b73e">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double * Epetra_CrsMatrix::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined bracket operator for fast access to data. (Const and Non-const versions) </p>
<p>No error checking and dangerous for optimization purposes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Loc</td><td>- (In) Local row.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to pointer to locally indexed Loc row in matrix. </dd></dl>

</div>
</div>
<a id="adc075f22e741f7d6c186eb20f2498bf9" name="adc075f22e741f7d6c186eb20f2498bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc075f22e741f7d6c186eb20f2498bf9">&#9670;&#160;</a></span>OperatorDomainMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp; Epetra_CrsMatrix::OperatorDomainMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> object associated with the domain of this matrix operator. </p>

<p>Implements <a class="el" href="classEpetra__Operator.html#ab6e6c17974c47fcdd1faaa7e5894f7da">Epetra_Operator</a>.</p>

<p class="reference">References <a class="el" href="classEpetra__Operator.html#adae8757220ea247aaebe08da978cfbf5">Epetra_Operator::UseTranspose()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classEpetra__FastCrsOperator.html#ac09486f3a82ae069513ac4e39f191cd6">Epetra_FastCrsOperator::OperatorDomainMap()</a>.</p>

</div>
</div>
<a id="a2b97f29a7febcea4d8926548a413c650" name="a2b97f29a7febcea4d8926548a413c650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b97f29a7febcea4d8926548a413c650">&#9670;&#160;</a></span>OperatorRangeMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp; Epetra_CrsMatrix::OperatorRangeMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> object associated with the range of this matrix operator. </p>

<p>Implements <a class="el" href="classEpetra__Operator.html#ac97667dbc739ef5863f90f717f51275e">Epetra_Operator</a>.</p>

<p class="reference">References <a class="el" href="classEpetra__Operator.html#adae8757220ea247aaebe08da978cfbf5">Epetra_Operator::UseTranspose()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classEpetra__FastCrsOperator.html#a6400a898d576ec1f593ae4071d358798">Epetra_FastCrsOperator::OperatorRangeMap()</a>.</p>

</div>
</div>
<a id="ac54a33eafbaa0a966cf2c0ce454a7d59" name="ac54a33eafbaa0a966cf2c0ce454a7d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54a33eafbaa0a966cf2c0ce454a7d59">&#9670;&#160;</a></span>OptimizeStorage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::OptimizeStorage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make consecutive row index sections contiguous, minimize internal storage used for constructing graph. </p>
<p>After construction and during initialization (when values are being added), the matrix coefficients for each row are managed as separate segments of memory. This method moves the values for all rows into one large contiguous array and eliminates internal storage that is not needed after matrix construction. Calling this method can have a significant impact on memory costs and machine performance.</p>
<p>If this object was constructed in View mode then this method can't make non-contiguous values contiguous and will return a warning code of 1 if the viewed data isn't already contiguous.</p>
<dl class="section note"><dt>Note</dt><dd>A call to this method will also call the OptimizeStorage method for the associated <a class="el" href="classEpetra__CrsGraph.html" title="Epetra_CrsGraph: A class for constructing and using sparse compressed row graphs.">Epetra_CrsGraph</a> object. If the storage for this graph has already been optimized this additional call will have no effect.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true. </dd>
<dd>
If CV=View when the graph was constructed, then this method will be effective <em>only</em> if the indices of the graph were already contiguous. In this case, the indices are left untouched and internal storage for the graph is minimized.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#aab604df6545e7cb7c38eec982719d104" title="If OptimizeStorage() has been called, this query returns true, otherwise it returns false.">StorageOptimized()</a>==true, if successful. </dd>
<dd>
<a class="el" href="classEpetra__CrsMatrix.html#a98ed3d3f3cb0ab79ffceb1974b9a8809" title="Returns a reference to the Epetra_CrsGraph object associated with this matrix.">Graph()</a>.<a class="el" href="classEpetra__CrsMatrix.html#aab604df6545e7cb7c38eec982719d104" title="If OptimizeStorage() has been called, this query returns true, otherwise it returns false.">StorageOptimized()</a>==true, if successful. </dd></dl>

</div>
</div>
<a id="a2ca07ab2127fcc6e011f342f75d57593" name="a2ca07ab2127fcc6e011f342f75d57593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca07ab2127fcc6e011f342f75d57593">&#9670;&#160;</a></span>PackAndPrepare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::PackAndPrepare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;&#160;</td>
          <td class="paramname"><em>Source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumExportIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ExportLIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>LenExports</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>Exports</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>SizeOfPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>VarSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__Distributor.html">Epetra_Distributor</a> &amp;&#160;</td>
          <td class="paramname"><em>Distor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform any packing or preparation required for call to <a class="el" href="classEpetra__DistObject.html#ab26ca2d3f9d20a850734f4af633e4135" title="Perform actual transfer (redistribution) of data across memory images, using Epetra_Distributor objec...">DoTransfer()</a>. </p>

<p>Implements <a class="el" href="classEpetra__DistObject.html#a8e1ce66a9c14990d9c10770b1a3b1a83">Epetra_DistObject</a>.</p>

</div>
</div>
<a id="af5e117569991b807df5386868da10a78" name="af5e117569991b807df5386868da10a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e117569991b807df5386868da10a78">&#9670;&#160;</a></span>Print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Epetra_CrsMatrix::Print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print method. </p>

<p>Reimplemented from <a class="el" href="classEpetra__DistObject.html#afb80d48a0b6f974740aff376919ce107">Epetra_DistObject</a>.</p>

<p>Reimplemented in <a class="el" href="classEpetra__FECrsMatrix.html#ac7af46a223fbad1831b5bc96475b6165">Epetra_FECrsMatrix</a>.</p>

</div>
</div>
<a id="a3c2eb1fc1151fef071b29a37bff8822b" name="a3c2eb1fc1151fef071b29a37bff8822b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2eb1fc1151fef071b29a37bff8822b">&#9670;&#160;</a></span>PutScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::PutScalar </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ScalarConstant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize all values in the matrix with constant value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ScalarConstant</td><td>- (In) Value to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>None. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>All values in <em>this</em> set to ScalarConstant. </dd></dl>

</div>
</div>
<a id="a9acf8281b9f9177f6271497fc4cd9222" name="a9acf8281b9f9177f6271497fc4cd9222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9acf8281b9f9177f6271497fc4cd9222">&#9670;&#160;</a></span>RangeMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp; Epetra_CrsMatrix::RangeMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> object associated with the range of this matrix operator. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>

</div>
</div>
<a id="ab338ef7689fdb5131c6624a6348e2fa5" name="ab338ef7689fdb5131c6624a6348e2fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab338ef7689fdb5131c6624a6348e2fa5">&#9670;&#160;</a></span>RemoveEmptyProcessesInPlace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::RemoveEmptyProcessesInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> *&#160;</td>
          <td class="paramname"><em>NewMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove processes owning zero rows from the Maps and their communicator. </p>
<p>Remove processes owning zero rows from the Maps and their communicator. </p><dl class="section warning"><dt>Warning</dt><dd>This method is ONLY for use by experts.</dd>
<dd>
We make NO promises of backwards compatibility. This method may change or disappear at any time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newMap</td><td>[in] This <em>must</em> be the result of calling the removeEmptyProcesses() method on the row Map. If it is not, this method's behavior is undefined. This pointer will be null on excluded processes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c97a06e482fe0368fa4775e2a724109" name="a7c97a06e482fe0368fa4775e2a724109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c97a06e482fe0368fa4775e2a724109">&#9670;&#160;</a></span>ReplaceColMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::ReplaceColMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;&#160;</td>
          <td class="paramname"><em>newmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the current ColMap with the user-specified map object. </p>
<p>Replaces the current ColMap with the user-specified map object, but only if no entries have been inserted into the matrix (both <a class="el" href="classEpetra__CrsMatrix.html#aae10c5b74759484342ed40ced9561f49" title="If matrix indices has been transformed to local, this query returns true, otherwise it returns false.">IndicesAreLocal()</a> and <a class="el" href="classEpetra__CrsMatrix.html#ae1486df3fb52a638e43eb8aa896a1b4c" title="If matrix indices has not been transformed to local, this query returns true, otherwise it returns fa...">IndicesAreGlobal()</a> are false) or currentmap-&gt;PointSameAs(newmap) is true. This is a collective function. Returns 0 if map is replaced, -1 if not.</p>
<dl class="section pre"><dt>Precondition</dt><dd>(<a class="el" href="classEpetra__CrsMatrix.html#aae10c5b74759484342ed40ced9561f49" title="If matrix indices has been transformed to local, this query returns true, otherwise it returns false.">IndicesAreLocal()</a>==false &amp;&amp; <a class="el" href="classEpetra__CrsMatrix.html#ae1486df3fb52a638e43eb8aa896a1b4c" title="If matrix indices has not been transformed to local, this query returns true, otherwise it returns fa...">IndicesAreGlobal()</a>==false) || <a class="el" href="classEpetra__CrsMatrix.html#aab3589bfaac41458ab698d3d53780e61" title="Returns the Epetra_Map object that describes the set of column-indices that appear in each processor&#39;...">ColMap()</a>.PointSameAs(newmap)==true </dd></dl>

</div>
</div>
<a id="aeecb739b8f837a91406050f6f8bd7b9a" name="aeecb739b8f837a91406050f6f8bd7b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeecb739b8f837a91406050f6f8bd7b9a">&#9670;&#160;</a></span>ReplaceDiagonalValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::ReplaceDiagonalValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>Diagonal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces diagonal values of the matrix with those in the user-provided vector. </p>
<p>This routine is meant to allow replacement of <b>existing</b> diagonal values. If a diagonal value does not exist for a given row, the corresponding value in the input <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> will be ignored and the return code will be set to 1.</p>
<p>The <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> associated with the input <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> must be compatible with the RowMap of the matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Diagonal</td><td>- (In) New values to be placed in the main diagonal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful, set to 1 on the calling processor if one or more diagonal entries not present in matrix. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Diagonal values have been replaced with the values of Diagonal. </dd></dl>

</div>
</div>
<a id="a0d0efbedcbd1c34ba7c3d61c7bd5bbf2" name="a0d0efbedcbd1c34ba7c3d61c7bd5bbf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0efbedcbd1c34ba7c3d61c7bd5bbf2">&#9670;&#160;</a></span>ReplaceDomainMapAndImporter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::ReplaceDomainMapAndImporter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp;&#160;</td>
          <td class="paramname"><em>NewDomainMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> *&#160;</td>
          <td class="paramname"><em>NewImporter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the current DomainMap &amp; Importer with the user-specified map object. </p>
<p>Replaces the current DomainMap and Importer with the user-specified map object, but only if the matrix has been FillCompleted, Importer's TargetMap matches the ColMap and Importer's SourceMap matches the DomainMap (assuming the importer isn't null). If an Importer is passed in, <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> will copy it.</p>
<p>Returns 0 if map/importer is replaced, -1 if not.</p>
<dl class="section pre"><dt>Precondition</dt><dd>(!NewImporter &amp;&amp; <a class="el" href="classEpetra__CrsMatrix.html#aab3589bfaac41458ab698d3d53780e61" title="Returns the Epetra_Map object that describes the set of column-indices that appear in each processor&#39;...">ColMap()</a>.PointSameAs(NewDomainMap)) || (NewImporter &amp;&amp; <a class="el" href="classEpetra__CrsMatrix.html#aab3589bfaac41458ab698d3d53780e61" title="Returns the Epetra_Map object that describes the set of column-indices that appear in each processor&#39;...">ColMap()</a>.PointSameAs(NewImporter-&gt;TargetMap()) &amp;&amp; NewDomainMap.PointSameAs(NewImporter-&gt;SourceMap())) </dd></dl>

</div>
</div>
<a id="a36048758bcfe082ca07090569607d574" name="a36048758bcfe082ca07090569607d574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36048758bcfe082ca07090569607d574">&#9670;&#160;</a></span>ReplaceGlobalValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Epetra_CrsMatrix::ReplaceGlobalValues </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>GlobalRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>Values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>Indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace specified existing values with this list of entries for a given global row of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">GlobalRow</td><td>- (In) Row number (in global coordinates) to put elements. </td></tr>
    <tr><td class="paramname">NumEntries</td><td>- (In) Number of entries. </td></tr>
    <tr><td class="paramname">Values</td><td>- (In) Values to enter. </td></tr>
    <tr><td class="paramname">Indices</td><td>- (In) Global column indices corresponding to values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. Note that if a value is not already present for the specified location in the matrix, the input value will be ignored and a positive warning code will be returned.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#aae10c5b74759484342ed40ced9561f49" title="If matrix indices has been transformed to local, this query returns true, otherwise it returns false.">IndicesAreLocal()</a>==false &amp;&amp; <a class="el" href="classEpetra__CrsMatrix.html#ad9f864987f9c83d3e8f02716d7540055" title="If matrix indices are packed into single array (done in OptimizeStorage()) return true,...">IndicesAreContiguous()</a>==false </dd></dl>

<p>Reimplemented in <a class="el" href="classEpetra__FECrsMatrix.html#a36048758bcfe082ca07090569607d574">Epetra_FECrsMatrix</a>, and <a class="el" href="classEpetra__FECrsMatrix.html#a06de93de62291f2dbe9448e58bbed4d1">Epetra_FECrsMatrix</a>.</p>

</div>
</div>
<a id="acecf7e5bf939b56644e25c57f67e137d" name="acecf7e5bf939b56644e25c57f67e137d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acecf7e5bf939b56644e25c57f67e137d">&#9670;&#160;</a></span>ReplaceMyValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::ReplaceMyValues </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MyRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>Values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>Indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace current values with this list of entries for a given local row of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MyRow</td><td>- (In) Row number (in local coordinates) to put elements. </td></tr>
    <tr><td class="paramname">NumEntries</td><td>- (In) Number of entries. </td></tr>
    <tr><td class="paramname">Values</td><td>- (In) Values to enter. </td></tr>
    <tr><td class="paramname">Indices</td><td>- (In) Local column indices corresponding to values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. Note that if a value is not already present for the specified location in the matrix, the input value will be ignored and a positive warning code will be returned. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#aae10c5b74759484342ed40ced9561f49" title="If matrix indices has been transformed to local, this query returns true, otherwise it returns false.">IndicesAreLocal()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>MyRow contains the given list of Values at the given Indices. </dd></dl>

</div>
</div>
<a id="a3c83fee95e71471e118fa91c15809aa2" name="a3c83fee95e71471e118fa91c15809aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c83fee95e71471e118fa91c15809aa2">&#9670;&#160;</a></span>ReplaceRowMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::ReplaceRowMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;&#160;</td>
          <td class="paramname"><em>newmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the current RowMap with the user-specified map object. </p>
<p>Replaces the current RowMap with the user-specified map object, but only if currentmap-&gt;PointSameAs(newmap) is true. This is a collective function. Returns 0 if map is replaced, -1 if not.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a24855eec1cf6aeb201be88ba654d22bf" title="Returns the Epetra_Map object associated with the rows of this matrix.">RowMap()</a>.PointSameAs(newmap)==true </dd></dl>

</div>
</div>
<a id="a136bb231cfe4bb129c6754f224eb0889" name="a136bb231cfe4bb129c6754f224eb0889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136bb231cfe4bb129c6754f224eb0889">&#9670;&#160;</a></span>RightScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::RightScale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> on the right with a <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> x. </p>
<p>The <em>this</em> matrix will be scaled such that A(i,j) = x(j)*A(i,j) where i denotes the global row number of A and j denotes the global column number of A. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>- (In) The <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> used for scaling <em>this</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The matrix will be scaled as described above. </dd></dl>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#abf1ecd1ba05bedd2bbb95bc125803a4f">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="ac6fc2afcabadee62112e6e51375fabdf" name="ac6fc2afcabadee62112e6e51375fabdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6fc2afcabadee62112e6e51375fabdf">&#9670;&#160;</a></span>RowMatrixColMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp; Epetra_CrsMatrix::RowMatrixColMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> object associated with columns of this matrix. </p>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#a4033273af88b2ef7d5adf8f47205597c">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="a5d913cfd97ffa19fcdd062ae7098cff4" name="a5d913cfd97ffa19fcdd062ae7098cff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d913cfd97ffa19fcdd062ae7098cff4">&#9670;&#160;</a></span>RowMatrixImporter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> * Epetra_CrsMatrix::RowMatrixImporter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classEpetra__Import.html" title="Epetra_Import: This class builds an import object for efficient importing of off-processor elements.">Epetra_Import</a> object that contains the import operations for distributed operations. </p>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#a97f755dcfa9c9840b47c13efa8c1ef11">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="ae8cf38cfbefc8f9410ca65c35a65a130" name="ae8cf38cfbefc8f9410ca65c35a65a130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8cf38cfbefc8f9410ca65c35a65a130">&#9670;&#160;</a></span>RowMatrixRowMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEpetra__Map.html">Epetra_Map</a> &amp; Epetra_CrsMatrix::RowMatrixRowMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> object associated with the rows of this matrix. </p>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#a44f9cfc5d5f916e1fd23e1b92f4a446d">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="a89dca01cc1dcf5c46cd34ecba9a0c6d1" name="a89dca01cc1dcf5c46cd34ecba9a0c6d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89dca01cc1dcf5c46cd34ecba9a0c6d1">&#9670;&#160;</a></span>Scale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::Scale </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ScalarConstant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply all values in the matrix by a constant value (in place: A &lt;- ScalarConstant * A). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ScalarConstant</td><td>- (In) Value to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>None. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>All values of <em>this</em> have been multiplied by ScalarConstant. </dd></dl>

</div>
</div>
<a id="a859bf40b4652b385d06235450dcda7d8" name="a859bf40b4652b385d06235450dcda7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859bf40b4652b385d06235450dcda7d8">&#9670;&#160;</a></span>SetUseTranspose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::SetUseTranspose </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>UseTranspose_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If set true, transpose of this operator will be applied. </p>
<p>This flag allows the transpose of the given operator to be used implicitly. Setting this flag affects only the <a class="el" href="classEpetra__CrsMatrix.html#aa71714f462b0e0218cf6c0c9f6a65353" title="Returns the result of a Epetra_Operator applied to a Epetra_MultiVector X in Y.">Apply()</a> and <a class="el" href="classEpetra__CrsMatrix.html#a7df56e43070f908dec709b1a19348cee" title="Returns the result of a Epetra_Operator inverse applied to an Epetra_MultiVector X in Y.">ApplyInverse()</a> methods. If the implementation of this interface does not support transpose use, this method should return a value of -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UseTranspose</td><td>- (In) If true, multiply by the transpose of operator, otherwise just use operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Always returns 0. </dd></dl>

<p>Implements <a class="el" href="classEpetra__Operator.html#a3aedc73c2ef58b21bacb12bdc04130d7">Epetra_Operator</a>.</p>

<p class="reference">Referenced by <a class="el" href="classEpetra__FastCrsOperator.html#aa1161fc567b172f4685285fa0329e84c">Epetra_FastCrsOperator::SetUseTranspose()</a>.</p>

</div>
</div>
<a id="ac0717ceccbb3713daecdc3ed801f6fab" name="ac0717ceccbb3713daecdc3ed801f6fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0717ceccbb3713daecdc3ed801f6fab">&#9670;&#160;</a></span>Solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::Solve </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>Upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>Trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>UnitDiagonal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of a local solve using the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> a <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> X in Y. </p>
<p>This method solves a triangular system of equations asynchronously on each processor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Upper</td><td>- (In) If true, solve Uy = x, otherwise solve Ly = x. </td></tr>
    <tr><td class="paramname">Trans</td><td>- (In) If true, solve transpose problem. </td></tr>
    <tr><td class="paramname">UnitDiagonal</td><td>- (In) If true, assume diagonal is unit (whether it's stored or not). </td></tr>
    <tr><td class="paramname">X</td><td>- (In) An <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> of dimension NumVectors to solve for. </td></tr>
    <tr><td class="paramname">Y</td><td>- (Out) An <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> of dimension NumVectors containing result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged. </dd></dl>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#a63cec4057182c076033d004ca3724f53">Epetra_RowMatrix</a>.</p>

<p>Reimplemented in <a class="el" href="classEpetra__OskiMatrix.html#acbd52a0fdbc6c92a2f38ed32d92d5fc8">Epetra_OskiMatrix</a>.</p>

</div>
</div>
<a id="a4b0d7c00870df3bf3a18db186a290e64" name="a4b0d7c00870df3bf3a18db186a290e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0d7c00870df3bf3a18db186a290e64">&#9670;&#160;</a></span>Solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::Solve </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>Upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>Trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>UnitDiagonal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the result of a local solve using the <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> on a <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> x in y. </p>
<p>This method solves a triangular system of equations asynchronously on each processor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Upper</td><td>- (In) If true, solve Uy = x, otherwise solve Ly = x. </td></tr>
    <tr><td class="paramname">Trans</td><td>- (In) If true, solve transpose problem. </td></tr>
    <tr><td class="paramname">UnitDiagonal</td><td>- (In) If true, assume diagonal is unit (whether it's stored or not). </td></tr>
    <tr><td class="paramname">x</td><td>- (In) An <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> to solve for. </td></tr>
    <tr><td class="paramname">y</td><td>- (Out) An <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> containing result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#a08b8858f8fc28dcc45bf523ccad2cb50" title="If FillComplete() has been called, this query returns true, otherwise it returns false.">Filled()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Unchanged. </dd></dl>

</div>
</div>
<a id="ae5672eb590bbd4bf5f6124af1f66f3be" name="ae5672eb590bbd4bf5f6124af1f66f3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5672eb590bbd4bf5f6124af1f66f3be">&#9670;&#160;</a></span>SortGhostsAssociatedWithEachProcessor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::SortGhostsAssociatedWithEachProcessor </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>Flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> to locally order ghostnodes associated with each remote processor in ascending order. </p>
<p>To be compliant with AztecOO, <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> already locally orders ghostnodes such that information received from processor k has a lower local numbering than information received from processor j if k is less than j. SortGhostsAssociatedWithEachProcessor(True) further forces <a class="el" href="classEpetra__CrsMatrix.html#a355b4e8d1e28b16bacf37ab637ac0c3f" title="Signal that data entry is complete. Perform transformations to local index space.">FillComplete()</a> to locally number all ghostnodes received from processor k in ascending order. That is, the local numbering of b is less than c if the global numbering of b is less than c and if both b and c are owned by the same processor. This is done to be compliant with some limited block features within ML. In particular, some ML features require that a block structure of the matrix be maintained even within the ghost variables. Always returns 0. </p>

</div>
</div>
<a id="a1291bfb498b94ac4f1563b48d11dfae5" name="a1291bfb498b94ac4f1563b48d11dfae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1291bfb498b94ac4f1563b48d11dfae5">&#9670;&#160;</a></span>SumIntoGlobalValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Epetra_CrsMatrix::SumIntoGlobalValues </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>GlobalRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>Values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>Indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add this list of entries to existing values for a given global row of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">GlobalRow</td><td>- (In) Row number (in global coordinates) to put elements. </td></tr>
    <tr><td class="paramname">NumEntries</td><td>- (In) Number of entries. </td></tr>
    <tr><td class="paramname">Values</td><td>- (In) Values to enter. </td></tr>
    <tr><td class="paramname">Indices</td><td>- (In) Global column indices corresponding to values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. Note that if a value is not already present for the specified location in the matrix, the input value will be ignored and a positive warning code will be returned.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#aae10c5b74759484342ed40ced9561f49" title="If matrix indices has been transformed to local, this query returns true, otherwise it returns false.">IndicesAreLocal()</a>==false &amp;&amp; <a class="el" href="classEpetra__CrsMatrix.html#ad9f864987f9c83d3e8f02716d7540055" title="If matrix indices are packed into single array (done in OptimizeStorage()) return true,...">IndicesAreContiguous()</a>==false </dd></dl>

<p>Reimplemented in <a class="el" href="classEpetra__FECrsMatrix.html#a1291bfb498b94ac4f1563b48d11dfae5">Epetra_FECrsMatrix</a>, and <a class="el" href="classEpetra__FECrsMatrix.html#a63bd622d3e23f265e63abf5ad3981c42">Epetra_FECrsMatrix</a>.</p>

</div>
</div>
<a id="a8e93959017a68cb0103110d80b124c82" name="a8e93959017a68cb0103110d80b124c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e93959017a68cb0103110d80b124c82">&#9670;&#160;</a></span>SumIntoMyValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::SumIntoMyValues </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MyRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>Values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>Indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add this list of entries to existing values for a given local row of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MyRow</td><td>- (In) Row number (in local coordinates) to put elements. </td></tr>
    <tr><td class="paramname">NumEntries</td><td>- (In) Number of entries. </td></tr>
    <tr><td class="paramname">Values</td><td>- (In) Values to enter. </td></tr>
    <tr><td class="paramname">Indices</td><td>- (In) Local column indices corresponding to values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. Note that if the allocated length of the row has to be expanded, a positive warning code will be returned. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classEpetra__CrsMatrix.html#aae10c5b74759484342ed40ced9561f49" title="If matrix indices has been transformed to local, this query returns true, otherwise it returns false.">IndicesAreLocal()</a>==true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The given Values at the given Indices have been summed into the entries of MyRow. </dd></dl>

</div>
</div>
<a id="adc77171308612e405e1427aeff35ad27" name="adc77171308612e405e1427aeff35ad27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc77171308612e405e1427aeff35ad27">&#9670;&#160;</a></span>UnpackAndCombine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_CrsMatrix::UnpackAndCombine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;&#160;</td>
          <td class="paramname"><em>Source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumImportIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ImportLIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>LenImports</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Imports</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>SizeOfPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__Distributor.html">Epetra_Distributor</a> &amp;&#160;</td>
          <td class="paramname"><em>Distor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020f">Epetra_CombineMode</a>&#160;</td>
          <td class="paramname"><em>CombineMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__OffsetIndex.html">Epetra_OffsetIndex</a> *&#160;</td>
          <td class="paramname"><em>Indexor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform any unpacking and combining after call to <a class="el" href="classEpetra__DistObject.html#ab26ca2d3f9d20a850734f4af633e4135" title="Perform actual transfer (redistribution) of data across memory images, using Epetra_Distributor objec...">DoTransfer()</a>. </p>

<p>Implements <a class="el" href="classEpetra__DistObject.html#a38fa9a68b7998eb7ed664568e64133ea">Epetra_DistObject</a>.</p>

</div>
</div>
<a id="ac6a4fac8da3d1e717b1fb500f9806e53" name="ac6a4fac8da3d1e717b1fb500f9806e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a4fac8da3d1e717b1fb500f9806e53">&#9670;&#160;</a></span>UpperTriangular()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Epetra_CrsMatrix::UpperTriangular </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If matrix is upper triangular in local index space, this query returns true, otherwise it returns false. </p>

<p>Implements <a class="el" href="classEpetra__RowMatrix.html#ab30657243609dfca86645934ce223400">Epetra_RowMatrix</a>.</p>

</div>
</div>
<a id="a0cd834231c77c941d11ce1d0f1ddb727" name="a0cd834231c77c941d11ce1d0f1ddb727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd834231c77c941d11ce1d0f1ddb727">&#9670;&#160;</a></span>UseTranspose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Epetra_CrsMatrix::UseTranspose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current UseTranspose setting. </p>

<p>Implements <a class="el" href="classEpetra__Operator.html#adae8757220ea247aaebe08da978cfbf5">Epetra_Operator</a>.</p>

<p class="reference">Referenced by <a class="el" href="classEpetra__CrsMatrix.html#aa71714f462b0e0218cf6c0c9f6a65353">Apply()</a>, <a class="el" href="classEpetra__CrsMatrix.html#a7df56e43070f908dec709b1a19348cee">ApplyInverse()</a>, and <a class="el" href="classEpetra__FastCrsOperator.html#a68df46e5c78b85be82f7a372bf24fd95">Epetra_FastCrsOperator::UseTranspose()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><b>Epetra_CrsMatrix.h</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 9 2025 20:37:13 for Epetra by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
