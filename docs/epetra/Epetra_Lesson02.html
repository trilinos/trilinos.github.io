<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Epetra: Epetra Lesson 02: Map and Vector</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Epetra<span id="projectnumber">&#160;Development</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Epetra Lesson 02: Map and Vector</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A lesson on parallel distributions and distributed objects.</p>
<h1><a class="anchor" id="Epetra_Lesson02_Topics"></a>
Lesson topics</h1>
<p>In this lesson, we will explain how to create the simplest kind of Epetra linear algebra object: an <a href="http://trilinos.sandia.gov/packages/docs/dev/packages/epetra/doc/html/classEpetra__Vector.html">Epetra_Vector</a>, whose entries are distributed over the process(es) in a communicator. The <a href="http://trilinos.sandia.gov/packages/docs/dev/packages/epetra/doc/html/classEpetra__Map.html">Epetra_Map</a> object describes this distribution of entries over processes. You create a Map to describe the distribution scheme you want, and then use the Map to create objects (such as Vectors) that have this distribution. We spend a little bit more time than you might initially wish explaining Map, but understanding it is important for getting the best performance out of Epetra. We give examples of different distributions you can create, use their Maps to create Vectors, and then do some arithmetic with the Vectors.</p>
<h1><a class="anchor" id="Epetra_Lesson02_Map"></a>
Epetra_Map</h1>
<h2><a class="anchor" id="Epetra_Lesson02_Map_distribution"></a>
A Map instance describes a data distribution</h2>
<p><a href="http://trilinos.sandia.gov/packages/tpetra/">Epetra</a> uses objects called "Maps" to encapsulate the details of distributing data over MPI processes. Maps make data distribution into a first-class citizen. Each Map instance represents a particular data distribution.</p>
<p>You can think of a Map instance abstractly as representing a vector space. If two vectors have the same map, it's like they come from the same vector space. For example, you can add them together without performing communication. If they come from different vector spaces, then you need more information to know whether it is legal to add the vectors together.</p>
<p>You can find documentation for Epetra's Map class <a href="http://trilinos.sandia.gov/packages/docs/dev/packages/epetra/doc/html/classEpetra__Map.html">here</a>.</p>
<h2><a class="anchor" id="Epetra_Lesson02_Map_assigns"></a>
A Map assigns entries of a data structure to processes</h2>
<h3><a class="anchor" id="Epetra_Lesson02_Map_assigns_GIDs"></a>
Global indices matter to you</h3>
<p>For you as the user, the fact that you might be parallelizing your application using MPI is really an implementation detail. You care about what we call <em>global indices</em>. These represent the entries of a distributed object (such as rows or columns of a sparse matrix, or entries of a vector) uniquely over the entire object. The object in turn may be distributed over multiple processes. Just about any data structure containing entries that can be assigned an integer index can be distributed using a Map. For most Epetra users, this means entries of a vector, rows of an <a href="http://trilinos.sandia.gov/packages/docs/dev/packages/epetra/doc/html/classEpetra__MultiVector.html">Epetra_MultiVector</a>, or rows or columns of a sparse graph or matrix. However, it is not limited to these kinds of objects. You may even use Map for your own distributed objects.</p>
<p>A Map assigns global indices to parallel processes. If it assigns a global index G to a process P, we say that process P <em>owns</em> global index G. It is legal for multiple processes to own the same global index G. In fact, this is how we implement many useful communication patterns, including those in sparse matrix-vector multiply. We won't go into much detail in this lesson about that.</p>
<h3><a class="anchor" id="Epetra_Lesson02_Map_assigns_LIDs"></a>
Local indices are an implementation detail</h3>
<p>For efficiency, within a process, we refer to a global index using its "local index" on that process. <em>Local indices</em> are local to the process that owns them. If process P owns global index G, then there is a unique local index L on process P corresponding to G. If the local index L is valid on process P, then there is a unique global index G owned by P corresponding to the pair (L, P). However, multiple processes might own the same global index, so a global index G might correspond to multiple (L, P) pairs. In summary, local indices on a process correspond to object "entries" (e.g., sparse matrix rows or columns) owned by that process.</p>
<h3><a class="anchor" id="Epetra_Lesson02_Map_assigns_exposeLIDs"></a>
We expose local indices for performance reasons</h3>
<p>Local indices matter to you because it may be more efficient to use them to access or modify local data than it is to use global indices. This is because distributed data structures must convert from global to local indices every time a user asks for an element by its global index. This requires a table lookup in general, since a process may own an arbitrary subset of all the global indices, in an arbitrary order. Even though local indices are an implementation detail, we expose them because avoiding that table lookup on each access can improve performance a lot.</p>
<h3><a class="anchor" id="Epetra_Lesson02_Map_assigns_Maps"></a>
Maps are themselves distributed data</h3>
<p>If a Map has N global entries over P processes, and if no one process owns all the global entries, we <em>never</em> store all N global indices on a single process. Some kinds of Maps require storing all the global indices, but in this case, the indices are themselves distributed over processes. This ensures <em>memory scalability</em> (no one process has to store all the data).</p>
<h2><a class="anchor" id="Epetra_Lesson02_compat"></a>
Map compatibility</h2>
<p>We mentioned above that a Map behaves much like a vector space. For instance, if two Vectors have the same Map, it is both legal and meaningful to add them together. This makes it useful to be able to compare Maps. There are two ways to compare two Maps. Two Maps <code>map1</code> and <code>map2</code> may either be "compatible" or "the
same" (<code>map1.SameAs(map2)</code>).</p>
<p>Compatibility of two Maps corresponds to <a href="https://secure.wikimedia.org/wikipedia/en/wiki/Isomorphism">isomorphism</a> of two vector spaces. Two Maps that are the same are always compatible. The compatibility criterion is less restrictive than the "sameness" criterion. Adding together two vectors with compatible but not the same Maps is legal. It might not make mathematical sense, depending on your application. This is because entries of the vectors are ordered differently. (Also, just because two vector spaces are isomorphic, doesn't necessarily mean that adding entries of one to entries of another makes sense.) Adding together two vectors with the same Maps is both legal and mathematically sensible.</p>
<p>Both sameness and compatibility are commutative Boolean relations: for example, <code>map1.SameAs(map2)</code> means <code>map2.SameAs(map1)</code>.</p>
<p>Two Maps are <em>compatible</em> when: </p><ul>
<li>
they have the same global number of entries  </li>
<li>
MPI processes in the Map's communicator that have the same MPI rank, own the same number of entries.  </li>
</ul>
<p>Two Maps are <em>the same</em> when: </p><ul>
<li>
their minimum and maximum global indices are the same  </li>
<li>
they have the same global number of entries  </li>
<li>
the Maps are both distributed over multiple processes, or both not distributed over multiple processes  </li>
<li>
the Maps have the same <em>index base</em> (this means the smallest legal global index value, more or less)  </li>
<li>
Processes that have the same rank, own the same number of entries.  </li>
<li>
Processes that have the same rank, own the same entries. That is, their entries have the same indices, in the same order.  </li>
</ul>
<h2><a class="anchor" id="Epetra_Lesson02_LID_GID_types"></a>
Types of local and global indices</h2>
<p>In Epetra, local indices have type <code>int</code>. On most systems today, this is a 32-bit unsigned integer. Originally, global ordinals could only have type <code>int</code> as well. This meant that one could only solve problems with <picture><source srcset="form_10_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$2^{32} - 1$" src="form_10.png" width="38" height="11"/></picture> (about two billion) "things" (e.g., unknowns or matrix entries) in them. Many Epetra users now want to solve even larger problems. As a result, we added a configure-time option to build Epetra with 64-bit global indices, of type <code>long long</code>. This option is disabled by default, since some C++ compilers do not implement the <code>long long</code> type. (It is part of the C++11 language standard, but some C++98 compilers provide it as an extension of their C99 support.) The <code>long long</code> type must be at least 64 bits long, and is signed.</p>
<h2><a class="anchor" id="Epetra_Lesson02_Map_categories"></a>
Different categories of Maps</h2>
<h3><a class="anchor" id="Epetra_Lesson02_Map_categories_one_to_one"></a>
One to one</h3>
<p>A Map is <em>one to one</em> if each global index in the Map is owned by only one process. This means that the function from global index G to its local index and process rank (L,P) is one to one in a mathematical sense ("injective"). In this case, the function is only onto ("surjective") if there is only one process. Knowing whether a Map is one-to-one is important for data redistribution, which Epetra exposes as the <a href="http://trilinos.sandia.gov/packages/docs/dev/packages/epetra/doc/html/classEpetra__Import.html">Epetra_Import</a> and <a href="http://trilinos.sandia.gov/packages/docs/dev/packages/epetra/doc/html/classEpetra__Export.html">Epetra_Export</a> operations. We will cover Import and Export in subsequent lessons.</p>
<p>An example of a one-to-one Map is a Map containing 101 global indices 0 .. 100 and distributed over four processes, where </p><ul>
<li>
Process 0 owns 0 .. 24  </li>
<li>
Process 1 owns 25 .. 49  </li>
<li>
Process 2 owns 50 .. 74  </li>
<li>
Process 3 owns 75 .. 100  </li>
</ul>
<p>An example of a <em>not</em> one-to-one Map is a Map containing 101 global indices 0 .. 100 and distributed over four processes, where </p><ul>
<li>
Process 0 owns 0 .. 25  </li>
<li>
Process 1 owns 25 .. 50  </li>
<li>
Process 2 owns 50 .. 75  </li>
<li>
Process 3 owns 75 .. 100  </li>
</ul>
<p>Note the overlap of one global index between each "adjacent" process. An example of a mathematical problem with an overlapping distribution like this would be a 1-D linear finite element or finite difference discretization, where entries are distributed with unique ownership among the processes, but the boundary node between two adjacent entries on different processes is shared among those two processes.</p>
<h3><a class="anchor" id="Epetra_Lesson02_Map_categories_contig"></a>
Contiguity and uniformity</h3>
<p>A Map is <em>contiguous</em> when each process' list of global indices forms an interval and is strictly increasing, and the globally minimum global index equals the index base. Map optimizes for the contiguous case. In particular, noncontiguous Maps require communication in order to figure out which process owns a particular global index.</p>
<p>Note that in Epetra, "contiguous" is an optimization, not a predicate. Epetra may not necessarily work hard to check contiguity. The best way to ensure that your Map is contiguous is to use one of the two constructors that always make a contiguous Map.</p>
<p>An example of a contiguous Map is one containing 101 global indices 0 .. 100 and distributed over four processes, where </p><ul>
<li>
Process 0 owns 0 .. 24  </li>
<li>
Process 1 owns 25 .. 49  </li>
<li>
Process 2 owns 50 .. 74  </li>
<li>
Process 3 owns 75 .. 100  </li>
</ul>
<p>Note that Process 3 in this example owns 26 global indices, whereas the other processes each own 25. We say that a Map is <em>uniform</em> if each process owns the same number of global indices. The above Map is <em>not</em> uniform. Map includes both a constructor for uniform contiguous Maps, where you specify the total number of global indices, and a constructor for possibly nonuniform contiguous Maps, where you specify the number of global indices owned by each process.</p>
<h3><a class="anchor" id="Epetra_Lesson02_Map_categories_dist_repl"></a>
Globally distributed or locally replicated</h3>
<p><em>Globally distributed</em> means that all of the following are true: </p><ol>
<li>
The Map's communicator has more than one process.  </li>
<li>
There is at least one process in the Map's communicator, whose local number of entries does not equal the number of global entries. (That is, not all the entries are replicated over all the processes.)  </li>
</ol>
<p>If at least one of the above are not true, then we call the Map <em>locally replicated</em>. The two terms are mutually exclusive.</p>
<h1><a class="anchor" id="Epetra_Lesson02_Vector"></a>
Epetra_Vector</h1>
<p><a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> implements a finite-dimensional vector distributed over processes. <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> inherits from the <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> class, which represents a collection of one or more vectors with the same Map. Trilinos' solvers favor block algorithms, so they favors MultiVectors over single Vectors. A single Vector is just a MultiVector containing one vector, with a few convenience methods. You'll find documentation for Epetra's Vector class <a href="http://trilinos.sandia.gov/packages/docs/dev/packages/epetra/doc/html/classEpetra__Vector.html">here</a>.</p>
<p>Vector's interface contains some common linear algebra operations for vector-vector operations, including operations analogous to those in the BLAS 1 standard.</p>
<h1><a class="anchor" id="Epetra_Lesson02_example_init"></a>
Code example: Initialize Maps and Vectors</h1>
<p>The following example follows the same initialization steps as in the previous lesson. It then creates two distributed Maps and some vectors, and does a few computations with the vectors.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="comment">// This defines useful macros like HAVE_MPI, which is defined if and</span></div>
<div class="line"><span class="comment">// only if Epetra was built with MPI enabled.</span></div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_config.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef HAVE_MPI</span></div>
<div class="line"><span class="preprocessor">#  include &lt;mpi.h&gt;</span></div>
<div class="line"><span class="comment">// Epetra&#39;s wrapper for MPI_Comm.  This header file only exists if</span></div>
<div class="line"><span class="comment">// Epetra was built with MPI enabled.</span></div>
<div class="line"><span class="preprocessor">#  include &lt;Epetra_MpiComm.h&gt;</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#  include &lt;Epetra_SerialComm.h&gt;</span></div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// HAVE_MPI</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_Map.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_Vector.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_Version.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;stdexcept&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">exampleRoutine (<span class="keyword">const</span> <a class="code hl_class" href="classEpetra__Comm.html">Epetra_Comm</a>&amp; comm,</div>
<div class="line">                std::ostream&amp; out)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using </span>std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Print out the Epetra software version.</span></div>
<div class="line">  <span class="keywordflow">if</span> (comm.<a class="code hl_function" href="classEpetra__Comm.html#a60135f8b72809635695dd2b8f539da6b">MyPID</a> () == 0) {</div>
<div class="line">    out &lt;&lt; Epetra_Version () &lt;&lt; endl &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The type of global indices.  You could just set this to int,</span></div>
<div class="line">  <span class="comment">// but we want the example to work for Epetra64 as well.</span></div>
<div class="line"><span class="preprocessor">#ifdef EPETRA_NO_32BIT_GLOBAL_INDICES</span></div>
<div class="line">  <span class="comment">// Epetra was compiled only with 64-bit global index support, so use</span></div>
<div class="line">  <span class="comment">// 64-bit global indices.</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> global_ordinal_type;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <span class="comment">// Epetra was compiled with 32-bit global index support.  If</span></div>
<div class="line">  <span class="comment">// EPETRA_NO_64BIT_GLOBAL_INDICES is defined, it does not also</span></div>
<div class="line">  <span class="comment">// support 64-bit indices.</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">int</span> global_ordinal_type;</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// EPETRA_NO_32BIT_GLOBAL_INDICES</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create some Epetra_Map objects</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Epetra has local and global Maps.  Local maps describe objects</span></div>
<div class="line">  <span class="comment">// that are replicated over all participating MPI processes.  Global</span></div>
<div class="line">  <span class="comment">// maps describe distributed objects.  You can do imports and</span></div>
<div class="line">  <span class="comment">// exports between local and global maps; this is how you would turn</span></div>
<div class="line">  <span class="comment">// locally replicated objects into distributed objects and vice</span></div>
<div class="line">  <span class="comment">// versa.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The total (global, i.e., over all MPI processes) number of</span></div>
<div class="line">  <span class="comment">// entries in the Map.  This has the same type as that of global</span></div>
<div class="line">  <span class="comment">// indices, so it can represent very large values if Epetra was</span></div>
<div class="line">  <span class="comment">// built with 64-bit global index support.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// For this example, we scale the global number of entries in the</span></div>
<div class="line">  <span class="comment">// Map with the number of MPI processes.  That way, you can run this</span></div>
<div class="line">  <span class="comment">// example with any number of MPI processes and every process will</span></div>
<div class="line">  <span class="comment">// still have a positive number of entries.</span></div>
<div class="line">  <span class="keyword">const</span> global_ordinal_type numGlobalEntries = comm.<a class="code hl_function" href="classEpetra__Comm.html#a08ed286ec280a7bae33ea6b6e772ff1a">NumProc</a> () * 5;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Tpetra can index the entries of a Map starting with 0 (C style),</span></div>
<div class="line">  <span class="comment">// 1 (Fortran style), or any base you want.  1-based indexing is</span></div>
<div class="line">  <span class="comment">// handy when interfacing with Fortran.  We choose 0-based indexing</span></div>
<div class="line">  <span class="comment">// here.  This also has the same type as that of global indices.</span></div>
<div class="line">  <span class="keyword">const</span> global_ordinal_type indexBase = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct a Map that puts the same number of equations on each</span></div>
<div class="line">  <span class="comment">// (MPI) process.  The Epetra_Comm is passed in by value, but that&#39;s</span></div>
<div class="line">  <span class="comment">// OK, because Epetra_Comm has shallow copy semantics.  (Its copy</span></div>
<div class="line">  <span class="comment">// constructor and assignment operator do not call MPI_Comm_dup;</span></div>
<div class="line">  <span class="comment">// they just pass along the MPI_Comm.)</span></div>
<div class="line">  <a class="code hl_class" href="classEpetra__Map.html">Epetra_Map</a> contigMap (numGlobalEntries, indexBase, comm);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// contigMap is contiguous by construction.</span></div>
<div class="line">  <span class="keywordflow">if</span> (! contigMap.LinearMap ()) {</div>
<div class="line">    <span class="keywordflow">throw</span> std::logic_error (<span class="stringliteral">&quot;The supposedly contiguous Map isn&#39;t contiguous.&quot;</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Let&#39;s create a second Map.  It will have the same number of</span></div>
<div class="line">  <span class="comment">// global entries per process, but will distribute them differently,</span></div>
<div class="line">  <span class="comment">// in round-robin (1-D cyclic) fashion instead of contiguously.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// We&#39;ll use the version of the Map constructor that takes, on each</span></div>
<div class="line">  <span class="comment">// MPI process, a list of the global indices in the Map belonging to</span></div>
<div class="line">  <span class="comment">// that process.  You can use this constructor to construct an</span></div>
<div class="line">  <span class="comment">// overlapping (also called &quot;not 1-to-1&quot;) Map, in which one or more</span></div>
<div class="line">  <span class="comment">// entries are owned by multiple processes.  We don&#39;t do that here;</span></div>
<div class="line">  <span class="comment">// we make a nonoverlapping (also called &quot;1-to-1&quot;) Map.</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> numGblIndsPerProc = 5;</div>
<div class="line">  global_ordinal_type* gblIndList = <span class="keyword">new</span> global_ordinal_type [numGblIndsPerProc];</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> numProcs = comm.<a class="code hl_function" href="classEpetra__Comm.html#a08ed286ec280a7bae33ea6b6e772ff1a">NumProc</a> ();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> myRank = comm.<a class="code hl_function" href="classEpetra__Comm.html#a60135f8b72809635695dd2b8f539da6b">MyPID</a> ();</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; numGblIndsPerProc; ++k) {</div>
<div class="line">    gblIndList[k] = myRank + k*numProcs;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classEpetra__Map.html">Epetra_Map</a> cyclicMap (numGlobalEntries, numGblIndsPerProc,</div>
<div class="line">                        gblIndList, indexBase, comm);</div>
<div class="line">  <span class="comment">// The above constructor makes a deep copy of the input index list,</span></div>
<div class="line">  <span class="comment">// so it&#39;s safe to deallocate that list after this constructor</span></div>
<div class="line">  <span class="comment">// completes.</span></div>
<div class="line">  <span class="keywordflow">if</span> (gblIndList != NULL) {</div>
<div class="line">    <span class="keyword">delete</span> [] gblIndList;</div>
<div class="line">    gblIndList = NULL;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If there&#39;s more than one MPI process in the communicator,</span></div>
<div class="line">  <span class="comment">// then cyclicMap is definitely NOT contiguous.</span></div>
<div class="line">  <span class="keywordflow">if</span> (comm.<a class="code hl_function" href="classEpetra__Comm.html#a08ed286ec280a7bae33ea6b6e772ff1a">NumProc</a> () &gt; 1 &amp;&amp; cyclicMap.LinearMap ()) {</div>
<div class="line">    <span class="keywordflow">throw</span> std::logic_error (<span class="stringliteral">&quot;The cyclic Map claims to be contiguous.&quot;</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// contigMap and cyclicMap should always be compatible.  However, if</span></div>
<div class="line">  <span class="comment">// the communicator contains more than 1 process, then contigMap and</span></div>
<div class="line">  <span class="comment">// cyclicMap are NOT the same.</span></div>
<div class="line">  <span class="comment">// if (! contigMap.isCompatible (*cyclicMap)) {</span></div>
<div class="line">  <span class="comment">//   throw std::logic_error (&quot;contigMap should be compatible with cyclicMap, &quot;</span></div>
<div class="line">  <span class="comment">//                           &quot;but it&#39;s not.&quot;);</span></div>
<div class="line">  <span class="comment">// }</span></div>
<div class="line">  <span class="keywordflow">if</span> (comm.<a class="code hl_function" href="classEpetra__Comm.html#a08ed286ec280a7bae33ea6b6e772ff1a">NumProc</a> () &gt; 1 &amp;&amp; contigMap.SameAs (cyclicMap)) {</div>
<div class="line">    <span class="keywordflow">throw</span> std::logic_error (<span class="stringliteral">&quot;contigMap should not be the same as cyclicMap.&quot;</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// We have maps now, so we can create vectors.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create an Epetra_Vector with the contiguous Map we created above.</span></div>
<div class="line">  <span class="comment">// This version of the constructor will fill the vector with zeros.</span></div>
<div class="line">  <span class="comment">// The Vector constructor takes a Map by value, but that&#39;s OK,</span></div>
<div class="line">  <span class="comment">// because Epetra_Map has shallow copy semantics.  It uses reference</span></div>
<div class="line">  <span class="comment">// counting internally to avoid copying data unnecessarily.</span></div>
<div class="line">  <a class="code hl_class" href="classEpetra__Vector.html">Epetra_Vector</a> x (contigMap);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The copy constructor performs a deep copy.</span></div>
<div class="line">  <span class="comment">// x and y have the same Map.</span></div>
<div class="line">  <a class="code hl_class" href="classEpetra__Vector.html">Epetra_Vector</a> y (x);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a Vector with the 1-D cyclic Map.  Calling the constructor</span></div>
<div class="line">  <span class="comment">// with false for the second argument leaves the data uninitialized,</span></div>
<div class="line">  <span class="comment">// so that you can fill it later without paying the cost of</span></div>
<div class="line">  <span class="comment">// initially filling it with zeros.</span></div>
<div class="line">  <a class="code hl_class" href="classEpetra__Vector.html">Epetra_Vector</a> z (cyclicMap, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set the entries of z to (pseudo)random numbers.  Please don&#39;t</span></div>
<div class="line">  <span class="comment">// consider this a good parallel pseudorandom number generator.</span></div>
<div class="line">  (void) z.Random ();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set the entries of x to all ones.</span></div>
<div class="line">  (void) x.PutScalar (1.0);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Define some constants for use below.</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = 3.14159;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> beta = 2.71828;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> gamma = -10.0;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// x = beta*x + alpha*z</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// This is a legal operation!  Even though the Maps of x and z are</span></div>
<div class="line">  <span class="comment">// not the same, their Maps are compatible.  Whether it makes sense</span></div>
<div class="line">  <span class="comment">// or not depends on your application.</span></div>
<div class="line">  (void) x.Update (alpha, z, beta);</div>
<div class="line"> </div>
<div class="line">  (void) y.PutScalar (42.0); <span class="comment">// Set all entries of y to 42.0</span></div>
<div class="line">  <span class="comment">// y = gamma*y + alpha*x + beta*z</span></div>
<div class="line">  y.Update (alpha, x, beta, z, gamma);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute the 2-norm of y.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// The norm may have a different type than scalar_type.</span></div>
<div class="line">  <span class="comment">// For example, if scalar_type is complex, then the norm is real.</span></div>
<div class="line">  <span class="comment">// The ScalarTraits &quot;traits class&quot; gives us the type of the norm.</span></div>
<div class="line">  <span class="keywordtype">double</span> theNorm = 0.0;</div>
<div class="line">  (void) y.Norm2 (&amp;theNorm);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Print the norm of y on Proc 0.</span></div>
<div class="line">  out &lt;&lt; <span class="stringliteral">&quot;Norm of y: &quot;</span> &lt;&lt; theNorm &lt;&lt; endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The same main() driver routine as in the first Epetra lesson.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using </span>std::cout;</div>
<div class="line">  <span class="keyword">using </span>std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef HAVE_MPI</span></div>
<div class="line">  MPI_Init (&amp;argc, &amp;argv);</div>
<div class="line">  <a class="code hl_class" href="classEpetra__MpiComm.html">Epetra_MpiComm</a> comm (MPI_COMM_WORLD);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <a class="code hl_class" href="classEpetra__SerialComm.html">Epetra_SerialComm</a> comm;</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// HAVE_MPI</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (comm.<a class="code hl_function" href="classEpetra__SerialComm.html#a237a6407573dea22f0366936d158486d">MyPID</a> () == 0) {</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Total number of processes: &quot;</span> &lt;&lt; comm.<a class="code hl_function" href="classEpetra__SerialComm.html#af55220ff6540694c810aa9f2b3ec146f">NumProc</a> () &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Do something with the new Epetra communicator.</span></div>
<div class="line">  exampleRoutine (comm, cout);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// This tells the Trilinos test framework that the test passed.</span></div>
<div class="line">  <span class="keywordflow">if</span> (comm.<a class="code hl_function" href="classEpetra__SerialComm.html#a237a6407573dea22f0366936d158486d">MyPID</a> () == 0) {</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;End Result: TEST PASSED&quot;</span> &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef HAVE_MPI</span></div>
<div class="line">  <span class="comment">// Since you called MPI_Init, you are responsible for calling</span></div>
<div class="line">  <span class="comment">// MPI_Finalize after you are done using MPI.</span></div>
<div class="line">  (void) MPI_Finalize ();</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// HAVE_MPI</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassEpetra__Comm_html"><div class="ttname"><a href="classEpetra__Comm.html">Epetra_Comm</a></div><div class="ttdoc">Epetra_Comm: The Epetra Communication Abstract Base Class.</div><div class="ttdef"><b>Definition</b> Epetra_Comm.h:81</div></div>
<div class="ttc" id="aclassEpetra__Comm_html_a08ed286ec280a7bae33ea6b6e772ff1a"><div class="ttname"><a href="classEpetra__Comm.html#a08ed286ec280a7bae33ea6b6e772ff1a">Epetra_Comm::NumProc</a></div><div class="ttdeci">virtual int NumProc() const =0</div><div class="ttdoc">Returns total number of processes.</div></div>
<div class="ttc" id="aclassEpetra__Comm_html_a60135f8b72809635695dd2b8f539da6b"><div class="ttname"><a href="classEpetra__Comm.html#a60135f8b72809635695dd2b8f539da6b">Epetra_Comm::MyPID</a></div><div class="ttdeci">virtual int MyPID() const =0</div><div class="ttdoc">Return my process ID.</div></div>
<div class="ttc" id="aclassEpetra__Map_html"><div class="ttname"><a href="classEpetra__Map.html">Epetra_Map</a></div><div class="ttdoc">Epetra_Map: A class for partitioning vectors and matrices.</div><div class="ttdef"><b>Definition</b> Epetra_Map.h:127</div></div>
<div class="ttc" id="aclassEpetra__MpiComm_html"><div class="ttname"><a href="classEpetra__MpiComm.html">Epetra_MpiComm</a></div><div class="ttdoc">Epetra_MpiComm: The Epetra MPI Communication Class.</div><div class="ttdef"><b>Definition</b> Epetra_MpiComm.h:72</div></div>
<div class="ttc" id="aclassEpetra__SerialComm_html"><div class="ttname"><a href="classEpetra__SerialComm.html">Epetra_SerialComm</a></div><div class="ttdoc">Epetra_SerialComm: The Epetra Serial Communication Class.</div><div class="ttdef"><b>Definition</b> Epetra_SerialComm.h:69</div></div>
<div class="ttc" id="aclassEpetra__SerialComm_html_a237a6407573dea22f0366936d158486d"><div class="ttname"><a href="classEpetra__SerialComm.html#a237a6407573dea22f0366936d158486d">Epetra_SerialComm::MyPID</a></div><div class="ttdeci">int MyPID() const</div><div class="ttdoc">Return my process ID.</div><div class="ttdef"><b>Definition</b> Epetra_SerialComm.h:440</div></div>
<div class="ttc" id="aclassEpetra__SerialComm_html_af55220ff6540694c810aa9f2b3ec146f"><div class="ttname"><a href="classEpetra__SerialComm.html#af55220ff6540694c810aa9f2b3ec146f">Epetra_SerialComm::NumProc</a></div><div class="ttdeci">int NumProc() const</div><div class="ttdoc">Returns total number of processes (always returns 1 for SerialComm).</div><div class="ttdef"><b>Definition</b> Epetra_SerialComm.h:443</div></div>
<div class="ttc" id="aclassEpetra__Vector_html"><div class="ttname"><a href="classEpetra__Vector.html">Epetra_Vector</a></div><div class="ttdoc">Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.</div><div class="ttdef"><b>Definition</b> Epetra_Vector.h:150</div></div>
</div><!-- fragment --><h1><a class="anchor" id="Epetra_Lesson02_example_read_modify_vec"></a>
Code example: Read and modify the entries of a Vector</h1>
<p>The following example follows the same initialization steps as in the previous lesson. It then creates a distributed <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> and a <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a>, and shows how to read and modify the entries of the <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a>.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="comment">// This defines useful macros like HAVE_MPI, which is defined if and</span></div>
<div class="line"><span class="comment">// only if Epetra was built with MPI enabled.</span></div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_config.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef HAVE_MPI</span></div>
<div class="line"><span class="preprocessor">#  include &lt;mpi.h&gt;</span></div>
<div class="line"><span class="comment">// Epetra&#39;s wrapper for MPI_Comm.  This header file only exists if</span></div>
<div class="line"><span class="comment">// Epetra was built with MPI enabled.</span></div>
<div class="line"><span class="preprocessor">#  include &lt;Epetra_MpiComm.h&gt;</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#  include &lt;Epetra_SerialComm.h&gt;</span></div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// HAVE_MPI</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_Map.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_Vector.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_Version.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">exampleRoutine (<span class="keyword">const</span> <a class="code hl_class" href="classEpetra__Comm.html">Epetra_Comm</a>&amp; comm,</div>
<div class="line">                std::ostream&amp; out)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using </span>std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Print out the Epetra software version.</span></div>
<div class="line">  <span class="keywordflow">if</span> (comm.<a class="code hl_function" href="classEpetra__Comm.html#a60135f8b72809635695dd2b8f539da6b">MyPID</a> () == 0) {</div>
<div class="line">    out &lt;&lt; Epetra_Version () &lt;&lt; endl &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The type of global indices.  You could just set this to int,</span></div>
<div class="line">  <span class="comment">// but we want the example to work for Epetra64 as well.</span></div>
<div class="line"><span class="preprocessor">#ifdef EPETRA_NO_32BIT_GLOBAL_INDICES</span></div>
<div class="line">  <span class="comment">// Epetra was compiled only with 64-bit global index support, so use</span></div>
<div class="line">  <span class="comment">// 64-bit global indices.</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> global_ordinal_type;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <span class="comment">// Epetra was compiled with 32-bit global index support.  If</span></div>
<div class="line">  <span class="comment">// EPETRA_NO_64BIT_GLOBAL_INDICES is defined, it does not also</span></div>
<div class="line">  <span class="comment">// support 64-bit indices.</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">int</span> global_ordinal_type;</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// EPETRA_NO_32BIT_GLOBAL_INDICES</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create an Epetra_Map</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The total (global, i.e., over all MPI processes) number of</span></div>
<div class="line">  <span class="comment">// entries in the Map.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// For this example, we scale the global number of entries in the</span></div>
<div class="line">  <span class="comment">// Map with the number of MPI processes.  That way, you can run this</span></div>
<div class="line">  <span class="comment">// example with any number of MPI processes and every process will</span></div>
<div class="line">  <span class="comment">// still have a positive number of entries.</span></div>
<div class="line">  <span class="keyword">const</span> global_ordinal_type numGlobalEntries = comm.<a class="code hl_function" href="classEpetra__Comm.html#a08ed286ec280a7bae33ea6b6e772ff1a">NumProc</a> () * 5;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Index base of the Map.  We choose zero-based (C-style) indexing.</span></div>
<div class="line">  <span class="keyword">const</span> global_ordinal_type indexBase = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct a Map that puts the same number of equations on each</span></div>
<div class="line">  <span class="comment">// MPI process.</span></div>
<div class="line">  <a class="code hl_class" href="classEpetra__Map.html">Epetra_Map</a> contigMap (numGlobalEntries, indexBase, comm);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create an Epetra_Vector</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a Vector with the Map we created above.</span></div>
<div class="line">  <span class="comment">// This version of the constructor will fill in the vector with zeros.</span></div>
<div class="line">  <a class="code hl_class" href="classEpetra__Vector.html">Epetra_Vector</a> x (contigMap);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Fill the Vector with a single number, or with random numbers</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set all entries of x to 42.0.</span></div>
<div class="line">  (void) x.PutScalar (42.0);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Print the norm of x.</span></div>
<div class="line">  <span class="keywordtype">double</span> theNorm = 0.0;</div>
<div class="line">  (void) x.Norm2 (&amp;theNorm);</div>
<div class="line">  out &lt;&lt; <span class="stringliteral">&quot;Norm of x (all entries are 42.0): &quot;</span> &lt;&lt; theNorm &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set the entries of x to (pseudo)random numbers.  Please don&#39;t</span></div>
<div class="line">  <span class="comment">// consider this a good parallel pseudorandom number generator.</span></div>
<div class="line">  (void) x.Random ();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Print the norm of x.</span></div>
<div class="line">  (void) x.Norm2 (&amp;theNorm);</div>
<div class="line">  out &lt;&lt; <span class="stringliteral">&quot;Norm of x (random numbers): &quot;</span> &lt;&lt; theNorm &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Read the entries of the Vector</span></div>
<div class="line"> </div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> localLength = x.MyLength ();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Count the local number of entries less than 0.5.</span></div>
<div class="line">    <span class="comment">// Use local indices to access the entries of x_data.</span></div>
<div class="line">    <span class="keywordtype">int</span> localCount = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> localIndex = 0; localIndex &lt; localLength; ++localIndex) {</div>
<div class="line">      <span class="keywordflow">if</span> (x[localIndex] &lt; 0.5) {</div>
<div class="line">        ++localCount;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> globalCount = 0;</div>
<div class="line">    (void) comm.<a class="code hl_function" href="classEpetra__Comm.html#af81a51a85a8756371c6005de62378dbb">SumAll</a> (&amp;localCount, &amp;globalCount, 1);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Find the total number of entries less than 0.5,</span></div>
<div class="line">    <span class="comment">// over all processes in the Vector&#39;s communicator.</span></div>
<div class="line">    out &lt;&lt; <span class="stringliteral">&quot;x has &quot;</span> &lt;&lt; globalCount &lt;&lt; <span class="stringliteral">&quot; entr&quot;</span></div>
<div class="line">        &lt;&lt; (globalCount != 1 ? <span class="stringliteral">&quot;ies&quot;</span> : <span class="stringliteral">&quot;y&quot;</span>)</div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot; less than 0.5.&quot;</span> &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Modify the entries of the Vector</span></div>
<div class="line"> </div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Use local indices to access the entries of x_data.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> localLength = x.MyLength ();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> localIndex = 0; localIndex &lt; localLength; ++localIndex) {</div>
<div class="line">      <span class="comment">// Add the value of the local index to every entry of x.</span></div>
<div class="line">      x[localIndex] += <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span> (localIndex);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Print the norm of x.</span></div>
<div class="line">    theNorm = 0.0;</div>
<div class="line">    (void) x.Norm2 (&amp;theNorm);</div>
<div class="line">    out &lt;&lt; <span class="stringliteral">&quot;Norm of x (modified random numbers): &quot;</span> &lt;&lt; theNorm &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The same main() driver routine as in the previous Epetra lesson.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using </span>std::cout;</div>
<div class="line">  <span class="keyword">using </span>std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef HAVE_MPI</span></div>
<div class="line">  MPI_Init (&amp;argc, &amp;argv);</div>
<div class="line">  <a class="code hl_class" href="classEpetra__MpiComm.html">Epetra_MpiComm</a> comm (MPI_COMM_WORLD);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <a class="code hl_class" href="classEpetra__SerialComm.html">Epetra_SerialComm</a> comm;</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// HAVE_MPI</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (comm.<a class="code hl_function" href="classEpetra__SerialComm.html#a237a6407573dea22f0366936d158486d">MyPID</a> () == 0) {</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Total number of processes: &quot;</span> &lt;&lt; comm.<a class="code hl_function" href="classEpetra__SerialComm.html#af55220ff6540694c810aa9f2b3ec146f">NumProc</a> () &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Do something with the new Epetra communicator.</span></div>
<div class="line">  exampleRoutine (comm, cout);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// This tells the Trilinos test framework that the test passed.</span></div>
<div class="line">  <span class="keywordflow">if</span> (comm.<a class="code hl_function" href="classEpetra__SerialComm.html#a237a6407573dea22f0366936d158486d">MyPID</a> () == 0) {</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;End Result: TEST PASSED&quot;</span> &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef HAVE_MPI</span></div>
<div class="line">  <span class="comment">// Since you called MPI_Init, you are responsible for calling</span></div>
<div class="line">  <span class="comment">// MPI_Finalize after you are done using MPI.</span></div>
<div class="line">  (void) MPI_Finalize ();</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// HAVE_MPI</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassEpetra__Comm_html_af81a51a85a8756371c6005de62378dbb"><div class="ttname"><a href="classEpetra__Comm.html#af81a51a85a8756371c6005de62378dbb">Epetra_Comm::SumAll</a></div><div class="ttdeci">virtual int SumAll(double *PartialSums, double *GlobalSums, int Count) const =0</div><div class="ttdoc">Epetra_Comm Global Sum function.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="Epetra_Lesson02_Other"></a>
Things not previously explained</h1>
<p>This lesson introduces one new topic: namely, the Teuchos memory management classes like Teuchos::Array. We will explain them here.</p>
<h2><a class="anchor" id="Epetra_Lesson02_Other_Array"></a>
Teuchos memory management classes</h2>
<p>Teuchos::Array is an array container, templated on the type of objects that it contains. It behaves much like std::vector. The difference is that Array interoperates with the other Teuchos memory management classes. For example, Teuchos::ArrayView is a nonowning, nonpersistent view of part or all of an Array. The std::vector class does not have nonowning views; passing std::vector by value copies the data, and there is no way to get a view of part of the std::vector. Array and ArrayView fix these deficiencies. Teuchos::ArrayRCP is the array analog of !RCP; it allows shared ownership of an array. For more details, please refer to the reference guide to the <a href="http://www.cs.sandia.gov/~rabartl/TeuchosMemoryManagementSAND.pdf">Teuchos Memory Management Classes</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
