<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Epetra: Epetra Lesson 03: Power method</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Epetra<span id="projectnumber">&#160;Development</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Epetra Lesson 03: Power method</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Use Epetra sparse matrix and dense vector objects to implement a simple iteration (the power method)</p>
<h1><a class="anchor" id="Epetra_Lesson03_Topics"></a>
Lesson topics</h1>
<p>This lesson demonstrates the following: </p><ol>
<li>
How to construct a <a class="el" href="classEpetra__CrsMatrix.html" title="Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...">Epetra_CrsMatrix</a> (a distributed sparse matrix)  </li>
<li>
How to modify the entries of a previously constructed CrsMatrix  </li>
<li>
How to use CrsMatrix and Vector to implement a simple iterative eigensolver (the power method)  </li>
</ol>
<h1><a class="anchor" id="Epetra_Lesson03_Relation"></a>
Relation to other lessons</h1>
<p>Before starting this lesson, it helps to have finished <a class="el" href="Epetra_Lesson01.html">Epetra Lesson 01: Initialization</a> (how to initialize Epetra) and <a class="el" href="Epetra_Lesson02.html#Epetra_Lesson02_Vector">Epetra_Vector</a> (how to create distributions and distributed vectors). After completing this lesson, you might want to learn about more efficient ways to add or modify entries in a Epetra sparse matrix.</p>
<h1><a class="anchor" id="Epetra_Lesson03_Fill"></a>
Creating and filling a sparse matrix</h1>
<p>This is the first lesson in the usual sequence which covers adding entries to ("filling") a Epetra sparse matrix, and modifying the values of those entries after creating the matrix. Creating and filling a Epetra sparse matrix involves the following steps: </p><ol>
<li>
Create the CrsMatrix (by calling one of its constructors)  </li>
<li>
Call methods to add entries to the sparse matrix  </li>
<li>
Call the matrix's <code>FillComplete()</code> method  </li>
</ol>
<p>We will explain each of these steps in turn.</p>
<h2><a class="anchor" id="Epetra_Lesson03_Fill_create"></a>
Creating the CrsMatrix</h2>
<p>Epetra's sparse matrices are distributed over one or more parallel processes, just like vectors or other distributed objects. Also just like vectors, you have to tell the sparse matrix its distribution on construction. Unlike vectors, though, sparse matrices have two dimensions over which to be distributed: rows and columns.</p>
<p>Many users are perfectly happy ignoring the column distribution and just distributing the matrix in "one-dimensional" fashion over rows. In that case, you need only supply the "row Map" to the constructor. This implies that for any row which a process owns, that process may insert entries in any column in that row.</p>
<p>Some users want to use the full flexibility of distributing both the rows and columns of the matrix over processes. This "two-dimensional" distribution, if chosen optimally, can significantly reduce the amount of communication needed for distributed-memory parallel sparse matrix-vector multiply. Trilinos packages like Zoltan can help you compute this distribution. In that case, you may give both the "row
Map" and the "column Map" to the constructor. This implies that for any row which a process owns, that process may insert entries in any column in that row which that process owns in its column Map.</p>
<p>Finally, other users already know the structure of the sparse matrix, and just want to fill in values. These users should first create the graph (as an <a class="el" href="classEpetra__CrsGraph.html" title="Epetra_CrsGraph: A class for constructing and using sparse compressed row graphs.">Epetra_CrsGraph</a>), call <code>FillComplete()</code> on the graph, and then give the graph to the constructor of CrsMatrix. The graph may have either a "1-D" or "2-D" distribution, as mentioned above.</p>
<h2><a class="anchor" id="Epetra_Lesson03_Fill_add"></a>
Adding entries to the sparse matrix</h2>
<p>Methods of CrsMatrix that start with "Insert" actually change the structure of the sparse matrix. Methods that start with "Replace" or "SumInto" only modify existing values.</p>
<h2><a class="anchor" id="Epetra_Lesson03_Fill_FillComplete"></a>
Calling \c FillComplete()</h2>
<p>Calling <code>FillComplete()</code> signals that you are done changing the structure (if allowed) or values of the sparse matrix. This is an expensive operation, because it both rearranges local data, and communicates in order to build reusable communication patterns for sparse matrix-vector multiply. You should try to amortize the cost of this operation whenever possible over many sparse matrix-vector multiplies.</p>
<p><code>FillComplete()</code> takes two arguments: </p><ul>
<li>
the domain Map (the distribution of the input vector x in a sparse matrix-vector multiply y = A*x)  </li>
<li>
the range Map (the distribution of the output vector y in a sparse matrix-vector multiply y = A*x)  </li>
</ul>
<p>Both the domain and range Maps must be one-to-one: that is, each global index in the Map must be uniquely owned by one and only one process. You will need to supply these two arguments to <code>FillComplete()</code> under any of the following conditions: </p><ul>
<li>
When the row Map is not the same as the range Map (it can't be if the row Map is not one to one)  </li>
<li>
When the domain and range Maps are not equal (e.g., if the matrix is not square)  </li>
<li>
When the domain or range Map as not the same as the row Map </li>
</ul>
<p>If the domain and range Maps equal the row Map and the row Map is one-to-one, then you may call <code>FillComplete()</code> with no arguments.</p>
<p>Once you have called <code>FillComplete()</code>, you may modify the values in the sparse matrix, but you may <em>not</em> modify its graph structure.</p>
<h1><a class="anchor" id="Epetra_Lesson03_example"></a>
Code example</h1>
<p>The following code example shows how to fill and compute with a Epetra sparse matrix, using the procedure discussed in the text above.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="comment">// This defines useful macros like HAVE_MPI, which is defined if and</span></div>
<div class="line"><span class="comment">// only if Epetra was built with MPI enabled.</span></div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_config.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef HAVE_MPI</span></div>
<div class="line"><span class="preprocessor">#  include &lt;mpi.h&gt;</span></div>
<div class="line"><span class="comment">// Epetra&#39;s wrapper for MPI_Comm.  This header file only exists if</span></div>
<div class="line"><span class="comment">// Epetra was built with MPI enabled.</span></div>
<div class="line"><span class="preprocessor">#  include &lt;Epetra_MpiComm.h&gt;</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#  include &lt;Epetra_SerialComm.h&gt;</span></div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// HAVE_MPI</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_CrsMatrix.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_Map.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_Vector.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Epetra_Version.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdexcept&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Implementation of the power method for estimating the eigenvalue of</span></div>
<div class="line"><span class="comment">// maximum magnitude of a matrix.  This function returns the</span></div>
<div class="line"><span class="comment">// eigenvalue estimate.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// A: The sparse matrix or operator, as an Epetra_Operator.</span></div>
<div class="line"><span class="comment">// niters: Maximum number of iterations of the power method.</span></div>
<div class="line"><span class="comment">// tolerance: If the 2-norm of the residual A*x-lambda*x (for the</span></div>
<div class="line"><span class="comment">//   current eigenvalue estimate lambda) is less than this, stop</span></div>
<div class="line"><span class="comment">//   iterating.</span></div>
<div class="line"><span class="comment">// out: output stream to which to print the current status of the</span></div>
<div class="line"><span class="comment">//   power method.</span></div>
<div class="line"><span class="keywordtype">double</span></div>
<div class="line">powerMethod (<span class="keyword">const</span> <a class="code hl_class" href="classEpetra__Operator.html">Epetra_Operator</a>&amp; A,</div>
<div class="line">             <span class="keyword">const</span> <span class="keywordtype">int</span> niters,</div>
<div class="line">             <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using </span>std::cout;</div>
<div class="line">  <span class="keyword">using </span>std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef HAVE_MPI</span></div>
<div class="line">  MPI_Init (&amp;argc, &amp;argv);</div>
<div class="line">  <a class="code hl_class" href="classEpetra__MpiComm.html">Epetra_MpiComm</a> comm (MPI_COMM_WORLD);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <a class="code hl_class" href="classEpetra__SerialComm.html">Epetra_SerialComm</a> comm;</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// HAVE_MPI</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> myRank = comm.<a class="code hl_function" href="classEpetra__SerialComm.html#a237a6407573dea22f0366936d158486d">MyPID</a> ();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> numProcs = comm.<a class="code hl_function" href="classEpetra__SerialComm.html#af55220ff6540694c810aa9f2b3ec146f">NumProc</a> ();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">    <span class="comment">// Print out the Epetra software version.</span></div>
<div class="line">    cout &lt;&lt; Epetra_Version () &lt;&lt; endl &lt;&lt; endl</div>
<div class="line">         &lt;&lt; <span class="stringliteral">&quot;Total number of processes: &quot;</span> &lt;&lt; numProcs &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The type of global indices.  You could just set this to int,</span></div>
<div class="line">  <span class="comment">// but we want the example to work for Epetra64 as well.</span></div>
<div class="line"><span class="preprocessor">#ifdef EPETRA_NO_32BIT_GLOBAL_INDICES</span></div>
<div class="line">  <span class="comment">// Epetra was compiled only with 64-bit global index support, so use</span></div>
<div class="line">  <span class="comment">// 64-bit global indices.</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> global_ordinal_type;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <span class="comment">// Epetra was compiled with 32-bit global index support.  If</span></div>
<div class="line">  <span class="comment">// EPETRA_NO_64BIT_GLOBAL_INDICES is defined, it does not also</span></div>
<div class="line">  <span class="comment">// support 64-bit indices.</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">int</span> global_ordinal_type;</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// EPETRA_NO_32BIT_GLOBAL_INDICES</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of rows and columns in the matrix.</span></div>
<div class="line">  <span class="keyword">const</span> global_ordinal_type numGlobalElements = 50;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct a Map that puts approximately the same number of</span></div>
<div class="line">  <span class="comment">// equations on each processor.</span></div>
<div class="line">  <span class="keyword">const</span> global_ordinal_type indexBase = 0;</div>
<div class="line">  <a class="code hl_class" href="classEpetra__Map.html">Epetra_Map</a> map (numGlobalElements, indexBase, comm);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get the list of global indices that this process owns.  In this</span></div>
<div class="line">  <span class="comment">// example, this is unnecessary, because we know that we created a</span></div>
<div class="line">  <span class="comment">// contiguous Map (see above).  (Thus, we really only need the min</span></div>
<div class="line">  <span class="comment">// and max global index on this process.)  However, in general, we</span></div>
<div class="line">  <span class="comment">// don&#39;t know what global indices the Map owns, so if we plan to add</span></div>
<div class="line">  <span class="comment">// entries into the sparse matrix using global indices, we have to</span></div>
<div class="line">  <span class="comment">// get the list of global indices this process owns.</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> numMyElements = map.NumMyElements ();</div>
<div class="line"> </div>
<div class="line">  global_ordinal_type* myGlobalElements = NULL;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef EPETRA_NO_32BIT_GLOBAL_INDICES</span></div>
<div class="line">  myGlobalElements = map.MyGlobalElements64 ();</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  myGlobalElements = map.MyGlobalElements ();</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// EPETRA_NO_32BIT_GLOBAL_INDICES</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// In general, tests like this really should synchronize across all</span></div>
<div class="line">  <span class="comment">// processes.  However, the likely cause for this case is a</span></div>
<div class="line">  <span class="comment">// misconfiguration of Epetra, so we expect it to happen on all</span></div>
<div class="line">  <span class="comment">// processes, if it happens at all.</span></div>
<div class="line">  <span class="keywordflow">if</span> (numMyElements &gt; 0 &amp;&amp; myGlobalElements == NULL) {</div>
<div class="line">    <span class="keywordflow">throw</span> std::logic_error (<span class="stringliteral">&quot;Failed to get the list of global indices&quot;</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;Creating the sparse matrix&quot;</span> &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a Epetra sparse matrix whose rows have distribution given</span></div>
<div class="line">  <span class="comment">// by the Map.  The max number of entries per row is 3.</span></div>
<div class="line">  <a class="code hl_class" href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a> A (<a class="code hl_enumvalue" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928aad81934e8f3b9399beea932f0b0e57d8">Copy</a>, map, 3);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Local error code for use below.</span></div>
<div class="line">  <span class="keywordtype">int</span> lclerr = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Fill the sparse matrix, one row at a time.  InsertGlobalValues</span></div>
<div class="line">  <span class="comment">// adds entries to the sparse matrix, using global column indices.</span></div>
<div class="line">  <span class="comment">// It changes both the graph structure and the values.</span></div>
<div class="line">  <span class="keywordtype">double</span> tempVals[3];</div>
<div class="line">  global_ordinal_type tempGblInds[3];</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numMyElements; ++i) {</div>
<div class="line">    <span class="comment">// A(0, 0:1) = [2, -1]</span></div>
<div class="line">    <span class="keywordflow">if</span> (myGlobalElements[i] == 0) {</div>
<div class="line">      tempVals[0] = 2.0;</div>
<div class="line">      tempVals[1] = -1.0;</div>
<div class="line">      tempGblInds[0] = myGlobalElements[i];</div>
<div class="line">      tempGblInds[1] = myGlobalElements[i] + 1;</div>
<div class="line">      <span class="keywordflow">if</span> (lclerr == 0) {</div>
<div class="line">        lclerr = A.InsertGlobalValues (myGlobalElements[i], 2, tempVals, tempGblInds);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (lclerr != 0) {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// A(N-1, N-2:N-1) = [-1, 2]</span></div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (myGlobalElements[i] == numGlobalElements - 1) {</div>
<div class="line">      tempVals[0] = -1.0;</div>
<div class="line">      tempVals[1] = 2.0;</div>
<div class="line">      tempGblInds[0] = myGlobalElements[i] - 1;</div>
<div class="line">      tempGblInds[1] = myGlobalElements[i];</div>
<div class="line">      <span class="keywordflow">if</span> (lclerr == 0) {</div>
<div class="line">        lclerr = A.InsertGlobalValues (myGlobalElements[i], 2, tempVals, tempGblInds);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (lclerr != 0) {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// A(i, i-1:i+1) = [-1, 2, -1]</span></div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">      tempVals[0] = -1.0;</div>
<div class="line">      tempVals[1] = 2.0;</div>
<div class="line">      tempVals[2] = -1.0;</div>
<div class="line">      tempGblInds[0] = myGlobalElements[i] - 1;</div>
<div class="line">      tempGblInds[1] = myGlobalElements[i];</div>
<div class="line">      tempGblInds[2] = myGlobalElements[i] + 1;</div>
<div class="line">      <span class="keywordflow">if</span> (lclerr == 0) {</div>
<div class="line">        lclerr = A.InsertGlobalValues (myGlobalElements[i], 3, tempVals, tempGblInds);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (lclerr != 0) {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If any process failed to insert at least one entry, throw.</span></div>
<div class="line">  <span class="keywordtype">int</span> gblerr = 0;</div>
<div class="line">  (void) comm.<a class="code hl_function" href="classEpetra__SerialComm.html#ac1699aa99f819e95ddd65a3c2ff4a5c9">MaxAll</a> (&amp;lclerr, &amp;gblerr, 1);</div>
<div class="line">  <span class="keywordflow">if</span> (gblerr != 0) {</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error (<span class="stringliteral">&quot;Some process failed to insert an entry.&quot;</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Tell the sparse matrix that we are done adding entries to it.</span></div>
<div class="line">  gblerr = A.FillComplete ();</div>
<div class="line">  <span class="keywordflow">if</span> (gblerr != 0) {</div>
<div class="line">    std::ostringstream os;</div>
<div class="line">    os &lt;&lt; <span class="stringliteral">&quot;A.FillComplete() failed with error code &quot;</span> &lt;&lt; gblerr &lt;&lt; <span class="stringliteral">&quot;.&quot;</span>;</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error (os.str ());</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of iterations</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> niters = 500;</div>
<div class="line">  <span class="comment">// Desired (absolute) residual tolerance</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance = 1.0e-2;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Run the power method and report the result.</span></div>
<div class="line">  <span class="keywordtype">double</span> lambda = powerMethod (A, niters, tolerance);</div>
<div class="line">  <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;Estimated max eigenvalue: &quot;</span> &lt;&lt; lambda &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Now we&#39;re going to change values in the sparse matrix and run the</span></div>
<div class="line">  <span class="comment">// power method again.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Increase diagonal dominance</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;Increasing magnitude of A(0,0), solving again&quot;</span> &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (A.RowMap ().MyGID (0)) {</div>
<div class="line">    <span class="comment">// Get a copy of the row with with global index 0.  Modify the</span></div>
<div class="line">    <span class="comment">// diagonal entry of that row.  Submit the modified values to the</span></div>
<div class="line">    <span class="comment">// matrix.</span></div>
<div class="line">    <span class="keyword">const</span> global_ordinal_type gidOfFirstRow = 0;</div>
<div class="line">    <span class="comment">// Since 0 is a GID in the row Map on the calling process,</span></div>
<div class="line">    <span class="comment">// lidOfFirstRow is a valid LID of that GID in the row Map.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> lidOfFirstRow = A.RowMap ().LID (gidOfFirstRow);</div>
<div class="line">    <span class="keywordtype">int</span> numEntriesInRow = A.NumMyEntries (lidOfFirstRow);</div>
<div class="line">    <span class="keywordtype">double</span>* rowvals = <span class="keyword">new</span> <span class="keywordtype">double</span> [numEntriesInRow];</div>
<div class="line">    global_ordinal_type* rowinds = <span class="keyword">new</span> global_ordinal_type [numEntriesInRow];</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Get a copy of the entries and column indices of global row 0.</span></div>
<div class="line">    <span class="comment">// Get global column indices, so that we can figure out which</span></div>
<div class="line">    <span class="comment">// entry corresponds to the diagonal entry in this row.  (The row</span></div>
<div class="line">    <span class="comment">// Map and column Map of the matrix may differ, so their local</span></div>
<div class="line">    <span class="comment">// indices may not be the same.)</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Note that it&#39;s legal (though we don&#39;t exercise it in this</span></div>
<div class="line">    <span class="comment">// example) for the row Map of the sparse matrix not to be one to</span></div>
<div class="line">    <span class="comment">// one.  This means that more than one process might own entries</span></div>
<div class="line">    <span class="comment">// in the first row.  In general, multiple processes might own the</span></div>
<div class="line">    <span class="comment">// (0,0) entry, so that the global A(0,0) value is really the sum</span></div>
<div class="line">    <span class="comment">// of all processes&#39; values for that entry.  However, scaling the</span></div>
<div class="line">    <span class="comment">// entry by a constant factor distributes across that sum, so it&#39;s</span></div>
<div class="line">    <span class="comment">// OK to do so.</span></div>
<div class="line">    <span class="keywordflow">if</span> (lclerr == 0) {</div>
<div class="line">      lclerr = A.ExtractGlobalRowCopy (gidOfFirstRow,</div>
<div class="line">                                       numEntriesInRow, numEntriesInRow,</div>
<div class="line">                                       rowvals, rowinds);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (lclerr == 0) { <span class="comment">// no error</span></div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numEntriesInRow; ++i) {</div>
<div class="line">        <span class="keywordflow">if</span> (rowinds[i] == gidOfFirstRow) {</div>
<div class="line">          <span class="comment">// We have found the diagonal entry; modify it.</span></div>
<div class="line">          rowvals[i] *= 10.0;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// &quot;Replace global values&quot; means modify the values, but not the</span></div>
<div class="line">      <span class="comment">// structure of the sparse matrix.  If the specified columns</span></div>
<div class="line">      <span class="comment">// aren&#39;t already populated in this row on this process, then this</span></div>
<div class="line">      <span class="comment">// method fails and returns nonzero.  Since we have already called</span></div>
<div class="line">      <span class="comment">// FillComplete() on this matrix, we may not modify its graph</span></div>
<div class="line">      <span class="comment">// structure any more.</span></div>
<div class="line">      <span class="keywordflow">if</span> (lclerr == 0) {</div>
<div class="line">        lclerr = A.ReplaceGlobalValues (gidOfFirstRow, numEntriesInRow,</div>
<div class="line">                                        rowvals, rowinds);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (rowvals != NULL) {</div>
<div class="line">      <span class="keyword">delete</span> [] rowvals;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (rowinds != NULL) {</div>
<div class="line">      <span class="keyword">delete</span> [] rowinds;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If the owning process(es) of global row 0 failed to replace the</span></div>
<div class="line">  <span class="comment">// one entry, throw.</span></div>
<div class="line">  gblerr = 0;</div>
<div class="line">  (void) comm.<a class="code hl_function" href="classEpetra__SerialComm.html#ac1699aa99f819e95ddd65a3c2ff4a5c9">MaxAll</a> (&amp;lclerr, &amp;gblerr, 1);</div>
<div class="line">  <span class="keywordflow">if</span> (gblerr != 0) {</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error (<span class="stringliteral">&quot;One of the owning process(es) of global &quot;</span></div>
<div class="line">                              <span class="stringliteral">&quot;row 0 failed to replace an entry.&quot;</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Run the power method again.</span></div>
<div class="line">  lambda = powerMethod (A, niters, tolerance);</div>
<div class="line">  <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;Estimated max eigenvalue: &quot;</span> &lt;&lt; lambda &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// This tells the Trilinos test framework that the test passed.</span></div>
<div class="line">  <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;End Result: TEST PASSED&quot;</span> &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef HAVE_MPI</span></div>
<div class="line">  (void) MPI_Finalize ();</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// HAVE_MPI</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span></div>
<div class="line">powerMethod (<span class="keyword">const</span> <a class="code hl_class" href="classEpetra__Operator.html">Epetra_Operator</a>&amp; A,</div>
<div class="line">             <span class="keyword">const</span> <span class="keywordtype">int</span> niters,</div>
<div class="line">             <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using </span>std::cout;</div>
<div class="line">  <span class="keyword">using </span>std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// An Operator doesn&#39;t have a Comm, but its domain Map does.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classEpetra__Comm.html">Epetra_Comm</a>&amp; comm = A.OperatorDomainMap ().Comm ();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> myRank = comm.<a class="code hl_function" href="classEpetra__Comm.html#a60135f8b72809635695dd2b8f539da6b">MyPID</a> ();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create three vectors for iterating the power method.  Since the</span></div>
<div class="line">  <span class="comment">// power method computes z = A*q, q should be in the domain of A and</span></div>
<div class="line">  <span class="comment">// z should be in the range.  (Obviously the power method requires</span></div>
<div class="line">  <span class="comment">// that the domain and the range are equal, but it&#39;s a good idea to</span></div>
<div class="line">  <span class="comment">// get into the habit of thinking whether a particular vector</span></div>
<div class="line">  <span class="comment">// &quot;belongs&quot; in the domain or range of the matrix.)  The residual</span></div>
<div class="line">  <span class="comment">// vector &quot;resid&quot; is of course in the range of A.</span></div>
<div class="line">  <a class="code hl_class" href="classEpetra__Vector.html">Epetra_Vector</a> q (A.OperatorDomainMap ());</div>
<div class="line">  <a class="code hl_class" href="classEpetra__Vector.html">Epetra_Vector</a> z (A.OperatorRangeMap ());</div>
<div class="line">  <a class="code hl_class" href="classEpetra__Vector.html">Epetra_Vector</a> resid (A.OperatorRangeMap ());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Local error code for use below.</span></div>
<div class="line">  <span class="keywordtype">int</span> lclerr = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Fill the iteration vector z with random numbers to start.  Don&#39;t</span></div>
<div class="line">  <span class="comment">// have grand expectations about the quality of our pseudorandom</span></div>
<div class="line">  <span class="comment">// number generator; this is usually good enough for eigensolvers.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// If this call fails, just let the code below finish before trying</span></div>
<div class="line">  <span class="comment">// to catch the error globally.  Ditto for other calls below.</span></div>
<div class="line">  lclerr = z.Random ();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// lambda: the current approximation of the eigenvalue of maximum magnitude.</span></div>
<div class="line">  <span class="comment">// normz: the 2-norm of the current iteration vector z.</span></div>
<div class="line">  <span class="comment">// residual: the 2-norm of the current residual vector &quot;resid&quot;</span></div>
<div class="line">  <span class="keywordtype">double</span> lambda = 0.0;</div>
<div class="line">  <span class="keywordtype">double</span> normz = 0.0;</div>
<div class="line">  <span class="keywordtype">double</span> residual = 0.0;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> zero = 0.0;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> one = 1.0;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// How often to report progress in the power method.  Reporting</span></div>
<div class="line">  <span class="comment">// progress requires computing a residual which can be expensive.</span></div>
<div class="line">  <span class="comment">// However, if you don&#39;t compute the residual often enough, you</span></div>
<div class="line">  <span class="comment">// might keep iterating even after you&#39;ve converged.</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> reportFrequency = 10;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Do the power method, until the method has converged or the</span></div>
<div class="line">  <span class="comment">// maximum iteration count has been reached.</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iter = 0; iter &lt; niters; ++iter) {</div>
<div class="line">    <span class="comment">// If you feel confident that your code is correct, you may omit</span></div>
<div class="line">    <span class="comment">// everything having to do with lclerr, and just write the following:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// z.Norm2 (&amp;normz);         // Compute the 2-norm of z</span></div>
<div class="line">    <span class="comment">// q.Scale (one / normz, z); // q := z / normz</span></div>
<div class="line">    <span class="comment">// A.Apply (q, z);           // z := A * q</span></div>
<div class="line">    <span class="comment">// q.Dot (z, &amp;lambda);       // Approx. max eigenvalue</span></div>
<div class="line"> </div>
<div class="line">    lclerr = (lclerr == 0) ? z.Norm2 (&amp;normz) : lclerr;</div>
<div class="line">    lclerr = (lclerr == 0) ? q.Scale (one / normz, z) : lclerr;</div>
<div class="line">    lclerr = (lclerr == 0) ? A.Apply (q, z) : lclerr;</div>
<div class="line">    lclerr = (lclerr == 0) ? q.Dot (z, &amp;lambda) : lclerr;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Compute and report the residual norm every reportFrequency</span></div>
<div class="line">    <span class="comment">// iterations, or if we&#39;ve reached the maximum iteration count.</span></div>
<div class="line">    <span class="keywordflow">if</span> (iter % reportFrequency == 0 || iter + 1 == niters) {</div>
<div class="line">      <span class="comment">// If you feel confident that your code is correct, you may omit</span></div>
<div class="line">      <span class="comment">// everything having to do with lclerr, and just write the</span></div>
<div class="line">      <span class="comment">// following:</span></div>
<div class="line">      <span class="comment">//</span></div>
<div class="line">      <span class="comment">// resid.Update (one, z, -lambda, q, zero); // z := A*q - lambda*q</span></div>
<div class="line">      <span class="comment">// resid.Norm2 (&amp;residual); // 2-norm of the residual vector</span></div>
<div class="line"> </div>
<div class="line">      lclerr = (lclerr == 0) ? resid.Update (one, z, -lambda, q, zero) : lclerr;</div>
<div class="line">      lclerr = (lclerr == 0) ? resid.Norm2 (&amp;residual) : lclerr;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Iteration &quot;</span> &lt;&lt; iter &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; endl</div>
<div class="line">             &lt;&lt; <span class="stringliteral">&quot;- lambda = &quot;</span> &lt;&lt; lambda &lt;&lt; endl</div>
<div class="line">             &lt;&lt; <span class="stringliteral">&quot;- ||A*q - lambda*q||_2 = &quot;</span> &lt;&lt; residual &lt;&lt; endl;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (residual &lt; tolerance) {</div>
<div class="line">      <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Converged after &quot;</span> &lt;&lt; iter &lt;&lt; <span class="stringliteral">&quot; iterations&quot;</span> &lt;&lt; endl;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (iter + 1 == niters) {</div>
<div class="line">      <span class="keywordflow">if</span> (myRank == 0) {</div>
<div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Failed to converge after &quot;</span> &lt;&lt; niters &lt;&lt; <span class="stringliteral">&quot; iterations&quot;</span> &lt;&lt; endl;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If any process failed to insert at least one entry, throw.</span></div>
<div class="line">  <span class="keywordtype">int</span> gblerr = 0;</div>
<div class="line">  (void) comm.<a class="code hl_function" href="classEpetra__Comm.html#a04039ddd27c1aae04104d62992a58787">MaxAll</a> (&amp;lclerr, &amp;gblerr, 1);</div>
<div class="line">  <span class="keywordflow">if</span> (gblerr != 0) {</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error (<span class="stringliteral">&quot;The power method failed in some way.&quot;</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> lambda;</div>
<div class="line">}</div>
<div class="ttc" id="aEpetra__DataAccess_8h_html_ad1a985e79f94ad63030815a0d7d90928aad81934e8f3b9399beea932f0b0e57d8"><div class="ttname"><a href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928aad81934e8f3b9399beea932f0b0e57d8">Copy</a></div><div class="ttdeci">@ Copy</div><div class="ttdef"><b>Definition</b> Epetra_DataAccess.h:63</div></div>
<div class="ttc" id="aclassEpetra__Comm_html"><div class="ttname"><a href="classEpetra__Comm.html">Epetra_Comm</a></div><div class="ttdoc">Epetra_Comm: The Epetra Communication Abstract Base Class.</div><div class="ttdef"><b>Definition</b> Epetra_Comm.h:81</div></div>
<div class="ttc" id="aclassEpetra__Comm_html_a04039ddd27c1aae04104d62992a58787"><div class="ttname"><a href="classEpetra__Comm.html#a04039ddd27c1aae04104d62992a58787">Epetra_Comm::MaxAll</a></div><div class="ttdeci">virtual int MaxAll(double *PartialMaxs, double *GlobalMaxs, int Count) const =0</div><div class="ttdoc">Epetra_Comm Global Max function.</div></div>
<div class="ttc" id="aclassEpetra__Comm_html_a60135f8b72809635695dd2b8f539da6b"><div class="ttname"><a href="classEpetra__Comm.html#a60135f8b72809635695dd2b8f539da6b">Epetra_Comm::MyPID</a></div><div class="ttdeci">virtual int MyPID() const =0</div><div class="ttdoc">Return my process ID.</div></div>
<div class="ttc" id="aclassEpetra__CrsMatrix_html"><div class="ttname"><a href="classEpetra__CrsMatrix.html">Epetra_CrsMatrix</a></div><div class="ttdoc">Epetra_CrsMatrix: A class for constructing and using real-valued double-precision sparse compressed r...</div><div class="ttdef"><b>Definition</b> Epetra_CrsMatrix.h:181</div></div>
<div class="ttc" id="aclassEpetra__Map_html"><div class="ttname"><a href="classEpetra__Map.html">Epetra_Map</a></div><div class="ttdoc">Epetra_Map: A class for partitioning vectors and matrices.</div><div class="ttdef"><b>Definition</b> Epetra_Map.h:127</div></div>
<div class="ttc" id="aclassEpetra__MpiComm_html"><div class="ttname"><a href="classEpetra__MpiComm.html">Epetra_MpiComm</a></div><div class="ttdoc">Epetra_MpiComm: The Epetra MPI Communication Class.</div><div class="ttdef"><b>Definition</b> Epetra_MpiComm.h:72</div></div>
<div class="ttc" id="aclassEpetra__Operator_html"><div class="ttname"><a href="classEpetra__Operator.html">Epetra_Operator</a></div><div class="ttdoc">Epetra_Operator: A pure virtual class for using real-valued double-precision operators.</div><div class="ttdef"><b>Definition</b> Epetra_Operator.h:68</div></div>
<div class="ttc" id="aclassEpetra__SerialComm_html"><div class="ttname"><a href="classEpetra__SerialComm.html">Epetra_SerialComm</a></div><div class="ttdoc">Epetra_SerialComm: The Epetra Serial Communication Class.</div><div class="ttdef"><b>Definition</b> Epetra_SerialComm.h:69</div></div>
<div class="ttc" id="aclassEpetra__SerialComm_html_a237a6407573dea22f0366936d158486d"><div class="ttname"><a href="classEpetra__SerialComm.html#a237a6407573dea22f0366936d158486d">Epetra_SerialComm::MyPID</a></div><div class="ttdeci">int MyPID() const</div><div class="ttdoc">Return my process ID.</div><div class="ttdef"><b>Definition</b> Epetra_SerialComm.h:440</div></div>
<div class="ttc" id="aclassEpetra__SerialComm_html_ac1699aa99f819e95ddd65a3c2ff4a5c9"><div class="ttname"><a href="classEpetra__SerialComm.html#ac1699aa99f819e95ddd65a3c2ff4a5c9">Epetra_SerialComm::MaxAll</a></div><div class="ttdeci">int MaxAll(double *PartialMaxs, double *GlobalMaxs, int Count) const</div><div class="ttdoc">Epetra_SerialComm Global Max function.</div></div>
<div class="ttc" id="aclassEpetra__SerialComm_html_af55220ff6540694c810aa9f2b3ec146f"><div class="ttname"><a href="classEpetra__SerialComm.html#af55220ff6540694c810aa9f2b3ec146f">Epetra_SerialComm::NumProc</a></div><div class="ttdeci">int NumProc() const</div><div class="ttdoc">Returns total number of processes (always returns 1 for SerialComm).</div><div class="ttdef"><b>Definition</b> Epetra_SerialComm.h:443</div></div>
<div class="ttc" id="aclassEpetra__Vector_html"><div class="ttname"><a href="classEpetra__Vector.html">Epetra_Vector</a></div><div class="ttdoc">Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.</div><div class="ttdef"><b>Definition</b> Epetra_Vector.h:150</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
