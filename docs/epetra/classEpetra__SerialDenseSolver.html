<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Epetra: Epetra_SerialDenseSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Epetra<span id="projectnumber">&#160;Development</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classEpetra__SerialDenseSolver-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Epetra_SerialDenseSolver Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classEpetra__SerialDenseSolver.html" title="Epetra_SerialDenseSolver: A class for solving dense linear problems.">Epetra_SerialDenseSolver</a>: A class for solving dense linear problems.  
 <a href="classEpetra__SerialDenseSolver.html#details">More...</a></p>

<p><code>#include &lt;Epetra_SerialDenseSolver.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Epetra_SerialDenseSolver:</div>
<div class="dyncontent">
<div class="center"><img src="classEpetra__SerialDenseSolver__inherit__graph.gif" border="0" usemap="#aEpetra__SerialDenseSolver_inherit__map" alt="Inheritance graph"/></div>
<map name="aEpetra__SerialDenseSolver_inherit__map" id="aEpetra__SerialDenseSolver_inherit__map">
<area shape="rect" title="Epetra_SerialDenseSolver: A class for solving dense linear problems." alt="" coords="207,79,397,104"/>
<area shape="rect" href="classEpetra__SerialSpdDenseSolver.html" title="Epetra_SerialSpdDenseSolver: A class for constructing and using symmetric positive definite dense mat..." alt="" coords="195,152,409,177"/>
<area shape="poly" title=" " alt="" coords="305,118,305,152,299,152,299,118"/>
<area shape="rect" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes." alt="" coords="5,5,156,31"/>
<area shape="poly" title=" " alt="" coords="130,32,267,76,265,81,128,37"/>
<area shape="rect" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class." alt="" coords="180,5,285,31"/>
<area shape="poly" title=" " alt="" coords="255,39,293,77,289,80,252,43"/>
<area shape="rect" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class." alt="" coords="310,5,433,31"/>
<area shape="poly" title=" " alt="" coords="352,43,315,80,311,77,349,39"/>
<area shape="rect" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class." alt="" coords="457,5,571,31"/>
<area shape="poly" title=" " alt="" coords="468,37,337,81,335,76,466,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Epetra_SerialDenseSolver:</div>
<div class="dyncontent">
<div class="center"><img src="classEpetra__SerialDenseSolver__coll__graph.gif" border="0" usemap="#aEpetra__SerialDenseSolver_coll__map" alt="Collaboration graph"/></div>
<map name="aEpetra__SerialDenseSolver_coll__map" id="aEpetra__SerialDenseSolver_coll__map">
<area shape="rect" title="Epetra_SerialDenseSolver: A class for solving dense linear problems." alt="" coords="340,300,531,325"/>
<area shape="rect" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes." alt="" coords="5,93,156,119"/>
<area shape="poly" title=" " alt="" coords="97,129,119,161,148,191,185,221,218,240,298,273,378,297,377,303,296,279,215,245,182,226,144,195,115,164,92,132"/>
<area shape="rect" href="classEpetra__SerialDenseMatrix.html" title="Epetra_SerialDenseMatrix: A class for constructing and using real double precision general dense matr..." alt="" coords="159,168,349,193"/>
<area shape="poly" title=" " alt="" coords="122,122,228,166,226,170,120,126"/>
<area shape="rect" href="classEpetra__Flops.html" title="Epetra_Flops: The Epetra Floating Point Operations Class." alt="" coords="27,5,134,31"/>
<area shape="poly" title=" " alt="" coords="83,45,83,93,78,93,78,45"/>
<area shape="rect" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class." alt="" coords="548,93,653,119"/>
<area shape="poly" title=" " alt="" coords="594,133,559,203,534,242,502,278,485,292,465,302,463,298,482,287,499,274,529,239,555,200,589,131"/>
<area shape="poly" title=" " alt="" coords="535,124,309,171,308,165,534,119"/>
<area shape="rect" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class." alt="" coords="374,168,497,193"/>
<area shape="poly" title=" " alt="" coords="438,207,438,300,433,300,433,207"/>
<area shape="rect" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class." alt="" coords="411,93,524,119"/>
<area shape="poly" title=" " alt="" coords="490,128,508,158,513,176,511,194,499,226,481,256,448,301,444,298,477,254,494,224,506,193,507,176,503,160,486,131"/>
<area shape="poly" title=" " alt="" coords="421,126,288,171,287,165,420,121"/>
<area shape="poly" title=" " alt="" coords="281,200,381,274,418,298,415,302,378,278,277,204"/>
<area shape="rect" href="classEpetra__SerialDenseOperator.html" title="Epetra_SerialDenseOperator: A pure virtual class for using real&#45;valued double&#45;precision operators." alt="" coords="180,93,387,119"/>
<area shape="poly" title=" " alt="" coords="276,133,261,169,256,167,271,131"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructor/Destructor Methods</div></td></tr>
<tr class="memitem:ad57922a39cdc1b83270d0afd54743d65" id="r_ad57922a39cdc1b83270d0afd54743d65"><td class="memItemLeft" align="right" valign="top"><a id="ad57922a39cdc1b83270d0afd54743d65" name="ad57922a39cdc1b83270d0afd54743d65"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_SerialDenseSolver</b> ()</td></tr>
<tr class="memdesc:ad57922a39cdc1b83270d0afd54743d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor; matrix should be set using <a class="el" href="classEpetra__SerialDenseSolver.html#a463db09d67b55f002d09b190233782f7" title="Sets the pointers for coefficient matrix.">SetMatrix()</a>, LHS and RHS set with <a class="el" href="classEpetra__SerialDenseSolver.html#afe1e21cd4c5556318154c30d8ae523eb" title="Sets the pointers for left and right hand side vector(s).">SetVectors()</a>. <br /></td></tr>
<tr class="separator:ad57922a39cdc1b83270d0afd54743d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3f77beac49977769a72b5a3ecc8242" id="r_a3c3f77beac49977769a72b5a3ecc8242"><td class="memItemLeft" align="right" valign="top"><a id="a3c3f77beac49977769a72b5a3ecc8242" name="a3c3f77beac49977769a72b5a3ecc8242"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_SerialDenseSolver</b> ()</td></tr>
<tr class="memdesc:a3c3f77beac49977769a72b5a3ecc8242"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__SerialDenseSolver.html" title="Epetra_SerialDenseSolver: A class for solving dense linear problems.">Epetra_SerialDenseSolver</a> destructor. <br /></td></tr>
<tr class="separator:a3c3f77beac49977769a72b5a3ecc8242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Set Methods</div></td></tr>
<tr class="memitem:a463db09d67b55f002d09b190233782f7" id="r_a463db09d67b55f002d09b190233782f7"><td class="memItemLeft" align="right" valign="top"><a id="a463db09d67b55f002d09b190233782f7" name="a463db09d67b55f002d09b190233782f7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>SetMatrix</b> (<a class="el" href="classEpetra__SerialDenseMatrix.html">Epetra_SerialDenseMatrix</a> &amp;<a class="el" href="classEpetra__SerialDenseSolver.html#a1cce48c6032f17fe566bac7a24dc3585">A</a>)</td></tr>
<tr class="memdesc:a463db09d67b55f002d09b190233782f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pointers for coefficient matrix. <br /></td></tr>
<tr class="separator:a463db09d67b55f002d09b190233782f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1e21cd4c5556318154c30d8ae523eb" id="r_afe1e21cd4c5556318154c30d8ae523eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__SerialDenseSolver.html#afe1e21cd4c5556318154c30d8ae523eb">SetVectors</a> (<a class="el" href="classEpetra__SerialDenseMatrix.html">Epetra_SerialDenseMatrix</a> &amp;<a class="el" href="classEpetra__SerialDenseSolver.html#a626e1851dbf26e05e2a74d580798208e">X</a>, <a class="el" href="classEpetra__SerialDenseMatrix.html">Epetra_SerialDenseMatrix</a> &amp;<a class="el" href="classEpetra__SerialDenseSolver.html#ae1c7e8b548d0d40ff626b44d6c1df77c">B</a>)</td></tr>
<tr class="memdesc:afe1e21cd4c5556318154c30d8ae523eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pointers for left and right hand side vector(s).  <br /></td></tr>
<tr class="separator:afe1e21cd4c5556318154c30d8ae523eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Strategy modifying Methods</div></td></tr>
<tr class="memitem:afdcdce6b9d0a5eabbb3f2646675beb64" id="r_afdcdce6b9d0a5eabbb3f2646675beb64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__SerialDenseSolver.html#afdcdce6b9d0a5eabbb3f2646675beb64">FactorWithEquilibration</a> (bool Flag)</td></tr>
<tr class="memdesc:afdcdce6b9d0a5eabbb3f2646675beb64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes equilibration to be called just before the matrix factorization as part of the call to Factor.  <br /></td></tr>
<tr class="separator:afdcdce6b9d0a5eabbb3f2646675beb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778bde814992f93ecc6db73d93c8d223" id="r_a778bde814992f93ecc6db73d93c8d223"><td class="memItemLeft" align="right" valign="top"><a id="a778bde814992f93ecc6db73d93c8d223" name="a778bde814992f93ecc6db73d93c8d223"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SolveWithTranspose</b> (bool Flag)</td></tr>
<tr class="memdesc:a778bde814992f93ecc6db73d93c8d223"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Flag is true, causes all subsequent function calls to work with the transpose of <em>this</em> matrix, otherwise not. <br /></td></tr>
<tr class="separator:a778bde814992f93ecc6db73d93c8d223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4405659559ec0099ed673bb0530dde7c" id="r_a4405659559ec0099ed673bb0530dde7c"><td class="memItemLeft" align="right" valign="top"><a id="a4405659559ec0099ed673bb0530dde7c" name="a4405659559ec0099ed673bb0530dde7c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SolveToRefinedSolution</b> (bool Flag)</td></tr>
<tr class="memdesc:a4405659559ec0099ed673bb0530dde7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes all solves to compute solution to best ability using iterative refinement. <br /></td></tr>
<tr class="separator:a4405659559ec0099ed673bb0530dde7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686f12671fd1fae79a58b71324d4fc78" id="r_a686f12671fd1fae79a58b71324d4fc78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__SerialDenseSolver.html#a686f12671fd1fae79a58b71324d4fc78">EstimateSolutionErrors</a> (bool Flag)</td></tr>
<tr class="memdesc:a686f12671fd1fae79a58b71324d4fc78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes all solves to estimate the forward and backward solution error.  <br /></td></tr>
<tr class="separator:a686f12671fd1fae79a58b71324d4fc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Factor/Solve/Invert Methods</div></td></tr>
<tr class="memitem:a045cb0339c25fa35a6c0012a5cdea53a" id="r_a045cb0339c25fa35a6c0012a5cdea53a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__SerialDenseSolver.html#a045cb0339c25fa35a6c0012a5cdea53a">Factor</a> (void)</td></tr>
<tr class="memdesc:a045cb0339c25fa35a6c0012a5cdea53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the in-place LU factorization of the matrix using the LAPACK routine <em>DGETRF</em>.  <br /></td></tr>
<tr class="separator:a045cb0339c25fa35a6c0012a5cdea53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ecf069e7e65a6c996add51524902eb" id="r_a62ecf069e7e65a6c996add51524902eb"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__SerialDenseSolver.html#a62ecf069e7e65a6c996add51524902eb">Solve</a> (void)</td></tr>
<tr class="memdesc:a62ecf069e7e65a6c996add51524902eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the solution X to AX = B for the <em>this</em> matrix and the B provided to <a class="el" href="classEpetra__SerialDenseSolver.html#afe1e21cd4c5556318154c30d8ae523eb" title="Sets the pointers for left and right hand side vector(s).">SetVectors()</a>..  <br /></td></tr>
<tr class="separator:a62ecf069e7e65a6c996add51524902eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ea2457127bc5f26d3088962ae48a3f" id="r_a86ea2457127bc5f26d3088962ae48a3f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__SerialDenseSolver.html#a86ea2457127bc5f26d3088962ae48a3f">Invert</a> (void)</td></tr>
<tr class="memdesc:a86ea2457127bc5f26d3088962ae48a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the <em>this</em> matrix.  <br /></td></tr>
<tr class="separator:a86ea2457127bc5f26d3088962ae48a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab065e5331fc78f5998e393a7e057d764" id="r_ab065e5331fc78f5998e393a7e057d764"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__SerialDenseSolver.html#ab065e5331fc78f5998e393a7e057d764">ComputeEquilibrateScaling</a> (void)</td></tr>
<tr class="memdesc:ab065e5331fc78f5998e393a7e057d764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the scaling vector S(i) = 1/sqrt(A(i,i)) of the <em>this</em> matrix.  <br /></td></tr>
<tr class="separator:ab065e5331fc78f5998e393a7e057d764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d4ad5af1bf4e0dd7463676bbfdf004" id="r_a24d4ad5af1bf4e0dd7463676bbfdf004"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__SerialDenseSolver.html#a24d4ad5af1bf4e0dd7463676bbfdf004">EquilibrateMatrix</a> (void)</td></tr>
<tr class="memdesc:a24d4ad5af1bf4e0dd7463676bbfdf004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equilibrates the <em>this</em> matrix.  <br /></td></tr>
<tr class="separator:a24d4ad5af1bf4e0dd7463676bbfdf004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251e7d0664d55ad25376adf81a12e41a" id="r_a251e7d0664d55ad25376adf81a12e41a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__SerialDenseSolver.html#a251e7d0664d55ad25376adf81a12e41a">EquilibrateRHS</a> (void)</td></tr>
<tr class="memdesc:a251e7d0664d55ad25376adf81a12e41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equilibrates the current RHS.  <br /></td></tr>
<tr class="separator:a251e7d0664d55ad25376adf81a12e41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209dd8f5f17fd31fa1b1fb68ce460949" id="r_a209dd8f5f17fd31fa1b1fb68ce460949"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__SerialDenseSolver.html#a209dd8f5f17fd31fa1b1fb68ce460949">ApplyRefinement</a> (void)</td></tr>
<tr class="memdesc:a209dd8f5f17fd31fa1b1fb68ce460949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply Iterative Refinement.  <br /></td></tr>
<tr class="separator:a209dd8f5f17fd31fa1b1fb68ce460949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f21e67939c7f1f4e63a66e1221cdf3" id="r_a83f21e67939c7f1f4e63a66e1221cdf3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__SerialDenseSolver.html#a83f21e67939c7f1f4e63a66e1221cdf3">UnequilibrateLHS</a> (void)</td></tr>
<tr class="memdesc:a83f21e67939c7f1f4e63a66e1221cdf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unscales the solution vectors if equilibration was used to solve the system.  <br /></td></tr>
<tr class="separator:a83f21e67939c7f1f4e63a66e1221cdf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5c288ff50d1c4bd4b0dbcfe49392f1" id="r_a3d5c288ff50d1c4bd4b0dbcfe49392f1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__SerialDenseSolver.html#a3d5c288ff50d1c4bd4b0dbcfe49392f1">ReciprocalConditionEstimate</a> (double &amp;Value)</td></tr>
<tr class="memdesc:a3d5c288ff50d1c4bd4b0dbcfe49392f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reciprocal of the 1-norm condition number of the <em>this</em> matrix.  <br /></td></tr>
<tr class="separator:a3d5c288ff50d1c4bd4b0dbcfe49392f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Query methods</div></td></tr>
<tr class="memitem:a4fad947b197aee9b59afa4f5269dd690" id="r_a4fad947b197aee9b59afa4f5269dd690"><td class="memItemLeft" align="right" valign="top"><a id="a4fad947b197aee9b59afa4f5269dd690" name="a4fad947b197aee9b59afa4f5269dd690"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Transpose</b> ()</td></tr>
<tr class="memdesc:a4fad947b197aee9b59afa4f5269dd690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if transpose of <em>this</em> matrix has and will be used. <br /></td></tr>
<tr class="separator:a4fad947b197aee9b59afa4f5269dd690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb233a5bf41eaf162117bbc738ad2b7" id="r_acdb233a5bf41eaf162117bbc738ad2b7"><td class="memItemLeft" align="right" valign="top"><a id="acdb233a5bf41eaf162117bbc738ad2b7" name="acdb233a5bf41eaf162117bbc738ad2b7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Factored</b> ()</td></tr>
<tr class="memdesc:acdb233a5bf41eaf162117bbc738ad2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if matrix is factored (factor available via <a class="el" href="classEpetra__SerialDenseSolver.html#a1e1217f34d9d0c35544641e68e95f17d" title="Returns pointer to the factored matrix (may be the same as A() if factorization done in place).">AF()</a> and <a class="el" href="classEpetra__SerialDenseSolver.html#a1231b3048e25c2cc8524a1a78e47e5e6" title="Returns the leading dimension of the factored matrix.">LDAF()</a>). <br /></td></tr>
<tr class="separator:acdb233a5bf41eaf162117bbc738ad2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826823776bd79fc2dd93eabbb3e5fdb9" id="r_a826823776bd79fc2dd93eabbb3e5fdb9"><td class="memItemLeft" align="right" valign="top"><a id="a826823776bd79fc2dd93eabbb3e5fdb9" name="a826823776bd79fc2dd93eabbb3e5fdb9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>A_Equilibrated</b> ()</td></tr>
<tr class="memdesc:a826823776bd79fc2dd93eabbb3e5fdb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if factor is equilibrated (factor available via <a class="el" href="classEpetra__SerialDenseSolver.html#a1e1217f34d9d0c35544641e68e95f17d" title="Returns pointer to the factored matrix (may be the same as A() if factorization done in place).">AF()</a> and <a class="el" href="classEpetra__SerialDenseSolver.html#a1231b3048e25c2cc8524a1a78e47e5e6" title="Returns the leading dimension of the factored matrix.">LDAF()</a>). <br /></td></tr>
<tr class="separator:a826823776bd79fc2dd93eabbb3e5fdb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb5eaf4a3a0dc83634e799d8e9124b2" id="r_aeeb5eaf4a3a0dc83634e799d8e9124b2"><td class="memItemLeft" align="right" valign="top"><a id="aeeb5eaf4a3a0dc83634e799d8e9124b2" name="aeeb5eaf4a3a0dc83634e799d8e9124b2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>B_Equilibrated</b> ()</td></tr>
<tr class="memdesc:aeeb5eaf4a3a0dc83634e799d8e9124b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if RHS is equilibrated (RHS available via <a class="el" href="classEpetra__SerialDenseSolver.html#ae1c7e8b548d0d40ff626b44d6c1df77c" title="Returns pointer to current RHS.">B()</a> and <a class="el" href="classEpetra__SerialDenseSolver.html#a1797c90abd27950b58231c14a9be1100" title="Returns the leading dimension of the RHS.">LDB()</a>). <br /></td></tr>
<tr class="separator:aeeb5eaf4a3a0dc83634e799d8e9124b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f4036471925643a18538f6e2e663d7" id="r_ab3f4036471925643a18538f6e2e663d7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__SerialDenseSolver.html#ab3f4036471925643a18538f6e2e663d7">ShouldEquilibrate</a> ()</td></tr>
<tr class="memdesc:ab3f4036471925643a18538f6e2e663d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the LAPACK general rules for equilibration suggest you should equilibrate the system.  <br /></td></tr>
<tr class="separator:ab3f4036471925643a18538f6e2e663d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a0d862dafa3921329964c02bd9c596" id="r_a65a0d862dafa3921329964c02bd9c596"><td class="memItemLeft" align="right" valign="top"><a id="a65a0d862dafa3921329964c02bd9c596" name="a65a0d862dafa3921329964c02bd9c596"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>SolutionErrorsEstimated</b> ()</td></tr>
<tr class="memdesc:a65a0d862dafa3921329964c02bd9c596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if forward and backward error estimated have been computed (available via <a class="el" href="classEpetra__SerialDenseSolver.html#a9a9179c0e5e26d4d64eae884c0414bf1" title="Returns a pointer to the forward error estimates computed by LAPACK.">FERR()</a> and <a class="el" href="classEpetra__SerialDenseSolver.html#af4bc8ca9e4d861641f75c5eaa09f3b97" title="Returns a pointer to the backward error estimates computed by LAPACK.">BERR()</a>). <br /></td></tr>
<tr class="separator:a65a0d862dafa3921329964c02bd9c596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec8cfbb9961ab0103b7644fc0fbfac7" id="r_acec8cfbb9961ab0103b7644fc0fbfac7"><td class="memItemLeft" align="right" valign="top"><a id="acec8cfbb9961ab0103b7644fc0fbfac7" name="acec8cfbb9961ab0103b7644fc0fbfac7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Inverted</b> ()</td></tr>
<tr class="memdesc:acec8cfbb9961ab0103b7644fc0fbfac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if matrix inverse has been computed (inverse available via <a class="el" href="classEpetra__SerialDenseSolver.html#a1e1217f34d9d0c35544641e68e95f17d" title="Returns pointer to the factored matrix (may be the same as A() if factorization done in place).">AF()</a> and <a class="el" href="classEpetra__SerialDenseSolver.html#a1231b3048e25c2cc8524a1a78e47e5e6" title="Returns the leading dimension of the factored matrix.">LDAF()</a>). <br /></td></tr>
<tr class="separator:acec8cfbb9961ab0103b7644fc0fbfac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa8747386909cb8e32971f7458401c9" id="r_a0aa8747386909cb8e32971f7458401c9"><td class="memItemLeft" align="right" valign="top"><a id="a0aa8747386909cb8e32971f7458401c9" name="a0aa8747386909cb8e32971f7458401c9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ReciprocalConditionEstimated</b> ()</td></tr>
<tr class="memdesc:a0aa8747386909cb8e32971f7458401c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the condition number of the <em>this</em> matrix has been computed (value available via <a class="el" href="classEpetra__SerialDenseSolver.html#a3d5c288ff50d1c4bd4b0dbcfe49392f1" title="Returns the reciprocal of the 1-norm condition number of the this matrix.">ReciprocalConditionEstimate()</a>). <br /></td></tr>
<tr class="separator:a0aa8747386909cb8e32971f7458401c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81a52b499f6528686d83d3367e4bc79" id="r_af81a52b499f6528686d83d3367e4bc79"><td class="memItemLeft" align="right" valign="top"><a id="af81a52b499f6528686d83d3367e4bc79" name="af81a52b499f6528686d83d3367e4bc79"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Solved</b> ()</td></tr>
<tr class="memdesc:af81a52b499f6528686d83d3367e4bc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the current set of vectors has been solved. <br /></td></tr>
<tr class="separator:af81a52b499f6528686d83d3367e4bc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416b849e1c6cd500393361c0daf1624f" id="r_a416b849e1c6cd500393361c0daf1624f"><td class="memItemLeft" align="right" valign="top"><a id="a416b849e1c6cd500393361c0daf1624f" name="a416b849e1c6cd500393361c0daf1624f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>SolutionRefined</b> ()</td></tr>
<tr class="memdesc:a416b849e1c6cd500393361c0daf1624f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the current set of vectors has been refined. <br /></td></tr>
<tr class="separator:a416b849e1c6cd500393361c0daf1624f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data Accessor methods</div></td></tr>
<tr class="memitem:ac96e9a148997c3b77629abb2e923dc7f" id="r_ac96e9a148997c3b77629abb2e923dc7f"><td class="memItemLeft" align="right" valign="top"><a id="ac96e9a148997c3b77629abb2e923dc7f" name="ac96e9a148997c3b77629abb2e923dc7f"></a>
<a class="el" href="classEpetra__SerialDenseMatrix.html">Epetra_SerialDenseMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Matrix</b> () const</td></tr>
<tr class="memdesc:ac96e9a148997c3b77629abb2e923dc7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to current matrix. <br /></td></tr>
<tr class="separator:ac96e9a148997c3b77629abb2e923dc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aea00e28f40087269f66e1b85d22485" id="r_a8aea00e28f40087269f66e1b85d22485"><td class="memItemLeft" align="right" valign="top"><a id="a8aea00e28f40087269f66e1b85d22485" name="a8aea00e28f40087269f66e1b85d22485"></a>
<a class="el" href="classEpetra__SerialDenseMatrix.html">Epetra_SerialDenseMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>FactoredMatrix</b> () const</td></tr>
<tr class="memdesc:a8aea00e28f40087269f66e1b85d22485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to factored matrix (assuming factorization has been performed). <br /></td></tr>
<tr class="separator:a8aea00e28f40087269f66e1b85d22485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae70d4c1838e27cb9c571490603a1f3" id="r_a8ae70d4c1838e27cb9c571490603a1f3"><td class="memItemLeft" align="right" valign="top"><a id="a8ae70d4c1838e27cb9c571490603a1f3" name="a8ae70d4c1838e27cb9c571490603a1f3"></a>
<a class="el" href="classEpetra__SerialDenseMatrix.html">Epetra_SerialDenseMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>LHS</b> () const</td></tr>
<tr class="memdesc:a8ae70d4c1838e27cb9c571490603a1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to current LHS. <br /></td></tr>
<tr class="separator:a8ae70d4c1838e27cb9c571490603a1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582032745aba7d0a704a92d974232462" id="r_a582032745aba7d0a704a92d974232462"><td class="memItemLeft" align="right" valign="top"><a id="a582032745aba7d0a704a92d974232462" name="a582032745aba7d0a704a92d974232462"></a>
<a class="el" href="classEpetra__SerialDenseMatrix.html">Epetra_SerialDenseMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>RHS</b> () const</td></tr>
<tr class="memdesc:a582032745aba7d0a704a92d974232462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to current RHS. <br /></td></tr>
<tr class="separator:a582032745aba7d0a704a92d974232462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0df8367c44d40ce6af76ff71fd3554" id="r_a0a0df8367c44d40ce6af76ff71fd3554"><td class="memItemLeft" align="right" valign="top"><a id="a0a0df8367c44d40ce6af76ff71fd3554" name="a0a0df8367c44d40ce6af76ff71fd3554"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>M</b> () const</td></tr>
<tr class="memdesc:a0a0df8367c44d40ce6af76ff71fd3554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns row dimension of system. <br /></td></tr>
<tr class="separator:a0a0df8367c44d40ce6af76ff71fd3554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc587513ce840ae9011fd2d1b286d4a" id="r_a6cc587513ce840ae9011fd2d1b286d4a"><td class="memItemLeft" align="right" valign="top"><a id="a6cc587513ce840ae9011fd2d1b286d4a" name="a6cc587513ce840ae9011fd2d1b286d4a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>N</b> () const</td></tr>
<tr class="memdesc:a6cc587513ce840ae9011fd2d1b286d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns column dimension of system. <br /></td></tr>
<tr class="separator:a6cc587513ce840ae9011fd2d1b286d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cce48c6032f17fe566bac7a24dc3585" id="r_a1cce48c6032f17fe566bac7a24dc3585"><td class="memItemLeft" align="right" valign="top"><a id="a1cce48c6032f17fe566bac7a24dc3585" name="a1cce48c6032f17fe566bac7a24dc3585"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>A</b> () const</td></tr>
<tr class="memdesc:a1cce48c6032f17fe566bac7a24dc3585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the <em>this</em> matrix. <br /></td></tr>
<tr class="separator:a1cce48c6032f17fe566bac7a24dc3585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0bfb2cb12b05260c187d3c9188aa6ef" id="r_ac0bfb2cb12b05260c187d3c9188aa6ef"><td class="memItemLeft" align="right" valign="top"><a id="ac0bfb2cb12b05260c187d3c9188aa6ef" name="ac0bfb2cb12b05260c187d3c9188aa6ef"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>LDA</b> () const</td></tr>
<tr class="memdesc:ac0bfb2cb12b05260c187d3c9188aa6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the leading dimension of the <em>this</em> matrix. <br /></td></tr>
<tr class="separator:ac0bfb2cb12b05260c187d3c9188aa6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c7e8b548d0d40ff626b44d6c1df77c" id="r_ae1c7e8b548d0d40ff626b44d6c1df77c"><td class="memItemLeft" align="right" valign="top"><a id="ae1c7e8b548d0d40ff626b44d6c1df77c" name="ae1c7e8b548d0d40ff626b44d6c1df77c"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>B</b> () const</td></tr>
<tr class="memdesc:ae1c7e8b548d0d40ff626b44d6c1df77c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to current RHS. <br /></td></tr>
<tr class="separator:ae1c7e8b548d0d40ff626b44d6c1df77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1797c90abd27950b58231c14a9be1100" id="r_a1797c90abd27950b58231c14a9be1100"><td class="memItemLeft" align="right" valign="top"><a id="a1797c90abd27950b58231c14a9be1100" name="a1797c90abd27950b58231c14a9be1100"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>LDB</b> () const</td></tr>
<tr class="memdesc:a1797c90abd27950b58231c14a9be1100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the leading dimension of the RHS. <br /></td></tr>
<tr class="separator:a1797c90abd27950b58231c14a9be1100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa189038ce981161973ce5833853b3548" id="r_aa189038ce981161973ce5833853b3548"><td class="memItemLeft" align="right" valign="top"><a id="aa189038ce981161973ce5833853b3548" name="aa189038ce981161973ce5833853b3548"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>NRHS</b> () const</td></tr>
<tr class="memdesc:aa189038ce981161973ce5833853b3548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of current right hand sides and solution vectors. <br /></td></tr>
<tr class="separator:aa189038ce981161973ce5833853b3548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626e1851dbf26e05e2a74d580798208e" id="r_a626e1851dbf26e05e2a74d580798208e"><td class="memItemLeft" align="right" valign="top"><a id="a626e1851dbf26e05e2a74d580798208e" name="a626e1851dbf26e05e2a74d580798208e"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>X</b> () const</td></tr>
<tr class="memdesc:a626e1851dbf26e05e2a74d580798208e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to current solution. <br /></td></tr>
<tr class="separator:a626e1851dbf26e05e2a74d580798208e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fc1d1d5fa332de12fcf52a2ddf32e3" id="r_a21fc1d1d5fa332de12fcf52a2ddf32e3"><td class="memItemLeft" align="right" valign="top"><a id="a21fc1d1d5fa332de12fcf52a2ddf32e3" name="a21fc1d1d5fa332de12fcf52a2ddf32e3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>LDX</b> () const</td></tr>
<tr class="memdesc:a21fc1d1d5fa332de12fcf52a2ddf32e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the leading dimension of the solution. <br /></td></tr>
<tr class="separator:a21fc1d1d5fa332de12fcf52a2ddf32e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1217f34d9d0c35544641e68e95f17d" id="r_a1e1217f34d9d0c35544641e68e95f17d"><td class="memItemLeft" align="right" valign="top"><a id="a1e1217f34d9d0c35544641e68e95f17d" name="a1e1217f34d9d0c35544641e68e95f17d"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>AF</b> () const</td></tr>
<tr class="memdesc:a1e1217f34d9d0c35544641e68e95f17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the factored matrix (may be the same as A() if factorization done in place). <br /></td></tr>
<tr class="separator:a1e1217f34d9d0c35544641e68e95f17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1231b3048e25c2cc8524a1a78e47e5e6" id="r_a1231b3048e25c2cc8524a1a78e47e5e6"><td class="memItemLeft" align="right" valign="top"><a id="a1231b3048e25c2cc8524a1a78e47e5e6" name="a1231b3048e25c2cc8524a1a78e47e5e6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>LDAF</b> () const</td></tr>
<tr class="memdesc:a1231b3048e25c2cc8524a1a78e47e5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the leading dimension of the factored matrix. <br /></td></tr>
<tr class="separator:a1231b3048e25c2cc8524a1a78e47e5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8378b59f173d075fa915309afab7da81" id="r_a8378b59f173d075fa915309afab7da81"><td class="memItemLeft" align="right" valign="top"><a id="a8378b59f173d075fa915309afab7da81" name="a8378b59f173d075fa915309afab7da81"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><b>IPIV</b> () const</td></tr>
<tr class="memdesc:a8378b59f173d075fa915309afab7da81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to pivot vector (if factorization has been computed), zero otherwise. <br /></td></tr>
<tr class="separator:a8378b59f173d075fa915309afab7da81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28e10943b6fc1ff50d877f91415e6f2" id="r_ab28e10943b6fc1ff50d877f91415e6f2"><td class="memItemLeft" align="right" valign="top"><a id="ab28e10943b6fc1ff50d877f91415e6f2" name="ab28e10943b6fc1ff50d877f91415e6f2"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>ANORM</b> () const</td></tr>
<tr class="memdesc:ab28e10943b6fc1ff50d877f91415e6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 1-Norm of the <em>this</em> matrix (returns -1 if not yet computed). <br /></td></tr>
<tr class="separator:ab28e10943b6fc1ff50d877f91415e6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e8f395375a1b03c877c6523087f0cd" id="r_ab9e8f395375a1b03c877c6523087f0cd"><td class="memItemLeft" align="right" valign="top"><a id="ab9e8f395375a1b03c877c6523087f0cd" name="ab9e8f395375a1b03c877c6523087f0cd"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>RCOND</b> () const</td></tr>
<tr class="memdesc:ab9e8f395375a1b03c877c6523087f0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reciprocal of the condition number of the <em>this</em> matrix (returns -1 if not yet computed). <br /></td></tr>
<tr class="separator:ab9e8f395375a1b03c877c6523087f0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763529576ae9537c316e97bc936f8b67" id="r_a763529576ae9537c316e97bc936f8b67"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__SerialDenseSolver.html#a763529576ae9537c316e97bc936f8b67">ROWCND</a> () const</td></tr>
<tr class="memdesc:a763529576ae9537c316e97bc936f8b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ratio of smallest to largest row scale factors for the <em>this</em> matrix (returns -1 if not yet computed).  <br /></td></tr>
<tr class="separator:a763529576ae9537c316e97bc936f8b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4066d83138fe4231ae093a5e05cdba49" id="r_a4066d83138fe4231ae093a5e05cdba49"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__SerialDenseSolver.html#a4066d83138fe4231ae093a5e05cdba49">COLCND</a> () const</td></tr>
<tr class="memdesc:a4066d83138fe4231ae093a5e05cdba49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ratio of smallest to largest column scale factors for the <em>this</em> matrix (returns -1 if not yet computed).  <br /></td></tr>
<tr class="separator:a4066d83138fe4231ae093a5e05cdba49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdec9d37be1d2921c7fa51c9b0edbfb" id="r_a3cdec9d37be1d2921c7fa51c9b0edbfb"><td class="memItemLeft" align="right" valign="top"><a id="a3cdec9d37be1d2921c7fa51c9b0edbfb" name="a3cdec9d37be1d2921c7fa51c9b0edbfb"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>AMAX</b> () const</td></tr>
<tr class="memdesc:a3cdec9d37be1d2921c7fa51c9b0edbfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of the largest entry of the <em>this</em> matrix (returns -1 if not yet computed). <br /></td></tr>
<tr class="separator:a3cdec9d37be1d2921c7fa51c9b0edbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9179c0e5e26d4d64eae884c0414bf1" id="r_a9a9179c0e5e26d4d64eae884c0414bf1"><td class="memItemLeft" align="right" valign="top"><a id="a9a9179c0e5e26d4d64eae884c0414bf1" name="a9a9179c0e5e26d4d64eae884c0414bf1"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>FERR</b> () const</td></tr>
<tr class="memdesc:a9a9179c0e5e26d4d64eae884c0414bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the forward error estimates computed by LAPACK. <br /></td></tr>
<tr class="separator:a9a9179c0e5e26d4d64eae884c0414bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bc8ca9e4d861641f75c5eaa09f3b97" id="r_af4bc8ca9e4d861641f75c5eaa09f3b97"><td class="memItemLeft" align="right" valign="top"><a id="af4bc8ca9e4d861641f75c5eaa09f3b97" name="af4bc8ca9e4d861641f75c5eaa09f3b97"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>BERR</b> () const</td></tr>
<tr class="memdesc:af4bc8ca9e4d861641f75c5eaa09f3b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the backward error estimates computed by LAPACK. <br /></td></tr>
<tr class="separator:af4bc8ca9e4d861641f75c5eaa09f3b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e7e579af305059b2eabaf9ff15776a" id="r_a29e7e579af305059b2eabaf9ff15776a"><td class="memItemLeft" align="right" valign="top"><a id="a29e7e579af305059b2eabaf9ff15776a" name="a29e7e579af305059b2eabaf9ff15776a"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>R</b> () const</td></tr>
<tr class="memdesc:a29e7e579af305059b2eabaf9ff15776a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the row scaling vector used for equilibration. <br /></td></tr>
<tr class="separator:a29e7e579af305059b2eabaf9ff15776a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68a3dd13856dabe34b7e496449ff965" id="r_aa68a3dd13856dabe34b7e496449ff965"><td class="memItemLeft" align="right" valign="top"><a id="aa68a3dd13856dabe34b7e496449ff965" name="aa68a3dd13856dabe34b7e496449ff965"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>C</b> () const</td></tr>
<tr class="memdesc:aa68a3dd13856dabe34b7e496449ff965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the column scale vector used for equilibration. <br /></td></tr>
<tr class="separator:aa68a3dd13856dabe34b7e496449ff965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__CompObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__CompObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__CompObject.html">Epetra_CompObject</a></td></tr>
<tr class="memitem:a72d50bb3df3487828adb4d4b8f9a282b inherit pub_methods_classEpetra__CompObject" id="r_a72d50bb3df3487828adb4d4b8f9a282b"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_CompObject</b> ()</td></tr>
<tr class="memdesc:a72d50bb3df3487828adb4d4b8f9a282b inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic <a class="el" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes.">Epetra_CompObject</a> constuctor. <br /></td></tr>
<tr class="separator:a72d50bb3df3487828adb4d4b8f9a282b inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1109b4825ca8fa5043c57c83227c56 inherit pub_methods_classEpetra__CompObject" id="r_a3d1109b4825ca8fa5043c57c83227c56"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_CompObject</b> (const <a class="el" href="classEpetra__CompObject.html">Epetra_CompObject</a> &amp;Source)</td></tr>
<tr class="memdesc:a3d1109b4825ca8fa5043c57c83227c56 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes.">Epetra_CompObject</a> copy constructor. <br /></td></tr>
<tr class="separator:a3d1109b4825ca8fa5043c57c83227c56 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af670a39b6993246fe87fc4c4b9f00971 inherit pub_methods_classEpetra__CompObject" id="r_af670a39b6993246fe87fc4c4b9f00971"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_CompObject</b> ()</td></tr>
<tr class="memdesc:af670a39b6993246fe87fc4c4b9f00971 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes.">Epetra_CompObject</a> destructor. <br /></td></tr>
<tr class="separator:af670a39b6993246fe87fc4c4b9f00971 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665dd8befefacf0e5f188ea8a011bd80 inherit pub_methods_classEpetra__CompObject" id="r_a665dd8befefacf0e5f188ea8a011bd80"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetFlopCounter</b> (const <a class="el" href="classEpetra__Flops.html">Epetra_Flops</a> &amp;FlopCounter_in)</td></tr>
<tr class="memdesc:a665dd8befefacf0e5f188ea8a011bd80 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal <a class="el" href="classEpetra__Flops.html" title="Epetra_Flops: The Epetra Floating Point Operations Class.">Epetra_Flops()</a> pointer. <br /></td></tr>
<tr class="separator:a665dd8befefacf0e5f188ea8a011bd80 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac5e8ba25d3ff75dd93ee5d85f46c5b inherit pub_methods_classEpetra__CompObject" id="r_a0ac5e8ba25d3ff75dd93ee5d85f46c5b"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetFlopCounter</b> (const <a class="el" href="classEpetra__CompObject.html">Epetra_CompObject</a> &amp;CompObject)</td></tr>
<tr class="memdesc:a0ac5e8ba25d3ff75dd93ee5d85f46c5b inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal <a class="el" href="classEpetra__Flops.html" title="Epetra_Flops: The Epetra Floating Point Operations Class.">Epetra_Flops()</a> pointer to the flop counter of another <a class="el" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes.">Epetra_CompObject</a>. <br /></td></tr>
<tr class="separator:a0ac5e8ba25d3ff75dd93ee5d85f46c5b inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78028e410947150bba43f206d0c0b0ef inherit pub_methods_classEpetra__CompObject" id="r_a78028e410947150bba43f206d0c0b0ef"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UnsetFlopCounter</b> ()</td></tr>
<tr class="memdesc:a78028e410947150bba43f206d0c0b0ef inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal <a class="el" href="classEpetra__Flops.html" title="Epetra_Flops: The Epetra Floating Point Operations Class.">Epetra_Flops()</a> pointer to 0 (no flops counted). <br /></td></tr>
<tr class="separator:a78028e410947150bba43f206d0c0b0ef inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e1619549eb9d1b62a04172fedc77b7 inherit pub_methods_classEpetra__CompObject" id="r_a31e1619549eb9d1b62a04172fedc77b7"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classEpetra__Flops.html">Epetra_Flops</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetFlopCounter</b> () const</td></tr>
<tr class="memdesc:a31e1619549eb9d1b62a04172fedc77b7 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pointer to the <a class="el" href="classEpetra__Flops.html" title="Epetra_Flops: The Epetra Floating Point Operations Class.">Epetra_Flops()</a> object associated with this object, returns 0 if none. <br /></td></tr>
<tr class="separator:a31e1619549eb9d1b62a04172fedc77b7 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adff4c34d61377709fc8a17e99e3eae inherit pub_methods_classEpetra__CompObject" id="r_a4adff4c34d61377709fc8a17e99e3eae"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>ResetFlops</b> () const</td></tr>
<tr class="memdesc:a4adff4c34d61377709fc8a17e99e3eae inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the number of floating point operations to zero for <em>this</em> multi-vector. <br /></td></tr>
<tr class="separator:a4adff4c34d61377709fc8a17e99e3eae inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8326f0873a8866ac9f15f08f5ef31b0d inherit pub_methods_classEpetra__CompObject" id="r_a8326f0873a8866ac9f15f08f5ef31b0d"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><b>Flops</b> () const</td></tr>
<tr class="memdesc:a8326f0873a8866ac9f15f08f5ef31b0d inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of floating point operations with <em>this</em> multi-vector. <br /></td></tr>
<tr class="separator:a8326f0873a8866ac9f15f08f5ef31b0d inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac776bf8d9e68e57951ef766ec16e636b inherit pub_methods_classEpetra__CompObject" id="r_ac776bf8d9e68e57951ef766ec16e636b"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateFlops</b> (int Flops_in) const</td></tr>
<tr class="memdesc:ac776bf8d9e68e57951ef766ec16e636b inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment Flop count for <em>this</em> object. <br /></td></tr>
<tr class="separator:ac776bf8d9e68e57951ef766ec16e636b inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4373b39e384b424078818c6774ffb59a inherit pub_methods_classEpetra__CompObject" id="r_a4373b39e384b424078818c6774ffb59a"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateFlops</b> (long int Flops_in) const</td></tr>
<tr class="memdesc:a4373b39e384b424078818c6774ffb59a inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment Flop count for <em>this</em> object. <br /></td></tr>
<tr class="separator:a4373b39e384b424078818c6774ffb59a inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a2cf1d3a37d9e486edc64202ed42b2 inherit pub_methods_classEpetra__CompObject" id="r_a77a2cf1d3a37d9e486edc64202ed42b2"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateFlops</b> (long long Flops_in) const</td></tr>
<tr class="memdesc:a77a2cf1d3a37d9e486edc64202ed42b2 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment Flop count for <em>this</em> object. <br /></td></tr>
<tr class="separator:a77a2cf1d3a37d9e486edc64202ed42b2 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6480e644cf6c9a524ef839add22952 inherit pub_methods_classEpetra__CompObject" id="r_a4c6480e644cf6c9a524ef839add22952"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateFlops</b> (double Flops_in) const</td></tr>
<tr class="memdesc:a4c6480e644cf6c9a524ef839add22952 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment Flop count for <em>this</em> object. <br /></td></tr>
<tr class="separator:a4c6480e644cf6c9a524ef839add22952 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe126845543d91403abf3a50333fb891 inherit pub_methods_classEpetra__CompObject" id="r_abe126845543d91403abf3a50333fb891"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateFlops</b> (float Flops_in) const</td></tr>
<tr class="memdesc:abe126845543d91403abf3a50333fb891 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment Flop count for <em>this</em> object. <br /></td></tr>
<tr class="separator:abe126845543d91403abf3a50333fb891 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb8e33c7b18538fa0c088a1dfe1216f inherit pub_methods_classEpetra__CompObject" id="r_a8bb8e33c7b18538fa0c088a1dfe1216f"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classEpetra__CompObject.html">Epetra_CompObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classEpetra__CompObject.html">Epetra_CompObject</a> &amp;src)</td></tr>
<tr class="separator:a8bb8e33c7b18538fa0c088a1dfe1216f inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__BLAS"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__BLAS')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__BLAS.html">Epetra_BLAS</a></td></tr>
<tr class="memitem:a8e4e2d564543a813e06462a599ed5b88 inherit pub_methods_classEpetra__BLAS" id="r_a8e4e2d564543a813e06462a599ed5b88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__BLAS.html#a8e4e2d564543a813e06462a599ed5b88">Epetra_BLAS</a> (void)</td></tr>
<tr class="memdesc:a8e4e2d564543a813e06462a599ed5b88 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> Constructor.  <br /></td></tr>
<tr class="separator:a8e4e2d564543a813e06462a599ed5b88 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a2dc7741eea3b947a11280c0ad7ba3 inherit pub_methods_classEpetra__BLAS" id="r_a40a2dc7741eea3b947a11280c0ad7ba3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__BLAS.html#a40a2dc7741eea3b947a11280c0ad7ba3">Epetra_BLAS</a> (const <a class="el" href="classEpetra__BLAS.html">Epetra_BLAS</a> &amp;BLAS)</td></tr>
<tr class="memdesc:a40a2dc7741eea3b947a11280c0ad7ba3 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> Copy Constructor.  <br /></td></tr>
<tr class="separator:a40a2dc7741eea3b947a11280c0ad7ba3 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cd61f7e045c7a41d75e4b073b116e2 inherit pub_methods_classEpetra__BLAS" id="r_a65cd61f7e045c7a41d75e4b073b116e2"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_BLAS</b> (void)</td></tr>
<tr class="memdesc:a65cd61f7e045c7a41d75e4b073b116e2 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> Destructor. <br /></td></tr>
<tr class="separator:a65cd61f7e045c7a41d75e4b073b116e2 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6e26cf6efd99af2a0a5090b732fab8 inherit pub_methods_classEpetra__BLAS" id="r_a2b6e26cf6efd99af2a0a5090b732fab8"><td class="memItemLeft" align="right" valign="top">
float&#160;</td><td class="memItemRight" valign="bottom"><b>ASUM</b> (const int N, const float *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a2b6e26cf6efd99af2a0a5090b732fab8 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> one norm function (SASUM). <br /></td></tr>
<tr class="separator:a2b6e26cf6efd99af2a0a5090b732fab8 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b10dd77bd77ae08ee2d4f797ccb38c inherit pub_methods_classEpetra__BLAS" id="r_a98b10dd77bd77ae08ee2d4f797ccb38c"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><b>ASUM</b> (const int N, const double *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a98b10dd77bd77ae08ee2d4f797ccb38c inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> one norm function (DASUM). <br /></td></tr>
<tr class="separator:a98b10dd77bd77ae08ee2d4f797ccb38c inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146020f20aa38d12a13a0240f4bd4d89 inherit pub_methods_classEpetra__BLAS" id="r_a146020f20aa38d12a13a0240f4bd4d89"><td class="memItemLeft" align="right" valign="top">
float&#160;</td><td class="memItemRight" valign="bottom"><b>DOT</b> (const int N, const float *X, const float *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:a146020f20aa38d12a13a0240f4bd4d89 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> dot product function (SDOT). <br /></td></tr>
<tr class="separator:a146020f20aa38d12a13a0240f4bd4d89 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d29ddf22e2dbc8cc4aa15920112ba6f inherit pub_methods_classEpetra__BLAS" id="r_a5d29ddf22e2dbc8cc4aa15920112ba6f"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><b>DOT</b> (const int N, const double *X, const double *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:a5d29ddf22e2dbc8cc4aa15920112ba6f inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> dot product function (DDOT). <br /></td></tr>
<tr class="separator:a5d29ddf22e2dbc8cc4aa15920112ba6f inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b602d1308905182ead57a14ce94dc4c inherit pub_methods_classEpetra__BLAS" id="r_a2b602d1308905182ead57a14ce94dc4c"><td class="memItemLeft" align="right" valign="top">
float&#160;</td><td class="memItemRight" valign="bottom"><b>NRM2</b> (const int N, const float *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a2b602d1308905182ead57a14ce94dc4c inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> norm function (SNRM2). <br /></td></tr>
<tr class="separator:a2b602d1308905182ead57a14ce94dc4c inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3915137d4a88e64be1b3b6fff0ae0ba8 inherit pub_methods_classEpetra__BLAS" id="r_a3915137d4a88e64be1b3b6fff0ae0ba8"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><b>NRM2</b> (const int N, const double *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a3915137d4a88e64be1b3b6fff0ae0ba8 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> norm function (DNRM2). <br /></td></tr>
<tr class="separator:a3915137d4a88e64be1b3b6fff0ae0ba8 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132159d7d231a9a9e36e9175cc9faf09 inherit pub_methods_classEpetra__BLAS" id="r_a132159d7d231a9a9e36e9175cc9faf09"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SCAL</b> (const int N, const float ALPHA, float *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a132159d7d231a9a9e36e9175cc9faf09 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> vector scale function (SSCAL) <br /></td></tr>
<tr class="separator:a132159d7d231a9a9e36e9175cc9faf09 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9cf3e5a447112125294b8988fe50124 inherit pub_methods_classEpetra__BLAS" id="r_ae9cf3e5a447112125294b8988fe50124"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SCAL</b> (const int N, const double ALPHA, double *X, const int INCX=1) const</td></tr>
<tr class="memdesc:ae9cf3e5a447112125294b8988fe50124 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> vector scale function (DSCAL) <br /></td></tr>
<tr class="separator:ae9cf3e5a447112125294b8988fe50124 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f43b364ff5e3627f983fe435b222ea5 inherit pub_methods_classEpetra__BLAS" id="r_a7f43b364ff5e3627f983fe435b222ea5"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>COPY</b> (const int N, const float *X, float *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:a7f43b364ff5e3627f983fe435b222ea5 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> vector copy function (SCOPY) <br /></td></tr>
<tr class="separator:a7f43b364ff5e3627f983fe435b222ea5 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f36b71efee7fc61fb8a3d5c8ce0cf0 inherit pub_methods_classEpetra__BLAS" id="r_a93f36b71efee7fc61fb8a3d5c8ce0cf0"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>COPY</b> (const int N, const double *X, double *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:a93f36b71efee7fc61fb8a3d5c8ce0cf0 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> vector scale function (DCOPY) <br /></td></tr>
<tr class="separator:a93f36b71efee7fc61fb8a3d5c8ce0cf0 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6412c2b4a56fbe2d0bbe94cc7a65e5f8 inherit pub_methods_classEpetra__BLAS" id="r_a6412c2b4a56fbe2d0bbe94cc7a65e5f8"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>IAMAX</b> (const int N, const float *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a6412c2b4a56fbe2d0bbe94cc7a65e5f8 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> arg maximum of absolute value function (ISAMAX) <br /></td></tr>
<tr class="separator:a6412c2b4a56fbe2d0bbe94cc7a65e5f8 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5532e66d0bd32b6ca19871bc007b6e16 inherit pub_methods_classEpetra__BLAS" id="r_a5532e66d0bd32b6ca19871bc007b6e16"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>IAMAX</b> (const int N, const double *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a5532e66d0bd32b6ca19871bc007b6e16 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> arg maximum of absolute value function (IDAMAX) <br /></td></tr>
<tr class="separator:a5532e66d0bd32b6ca19871bc007b6e16 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05c457263f160300f80c638525a5e19 inherit pub_methods_classEpetra__BLAS" id="r_af05c457263f160300f80c638525a5e19"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>AXPY</b> (const int N, const float ALPHA, const float *X, float *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:af05c457263f160300f80c638525a5e19 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> vector update function (SAXPY) <br /></td></tr>
<tr class="separator:af05c457263f160300f80c638525a5e19 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3042fd0acc417128584ce36483dc079 inherit pub_methods_classEpetra__BLAS" id="r_ac3042fd0acc417128584ce36483dc079"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>AXPY</b> (const int N, const double ALPHA, const double *X, double *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:ac3042fd0acc417128584ce36483dc079 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> vector update function (DAXPY) <br /></td></tr>
<tr class="separator:ac3042fd0acc417128584ce36483dc079 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ad7f5429608aba90723eb46a426575 inherit pub_methods_classEpetra__BLAS" id="r_ae9ad7f5429608aba90723eb46a426575"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEMV</b> (const char TRANS, const int M, const int N, const float ALPHA, const float *A, const int LDA, const float *X, const float BETA, float *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:ae9ad7f5429608aba90723eb46a426575 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> matrix-vector multiply function (SGEMV) <br /></td></tr>
<tr class="separator:ae9ad7f5429608aba90723eb46a426575 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa69dbfc706abc19f3d441ffc07683c inherit pub_methods_classEpetra__BLAS" id="r_a0aa69dbfc706abc19f3d441ffc07683c"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEMV</b> (const char TRANS, const int M, const int N, const double ALPHA, const double *A, const int LDA, const double *X, const double BETA, double *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:a0aa69dbfc706abc19f3d441ffc07683c inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> matrix-vector multiply function (DGEMV) <br /></td></tr>
<tr class="separator:a0aa69dbfc706abc19f3d441ffc07683c inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c5f255a3a03f9d3fa87aaa6cfb92ec inherit pub_methods_classEpetra__BLAS" id="r_a95c5f255a3a03f9d3fa87aaa6cfb92ec"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEMM</b> (const char TRANSA, const char TRANSB, const int M, const int N, const int K, const float ALPHA, const float *A, const int LDA, const float *B, const int LDB, const float BETA, float *C, const int LDC) const</td></tr>
<tr class="memdesc:a95c5f255a3a03f9d3fa87aaa6cfb92ec inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> matrix-matrix multiply function (SGEMM) <br /></td></tr>
<tr class="separator:a95c5f255a3a03f9d3fa87aaa6cfb92ec inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf93b9ef6ee2782cbbdc1e2ac00b5a2e inherit pub_methods_classEpetra__BLAS" id="r_acf93b9ef6ee2782cbbdc1e2ac00b5a2e"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEMM</b> (const char TRANSA, const char TRANSB, const int M, const int N, const int K, const double ALPHA, const double *A, const int LDA, const double *B, const int LDB, const double BETA, double *C, const int LDC) const</td></tr>
<tr class="memdesc:acf93b9ef6ee2782cbbdc1e2ac00b5a2e inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> matrix-matrix multiply function (DGEMM) <br /></td></tr>
<tr class="separator:acf93b9ef6ee2782cbbdc1e2ac00b5a2e inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa11c3c601b27c400568a60596434b4 inherit pub_methods_classEpetra__BLAS" id="r_a8fa11c3c601b27c400568a60596434b4"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYMM</b> (const char SIDE, const char UPLO, const int M, const int N, const float ALPHA, const float *A, const int LDA, const float *B, const int LDB, const float BETA, float *C, const int LDC) const</td></tr>
<tr class="memdesc:a8fa11c3c601b27c400568a60596434b4 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> symmetric matrix-matrix multiply function (SSYMM) <br /></td></tr>
<tr class="separator:a8fa11c3c601b27c400568a60596434b4 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ca61221b2acf0befef968748c6bb80 inherit pub_methods_classEpetra__BLAS" id="r_ad1ca61221b2acf0befef968748c6bb80"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYMM</b> (const char SIDE, const char UPLO, const int M, const int N, const double ALPHA, const double *A, const int LDA, const double *B, const int LDB, const double BETA, double *C, const int LDC) const</td></tr>
<tr class="memdesc:ad1ca61221b2acf0befef968748c6bb80 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> matrix-matrix multiply function (DSYMM) <br /></td></tr>
<tr class="separator:ad1ca61221b2acf0befef968748c6bb80 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2dcbf05331765f0ddb661460390a6e inherit pub_methods_classEpetra__BLAS" id="r_add2dcbf05331765f0ddb661460390a6e"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>TRMM</b> (const char SIDE, const char UPLO, const char TRANSA, const char DIAG, const int M, const int N, const float ALPHA, const float *A, const int LDA, float *B, const int LDB) const</td></tr>
<tr class="memdesc:add2dcbf05331765f0ddb661460390a6e inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> triangular matrix-matrix multiply function (STRMM) <br /></td></tr>
<tr class="separator:add2dcbf05331765f0ddb661460390a6e inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65212f8eee6597c24722b7bf2d54168b inherit pub_methods_classEpetra__BLAS" id="r_a65212f8eee6597c24722b7bf2d54168b"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>TRMM</b> (const char SIDE, const char UPLO, const char TRANSA, const char DIAG, const int M, const int N, const double ALPHA, const double *A, const int LDA, double *B, const int LDB) const</td></tr>
<tr class="memdesc:a65212f8eee6597c24722b7bf2d54168b inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> triangular matrix-matrix multiply function (DTRMM) <br /></td></tr>
<tr class="separator:a65212f8eee6597c24722b7bf2d54168b inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd9f6cd122a04b0544b62f26761b885 inherit pub_methods_classEpetra__BLAS" id="r_a6fd9f6cd122a04b0544b62f26761b885"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYRK</b> (const char UPLO, const char TRANS, const int N, const int K, const float ALPHA, const float *A, const int LDA, const float BETA, float *C, const int LDC) const</td></tr>
<tr class="memdesc:a6fd9f6cd122a04b0544b62f26761b885 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eperta_BLAS symetric rank k funtion (ssyrk) <br /></td></tr>
<tr class="separator:a6fd9f6cd122a04b0544b62f26761b885 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a2d21fe184982d57544b23b66ba522 inherit pub_methods_classEpetra__BLAS" id="r_a97a2d21fe184982d57544b23b66ba522"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYRK</b> (const char UPLO, const char TRANS, const int N, const int K, const double ALPHA, const double *A, const int LDA, const double BETA, double *C, const int LDC) const</td></tr>
<tr class="memdesc:a97a2d21fe184982d57544b23b66ba522 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eperta_BLAS symetric rank k funtion (dsyrk) <br /></td></tr>
<tr class="separator:a97a2d21fe184982d57544b23b66ba522 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__LAPACK"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__LAPACK')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__LAPACK.html">Epetra_LAPACK</a></td></tr>
<tr class="memitem:a56fa1fb6d6a77048a6d500c767dba808 inherit pub_methods_classEpetra__LAPACK" id="r_a56fa1fb6d6a77048a6d500c767dba808"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__LAPACK.html#a56fa1fb6d6a77048a6d500c767dba808">Epetra_LAPACK</a> (void)</td></tr>
<tr class="memdesc:a56fa1fb6d6a77048a6d500c767dba808 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> Constructor.  <br /></td></tr>
<tr class="separator:a56fa1fb6d6a77048a6d500c767dba808 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334ef8d72b1b4875b0b8660904b85eba inherit pub_methods_classEpetra__LAPACK" id="r_a334ef8d72b1b4875b0b8660904b85eba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__LAPACK.html#a334ef8d72b1b4875b0b8660904b85eba">Epetra_LAPACK</a> (const <a class="el" href="classEpetra__LAPACK.html">Epetra_LAPACK</a> &amp;LAPACK)</td></tr>
<tr class="memdesc:a334ef8d72b1b4875b0b8660904b85eba inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> Copy Constructor.  <br /></td></tr>
<tr class="separator:a334ef8d72b1b4875b0b8660904b85eba inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa688eb15f982b7299f283611eb8764c9 inherit pub_methods_classEpetra__LAPACK" id="r_aa688eb15f982b7299f283611eb8764c9"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_LAPACK</b> (void)</td></tr>
<tr class="memdesc:aa688eb15f982b7299f283611eb8764c9 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> Destructor. <br /></td></tr>
<tr class="separator:aa688eb15f982b7299f283611eb8764c9 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f2b85bae6d075709866ac265c100eb inherit pub_methods_classEpetra__LAPACK" id="r_a80f2b85bae6d075709866ac265c100eb"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>POTRF</b> (const char UPLO, const int N, float *A, const int LDA, int *INFO) const</td></tr>
<tr class="memdesc:a80f2b85bae6d075709866ac265c100eb inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> factorization for positive definite matrix (SPOTRF) <br /></td></tr>
<tr class="separator:a80f2b85bae6d075709866ac265c100eb inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad546b8c9f9da9b97f3ea86557d881b1c inherit pub_methods_classEpetra__LAPACK" id="r_ad546b8c9f9da9b97f3ea86557d881b1c"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>POTRF</b> (const char UPLO, const int N, double *A, const int LDA, int *INFO) const</td></tr>
<tr class="memdesc:ad546b8c9f9da9b97f3ea86557d881b1c inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> factorization for positive definite matrix (DPOTRF) <br /></td></tr>
<tr class="separator:ad546b8c9f9da9b97f3ea86557d881b1c inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115ffa835875293db417c0fa05f6739f inherit pub_methods_classEpetra__LAPACK" id="r_a115ffa835875293db417c0fa05f6739f"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>POTRS</b> (const char UPLO, const int N, const int NRHS, const float *A, const int LDA, float *X, const int LDX, int *INFO) const</td></tr>
<tr class="memdesc:a115ffa835875293db417c0fa05f6739f inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> solve (after factorization) for positive definite matrix (SPOTRS) <br /></td></tr>
<tr class="separator:a115ffa835875293db417c0fa05f6739f inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97745d8848ae3a88a38b0d288d4caac inherit pub_methods_classEpetra__LAPACK" id="r_af97745d8848ae3a88a38b0d288d4caac"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>POTRS</b> (const char UPLO, const int N, const int NRHS, const double *A, const int LDA, double *X, const int LDX, int *INFO) const</td></tr>
<tr class="memdesc:af97745d8848ae3a88a38b0d288d4caac inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> solve (after factorization) for positive definite matrix (DPOTRS) <br /></td></tr>
<tr class="separator:af97745d8848ae3a88a38b0d288d4caac inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5944746dad705b371e83f6d130eaebd1 inherit pub_methods_classEpetra__LAPACK" id="r_a5944746dad705b371e83f6d130eaebd1"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>POTRI</b> (const char UPLO, const int N, float *A, const int LDA, int *INFO) const</td></tr>
<tr class="memdesc:a5944746dad705b371e83f6d130eaebd1 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> inversion for positive definite matrix (SPOTRI) <br /></td></tr>
<tr class="separator:a5944746dad705b371e83f6d130eaebd1 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f98e13607ee1f4f8ee815cd3e12e7a0 inherit pub_methods_classEpetra__LAPACK" id="r_a8f98e13607ee1f4f8ee815cd3e12e7a0"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>POTRI</b> (const char UPLO, const int N, double *A, const int LDA, int *INFO) const</td></tr>
<tr class="memdesc:a8f98e13607ee1f4f8ee815cd3e12e7a0 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> inversion for positive definite matrix (DPOTRI) <br /></td></tr>
<tr class="separator:a8f98e13607ee1f4f8ee815cd3e12e7a0 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7947276037b3bec18286a2134c9ebaaa inherit pub_methods_classEpetra__LAPACK" id="r_a7947276037b3bec18286a2134c9ebaaa"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>POCON</b> (const char UPLO, const int N, const float *A, const int LDA, const float ANORM, float *RCOND, float *WORK, int *IWORK, int *INFO) const</td></tr>
<tr class="memdesc:a7947276037b3bec18286a2134c9ebaaa inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> condition number estimator for positive definite matrix (SPOCON) <br /></td></tr>
<tr class="separator:a7947276037b3bec18286a2134c9ebaaa inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9de2ea244e1961c51960e685e9a598 inherit pub_methods_classEpetra__LAPACK" id="r_a3a9de2ea244e1961c51960e685e9a598"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>POCON</b> (const char UPLO, const int N, const double *A, const int LDA, const double ANORM, double *RCOND, double *WORK, int *IWORK, int *INFO) const</td></tr>
<tr class="memdesc:a3a9de2ea244e1961c51960e685e9a598 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> condition number estimator for positive definite matrix (DPOCON) <br /></td></tr>
<tr class="separator:a3a9de2ea244e1961c51960e685e9a598 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38a78008d939bb5b0b58f9de8f1b67f inherit pub_methods_classEpetra__LAPACK" id="r_ab38a78008d939bb5b0b58f9de8f1b67f"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>POSV</b> (const char UPLO, const int N, const int NRHS, float *A, const int LDA, float *X, const int LDX, int *INFO) const</td></tr>
<tr class="memdesc:ab38a78008d939bb5b0b58f9de8f1b67f inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> factor and solve for positive definite matrix (SPOSV) <br /></td></tr>
<tr class="separator:ab38a78008d939bb5b0b58f9de8f1b67f inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0232b040484f14eda21011cb96133db1 inherit pub_methods_classEpetra__LAPACK" id="r_a0232b040484f14eda21011cb96133db1"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>POSV</b> (const char UPLO, const int N, const int NRHS, double *A, const int LDA, double *X, const int LDX, int *INFO) const</td></tr>
<tr class="memdesc:a0232b040484f14eda21011cb96133db1 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> factor and solve for positive definite matrix (DPOSV) <br /></td></tr>
<tr class="separator:a0232b040484f14eda21011cb96133db1 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc6bd6ffb33bef837b182f4d21304a1 inherit pub_methods_classEpetra__LAPACK" id="r_abfc6bd6ffb33bef837b182f4d21304a1"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>POEQU</b> (const int N, const float *A, const int LDA, float *S, float *SCOND, float *AMAX, int *INFO) const</td></tr>
<tr class="memdesc:abfc6bd6ffb33bef837b182f4d21304a1 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> equilibration for positive definite matrix (SPOEQU) <br /></td></tr>
<tr class="separator:abfc6bd6ffb33bef837b182f4d21304a1 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0a311ee7c111ecb317714c138cecd7 inherit pub_methods_classEpetra__LAPACK" id="r_a2b0a311ee7c111ecb317714c138cecd7"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>POEQU</b> (const int N, const double *A, const int LDA, double *S, double *SCOND, double *AMAX, int *INFO) const</td></tr>
<tr class="memdesc:a2b0a311ee7c111ecb317714c138cecd7 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> equilibration for positive definite matrix (DPOEQU) <br /></td></tr>
<tr class="separator:a2b0a311ee7c111ecb317714c138cecd7 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08935f1d86a50ca580cb0886c289a7c8 inherit pub_methods_classEpetra__LAPACK" id="r_a08935f1d86a50ca580cb0886c289a7c8"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>PORFS</b> (const char UPLO, const int N, const int NRHS, const float *A, const int LDA, const float *AF, const int LDAF, const float *B, const int LDB, float *X, const int LDX, float *FERR, float *BERR, float *WORK, int *IWORK, int *INFO) const</td></tr>
<tr class="memdesc:a08935f1d86a50ca580cb0886c289a7c8 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> solve driver for positive definite matrix (SPOSVX) <br /></td></tr>
<tr class="separator:a08935f1d86a50ca580cb0886c289a7c8 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219d8756e6e5309b54dbfe5d98b74224 inherit pub_methods_classEpetra__LAPACK" id="r_a219d8756e6e5309b54dbfe5d98b74224"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>PORFS</b> (const char UPLO, const int N, const int NRHS, const double *A, const int LDA, const double *AF, const int LDAF, const double *B, const int LDB, double *X, const int LDX, double *FERR, double *BERR, double *WORK, int *IWORK, int *INFO) const</td></tr>
<tr class="memdesc:a219d8756e6e5309b54dbfe5d98b74224 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> solve driver for positive definite matrix (DPOSVX) <br /></td></tr>
<tr class="separator:a219d8756e6e5309b54dbfe5d98b74224 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33daef20f778bc13d9fd005dc505bc81 inherit pub_methods_classEpetra__LAPACK" id="r_a33daef20f778bc13d9fd005dc505bc81"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>POSVX</b> (const char FACT, const char UPLO, const int N, const int NRHS, float *A, const int LDA, float *AF, const int LDAF, const char EQUED, float *S, float *B, const int LDB, float *X, const int LDX, float *RCOND, float *FERR, float *BERR, float *WORK, int *IWORK, int *INFO) const</td></tr>
<tr class="memdesc:a33daef20f778bc13d9fd005dc505bc81 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> solve driver for positive definite matrix (SPOSVX) <br /></td></tr>
<tr class="separator:a33daef20f778bc13d9fd005dc505bc81 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2dae25799a819d691ad4d90328ff5b inherit pub_methods_classEpetra__LAPACK" id="r_aeb2dae25799a819d691ad4d90328ff5b"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>POSVX</b> (const char FACT, const char UPLO, const int N, const int NRHS, double *A, const int LDA, double *AF, const int LDAF, const char EQUED, double *S, double *B, const int LDB, double *X, const int LDX, double *RCOND, double *FERR, double *BERR, double *WORK, int *IWORK, int *INFO) const</td></tr>
<tr class="memdesc:aeb2dae25799a819d691ad4d90328ff5b inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> solve driver for positive definite matrix (DPOSVX) <br /></td></tr>
<tr class="separator:aeb2dae25799a819d691ad4d90328ff5b inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c7998f75d2578f5d2d52e943c9179c inherit pub_methods_classEpetra__LAPACK" id="r_a02c7998f75d2578f5d2d52e943c9179c"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GELS</b> (const char TRANS, const int M, const int N, const int NRHS, double *A, const int LDA, double *B, const int LDB, double *WORK, const int LWORK, int *INFO) const</td></tr>
<tr class="memdesc:a02c7998f75d2578f5d2d52e943c9179c inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> simple driver to solve least-squares systems. <br /></td></tr>
<tr class="separator:a02c7998f75d2578f5d2d52e943c9179c inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5c1715497f6fa23ca1a5aa86ff2aba inherit pub_methods_classEpetra__LAPACK" id="r_a9e5c1715497f6fa23ca1a5aa86ff2aba"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GETRF</b> (const int M, const int N, float *A, const int LDA, int *IPIV, int *INFO) const</td></tr>
<tr class="memdesc:a9e5c1715497f6fa23ca1a5aa86ff2aba inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> factorization for general matrix (SGETRF) <br /></td></tr>
<tr class="separator:a9e5c1715497f6fa23ca1a5aa86ff2aba inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da63416c48424aaa9f794e6c7988713 inherit pub_methods_classEpetra__LAPACK" id="r_a4da63416c48424aaa9f794e6c7988713"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GETRF</b> (const int M, const int N, double *A, const int LDA, int *IPIV, int *INFO) const</td></tr>
<tr class="memdesc:a4da63416c48424aaa9f794e6c7988713 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> factorization for general matrix (DGETRF) <br /></td></tr>
<tr class="separator:a4da63416c48424aaa9f794e6c7988713 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe634fea664d00c09442400ad7b530a2 inherit pub_methods_classEpetra__LAPACK" id="r_afe634fea664d00c09442400ad7b530a2"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEQRF</b> (const int M, const int N, float *A, const int LDA, float *TAU, float *WORK, const int lwork, int *INFO) const</td></tr>
<tr class="memdesc:afe634fea664d00c09442400ad7b530a2 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> QR factorization for general matrix (SGEQRF) <br /></td></tr>
<tr class="separator:afe634fea664d00c09442400ad7b530a2 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840ae3b3d19a18a530da250b6b249eb4 inherit pub_methods_classEpetra__LAPACK" id="r_a840ae3b3d19a18a530da250b6b249eb4"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEQRF</b> (const int M, const int N, double *A, const int LDA, double *TAU, double *WORK, const int lwork, int *INFO) const</td></tr>
<tr class="memdesc:a840ae3b3d19a18a530da250b6b249eb4 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> factorization for general matrix (DGEQRF) <br /></td></tr>
<tr class="separator:a840ae3b3d19a18a530da250b6b249eb4 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef2286af1233fcc0c4bb2152fc613e3 inherit pub_methods_classEpetra__LAPACK" id="r_afef2286af1233fcc0c4bb2152fc613e3"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GETRS</b> (const char TRANS, const int N, const int NRHS, const float *A, const int LDA, const int *IPIV, float *X, const int LDX, int *INFO) const</td></tr>
<tr class="memdesc:afef2286af1233fcc0c4bb2152fc613e3 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> solve (after factorization) for general matrix (SGETRS) <br /></td></tr>
<tr class="separator:afef2286af1233fcc0c4bb2152fc613e3 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6b689b41911ddc9e81ed09e99935e0 inherit pub_methods_classEpetra__LAPACK" id="r_a2c6b689b41911ddc9e81ed09e99935e0"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GETRS</b> (const char TRANS, const int N, const int NRHS, const double *A, const int LDA, const int *IPIV, double *X, const int LDX, int *INFO) const</td></tr>
<tr class="memdesc:a2c6b689b41911ddc9e81ed09e99935e0 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> solve (after factorization) for general matrix (DGETRS) <br /></td></tr>
<tr class="separator:a2c6b689b41911ddc9e81ed09e99935e0 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcea107fbd6c84f292a9c03134e50522 inherit pub_methods_classEpetra__LAPACK" id="r_afcea107fbd6c84f292a9c03134e50522"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GETRI</b> (const int N, float *A, const int LDA, int *IPIV, float *WORK, const int *LWORK, int *INFO) const</td></tr>
<tr class="memdesc:afcea107fbd6c84f292a9c03134e50522 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> inversion for general matrix (SGETRI) <br /></td></tr>
<tr class="separator:afcea107fbd6c84f292a9c03134e50522 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0677f21eb7a810b55f02e38536d23bc inherit pub_methods_classEpetra__LAPACK" id="r_ae0677f21eb7a810b55f02e38536d23bc"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GETRI</b> (const int N, double *A, const int LDA, int *IPIV, double *WORK, const int *LWORK, int *INFO) const</td></tr>
<tr class="memdesc:ae0677f21eb7a810b55f02e38536d23bc inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> inversion for general matrix (DGETRI) <br /></td></tr>
<tr class="separator:ae0677f21eb7a810b55f02e38536d23bc inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1ac9f8fc9bfbc61b907226be7bb71d inherit pub_methods_classEpetra__LAPACK" id="r_a5e1ac9f8fc9bfbc61b907226be7bb71d"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GECON</b> (const char NORM, const int N, const float *A, const int LDA, const float ANORM, float *RCOND, float *WORK, int *IWORK, int *INFO) const</td></tr>
<tr class="memdesc:a5e1ac9f8fc9bfbc61b907226be7bb71d inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> condition number estimator for general matrix (SGECON) <br /></td></tr>
<tr class="separator:a5e1ac9f8fc9bfbc61b907226be7bb71d inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48456f075c945414c006235b5abb2a28 inherit pub_methods_classEpetra__LAPACK" id="r_a48456f075c945414c006235b5abb2a28"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GECON</b> (const char NORM, const int N, const double *A, const int LDA, const double ANORM, double *RCOND, double *WORK, int *IWORK, int *INFO) const</td></tr>
<tr class="memdesc:a48456f075c945414c006235b5abb2a28 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> condition number estimator for general matrix (DGECON) <br /></td></tr>
<tr class="separator:a48456f075c945414c006235b5abb2a28 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbc930f9d2d5d1a5d476b9b3d4cd700 inherit pub_methods_classEpetra__LAPACK" id="r_acfbc930f9d2d5d1a5d476b9b3d4cd700"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GESV</b> (const int N, const int NRHS, float *A, const int LDA, int *IPIV, float *X, const int LDX, int *INFO) const</td></tr>
<tr class="memdesc:acfbc930f9d2d5d1a5d476b9b3d4cd700 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> factor and solve for general matrix (SGESV) <br /></td></tr>
<tr class="separator:acfbc930f9d2d5d1a5d476b9b3d4cd700 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39442ee32cccf5fbfb282f26f0342722 inherit pub_methods_classEpetra__LAPACK" id="r_a39442ee32cccf5fbfb282f26f0342722"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GESV</b> (const int N, const int NRHS, double *A, const int LDA, int *IPIV, double *X, const int LDX, int *INFO) const</td></tr>
<tr class="memdesc:a39442ee32cccf5fbfb282f26f0342722 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> factor and solve for general matrix (DGESV) <br /></td></tr>
<tr class="separator:a39442ee32cccf5fbfb282f26f0342722 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021ba3cfcf891758eb9bba2282a77d48 inherit pub_methods_classEpetra__LAPACK" id="r_a021ba3cfcf891758eb9bba2282a77d48"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEEQU</b> (const int M, const int N, const float *A, const int LDA, float *R, float *C, float *ROWCND, float *COLCND, float *AMAX, int *INFO) const</td></tr>
<tr class="memdesc:a021ba3cfcf891758eb9bba2282a77d48 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> equilibration for general matrix (SGEEQU) <br /></td></tr>
<tr class="separator:a021ba3cfcf891758eb9bba2282a77d48 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab512e11f80c757853ec7eab6aed06152 inherit pub_methods_classEpetra__LAPACK" id="r_ab512e11f80c757853ec7eab6aed06152"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEEQU</b> (const int M, const int N, const double *A, const int LDA, double *R, double *C, double *ROWCND, double *COLCND, double *AMAX, int *INFO) const</td></tr>
<tr class="memdesc:ab512e11f80c757853ec7eab6aed06152 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> equilibration for general matrix (DGEEQU) <br /></td></tr>
<tr class="separator:ab512e11f80c757853ec7eab6aed06152 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999d04d2c6ea980d86a6b256b81355e6 inherit pub_methods_classEpetra__LAPACK" id="r_a999d04d2c6ea980d86a6b256b81355e6"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GERFS</b> (const char TRANS, const int N, const int NRHS, const float *A, const int LDA, const float *AF, const int LDAF, const int *IPIV, const float *B, const int LDB, float *X, const int LDX, float *FERR, float *BERR, float *WORK, int *IWORK, int *INFO) const</td></tr>
<tr class="memdesc:a999d04d2c6ea980d86a6b256b81355e6 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> Refine solution (GERFS) <br /></td></tr>
<tr class="separator:a999d04d2c6ea980d86a6b256b81355e6 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82488b88f711966648edbdfbc5157918 inherit pub_methods_classEpetra__LAPACK" id="r_a82488b88f711966648edbdfbc5157918"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GERFS</b> (const char TRANS, const int N, const int NRHS, const double *A, const int LDA, const double *AF, const int LDAF, const int *IPIV, const double *B, const int LDB, double *X, const int LDX, double *FERR, double *BERR, double *WORK, int *IWORK, int *INFO) const</td></tr>
<tr class="memdesc:a82488b88f711966648edbdfbc5157918 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> Refine solution (GERFS) <br /></td></tr>
<tr class="separator:a82488b88f711966648edbdfbc5157918 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab103cddee009dba8bc6fc0e48ad7ec34 inherit pub_methods_classEpetra__LAPACK" id="r_ab103cddee009dba8bc6fc0e48ad7ec34"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GESVX</b> (const char FACT, const char TRANS, const int N, const int NRHS, float *A, const int LDA, float *AF, const int LDAF, int *IPIV, const char EQUED, float *R, float *C, float *B, const int LDB, float *X, const int LDX, float *RCOND, float *FERR, float *BERR, float *WORK, int *IWORK, int *INFO) const</td></tr>
<tr class="memdesc:ab103cddee009dba8bc6fc0e48ad7ec34 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> solve driver for general matrix (SGESVX) <br /></td></tr>
<tr class="separator:ab103cddee009dba8bc6fc0e48ad7ec34 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f99d343f6e313d9fd43f97f93cd81a inherit pub_methods_classEpetra__LAPACK" id="r_aa8f99d343f6e313d9fd43f97f93cd81a"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GESVX</b> (const char FACT, const char TRANS, const int N, const int NRHS, double *A, const int LDA, double *AF, const int LDAF, int *IPIV, const char EQUED, double *R, double *C, double *B, const int LDB, double *X, const int LDX, double *RCOND, double *FERR, double *BERR, double *WORK, int *IWORK, int *INFO) const</td></tr>
<tr class="memdesc:aa8f99d343f6e313d9fd43f97f93cd81a inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> solve driver for general matrix (DGESVX) <br /></td></tr>
<tr class="separator:aa8f99d343f6e313d9fd43f97f93cd81a inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9c21e93a2258b606e6839ad5eb67c9 inherit pub_methods_classEpetra__LAPACK" id="r_a8e9c21e93a2258b606e6839ad5eb67c9"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEHRD</b> (const int N, const int ILO, const int IHI, float *A, const int LDA, float *TAU, float *WORK, const int LWORK, int *INFO) const</td></tr>
<tr class="memdesc:a8e9c21e93a2258b606e6839ad5eb67c9 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper for reduction to Hessenberg form (SGEHRD) <br /></td></tr>
<tr class="separator:a8e9c21e93a2258b606e6839ad5eb67c9 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f02efa88af25fefdea166e6e0b5108 inherit pub_methods_classEpetra__LAPACK" id="r_a09f02efa88af25fefdea166e6e0b5108"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEHRD</b> (const int N, const int ILO, const int IHI, double *A, const int LDA, double *TAU, double *WORK, const int LWORK, int *INFO) const</td></tr>
<tr class="memdesc:a09f02efa88af25fefdea166e6e0b5108 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper for reduction to Hessenberg form (DGEHRD) <br /></td></tr>
<tr class="separator:a09f02efa88af25fefdea166e6e0b5108 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a53c1e55a3eed18a3121fae63c0bcb inherit pub_methods_classEpetra__LAPACK" id="r_aa6a53c1e55a3eed18a3121fae63c0bcb"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>HSEQR</b> (const char JOB, const char COMPZ, const int N, const int ILO, const int IHI, float *H, const int LDH, float *WR, float *WI, float *Z, const int LDZ, float *WORK, const int LWORK, int *INFO) const</td></tr>
<tr class="memdesc:aa6a53c1e55a3eed18a3121fae63c0bcb inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper for computing the eigenvalues of a real upper Hessenberg matrix (SHSEQR) <br /></td></tr>
<tr class="separator:aa6a53c1e55a3eed18a3121fae63c0bcb inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671200b5b4f6623f49729b6366852664 inherit pub_methods_classEpetra__LAPACK" id="r_a671200b5b4f6623f49729b6366852664"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>HSEQR</b> (const char JOB, const char COMPZ, const int N, const int ILO, const int IHI, double *H, const int LDH, double *WR, double *WI, double *Z, const int LDZ, double *WORK, const int LWORK, int *INFO) const</td></tr>
<tr class="memdesc:a671200b5b4f6623f49729b6366852664 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper for computing the eigenvalues of a real upper Hessenberg matrix (DHSEQR) <br /></td></tr>
<tr class="separator:a671200b5b4f6623f49729b6366852664 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ce9df5ca21223bb9077bcf8b5e101a inherit pub_methods_classEpetra__LAPACK" id="r_a52ce9df5ca21223bb9077bcf8b5e101a"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>ORGQR</b> (const int M, const int N, const int K, float *A, const int LDA, float *TAU, float *WORK, const int LWORK, int *INFO) const</td></tr>
<tr class="memdesc:a52ce9df5ca21223bb9077bcf8b5e101a inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper for generating a m x n real matrix Q with orthonormal columns, defined as the product of k elementary reflectors. (SORGQR) <br /></td></tr>
<tr class="separator:a52ce9df5ca21223bb9077bcf8b5e101a inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee0c131258bf454316a0848570aaa7d inherit pub_methods_classEpetra__LAPACK" id="r_a8ee0c131258bf454316a0848570aaa7d"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>ORGQR</b> (const int M, const int N, const int K, double *A, const int LDA, double *TAU, double *WORK, const int LWORK, int *INFO) const</td></tr>
<tr class="memdesc:a8ee0c131258bf454316a0848570aaa7d inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper for generating a m x n real matrix Q with orthonormal columns, defined as the product of k elementary reflectors. (DORGQR) <br /></td></tr>
<tr class="separator:a8ee0c131258bf454316a0848570aaa7d inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07be652dba16d32c5bc595ccf8aff11 inherit pub_methods_classEpetra__LAPACK" id="r_ad07be652dba16d32c5bc595ccf8aff11"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>ORGHR</b> (const int N, const int ILO, const int IHI, float *A, const int LDA, float *TAU, float *WORK, const int LWORK, int *INFO) const</td></tr>
<tr class="memdesc:ad07be652dba16d32c5bc595ccf8aff11 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper for generating a real orthogonal matrix Q defined by elementary reflectors. (SORGHR) <br /></td></tr>
<tr class="separator:ad07be652dba16d32c5bc595ccf8aff11 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78da1d1c7b6700bfb72c05134d5a92f2 inherit pub_methods_classEpetra__LAPACK" id="r_a78da1d1c7b6700bfb72c05134d5a92f2"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>ORGHR</b> (const int N, const int ILO, const int IHI, double *A, const int LDA, double *TAU, double *WORK, const int LWORK, int *INFO) const</td></tr>
<tr class="memdesc:a78da1d1c7b6700bfb72c05134d5a92f2 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper for generating a real orthogonal matrix Q defined by elementary reflectors. (DORGHR) <br /></td></tr>
<tr class="separator:a78da1d1c7b6700bfb72c05134d5a92f2 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb0f7cf59bb6c6d8404ffe20b79c949 inherit pub_methods_classEpetra__LAPACK" id="r_a1eb0f7cf59bb6c6d8404ffe20b79c949"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>ORMHR</b> (const char SIDE, const char TRANS, const int M, const int N, const int ILO, const int IHI, const float *A, const int LDA, const float *TAU, float *C, const int LDC, float *WORK, const int LWORK, int *INFO) const</td></tr>
<tr class="memdesc:a1eb0f7cf59bb6c6d8404ffe20b79c949 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper for applying an orthogonal matrix in-place (SORMHR) <br /></td></tr>
<tr class="separator:a1eb0f7cf59bb6c6d8404ffe20b79c949 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe98e67964eca1d4705a6da512b8c947 inherit pub_methods_classEpetra__LAPACK" id="r_abe98e67964eca1d4705a6da512b8c947"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>ORMHR</b> (const char SIDE, const char TRANS, const int M, const int N, const int ILO, const int IHI, const double *A, const int LDA, const double *TAU, double *C, const int LDC, double *WORK, const int LWORK, int *INFO) const</td></tr>
<tr class="memdesc:abe98e67964eca1d4705a6da512b8c947 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper for applying an orthogonal matrix in-place (DORMHR) <br /></td></tr>
<tr class="separator:abe98e67964eca1d4705a6da512b8c947 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e63ff48dbd013b9dfb50cee8716f6b inherit pub_methods_classEpetra__LAPACK" id="r_ab8e63ff48dbd013b9dfb50cee8716f6b"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>LARFT</b> (const char DIRECT, const char STOREV, const int N, const int K, double *V, const int LDV, double *TAU, double *T, const int LDT) const</td></tr>
<tr class="memdesc:ab8e63ff48dbd013b9dfb50cee8716f6b inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> for forming the triangular factor of a product of elementary Householder reflectors (SLARFT). <br /></td></tr>
<tr class="separator:ab8e63ff48dbd013b9dfb50cee8716f6b inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c33edf612f7325aecb28c7610317ba inherit pub_methods_classEpetra__LAPACK" id="r_ae6c33edf612f7325aecb28c7610317ba"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>LARFT</b> (const char DIRECT, const char STOREV, const int N, const int K, float *V, const int LDV, float *TAU, float *T, const int LDT) const</td></tr>
<tr class="memdesc:ae6c33edf612f7325aecb28c7610317ba inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> for forming the triangular factor of a product of elementary Householder reflectors (DLARFT). <br /></td></tr>
<tr class="separator:ae6c33edf612f7325aecb28c7610317ba inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43b02077cbea8e9e43ca40602c8c606 inherit pub_methods_classEpetra__LAPACK" id="r_aa43b02077cbea8e9e43ca40602c8c606"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__LAPACK.html#aa43b02077cbea8e9e43ca40602c8c606">TREVC</a> (const char SIDE, const char HOWMNY, int *SELECT, const int N, const float *T, const int LDT, float *VL, const int LDVL, float *VR, const int LDVR, const int MM, int *M, float *WORK, int *INFO) const</td></tr>
<tr class="memdesc:aa43b02077cbea8e9e43ca40602c8c606 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper for computing eigenvectors of a quasi-triangular/triagnular matrix (STREVC)  <br /></td></tr>
<tr class="separator:aa43b02077cbea8e9e43ca40602c8c606 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a47d5bfa823dbfc448e3454ed8824fc inherit pub_methods_classEpetra__LAPACK" id="r_a4a47d5bfa823dbfc448e3454ed8824fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__LAPACK.html#a4a47d5bfa823dbfc448e3454ed8824fc">TREVC</a> (const char SIDE, const char HOWMNY, int *SELECT, const int N, const double *T, const int LDT, double *VL, const int LDVL, double *VR, const int LDVR, const int MM, int *M, double *WORK, int *INFO) const</td></tr>
<tr class="memdesc:a4a47d5bfa823dbfc448e3454ed8824fc inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper for computing eigenvectors of a quasi-triangular/triagnular matrix (DTREVC)  <br /></td></tr>
<tr class="separator:a4a47d5bfa823dbfc448e3454ed8824fc inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a83ee4809e865e14813b869b3954278 inherit pub_methods_classEpetra__LAPACK" id="r_a2a83ee4809e865e14813b869b3954278"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>TREXC</b> (const char COMPQ, const int N, float *T, const int LDT, float *Q, const int LDQ, int IFST, int ILST, float *WORK, int *INFO) const</td></tr>
<tr class="memdesc:a2a83ee4809e865e14813b869b3954278 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper for reordering the real-Schur/Schur factorization of a matrix (STREXC) <br /></td></tr>
<tr class="separator:a2a83ee4809e865e14813b869b3954278 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9b1c2f877ee08a02feb3a07ec025dd inherit pub_methods_classEpetra__LAPACK" id="r_adf9b1c2f877ee08a02feb3a07ec025dd"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>TREXC</b> (const char COMPQ, const int N, double *T, const int LDT, double *Q, const int LDQ, int IFST, int ILST, double *WORK, int *INFO) const</td></tr>
<tr class="memdesc:adf9b1c2f877ee08a02feb3a07ec025dd inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper for reordering the real-Schur/Schur factorization of a matrix (DTREXC) <br /></td></tr>
<tr class="separator:adf9b1c2f877ee08a02feb3a07ec025dd inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81c0c57cdfa11f5dcb35098d9141981 inherit pub_methods_classEpetra__LAPACK" id="r_ab81c0c57cdfa11f5dcb35098d9141981"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GESVD</b> (const char JOBU, const char JOBVT, const int M, const int N, float *A, const int LDA, float *S, float *U, const int LDU, float *VT, const int LDVT, float *WORK, const int *LWORK, int *INFO) const</td></tr>
<tr class="memdesc:ab81c0c57cdfa11f5dcb35098d9141981 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper for computing the singular value decomposition (SGESVD) <br /></td></tr>
<tr class="separator:ab81c0c57cdfa11f5dcb35098d9141981 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7f3124ecb25eec0c2bfa1fc02f7379 inherit pub_methods_classEpetra__LAPACK" id="r_a1c7f3124ecb25eec0c2bfa1fc02f7379"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GESVD</b> (const char JOBU, const char JOBVT, const int M, const int N, double *A, const int LDA, double *S, double *U, const int LDU, double *VT, const int LDVT, double *WORK, const int *LWORK, int *INFO) const</td></tr>
<tr class="memdesc:a1c7f3124ecb25eec0c2bfa1fc02f7379 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper for computing the singular value decomposition (DGESVD) <br /></td></tr>
<tr class="separator:a1c7f3124ecb25eec0c2bfa1fc02f7379 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e166a5dcaa789ec09366dfa227ca6f inherit pub_methods_classEpetra__LAPACK" id="r_a53e166a5dcaa789ec09366dfa227ca6f"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GGSVD</b> (const char JOBU, const char JOBV, const char JOBQ, const int M, const int N, const int P, int *K, int *L, double *A, const int LDA, double *B, const int LDB, double *ALPHA, double *BETA, double *U, const int LDU, double *V, const int LDV, double *Q, const int LDQ, double *WORK, int *IWORK, int *INFO) const</td></tr>
<tr class="memdesc:a53e166a5dcaa789ec09366dfa227ca6f inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to compute the generalized singular value decomposition (GSVD) of an M-by-N real matrix A and P-by-N real matrix B. <br /></td></tr>
<tr class="separator:a53e166a5dcaa789ec09366dfa227ca6f inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d063b8b37e374dbbe28afa94dfa253c inherit pub_methods_classEpetra__LAPACK" id="r_a0d063b8b37e374dbbe28afa94dfa253c"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GGSVD</b> (const char JOBU, const char JOBV, const char JOBQ, const int M, const int N, const int P, int *K, int *L, float *A, const int LDA, float *B, const int LDB, float *ALPHA, float *BETA, float *U, const int LDU, float *V, const int LDV, float *Q, const int LDQ, float *WORK, int *IWORK, int *INFO) const</td></tr>
<tr class="memdesc:a0d063b8b37e374dbbe28afa94dfa253c inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to compute the generalized singular value decomposition (GSVD) of an M-by-N real matrix A and P-by-N real matrix B. <br /></td></tr>
<tr class="separator:a0d063b8b37e374dbbe28afa94dfa253c inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ae540e5633b755239530ca5b61fa96 inherit pub_methods_classEpetra__LAPACK" id="r_ab1ae540e5633b755239530ca5b61fa96"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEEV</b> (const char JOBVL, const char JOBVR, const int N, double *A, const int LDA, double *WR, double *WI, double *VL, const int LDVL, double *VR, const int LDVR, double *WORK, const int LWORK, int *INFO) const</td></tr>
<tr class="memdesc:ab1ae540e5633b755239530ca5b61fa96 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to compute for an N-by-N real nonsymmetric matrix A, the eigenvalues and, optionally, the left and/or right eigenvectors. <br /></td></tr>
<tr class="separator:ab1ae540e5633b755239530ca5b61fa96 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898f0542b51df24a5e31f4ee1e22a528 inherit pub_methods_classEpetra__LAPACK" id="r_a898f0542b51df24a5e31f4ee1e22a528"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEEV</b> (const char JOBVL, const char JOBVR, const int N, float *A, const int LDA, float *WR, float *WI, float *VL, const int LDVL, float *VR, const int LDVR, float *WORK, const int LWORK, int *INFO) const</td></tr>
<tr class="memdesc:a898f0542b51df24a5e31f4ee1e22a528 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to compute for an N-by-N real nonsymmetric matrix A, the eigenvalues and, optionally, the left and/or right eigenvectors. <br /></td></tr>
<tr class="separator:a898f0542b51df24a5e31f4ee1e22a528 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7be0e5e632554a7fbced46efee8c70a inherit pub_methods_classEpetra__LAPACK" id="r_ab7be0e5e632554a7fbced46efee8c70a"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SPEV</b> (const char JOBZ, const char UPLO, const int N, double *AP, double *W, double *Z, int LDZ, double *WORK, int *INFO) const</td></tr>
<tr class="memdesc:ab7be0e5e632554a7fbced46efee8c70a inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to compute all the eigenvalues and, optionally, eigenvectors of a real symmetric matrix A in packed storage. <br /></td></tr>
<tr class="separator:ab7be0e5e632554a7fbced46efee8c70a inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fd3c5946366a7c3b9d7fbd8a7f4e6f inherit pub_methods_classEpetra__LAPACK" id="r_a68fd3c5946366a7c3b9d7fbd8a7f4e6f"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SPEV</b> (const char JOBZ, const char UPLO, const int N, float *AP, float *W, float *Z, int LDZ, float *WORK, int *INFO) const</td></tr>
<tr class="memdesc:a68fd3c5946366a7c3b9d7fbd8a7f4e6f inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to compute all the eigenvalues and, optionally, eigenvectors of a real symmetric matrix A in packed storage. <br /></td></tr>
<tr class="separator:a68fd3c5946366a7c3b9d7fbd8a7f4e6f inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214f5a0acd12248806d50b2a8841bdc3 inherit pub_methods_classEpetra__LAPACK" id="r_a214f5a0acd12248806d50b2a8841bdc3"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SPGV</b> (const int ITYPE, const char JOBZ, const char UPLO, const int N, double *AP, double *BP, double *W, double *Z, const int LDZ, double *WORK, int *INFO) const</td></tr>
<tr class="memdesc:a214f5a0acd12248806d50b2a8841bdc3 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to compute all the eigenvalues and, optionally, the eigenvectors of a real generalized symmetric-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. <br /></td></tr>
<tr class="separator:a214f5a0acd12248806d50b2a8841bdc3 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd954a0ca871f7f4a315921091e82423 inherit pub_methods_classEpetra__LAPACK" id="r_acd954a0ca871f7f4a315921091e82423"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SPGV</b> (const int ITYPE, const char JOBZ, const char UPLO, const int N, float *AP, float *BP, float *W, float *Z, const int LDZ, float *WORK, int *INFO) const</td></tr>
<tr class="memdesc:acd954a0ca871f7f4a315921091e82423 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to compute all the eigenvalues and, optionally, the eigenvectors of a real generalized symmetric-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. <br /></td></tr>
<tr class="separator:acd954a0ca871f7f4a315921091e82423 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062f3c11bd15c36636312dcb1e28e9be inherit pub_methods_classEpetra__LAPACK" id="r_a062f3c11bd15c36636312dcb1e28e9be"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYEV</b> (const char JOBZ, const char UPLO, const int N, double *A, const int LDA, double *W, double *WORK, const int LWORK, int *INFO) const</td></tr>
<tr class="memdesc:a062f3c11bd15c36636312dcb1e28e9be inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to compute all eigenvalues and, optionally, eigenvectors of a real symmetric matrix A. <br /></td></tr>
<tr class="separator:a062f3c11bd15c36636312dcb1e28e9be inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55dc0ffd374e459da84f5cab1af3d708 inherit pub_methods_classEpetra__LAPACK" id="r_a55dc0ffd374e459da84f5cab1af3d708"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYEV</b> (const char JOBZ, const char UPLO, const int N, float *A, const int LDA, float *W, float *WORK, const int LWORK, int *INFO) const</td></tr>
<tr class="memdesc:a55dc0ffd374e459da84f5cab1af3d708 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to compute all eigenvalues and, optionally, eigenvectors of a real symmetric matrix A. <br /></td></tr>
<tr class="separator:a55dc0ffd374e459da84f5cab1af3d708 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df88948496a661af6aa927ca4245b6c inherit pub_methods_classEpetra__LAPACK" id="r_a6df88948496a661af6aa927ca4245b6c"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYEVD</b> (const char JOBZ, const char UPLO, const int N, double *A, const int LDA, double *W, double *WORK, const int LWORK, int *IWORK, const int LIWORK, int *INFO) const</td></tr>
<tr class="memdesc:a6df88948496a661af6aa927ca4245b6c inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to compute all eigenvalues and, optionally, eigenvectors of a real symmetric matrix A. <br /></td></tr>
<tr class="separator:a6df88948496a661af6aa927ca4245b6c inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9836d492d55072acc36f2f9a7b4cc0ac inherit pub_methods_classEpetra__LAPACK" id="r_a9836d492d55072acc36f2f9a7b4cc0ac"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYEVD</b> (const char JOBZ, const char UPLO, const int N, float *A, const int LDA, float *W, float *WORK, const int LWORK, int *IWORK, const int LIWORK, int *INFO) const</td></tr>
<tr class="memdesc:a9836d492d55072acc36f2f9a7b4cc0ac inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to compute all eigenvalues and, optionally, eigenvectors of a real symmetric matrix A. <br /></td></tr>
<tr class="separator:a9836d492d55072acc36f2f9a7b4cc0ac inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d94080e6d75020863d3b3ce1ed0f96 inherit pub_methods_classEpetra__LAPACK" id="r_ac8d94080e6d75020863d3b3ce1ed0f96"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYEVX</b> (const char JOBZ, const char RANGE, const char UPLO, const int N, double *A, const int LDA, const double *VL, const double *VU, const int *IL, const int *IU, const double ABSTOL, int *M, double *W, double *Z, const int LDZ, double *WORK, const int LWORK, int *IWORK, int *IFAIL, int *INFO) const</td></tr>
<tr class="memdesc:ac8d94080e6d75020863d3b3ce1ed0f96 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to compute selected eigenvalues and, optionally, eigenvectors of a real symmetric matrix A. <br /></td></tr>
<tr class="separator:ac8d94080e6d75020863d3b3ce1ed0f96 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be3ea540d0199ee847aef69dbbe30f5 inherit pub_methods_classEpetra__LAPACK" id="r_a1be3ea540d0199ee847aef69dbbe30f5"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYEVX</b> (const char JOBZ, const char RANGE, const char UPLO, const int N, float *A, const int LDA, const float *VL, const float *VU, const int *IL, const int *IU, const float ABSTOL, int *M, float *W, float *Z, const int LDZ, float *WORK, const int LWORK, int *IWORK, int *IFAIL, int *INFO) const</td></tr>
<tr class="memdesc:a1be3ea540d0199ee847aef69dbbe30f5 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to compute selected eigenvalues and, optionally, eigenvectors of a real symmetric matrix A. <br /></td></tr>
<tr class="separator:a1be3ea540d0199ee847aef69dbbe30f5 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d55eccc302380bf5ce960372797d21c inherit pub_methods_classEpetra__LAPACK" id="r_a9d55eccc302380bf5ce960372797d21c"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYGV</b> (const int ITYPE, const char JOBZ, const char UPLO, const int N, double *A, const int LDA, double *B, const int LDB, double *W, double *WORK, const int LWORK, int *INFO) const</td></tr>
<tr class="memdesc:a9d55eccc302380bf5ce960372797d21c inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to compute all the eigenvalues, and optionally, the eigenvectors of a real generalized symmetric-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. <br /></td></tr>
<tr class="separator:a9d55eccc302380bf5ce960372797d21c inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67b0f64f55e95cfc9fd318b4711def8 inherit pub_methods_classEpetra__LAPACK" id="r_af67b0f64f55e95cfc9fd318b4711def8"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYGV</b> (const int ITYPE, const char JOBZ, const char UPLO, const int N, float *A, const int LDA, float *B, const int LDB, float *W, float *WORK, const int LWORK, int *INFO) const</td></tr>
<tr class="memdesc:af67b0f64f55e95cfc9fd318b4711def8 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to compute all the eigenvalues, and optionally, the eigenvectors of a real generalized symmetric-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. <br /></td></tr>
<tr class="separator:af67b0f64f55e95cfc9fd318b4711def8 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8785ce88b4069f1f8dcded9becd9ad0c inherit pub_methods_classEpetra__LAPACK" id="r_a8785ce88b4069f1f8dcded9becd9ad0c"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYGVX</b> (const int ITYPE, const char JOBZ, const char RANGE, const char UPLO, const int N, double *A, const int LDA, double *B, const int LDB, const double *VL, const double *VU, const int *IL, const int *IU, const double ABSTOL, int *M, double *W, double *Z, const int LDZ, double *WORK, const int LWORK, int *IWORK, int *IFAIL, int *INFO) const</td></tr>
<tr class="memdesc:a8785ce88b4069f1f8dcded9becd9ad0c inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to compute selected eigenvalues, and optionally, eigenvectors of a real generalized symmetric-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. <br /></td></tr>
<tr class="separator:a8785ce88b4069f1f8dcded9becd9ad0c inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4f3ca165706ba1c04899c25e6ce153 inherit pub_methods_classEpetra__LAPACK" id="r_a9f4f3ca165706ba1c04899c25e6ce153"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYGVX</b> (const int ITYPE, const char JOBZ, const char RANGE, const char UPLO, const int N, float *A, const int LDA, float *B, const int LDB, const float *VL, const float *VU, const int *IL, const int *IU, const float ABSTOL, int *M, float *W, float *Z, const int LDZ, float *WORK, const int LWORK, int *IWORK, int *IFAIL, int *INFO) const</td></tr>
<tr class="memdesc:a9f4f3ca165706ba1c04899c25e6ce153 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to compute selected eigenvalues, and optionally, eigenvectors of a real generalized symmetric-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. <br /></td></tr>
<tr class="separator:a9f4f3ca165706ba1c04899c25e6ce153 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8d909d382ff389009f2c12ebbdf7ef inherit pub_methods_classEpetra__LAPACK" id="r_a7a8d909d382ff389009f2c12ebbdf7ef"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYEVR</b> (const char JOBZ, const char RANGE, const char UPLO, const int N, double *A, const int LDA, const double *VL, const double *VU, const int *IL, const int *IU, const double ABSTOL, int *M, double *W, double *Z, const int LDZ, int *ISUPPZ, double *WORK, const int LWORK, int *IWORK, const int LIWORK, int *INFO) const</td></tr>
<tr class="memdesc:a7a8d909d382ff389009f2c12ebbdf7ef inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to compute selected eigenvalues and, optionally, eigenvectors of a real symmetric matrix T. <br /></td></tr>
<tr class="separator:a7a8d909d382ff389009f2c12ebbdf7ef inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04a99cb8afdf7479700af4180b4d1a3 inherit pub_methods_classEpetra__LAPACK" id="r_ad04a99cb8afdf7479700af4180b4d1a3"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYEVR</b> (const char JOBZ, const char RANGE, const char UPLO, const int N, float *A, const int LDA, const float *VL, const float *VU, const int *IL, const int *IU, const float ABSTOL, int *M, float *W, float *Z, const int LDZ, int *ISUPPZ, float *WORK, const int LWORK, int *IWORK, const int LIWORK, int *INFO) const</td></tr>
<tr class="memdesc:ad04a99cb8afdf7479700af4180b4d1a3 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to compute selected eigenvalues and, optionally, eigenvectors of a real symmetric matrix T. <br /></td></tr>
<tr class="separator:ad04a99cb8afdf7479700af4180b4d1a3 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678d26ab0cd81ed1e4f18448c5751f56 inherit pub_methods_classEpetra__LAPACK" id="r_a678d26ab0cd81ed1e4f18448c5751f56"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEEVX</b> (const char BALANC, const char JOBVL, const char JOBVR, const char SENSE, const int N, double *A, const int LDA, double *WR, double *WI, double *VL, const int LDVL, double *VR, const int LDVR, int *ILO, int *IHI, double *SCALE, double *ABNRM, double *RCONDE, double *RCONDV, double *WORK, const int LWORK, int *IWORK, int *INFO) const</td></tr>
<tr class="memdesc:a678d26ab0cd81ed1e4f18448c5751f56 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to compute for an N-by-N real nonsymmetric matrix A, the eigenvalues and, optionally, the left and/or right eigenvectors. <br /></td></tr>
<tr class="separator:a678d26ab0cd81ed1e4f18448c5751f56 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c4811ae92395e6bba8fb4970660811 inherit pub_methods_classEpetra__LAPACK" id="r_a45c4811ae92395e6bba8fb4970660811"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEEVX</b> (const char BALANC, const char JOBVL, const char JOBVR, const char SENSE, const int N, float *A, const int LDA, float *WR, float *WI, float *VL, const int LDVL, float *VR, const int LDVR, int *ILO, int *IHI, float *SCALE, float *ABNRM, float *RCONDE, float *RCONDV, float *WORK, const int LWORK, int *IWORK, int *INFO) const</td></tr>
<tr class="memdesc:a45c4811ae92395e6bba8fb4970660811 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to compute for an N-by-N real nonsymmetric matrix A, the eigenvalues and, optionally, the left and/or right eigenvectors. <br /></td></tr>
<tr class="separator:a45c4811ae92395e6bba8fb4970660811 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6aaa06ea8666c125578699145659a1 inherit pub_methods_classEpetra__LAPACK" id="r_a9e6aaa06ea8666c125578699145659a1"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GESDD</b> (const char JOBZ, const int M, const int N, double *A, const int LDA, double *S, double *U, const int LDU, double *VT, const int LDVT, double *WORK, const int LWORK, int *IWORK, int *INFO) const</td></tr>
<tr class="memdesc:a9e6aaa06ea8666c125578699145659a1 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to compute the singular value decomposition (SVD) of a real M-by-N matrix A, optionally computing the left and right singular vectors. <br /></td></tr>
<tr class="separator:a9e6aaa06ea8666c125578699145659a1 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1981659ff956b6f3be58bc323e52f1 inherit pub_methods_classEpetra__LAPACK" id="r_ada1981659ff956b6f3be58bc323e52f1"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GESDD</b> (const char JOBZ, const int M, const int N, float *A, const int LDA, float *S, float *U, const int LDU, float *VT, const int LDVT, float *WORK, const int LWORK, int *IWORK, int *INFO) const</td></tr>
<tr class="memdesc:ada1981659ff956b6f3be58bc323e52f1 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to. <br /></td></tr>
<tr class="separator:ada1981659ff956b6f3be58bc323e52f1 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d506dc23a6b9e57e5fe98023fda411 inherit pub_methods_classEpetra__LAPACK" id="r_a90d506dc23a6b9e57e5fe98023fda411"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GGEV</b> (const char JOBVL, const char JOBVR, const int N, double *A, const int LDA, double *B, const int LDB, double *ALPHAR, double *ALPHAI, double *BETA, double *VL, const int LDVL, double *VR, const int LDVR, double *WORK, const int LWORK, int *INFO) const</td></tr>
<tr class="memdesc:a90d506dc23a6b9e57e5fe98023fda411 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to compute for a pair of N-by-N real nonsymmetric matrices (A,B) the generalized eigenvalues, and optionally, the left and/or right generalized eigenvectors. <br /></td></tr>
<tr class="separator:a90d506dc23a6b9e57e5fe98023fda411 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accca6e03f9988a1f40a092a9df8cdc1b inherit pub_methods_classEpetra__LAPACK" id="r_accca6e03f9988a1f40a092a9df8cdc1b"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GGEV</b> (const char JOBVL, const char JOBVR, const int N, float *A, const int LDA, float *B, const int LDB, float *ALPHAR, float *ALPHAI, float *BETA, float *VL, const int LDVL, float *VR, const int LDVR, float *WORK, const int LWORK, int *INFO) const</td></tr>
<tr class="memdesc:accca6e03f9988a1f40a092a9df8cdc1b inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to compute for a pair of N-by-N real nonsymmetric matrices (A,B) the generalized eigenvalues, and optionally, the left and/or right generalized eigenvectors. <br /></td></tr>
<tr class="separator:accca6e03f9988a1f40a092a9df8cdc1b inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47565711717a87c6cc69bb79465644f inherit pub_methods_classEpetra__LAPACK" id="r_aa47565711717a87c6cc69bb79465644f"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GGLSE</b> (const int M, const int N, const int P, double *A, const int LDA, double *B, const int LDB, double *C, double *D, double *X, double *WORK, const int LWORK, int *INFO) const</td></tr>
<tr class="memdesc:aa47565711717a87c6cc69bb79465644f inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to solve the linear equality-constrained least squares (LSE) problem. <br /></td></tr>
<tr class="separator:aa47565711717a87c6cc69bb79465644f inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5b245d2c358deae1aa387998e2e30a inherit pub_methods_classEpetra__LAPACK" id="r_a7e5b245d2c358deae1aa387998e2e30a"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GGLSE</b> (const int M, const int N, const int P, float *A, const int LDA, float *B, const int LDB, float *C, float *D, float *X, float *WORK, const int LWORK, int *INFO) const</td></tr>
<tr class="memdesc:a7e5b245d2c358deae1aa387998e2e30a inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper to solve the linear equality-constrained least squares (LSE) problem. <br /></td></tr>
<tr class="separator:a7e5b245d2c358deae1aa387998e2e30a inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf2e82ac7720464d7cd614ae1fc8149 inherit pub_methods_classEpetra__LAPACK" id="r_a1cf2e82ac7720464d7cd614ae1fc8149"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>LAMCH</b> (const char CMACH, float &amp;T) const</td></tr>
<tr class="memdesc:a1cf2e82ac7720464d7cd614ae1fc8149 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper for DLAMCH routine. On out, T holds machine double precision floating point characteristics. This information is returned by the Lapack routine. <br /></td></tr>
<tr class="separator:a1cf2e82ac7720464d7cd614ae1fc8149 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83304155bea5e8ed7e111efdfa9010d5 inherit pub_methods_classEpetra__LAPACK" id="r_a83304155bea5e8ed7e111efdfa9010d5"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>LAMCH</b> (const char CMACH, double &amp;T) const</td></tr>
<tr class="memdesc:a83304155bea5e8ed7e111efdfa9010d5 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper for SLAMCH routine. On out, T holds machine single precision floating point characteristics. This information is returned by the Lapack routine. <br /></td></tr>
<tr class="separator:a83304155bea5e8ed7e111efdfa9010d5 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96b1f33f4ea2abd79c3a0bd545ec663 inherit pub_methods_classEpetra__LAPACK" id="r_af96b1f33f4ea2abd79c3a0bd545ec663"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>TRTRS</b> (const char UPLO, const char TRANS, const char DIAG, const int N, const int NRHS, const float *A, const int LDA, float *B, const int LDB, int *INFO) const</td></tr>
<tr class="memdesc:af96b1f33f4ea2abd79c3a0bd545ec663 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper for TRTRS routine. <br /></td></tr>
<tr class="separator:af96b1f33f4ea2abd79c3a0bd545ec663 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5635a7c82a1c7560c35d733482e104a0 inherit pub_methods_classEpetra__LAPACK" id="r_a5635a7c82a1c7560c35d733482e104a0"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>TRTRS</b> (const char UPLO, const char TRANS, const char DIAG, const int N, const int NRHS, const double *A, const int LDA, double *B, const int LDB, int *INFO) const</td></tr>
<tr class="memdesc:a5635a7c82a1c7560c35d733482e104a0 inherit pub_methods_classEpetra__LAPACK"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> wrapper for TRTRS routine. <br /></td></tr>
<tr class="separator:a5635a7c82a1c7560c35d733482e104a0 inherit pub_methods_classEpetra__LAPACK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__Object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__Object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__Object.html">Epetra_Object</a></td></tr>
<tr class="memitem:a7676631aca0d619c4e8d3e877c2b87a2 inherit pub_methods_classEpetra__Object" id="r_a7676631aca0d619c4e8d3e877c2b87a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a7676631aca0d619c4e8d3e877c2b87a2">Epetra_Object</a> (int TracebackModeIn=-1, bool set_label=true)</td></tr>
<tr class="memdesc:a7676631aca0d619c4e8d3e877c2b87a2 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Constructor.  <br /></td></tr>
<tr class="separator:a7676631aca0d619c4e8d3e877c2b87a2 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf156d9c8874a2a455ec305826c7313f inherit pub_methods_classEpetra__Object" id="r_acf156d9c8874a2a455ec305826c7313f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#acf156d9c8874a2a455ec305826c7313f">Epetra_Object</a> (const char *const <a class="el" href="classEpetra__Object.html#a1910d1c04e70ac482f7e377b271f6c26">Label</a>, int TracebackModeIn=-1)</td></tr>
<tr class="memdesc:acf156d9c8874a2a455ec305826c7313f inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Constructor.  <br /></td></tr>
<tr class="separator:acf156d9c8874a2a455ec305826c7313f inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f8bd631f2a97276ea07cea8c9c7057 inherit pub_methods_classEpetra__Object" id="r_ac5f8bd631f2a97276ea07cea8c9c7057"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#ac5f8bd631f2a97276ea07cea8c9c7057">Epetra_Object</a> (const <a class="el" href="classEpetra__Object.html">Epetra_Object</a> &amp;Object)</td></tr>
<tr class="memdesc:ac5f8bd631f2a97276ea07cea8c9c7057 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Copy Constructor.  <br /></td></tr>
<tr class="separator:ac5f8bd631f2a97276ea07cea8c9c7057 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742c256d523738e458d0256f72ba9e4b inherit pub_methods_classEpetra__Object" id="r_a742c256d523738e458d0256f72ba9e4b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a742c256d523738e458d0256f72ba9e4b">~Epetra_Object</a> ()</td></tr>
<tr class="memdesc:a742c256d523738e458d0256f72ba9e4b inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Destructor.  <br /></td></tr>
<tr class="separator:a742c256d523738e458d0256f72ba9e4b inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff5c5266120410acbe6ccb63734b5c8 inherit pub_methods_classEpetra__Object" id="r_a9ff5c5266120410acbe6ccb63734b5c8"><td class="memItemLeft" align="right" valign="top">
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>ReportError</b> (const std::string Message, int ErrorCode) const</td></tr>
<tr class="memdesc:a9ff5c5266120410acbe6ccb63734b5c8 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error reporting method. <br /></td></tr>
<tr class="separator:a9ff5c5266120410acbe6ccb63734b5c8 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049c5235b19bd286f95914b547b9f528 inherit pub_methods_classEpetra__Object" id="r_a049c5235b19bd286f95914b547b9f528"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a049c5235b19bd286f95914b547b9f528">SetLabel</a> (const char *const <a class="el" href="classEpetra__Object.html#a1910d1c04e70ac482f7e377b271f6c26">Label</a>)</td></tr>
<tr class="memdesc:a049c5235b19bd286f95914b547b9f528 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Label definition using char *.  <br /></td></tr>
<tr class="separator:a049c5235b19bd286f95914b547b9f528 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1910d1c04e70ac482f7e377b271f6c26 inherit pub_methods_classEpetra__Object" id="r_a1910d1c04e70ac482f7e377b271f6c26"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a1910d1c04e70ac482f7e377b271f6c26">Label</a> () const</td></tr>
<tr class="memdesc:a1910d1c04e70ac482f7e377b271f6c26 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Label access funtion.  <br /></td></tr>
<tr class="separator:a1910d1c04e70ac482f7e377b271f6c26 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">I/O methods</h2></td></tr>
<tr class="memitem:ad39efb318cc8fe47362364135e44c3d3" id="r_ad39efb318cc8fe47362364135e44c3d3"><td class="memItemLeft" align="right" valign="top"><a id="ad39efb318cc8fe47362364135e44c3d3" name="ad39efb318cc8fe47362364135e44c3d3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Equilibrate_</b></td></tr>
<tr class="separator:ad39efb318cc8fe47362364135e44c3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b61609b30e0642d627ebb6a8d046710" id="r_a5b61609b30e0642d627ebb6a8d046710"><td class="memItemLeft" align="right" valign="top"><a id="a5b61609b30e0642d627ebb6a8d046710" name="a5b61609b30e0642d627ebb6a8d046710"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ShouldEquilibrate_</b></td></tr>
<tr class="separator:a5b61609b30e0642d627ebb6a8d046710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f22a3c9168badfac25e3772eea23ef9" id="r_a7f22a3c9168badfac25e3772eea23ef9"><td class="memItemLeft" align="right" valign="top"><a id="a7f22a3c9168badfac25e3772eea23ef9" name="a7f22a3c9168badfac25e3772eea23ef9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>A_Equilibrated_</b></td></tr>
<tr class="separator:a7f22a3c9168badfac25e3772eea23ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e5ec110a5f6e74bf6f43f466b2db4c" id="r_a19e5ec110a5f6e74bf6f43f466b2db4c"><td class="memItemLeft" align="right" valign="top"><a id="a19e5ec110a5f6e74bf6f43f466b2db4c" name="a19e5ec110a5f6e74bf6f43f466b2db4c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>B_Equilibrated_</b></td></tr>
<tr class="separator:a19e5ec110a5f6e74bf6f43f466b2db4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aab6f6e663cfcd9d83d28e662e4ff79" id="r_a0aab6f6e663cfcd9d83d28e662e4ff79"><td class="memItemLeft" align="right" valign="top"><a id="a0aab6f6e663cfcd9d83d28e662e4ff79" name="a0aab6f6e663cfcd9d83d28e662e4ff79"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Transpose_</b></td></tr>
<tr class="separator:a0aab6f6e663cfcd9d83d28e662e4ff79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ada66b4f617306bc6964d087ed79b9" id="r_a13ada66b4f617306bc6964d087ed79b9"><td class="memItemLeft" align="right" valign="top"><a id="a13ada66b4f617306bc6964d087ed79b9" name="a13ada66b4f617306bc6964d087ed79b9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Factored_</b></td></tr>
<tr class="separator:a13ada66b4f617306bc6964d087ed79b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad0e91563b43ab4f20d198acf9c69d0" id="r_aaad0e91563b43ab4f20d198acf9c69d0"><td class="memItemLeft" align="right" valign="top"><a id="aaad0e91563b43ab4f20d198acf9c69d0" name="aaad0e91563b43ab4f20d198acf9c69d0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>EstimateSolutionErrors_</b></td></tr>
<tr class="separator:aaad0e91563b43ab4f20d198acf9c69d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7916e251cae9a4c103ecb5139d8ad917" id="r_a7916e251cae9a4c103ecb5139d8ad917"><td class="memItemLeft" align="right" valign="top"><a id="a7916e251cae9a4c103ecb5139d8ad917" name="a7916e251cae9a4c103ecb5139d8ad917"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>SolutionErrorsEstimated_</b></td></tr>
<tr class="separator:a7916e251cae9a4c103ecb5139d8ad917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac943d046cac1337a3a4ffd61aaa173f3" id="r_ac943d046cac1337a3a4ffd61aaa173f3"><td class="memItemLeft" align="right" valign="top"><a id="ac943d046cac1337a3a4ffd61aaa173f3" name="ac943d046cac1337a3a4ffd61aaa173f3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Solved_</b></td></tr>
<tr class="separator:ac943d046cac1337a3a4ffd61aaa173f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56b1b008e756cd2ef98c40dbb5e1c12" id="r_ac56b1b008e756cd2ef98c40dbb5e1c12"><td class="memItemLeft" align="right" valign="top"><a id="ac56b1b008e756cd2ef98c40dbb5e1c12" name="ac56b1b008e756cd2ef98c40dbb5e1c12"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Inverted_</b></td></tr>
<tr class="separator:ac56b1b008e756cd2ef98c40dbb5e1c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541327ccba38f40500c64c2206c73ad9" id="r_a541327ccba38f40500c64c2206c73ad9"><td class="memItemLeft" align="right" valign="top"><a id="a541327ccba38f40500c64c2206c73ad9" name="a541327ccba38f40500c64c2206c73ad9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ReciprocalConditionEstimated_</b></td></tr>
<tr class="separator:a541327ccba38f40500c64c2206c73ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5ec218ca86c694320436515465cfde" id="r_afc5ec218ca86c694320436515465cfde"><td class="memItemLeft" align="right" valign="top"><a id="afc5ec218ca86c694320436515465cfde" name="afc5ec218ca86c694320436515465cfde"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>RefineSolution_</b></td></tr>
<tr class="separator:afc5ec218ca86c694320436515465cfde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60fbf23359ab670a8dfaea981051657b" id="r_a60fbf23359ab670a8dfaea981051657b"><td class="memItemLeft" align="right" valign="top"><a id="a60fbf23359ab670a8dfaea981051657b" name="a60fbf23359ab670a8dfaea981051657b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>SolutionRefined_</b></td></tr>
<tr class="separator:a60fbf23359ab670a8dfaea981051657b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03425e37c69a3bcb5bdd640e5270e2b5" id="r_a03425e37c69a3bcb5bdd640e5270e2b5"><td class="memItemLeft" align="right" valign="top"><a id="a03425e37c69a3bcb5bdd640e5270e2b5" name="a03425e37c69a3bcb5bdd640e5270e2b5"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>TRANS_</b></td></tr>
<tr class="separator:a03425e37c69a3bcb5bdd640e5270e2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1946908487ea1a91ffed16ac7a0372f8" id="r_a1946908487ea1a91ffed16ac7a0372f8"><td class="memItemLeft" align="right" valign="top"><a id="a1946908487ea1a91ffed16ac7a0372f8" name="a1946908487ea1a91ffed16ac7a0372f8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>M_</b></td></tr>
<tr class="separator:a1946908487ea1a91ffed16ac7a0372f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af338c64fed8b7918d986d95b80b5449b" id="r_af338c64fed8b7918d986d95b80b5449b"><td class="memItemLeft" align="right" valign="top"><a id="af338c64fed8b7918d986d95b80b5449b" name="af338c64fed8b7918d986d95b80b5449b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>N_</b></td></tr>
<tr class="separator:af338c64fed8b7918d986d95b80b5449b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11de4e43f1ed393ca73a3cbcf687767" id="r_af11de4e43f1ed393ca73a3cbcf687767"><td class="memItemLeft" align="right" valign="top"><a id="af11de4e43f1ed393ca73a3cbcf687767" name="af11de4e43f1ed393ca73a3cbcf687767"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Min_MN_</b></td></tr>
<tr class="separator:af11de4e43f1ed393ca73a3cbcf687767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a5f2c66b8049c5c9ec47408d9d7d4a" id="r_a75a5f2c66b8049c5c9ec47408d9d7d4a"><td class="memItemLeft" align="right" valign="top"><a id="a75a5f2c66b8049c5c9ec47408d9d7d4a" name="a75a5f2c66b8049c5c9ec47408d9d7d4a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>NRHS_</b></td></tr>
<tr class="separator:a75a5f2c66b8049c5c9ec47408d9d7d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc9ed00d6958db73f06b2210719c43e" id="r_acbc9ed00d6958db73f06b2210719c43e"><td class="memItemLeft" align="right" valign="top"><a id="acbc9ed00d6958db73f06b2210719c43e" name="acbc9ed00d6958db73f06b2210719c43e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>LDA_</b></td></tr>
<tr class="separator:acbc9ed00d6958db73f06b2210719c43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a54d9b13bbbfe033a45e08f039dcc3c" id="r_a6a54d9b13bbbfe033a45e08f039dcc3c"><td class="memItemLeft" align="right" valign="top"><a id="a6a54d9b13bbbfe033a45e08f039dcc3c" name="a6a54d9b13bbbfe033a45e08f039dcc3c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>LDAF_</b></td></tr>
<tr class="separator:a6a54d9b13bbbfe033a45e08f039dcc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d18619c8a6789fcafea9061ad75e10f" id="r_a2d18619c8a6789fcafea9061ad75e10f"><td class="memItemLeft" align="right" valign="top"><a id="a2d18619c8a6789fcafea9061ad75e10f" name="a2d18619c8a6789fcafea9061ad75e10f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>LDB_</b></td></tr>
<tr class="separator:a2d18619c8a6789fcafea9061ad75e10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f14bb43442244689971ca377bc82f2" id="r_a62f14bb43442244689971ca377bc82f2"><td class="memItemLeft" align="right" valign="top"><a id="a62f14bb43442244689971ca377bc82f2" name="a62f14bb43442244689971ca377bc82f2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>LDX_</b></td></tr>
<tr class="separator:a62f14bb43442244689971ca377bc82f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4be0ceecd51236911a7ed174e56b7d6" id="r_aa4be0ceecd51236911a7ed174e56b7d6"><td class="memItemLeft" align="right" valign="top"><a id="aa4be0ceecd51236911a7ed174e56b7d6" name="aa4be0ceecd51236911a7ed174e56b7d6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>INFO_</b></td></tr>
<tr class="separator:aa4be0ceecd51236911a7ed174e56b7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022396d140b7168990e030dccf165e4c" id="r_a022396d140b7168990e030dccf165e4c"><td class="memItemLeft" align="right" valign="top"><a id="a022396d140b7168990e030dccf165e4c" name="a022396d140b7168990e030dccf165e4c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>LWORK_</b></td></tr>
<tr class="separator:a022396d140b7168990e030dccf165e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17396fdf3ada7c8b20efc377e815387e" id="r_a17396fdf3ada7c8b20efc377e815387e"><td class="memItemLeft" align="right" valign="top"><a id="a17396fdf3ada7c8b20efc377e815387e" name="a17396fdf3ada7c8b20efc377e815387e"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><b>IPIV_</b></td></tr>
<tr class="separator:a17396fdf3ada7c8b20efc377e815387e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4adf5fe3f4bf1dce07fe5d4f794c46" id="r_aeb4adf5fe3f4bf1dce07fe5d4f794c46"><td class="memItemLeft" align="right" valign="top"><a id="aeb4adf5fe3f4bf1dce07fe5d4f794c46" name="aeb4adf5fe3f4bf1dce07fe5d4f794c46"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><b>IWORK_</b></td></tr>
<tr class="separator:aeb4adf5fe3f4bf1dce07fe5d4f794c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbe61e3db87558527ae0fb5bce1f0a0" id="r_a9cbe61e3db87558527ae0fb5bce1f0a0"><td class="memItemLeft" align="right" valign="top"><a id="a9cbe61e3db87558527ae0fb5bce1f0a0" name="a9cbe61e3db87558527ae0fb5bce1f0a0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>ANORM_</b></td></tr>
<tr class="separator:a9cbe61e3db87558527ae0fb5bce1f0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b4e3fd8574ebee901ddcdcdb13ebae" id="r_ab6b4e3fd8574ebee901ddcdcdb13ebae"><td class="memItemLeft" align="right" valign="top"><a id="ab6b4e3fd8574ebee901ddcdcdb13ebae" name="ab6b4e3fd8574ebee901ddcdcdb13ebae"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>RCOND_</b></td></tr>
<tr class="separator:ab6b4e3fd8574ebee901ddcdcdb13ebae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65bb122adb579df4b99742168e3e97a" id="r_aa65bb122adb579df4b99742168e3e97a"><td class="memItemLeft" align="right" valign="top"><a id="aa65bb122adb579df4b99742168e3e97a" name="aa65bb122adb579df4b99742168e3e97a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>ROWCND_</b></td></tr>
<tr class="separator:aa65bb122adb579df4b99742168e3e97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec73d7a1e80f8847beaafb22b63bf4a" id="r_a2ec73d7a1e80f8847beaafb22b63bf4a"><td class="memItemLeft" align="right" valign="top"><a id="a2ec73d7a1e80f8847beaafb22b63bf4a" name="a2ec73d7a1e80f8847beaafb22b63bf4a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>COLCND_</b></td></tr>
<tr class="separator:a2ec73d7a1e80f8847beaafb22b63bf4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efcac1e66ad8cf759d62a9da59a92d5" id="r_a2efcac1e66ad8cf759d62a9da59a92d5"><td class="memItemLeft" align="right" valign="top"><a id="a2efcac1e66ad8cf759d62a9da59a92d5" name="a2efcac1e66ad8cf759d62a9da59a92d5"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>AMAX_</b></td></tr>
<tr class="separator:a2efcac1e66ad8cf759d62a9da59a92d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481c689c9daabae62a5751e743e145c1" id="r_a481c689c9daabae62a5751e743e145c1"><td class="memItemLeft" align="right" valign="top"><a id="a481c689c9daabae62a5751e743e145c1" name="a481c689c9daabae62a5751e743e145c1"></a>
<a class="el" href="classEpetra__SerialDenseMatrix.html">Epetra_SerialDenseMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Matrix_</b></td></tr>
<tr class="separator:a481c689c9daabae62a5751e743e145c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1ed36be647c7e19d1c2ffc7bf0144b" id="r_add1ed36be647c7e19d1c2ffc7bf0144b"><td class="memItemLeft" align="right" valign="top"><a id="add1ed36be647c7e19d1c2ffc7bf0144b" name="add1ed36be647c7e19d1c2ffc7bf0144b"></a>
<a class="el" href="classEpetra__SerialDenseMatrix.html">Epetra_SerialDenseMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>LHS_</b></td></tr>
<tr class="separator:add1ed36be647c7e19d1c2ffc7bf0144b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ea61ea6e05df655c04bd2ee1f45dda" id="r_a78ea61ea6e05df655c04bd2ee1f45dda"><td class="memItemLeft" align="right" valign="top"><a id="a78ea61ea6e05df655c04bd2ee1f45dda" name="a78ea61ea6e05df655c04bd2ee1f45dda"></a>
<a class="el" href="classEpetra__SerialDenseMatrix.html">Epetra_SerialDenseMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>RHS_</b></td></tr>
<tr class="separator:a78ea61ea6e05df655c04bd2ee1f45dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357ae1997446c840dab9669465a2bf3d" id="r_a357ae1997446c840dab9669465a2bf3d"><td class="memItemLeft" align="right" valign="top"><a id="a357ae1997446c840dab9669465a2bf3d" name="a357ae1997446c840dab9669465a2bf3d"></a>
<a class="el" href="classEpetra__SerialDenseMatrix.html">Epetra_SerialDenseMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Factor_</b></td></tr>
<tr class="separator:a357ae1997446c840dab9669465a2bf3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc8e0b6a9550a9ecc9230ea6841b9f3" id="r_adfc8e0b6a9550a9ecc9230ea6841b9f3"><td class="memItemLeft" align="right" valign="top"><a id="adfc8e0b6a9550a9ecc9230ea6841b9f3" name="adfc8e0b6a9550a9ecc9230ea6841b9f3"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>A_</b></td></tr>
<tr class="separator:adfc8e0b6a9550a9ecc9230ea6841b9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d03577a5b6f45a0b4407e14573cf09b" id="r_a2d03577a5b6f45a0b4407e14573cf09b"><td class="memItemLeft" align="right" valign="top"><a id="a2d03577a5b6f45a0b4407e14573cf09b" name="a2d03577a5b6f45a0b4407e14573cf09b"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>FERR_</b></td></tr>
<tr class="separator:a2d03577a5b6f45a0b4407e14573cf09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae472488048f676bf8d2de41e66eb07c4" id="r_ae472488048f676bf8d2de41e66eb07c4"><td class="memItemLeft" align="right" valign="top"><a id="ae472488048f676bf8d2de41e66eb07c4" name="ae472488048f676bf8d2de41e66eb07c4"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>BERR_</b></td></tr>
<tr class="separator:ae472488048f676bf8d2de41e66eb07c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebb6446bf89d7000f45a6420302d080" id="r_aaebb6446bf89d7000f45a6420302d080"><td class="memItemLeft" align="right" valign="top"><a id="aaebb6446bf89d7000f45a6420302d080" name="aaebb6446bf89d7000f45a6420302d080"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>AF_</b></td></tr>
<tr class="separator:aaebb6446bf89d7000f45a6420302d080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a2f027b16e2735625576c88122440a" id="r_a61a2f027b16e2735625576c88122440a"><td class="memItemLeft" align="right" valign="top"><a id="a61a2f027b16e2735625576c88122440a" name="a61a2f027b16e2735625576c88122440a"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>WORK_</b></td></tr>
<tr class="separator:a61a2f027b16e2735625576c88122440a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6ca5fdc176db5e4fea80a31d3600c3" id="r_aeb6ca5fdc176db5e4fea80a31d3600c3"><td class="memItemLeft" align="right" valign="top"><a id="aeb6ca5fdc176db5e4fea80a31d3600c3" name="aeb6ca5fdc176db5e4fea80a31d3600c3"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>R_</b></td></tr>
<tr class="separator:aeb6ca5fdc176db5e4fea80a31d3600c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5451cbf9a2e3c1ba08842b49c3640a2" id="r_ab5451cbf9a2e3c1ba08842b49c3640a2"><td class="memItemLeft" align="right" valign="top"><a id="ab5451cbf9a2e3c1ba08842b49c3640a2" name="ab5451cbf9a2e3c1ba08842b49c3640a2"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>C_</b></td></tr>
<tr class="separator:ab5451cbf9a2e3c1ba08842b49c3640a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cc5481540e198fa68a85d9211f99cd" id="r_a91cc5481540e198fa68a85d9211f99cd"><td class="memItemLeft" align="right" valign="top"><a id="a91cc5481540e198fa68a85d9211f99cd" name="a91cc5481540e198fa68a85d9211f99cd"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>B_</b></td></tr>
<tr class="separator:a91cc5481540e198fa68a85d9211f99cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7badd77ae69e7771c8ee8baa7263c1" id="r_a4a7badd77ae69e7771c8ee8baa7263c1"><td class="memItemLeft" align="right" valign="top"><a id="a4a7badd77ae69e7771c8ee8baa7263c1" name="a4a7badd77ae69e7771c8ee8baa7263c1"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>X_</b></td></tr>
<tr class="separator:a4a7badd77ae69e7771c8ee8baa7263c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fffcbe6458ce7865c49cd34e339fb1" id="r_ac2fffcbe6458ce7865c49cd34e339fb1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__SerialDenseSolver.html#ac2fffcbe6458ce7865c49cd34e339fb1">Print</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:ac2fffcbe6458ce7865c49cd34e339fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print service methods; defines behavior of ostream &lt;&lt; operator.  <br /></td></tr>
<tr class="separator:ac2fffcbe6458ce7865c49cd34e339fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4034e65e7531a40346fc17360d7ac23c" id="r_a4034e65e7531a40346fc17360d7ac23c"><td class="memItemLeft" align="right" valign="top"><a id="a4034e65e7531a40346fc17360d7ac23c" name="a4034e65e7531a40346fc17360d7ac23c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AllocateWORK</b> ()</td></tr>
<tr class="separator:a4034e65e7531a40346fc17360d7ac23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322e8f701459bfdec4d1ec03313bdae6" id="r_a322e8f701459bfdec4d1ec03313bdae6"><td class="memItemLeft" align="right" valign="top"><a id="a322e8f701459bfdec4d1ec03313bdae6" name="a322e8f701459bfdec4d1ec03313bdae6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AllocateIWORK</b> ()</td></tr>
<tr class="separator:a322e8f701459bfdec4d1ec03313bdae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59bca31c3d3c13f6e4aa97cac7107685" id="r_a59bca31c3d3c13f6e4aa97cac7107685"><td class="memItemLeft" align="right" valign="top"><a id="a59bca31c3d3c13f6e4aa97cac7107685" name="a59bca31c3d3c13f6e4aa97cac7107685"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>InitPointers</b> ()</td></tr>
<tr class="separator:a59bca31c3d3c13f6e4aa97cac7107685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2d45a49d20e2a3ed99d6ca850345a2" id="r_aab2d45a49d20e2a3ed99d6ca850345a2"><td class="memItemLeft" align="right" valign="top"><a id="aab2d45a49d20e2a3ed99d6ca850345a2" name="aab2d45a49d20e2a3ed99d6ca850345a2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeleteArrays</b> ()</td></tr>
<tr class="separator:aab2d45a49d20e2a3ed99d6ca850345a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d48e7dfbc1d4f35154399300f09e80" id="r_ae6d48e7dfbc1d4f35154399300f09e80"><td class="memItemLeft" align="right" valign="top"><a id="ae6d48e7dfbc1d4f35154399300f09e80" name="ae6d48e7dfbc1d4f35154399300f09e80"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ResetMatrix</b> ()</td></tr>
<tr class="separator:ae6d48e7dfbc1d4f35154399300f09e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac272d40f00b30215e7cfb9c95b692f7e" id="r_ac272d40f00b30215e7cfb9c95b692f7e"><td class="memItemLeft" align="right" valign="top"><a id="ac272d40f00b30215e7cfb9c95b692f7e" name="ac272d40f00b30215e7cfb9c95b692f7e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ResetVectors</b> ()</td></tr>
<tr class="separator:ac272d40f00b30215e7cfb9c95b692f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classEpetra__Object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classEpetra__Object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classEpetra__Object.html">Epetra_Object</a></td></tr>
<tr class="memitem:a3e039dae700d04726e0e78d73b69e7f6 inherit pub_static_methods_classEpetra__Object" id="r_a3e039dae700d04726e0e78d73b69e7f6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a3e039dae700d04726e0e78d73b69e7f6">SetTracebackMode</a> (int TracebackModeValue)</td></tr>
<tr class="memdesc:a3e039dae700d04726e0e78d73b69e7f6 inherit pub_static_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the <a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> error traceback report mode.  <br /></td></tr>
<tr class="separator:a3e039dae700d04726e0e78d73b69e7f6 inherit pub_static_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20914bd9b7bb7278ab332415c77ba999 inherit pub_static_methods_classEpetra__Object" id="r_a20914bd9b7bb7278ab332415c77ba999"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><b>GetTracebackMode</b> ()</td></tr>
<tr class="memdesc:a20914bd9b7bb7278ab332415c77ba999 inherit pub_static_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the <a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> error report mode. <br /></td></tr>
<tr class="separator:a20914bd9b7bb7278ab332415c77ba999 inherit pub_static_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661d6081fb13e1b4a4350faa88808f38 inherit pub_static_methods_classEpetra__Object" id="r_a661d6081fb13e1b4a4350faa88808f38"><td class="memItemLeft" align="right" valign="top">
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetTracebackStream</b> ()</td></tr>
<tr class="memdesc:a661d6081fb13e1b4a4350faa88808f38 inherit pub_static_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the output stream for error reporting. <br /></td></tr>
<tr class="separator:a661d6081fb13e1b4a4350faa88808f38 inherit pub_static_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classEpetra__Object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classEpetra__Object')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classEpetra__Object.html">Epetra_Object</a></td></tr>
<tr class="memitem:abcc693a0058b9910543df8c4ae76e5d9 inherit pub_static_attribs_classEpetra__Object" id="r_abcc693a0058b9910543df8c4ae76e5d9"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><b>TracebackMode</b></td></tr>
<tr class="separator:abcc693a0058b9910543df8c4ae76e5d9 inherit pub_static_attribs_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classEpetra__Object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classEpetra__Object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classEpetra__Object.html">Epetra_Object</a></td></tr>
<tr class="memitem:a4e3832c165d22a45d3dd6fecd16d91f4 inherit pro_methods_classEpetra__Object" id="r_a4e3832c165d22a45d3dd6fecd16d91f4"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (const int &amp;x) const</td></tr>
<tr class="separator:a4e3832c165d22a45d3dd6fecd16d91f4 inherit pro_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3f57c8b22b5b0df91400fca8447ab2 inherit pro_methods_classEpetra__Object" id="r_aaa3f57c8b22b5b0df91400fca8447ab2"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (const long long &amp;x) const</td></tr>
<tr class="separator:aaa3f57c8b22b5b0df91400fca8447ab2 inherit pro_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a2fa958fffb21a0479a19956185be1 inherit pro_methods_classEpetra__Object" id="r_ab8a2fa958fffb21a0479a19956185be1"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (const double &amp;x) const</td></tr>
<tr class="separator:ab8a2fa958fffb21a0479a19956185be1 inherit pro_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classEpetra__CompObject"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classEpetra__CompObject')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classEpetra__CompObject.html">Epetra_CompObject</a></td></tr>
<tr class="memitem:a4095552501f59c9dc407185a4944759f inherit pro_attribs_classEpetra__CompObject" id="r_a4095552501f59c9dc407185a4944759f"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classEpetra__Flops.html">Epetra_Flops</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>FlopCounter_</b></td></tr>
<tr class="separator:a4095552501f59c9dc407185a4944759f inherit pro_attribs_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classEpetra__SerialDenseSolver.html" title="Epetra_SerialDenseSolver: A class for solving dense linear problems.">Epetra_SerialDenseSolver</a>: A class for solving dense linear problems. </p>
<p>The <a class="el" href="classEpetra__SerialDenseSolver.html" title="Epetra_SerialDenseSolver: A class for solving dense linear problems.">Epetra_SerialDenseSolver</a> class enables the definition, in terms of <a class="el" href="classEpetra__SerialDenseMatrix.html" title="Epetra_SerialDenseMatrix: A class for constructing and using real double precision general dense matr...">Epetra_SerialDenseMatrix</a> and <a class="el" href="classEpetra__SerialDenseVector.html" title="Epetra_SerialDenseVector: A class for constructing and using dense vectors.">Epetra_SerialDenseVector</a> objects, of a dense linear problem, followed by the solution of that problem via the most sophisticated techniques available in LAPACK.</p>
<p>The <a class="el" href="classEpetra__SerialDenseSolver.html" title="Epetra_SerialDenseSolver: A class for solving dense linear problems.">Epetra_SerialDenseSolver</a> class is intended to provide full-featured support for solving linear problems for general dense rectangular (or square) matrices. It is written on top of BLAS and LAPACK and thus has excellent performance and numerical capabilities. Using this class, one can either perform simple factorizations and solves or apply all the tricks available in LAPACK to get the best possible solution for very ill-conditioned problems.</p>
<p><b><a class="el" href="classEpetra__SerialDenseSolver.html" title="Epetra_SerialDenseSolver: A class for solving dense linear problems.">Epetra_SerialDenseSolver</a> vs. <a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a></b></p>
<p>The <a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> class provides access to most of the same functionality as <a class="el" href="classEpetra__SerialDenseSolver.html" title="Epetra_SerialDenseSolver: A class for solving dense linear problems.">Epetra_SerialDenseSolver</a>. The primary difference is that <a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> is a "thin" layer on top of LAPACK and <a class="el" href="classEpetra__SerialDenseSolver.html" title="Epetra_SerialDenseSolver: A class for solving dense linear problems.">Epetra_SerialDenseSolver</a> attempts to provide easy access to the more sophisticated aspects of solving dense linear and eigensystems. </p><ul>
<li>
When you should use <a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a>: If you are simply looking for a convenient wrapper around the Fortran LAPACK routines and you have a well-conditioned problem, you should probably use <a class="el" href="classEpetra__LAPACK.html" title="Epetra_LAPACK: The Epetra LAPACK Wrapper Class.">Epetra_LAPACK</a> directly. </li>
<li>
<p class="startli">When you should use <a class="el" href="classEpetra__SerialDenseSolver.html" title="Epetra_SerialDenseSolver: A class for solving dense linear problems.">Epetra_SerialDenseSolver</a>: If you want to (or potentially want to) solve ill-conditioned problems or want to work with a more object-oriented interface, you should probably use <a class="el" href="classEpetra__SerialDenseSolver.html" title="Epetra_SerialDenseSolver: A class for solving dense linear problems.">Epetra_SerialDenseSolver</a>.</p>
<p class="endli"></p>
</li>
</ul>
<p><b>Constructing <a class="el" href="classEpetra__SerialDenseSolver.html" title="Epetra_SerialDenseSolver: A class for solving dense linear problems.">Epetra_SerialDenseSolver</a> Objects</b></p>
<p>There is a single <a class="el" href="classEpetra__SerialDenseSolver.html" title="Epetra_SerialDenseSolver: A class for solving dense linear problems.">Epetra_SerialDenseSolver</a> constructor. However, the matrix, right hand side and solution vectors must be set prior to executing most methods in this class.</p>
<p><b>Setting vectors used for linear solves</b></p>
<p>The matrix A, the left hand side X and the right hand side B (when solving AX = B, for X), can be set by appropriate set methods. Each of these three objects must be an <a class="el" href="classEpetra__SerialDenseMatrix.html" title="Epetra_SerialDenseMatrix: A class for constructing and using real double precision general dense matr...">Epetra_SerialDenseMatrix</a> or and <a class="el" href="classEpetra__SerialDenseVector.html" title="Epetra_SerialDenseVector: A class for constructing and using dense vectors.">Epetra_SerialDenseVector</a> object. The set methods are as follows: </p><ul>
<li>
<a class="el" href="classEpetra__SerialDenseSolver.html#a463db09d67b55f002d09b190233782f7" title="Sets the pointers for coefficient matrix.">SetMatrix()</a> - Sets the matrix. </li>
<li>
<a class="el" href="classEpetra__SerialDenseSolver.html#afe1e21cd4c5556318154c30d8ae523eb" title="Sets the pointers for left and right hand side vector(s).">SetVectors()</a> - Sets the left and right hand side vector(s). </li>
</ul>
<p><b>Vector and Utility Functions</b></p>
<p>Once a <a class="el" href="classEpetra__SerialDenseSolver.html" title="Epetra_SerialDenseSolver: A class for solving dense linear problems.">Epetra_SerialDenseSolver</a> is constructed, several mathematical functions can be applied to the object. Specifically: </p><ul>
<li>
Factorizations. </li>
<li>
Solves. </li>
<li>
Condition estimates. </li>
<li>
Equilibration. </li>
<li>
Norms. </li>
</ul>
<p><b>Counting floating point operations </b> The <a class="el" href="classEpetra__SerialDenseSolver.html" title="Epetra_SerialDenseSolver: A class for solving dense linear problems.">Epetra_SerialDenseSolver</a> class has <a class="el" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes.">Epetra_CompObject</a> as a base class. Thus, floating point operations are counted and accumulated in the Epetra_Flop object (if any) that was set using the <a class="el" href="classEpetra__CompObject.html#a665dd8befefacf0e5f188ea8a011bd80" title="Set the internal Epetra_Flops() pointer.">SetFlopCounter()</a> method in the <a class="el" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes.">Epetra_CompObject</a> base class.</p>
<p><b>Strategies for Solving Linear Systems</b> In many cases, linear systems can be accurately solved by simply computing the LU factorization of the matrix and then performing a forward back solve with a given set of right hand side vectors. However, in some instances, the factorization may be very poorly conditioned and this simple approach may not work. In these situations, equilibration and iterative refinement may improve the accuracy, or prevent a breakdown in the factorization.</p>
<p><a class="el" href="classEpetra__SerialDenseSolver.html" title="Epetra_SerialDenseSolver: A class for solving dense linear problems.">Epetra_SerialDenseSolver</a> will use equilibration with the factorization if, once the object is constructed and <em>before</em> it is factored, you call the function FactorWithEquilibration(true) to force equilibration to be used. If you are uncertain if equilibration should be used, you may call the function <a class="el" href="classEpetra__SerialDenseSolver.html#ab3f4036471925643a18538f6e2e663d7" title="Returns true if the LAPACK general rules for equilibration suggest you should equilibrate the system.">ShouldEquilibrate()</a> which will return true if equilibration could possibly help. <a class="el" href="classEpetra__SerialDenseSolver.html#ab3f4036471925643a18538f6e2e663d7" title="Returns true if the LAPACK general rules for equilibration suggest you should equilibrate the system.">ShouldEquilibrate()</a> uses guidelines specified in the LAPACK User Guide, namely if SCOND &lt; 0.1 and AMAX &lt; Underflow or AMAX &gt; Overflow, to determine if equilibration <em>might</em> be useful.</p>
<p><a class="el" href="classEpetra__SerialDenseSolver.html" title="Epetra_SerialDenseSolver: A class for solving dense linear problems.">Epetra_SerialDenseSolver</a> will use iterative refinement after a forward/back solve if you call SolveToRefinedSolution(true). It will also compute forward and backward error estimates if you call EstimateSolutionErrors(true). Access to the forward (back) error estimates is available via <a class="el" href="classEpetra__SerialDenseSolver.html#a9a9179c0e5e26d4d64eae884c0414bf1" title="Returns a pointer to the forward error estimates computed by LAPACK.">FERR()</a> (<a class="el" href="classEpetra__SerialDenseSolver.html#af4bc8ca9e4d861641f75c5eaa09f3b97" title="Returns a pointer to the backward error estimates computed by LAPACK.">BERR()</a>).</p>
<p>Examples using <a class="el" href="classEpetra__SerialDenseSolver.html" title="Epetra_SerialDenseSolver: A class for solving dense linear problems.">Epetra_SerialDenseSolver</a> can be found in the Epetra test directories. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a209dd8f5f17fd31fa1b1fb68ce460949" name="a209dd8f5f17fd31fa1b1fb68ce460949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a209dd8f5f17fd31fa1b1fb68ce460949">&#9670;&#160;</a></span>ApplyRefinement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Epetra_SerialDenseSolver::ApplyRefinement </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply Iterative Refinement. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. Otherwise returns the LAPACK error code INFO. </dd></dl>

<p>Reimplemented in <a class="el" href="classEpetra__SerialSpdDenseSolver.html#aee6ec9b1614f5debe082e69ab67a88f8">Epetra_SerialSpdDenseSolver</a>.</p>

</div>
</div>
<a id="a4066d83138fe4231ae093a5e05cdba49" name="a4066d83138fe4231ae093a5e05cdba49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4066d83138fe4231ae093a5e05cdba49">&#9670;&#160;</a></span>COLCND()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Epetra_SerialDenseSolver::COLCND </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ratio of smallest to largest column scale factors for the <em>this</em> matrix (returns -1 if not yet computed). </p>
<p>If <a class="el" href="classEpetra__SerialDenseSolver.html#a4066d83138fe4231ae093a5e05cdba49" title="Ratio of smallest to largest column scale factors for the this matrix (returns -1 if not yet computed...">COLCND()</a> is &gt;= 0.1 then equilibration is not needed. </p>

</div>
</div>
<a id="ab065e5331fc78f5998e393a7e057d764" name="ab065e5331fc78f5998e393a7e057d764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab065e5331fc78f5998e393a7e057d764">&#9670;&#160;</a></span>ComputeEquilibrateScaling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Epetra_SerialDenseSolver::ComputeEquilibrateScaling </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the scaling vector S(i) = 1/sqrt(A(i,i)) of the <em>this</em> matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. Otherwise returns the LAPACK error code INFO. </dd></dl>

<p>Reimplemented in <a class="el" href="classEpetra__SerialSpdDenseSolver.html#a88f6d517ce1cc713582909b24be90b79">Epetra_SerialSpdDenseSolver</a>.</p>

<p class="reference">Referenced by <a class="el" href="classEpetra__SerialSpdDenseSolver.html#a3d7ecb7ae8a09d915c3b270a90511c0e">Epetra_SerialSpdDenseSolver::ShouldEquilibrate()</a>.</p>

</div>
</div>
<a id="a24d4ad5af1bf4e0dd7463676bbfdf004" name="a24d4ad5af1bf4e0dd7463676bbfdf004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d4ad5af1bf4e0dd7463676bbfdf004">&#9670;&#160;</a></span>EquilibrateMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Epetra_SerialDenseSolver::EquilibrateMatrix </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equilibrates the <em>this</em> matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. Otherwise returns the LAPACK error code INFO. </dd></dl>

<p>Reimplemented in <a class="el" href="classEpetra__SerialSpdDenseSolver.html#a66fba56ebbf12230e5e3445e545b804c">Epetra_SerialSpdDenseSolver</a>.</p>

</div>
</div>
<a id="a251e7d0664d55ad25376adf81a12e41a" name="a251e7d0664d55ad25376adf81a12e41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251e7d0664d55ad25376adf81a12e41a">&#9670;&#160;</a></span>EquilibrateRHS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_SerialDenseSolver::EquilibrateRHS </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equilibrates the current RHS. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. Otherwise returns the LAPACK error code INFO. </dd></dl>

</div>
</div>
<a id="a686f12671fd1fae79a58b71324d4fc78" name="a686f12671fd1fae79a58b71324d4fc78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a686f12671fd1fae79a58b71324d4fc78">&#9670;&#160;</a></span>EstimateSolutionErrors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Epetra_SerialDenseSolver::EstimateSolutionErrors </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>Flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes all solves to estimate the forward and backward solution error. </p>
<p>Error estimates will be in the arrays FERR and BERR, resp, after the solve step is complete. These arrays are accessible via the <a class="el" href="classEpetra__SerialDenseSolver.html#a9a9179c0e5e26d4d64eae884c0414bf1" title="Returns a pointer to the forward error estimates computed by LAPACK.">FERR()</a> and <a class="el" href="classEpetra__SerialDenseSolver.html#af4bc8ca9e4d861641f75c5eaa09f3b97" title="Returns a pointer to the backward error estimates computed by LAPACK.">BERR()</a> access functions. </p>

</div>
</div>
<a id="a045cb0339c25fa35a6c0012a5cdea53a" name="a045cb0339c25fa35a6c0012a5cdea53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045cb0339c25fa35a6c0012a5cdea53a">&#9670;&#160;</a></span>Factor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Epetra_SerialDenseSolver::Factor </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the in-place LU factorization of the matrix using the LAPACK routine <em>DGETRF</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

<p>Reimplemented in <a class="el" href="classEpetra__SerialSpdDenseSolver.html#a3128531231c288e62c50d4fa93b74560">Epetra_SerialSpdDenseSolver</a>.</p>

</div>
</div>
<a id="afdcdce6b9d0a5eabbb3f2646675beb64" name="afdcdce6b9d0a5eabbb3f2646675beb64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdcdce6b9d0a5eabbb3f2646675beb64">&#9670;&#160;</a></span>FactorWithEquilibration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Epetra_SerialDenseSolver::FactorWithEquilibration </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>Flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Causes equilibration to be called just before the matrix factorization as part of the call to Factor. </p>
<p>This function must be called before the factorization is performed. </p>

</div>
</div>
<a id="a86ea2457127bc5f26d3088962ae48a3f" name="a86ea2457127bc5f26d3088962ae48a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ea2457127bc5f26d3088962ae48a3f">&#9670;&#160;</a></span>Invert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Epetra_SerialDenseSolver::Invert </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverts the <em>this</em> matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. Otherwise returns the LAPACK error code INFO. </dd></dl>

<p>Reimplemented in <a class="el" href="classEpetra__SerialSpdDenseSolver.html#a1d283c8f86e592c5e6d536b75fd3cf10">Epetra_SerialSpdDenseSolver</a>.</p>

</div>
</div>
<a id="ac2fffcbe6458ce7865c49cd34e339fb1" name="ac2fffcbe6458ce7865c49cd34e339fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2fffcbe6458ce7865c49cd34e339fb1">&#9670;&#160;</a></span>Print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Epetra_SerialDenseSolver::Print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print service methods; defines behavior of ostream &lt;&lt; operator. </p>

<p>Reimplemented from <a class="el" href="classEpetra__Object.html#af40e8f4c7d6701b84f741d3158db7c37">Epetra_Object</a>.</p>

</div>
</div>
<a id="a3d5c288ff50d1c4bd4b0dbcfe49392f1" name="a3d5c288ff50d1c4bd4b0dbcfe49392f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d5c288ff50d1c4bd4b0dbcfe49392f1">&#9670;&#160;</a></span>ReciprocalConditionEstimate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Epetra_SerialDenseSolver::ReciprocalConditionEstimate </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the reciprocal of the 1-norm condition number of the <em>this</em> matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>Out On return contains the reciprocal of the 1-norm condition number of the <em>this</em> matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. Otherwise returns the LAPACK error code INFO. </dd></dl>

<p>Reimplemented in <a class="el" href="classEpetra__SerialSpdDenseSolver.html#ab1978ff963c5afc0dee6997ff37cdd5c">Epetra_SerialSpdDenseSolver</a>.</p>

</div>
</div>
<a id="a763529576ae9537c316e97bc936f8b67" name="a763529576ae9537c316e97bc936f8b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763529576ae9537c316e97bc936f8b67">&#9670;&#160;</a></span>ROWCND()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Epetra_SerialDenseSolver::ROWCND </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ratio of smallest to largest row scale factors for the <em>this</em> matrix (returns -1 if not yet computed). </p>
<p>If <a class="el" href="classEpetra__SerialDenseSolver.html#a763529576ae9537c316e97bc936f8b67" title="Ratio of smallest to largest row scale factors for the this matrix (returns -1 if not yet computed).">ROWCND()</a> is &gt;= 0.1 and <a class="el" href="classEpetra__SerialDenseSolver.html#a3cdec9d37be1d2921c7fa51c9b0edbfb" title="Returns the absolute value of the largest entry of the this matrix (returns -1 if not yet computed).">AMAX()</a> is not close to overflow or underflow, then equilibration is not needed. </p>

</div>
</div>
<a id="afe1e21cd4c5556318154c30d8ae523eb" name="afe1e21cd4c5556318154c30d8ae523eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1e21cd4c5556318154c30d8ae523eb">&#9670;&#160;</a></span>SetVectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_SerialDenseSolver::SetVectors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEpetra__SerialDenseMatrix.html">Epetra_SerialDenseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEpetra__SerialDenseMatrix.html">Epetra_SerialDenseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the pointers for left and right hand side vector(s). </p>
<p>Row dimension of X must match column dimension of matrix A, row dimension of B must match row dimension of A. X and B must have the same dimensions. </p>

</div>
</div>
<a id="ab3f4036471925643a18538f6e2e663d7" name="ab3f4036471925643a18538f6e2e663d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f4036471925643a18538f6e2e663d7">&#9670;&#160;</a></span>ShouldEquilibrate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Epetra_SerialDenseSolver::ShouldEquilibrate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the LAPACK general rules for equilibration suggest you should equilibrate the system. </p>

<p>Reimplemented in <a class="el" href="classEpetra__SerialSpdDenseSolver.html#a3d7ecb7ae8a09d915c3b270a90511c0e">Epetra_SerialSpdDenseSolver</a>.</p>

</div>
</div>
<a id="a62ecf069e7e65a6c996add51524902eb" name="a62ecf069e7e65a6c996add51524902eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ecf069e7e65a6c996add51524902eb">&#9670;&#160;</a></span>Solve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Epetra_SerialDenseSolver::Solve </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the solution X to AX = B for the <em>this</em> matrix and the B provided to <a class="el" href="classEpetra__SerialDenseSolver.html#afe1e21cd4c5556318154c30d8ae523eb" title="Sets the pointers for left and right hand side vector(s).">SetVectors()</a>.. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

<p>Reimplemented in <a class="el" href="classEpetra__SerialSpdDenseSolver.html#a2e51d87a26883e761884b62462ff1eba">Epetra_SerialSpdDenseSolver</a>.</p>

</div>
</div>
<a id="a83f21e67939c7f1f4e63a66e1221cdf3" name="a83f21e67939c7f1f4e63a66e1221cdf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f21e67939c7f1f4e63a66e1221cdf3">&#9670;&#160;</a></span>UnequilibrateLHS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_SerialDenseSolver::UnequilibrateLHS </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unscales the solution vectors if equilibration was used to solve the system. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. Otherwise returns the LAPACK error code INFO. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><b>Epetra_SerialDenseSolver.h</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
