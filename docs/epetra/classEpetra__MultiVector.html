<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Epetra: Epetra_MultiVector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Epetra<span id="projectnumber">&#160;Development</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classEpetra__MultiVector-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Epetra_MultiVector Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a>: A class for constructing and using dense multi-vectors, vectors and matrices in parallel.  
 <a href="classEpetra__MultiVector.html#details">More...</a></p>

<p><code>#include &lt;Epetra_MultiVector.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Epetra_MultiVector:</div>
<div class="dyncontent">
<div class="center"><img src="classEpetra__MultiVector__inherit__graph.gif" border="0" usemap="#aEpetra__MultiVector_inherit__map" alt="Inheritance graph"/></div>
<map name="aEpetra__MultiVector_inherit__map" id="aEpetra__MultiVector_inherit__map">
<area shape="rect" title="Epetra_MultiVector: A class for constructing and using dense multi&#45;vectors, vectors and matrices in p..." alt="" coords="239,152,384,177"/>
<area shape="rect" href="classEpetra__FEVector.html" title=" " alt="" coords="71,225,199,251"/>
<area shape="poly" title=" " alt="" coords="271,185,165,228,163,223,269,180"/>
<area shape="rect" href="classEpetra__OskiMultiVector.html" title="Epetra_OskiMultiVector: A class for constructing and using dense Oski multi&#45;vectors on a single proce..." alt="" coords="224,225,399,251"/>
<area shape="poly" title=" " alt="" coords="314,191,314,225,309,225,309,191"/>
<area shape="rect" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer." alt="" coords="423,225,535,251"/>
<area shape="poly" title=" " alt="" coords="352,180,453,223,451,228,350,185"/>
<area shape="rect" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi&#45;vectors, vectors and matrices in pa..." alt="" coords="73,79,211,104"/>
<area shape="poly" title=" " alt="" coords="183,107,285,149,283,154,181,112"/>
<area shape="rect" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class." alt="" coords="5,5,119,31"/>
<area shape="poly" title=" " alt="" coords="87,38,131,76,127,80,83,42"/>
<area shape="rect" href="classEpetra__SrcDistObject.html" title="Epetra_SrcDistObject: A class for supporting flexible source distributed objects for import/export op..." alt="" coords="143,5,301,31"/>
<area shape="poly" title=" " alt="" coords="201,42,157,80,153,76,197,38"/>
<area shape="rect" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes." alt="" coords="236,79,387,104"/>
<area shape="poly" title=" " alt="" coords="314,118,314,152,309,152,309,118"/>
<area shape="rect" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class." alt="" coords="411,79,516,104"/>
<area shape="poly" title=" " alt="" coords="428,112,337,154,335,149,426,107"/>
<area shape="rect" href="classEpetra__OskiVector.html" title="Epetra_OskiVector: A class for constructing and using dense OSKI vectors on a single processor or a s..." alt="" coords="241,299,382,324"/>
<area shape="poly" title=" " alt="" coords="314,264,314,299,309,299,309,264"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Epetra_MultiVector:</div>
<div class="dyncontent">
<div class="center"><img src="classEpetra__MultiVector__coll__graph.gif" border="0" usemap="#aEpetra__MultiVector_coll__map" alt="Collaboration graph"/></div>
<map name="aEpetra__MultiVector_coll__map" id="aEpetra__MultiVector_coll__map">
<area shape="rect" title="Epetra_MultiVector: A class for constructing and using dense multi&#45;vectors, vectors and matrices in p..." alt="" coords="497,331,643,356"/>
<area shape="rect" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi&#45;vectors, vectors and matrices in pa..." alt="" coords="269,256,407,281"/>
<area shape="poly" title=" " alt="" coords="388,283,534,328,533,333,387,288"/>
<area shape="rect" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class." alt="" coords="5,80,119,105"/>
<area shape="poly" title=" " alt="" coords="64,119,70,157,78,175,89,191,129,222,175,243,223,256,269,262,268,268,222,261,173,248,126,227,85,195,73,178,65,158,59,120"/>
<area shape="rect" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices." alt="" coords="100,168,235,193"/>
<area shape="poly" title=" " alt="" coords="88,112,155,166,151,170,85,116"/>
<area shape="rect" href="classEpetra__SrcDistObject.html" title="Epetra_SrcDistObject: A class for supporting flexible source distributed objects for import/export op..." alt="" coords="259,168,417,193"/>
<area shape="poly" title=" " alt="" coords="341,207,341,255,335,255,335,207"/>
<area shape="poly" title=" " alt="" coords="204,197,316,253,314,258,201,202"/>
<area shape="rect" href="classEpetra__BlockMapData.html" title="Epetra_BlockMapData: The Epetra BlockMap Data Class." alt="" coords="143,80,309,105"/>
<area shape="poly" title=" " alt="" coords="213,118,178,169,173,166,208,115"/>
<area shape="rect" href="classEpetra__Data.html" title="Epetra_Data: The Epetra Base Data Class." alt="" coords="175,5,277,31"/>
<area shape="poly" title=" " alt="" coords="229,45,229,80,223,80,223,45"/>
<area shape="rect" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class." alt="" coords="442,168,557,193"/>
<area shape="poly" title=" " alt="" coords="467,202,361,258,359,253,464,198"/>
<area shape="rect" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes." alt="" coords="495,256,645,281"/>
<area shape="poly" title=" " alt="" coords="573,296,573,330,567,330,567,296"/>
<area shape="rect" href="classEpetra__Flops.html" title="Epetra_Flops: The Epetra Floating Point Operations Class." alt="" coords="581,168,687,193"/>
<area shape="poly" title=" " alt="" coords="619,206,581,257,577,254,615,203"/>
<area shape="rect" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class." alt="" coords="669,256,775,281"/>
<area shape="poly" title=" " alt="" coords="687,290,595,333,593,328,685,285"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors/destructors</div></td></tr>
<tr class="memitem:aff75bed4ad99508ed7319460fe749d7c" id="r_aff75bed4ad99508ed7319460fe749d7c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#aff75bed4ad99508ed7319460fe749d7c">Epetra_MultiVector</a> (const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;<a class="el" href="classEpetra__DistObject.html#a00702a53a4a8142f249639d254e760cd">Map</a>, int <a class="el" href="classEpetra__MultiVector.html#a1d29dedcbf070b11dfda5eb043c90b85">NumVectors</a>, bool zeroOut=true)</td></tr>
<tr class="memdesc:aff75bed4ad99508ed7319460fe749d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> constuctor.  <br /></td></tr>
<tr class="separator:aff75bed4ad99508ed7319460fe749d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30d44b8a9a960ea5ab5297e30319290" id="r_ab30d44b8a9a960ea5ab5297e30319290"><td class="memItemLeft" align="right" valign="top"><a id="ab30d44b8a9a960ea5ab5297e30319290" name="ab30d44b8a9a960ea5ab5297e30319290"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_MultiVector</b> (const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;Source)</td></tr>
<tr class="memdesc:ab30d44b8a9a960ea5ab5297e30319290"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> copy constructor. <br /></td></tr>
<tr class="separator:ab30d44b8a9a960ea5ab5297e30319290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39dd3af2515fd65193ccd0a21d02740f" id="r_a39dd3af2515fd65193ccd0a21d02740f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#a39dd3af2515fd65193ccd0a21d02740f">Epetra_MultiVector</a> (<a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a> CV, const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;<a class="el" href="classEpetra__DistObject.html#a00702a53a4a8142f249639d254e760cd">Map</a>, double *A, int MyLDA, int <a class="el" href="classEpetra__MultiVector.html#a1d29dedcbf070b11dfda5eb043c90b85">NumVectors</a>)</td></tr>
<tr class="memdesc:a39dd3af2515fd65193ccd0a21d02740f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set multi-vector values from two-dimensional array.  <br /></td></tr>
<tr class="separator:a39dd3af2515fd65193ccd0a21d02740f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17605f4bf2fd5967169be3b4b56004df" id="r_a17605f4bf2fd5967169be3b4b56004df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#a17605f4bf2fd5967169be3b4b56004df">Epetra_MultiVector</a> (<a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a> CV, const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;<a class="el" href="classEpetra__DistObject.html#a00702a53a4a8142f249639d254e760cd">Map</a>, double **ArrayOfPointers, int <a class="el" href="classEpetra__MultiVector.html#a1d29dedcbf070b11dfda5eb043c90b85">NumVectors</a>)</td></tr>
<tr class="memdesc:a17605f4bf2fd5967169be3b4b56004df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set multi-vector values from array of pointers.  <br /></td></tr>
<tr class="separator:a17605f4bf2fd5967169be3b4b56004df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996dbd09376c8eea018e8467b977f282" id="r_a996dbd09376c8eea018e8467b977f282"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#a996dbd09376c8eea018e8467b977f282">Epetra_MultiVector</a> (<a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a> CV, const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;Source, int *Indices, int <a class="el" href="classEpetra__MultiVector.html#a1d29dedcbf070b11dfda5eb043c90b85">NumVectors</a>)</td></tr>
<tr class="memdesc:a996dbd09376c8eea018e8467b977f282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set multi-vector values from list of vectors in an existing <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a>.  <br /></td></tr>
<tr class="separator:a996dbd09376c8eea018e8467b977f282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca53de28aec32b9c35b5e96a8c7e2503" id="r_aca53de28aec32b9c35b5e96a8c7e2503"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#aca53de28aec32b9c35b5e96a8c7e2503">Epetra_MultiVector</a> (<a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a> CV, const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;Source, int StartIndex, int <a class="el" href="classEpetra__MultiVector.html#a1d29dedcbf070b11dfda5eb043c90b85">NumVectors</a>)</td></tr>
<tr class="memdesc:aca53de28aec32b9c35b5e96a8c7e2503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set multi-vector values from range of vectors in an existing <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a>.  <br /></td></tr>
<tr class="separator:aca53de28aec32b9c35b5e96a8c7e2503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab338d877d985275b9eb9d6676d0c85f8" id="r_ab338d877d985275b9eb9d6676d0c85f8"><td class="memItemLeft" align="right" valign="top"><a id="ab338d877d985275b9eb9d6676d0c85f8" name="ab338d877d985275b9eb9d6676d0c85f8"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_MultiVector</b> ()</td></tr>
<tr class="memdesc:ab338d877d985275b9eb9d6676d0c85f8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> destructor. <br /></td></tr>
<tr class="separator:ab338d877d985275b9eb9d6676d0c85f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Post-construction modification routines</div></td></tr>
<tr class="memitem:a74947cc0e0550e2f8c1c03b0135e263a" id="r_a74947cc0e0550e2f8c1c03b0135e263a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#a74947cc0e0550e2f8c1c03b0135e263a">ReplaceGlobalValue</a> (int GlobalRow, int VectorIndex, double ScalarValue)</td></tr>
<tr class="memdesc:a74947cc0e0550e2f8c1c03b0135e263a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace current value at the specified (GlobalRow, VectorIndex) location with ScalarValue.  <br /></td></tr>
<tr class="separator:a74947cc0e0550e2f8c1c03b0135e263a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfc20129e42f61650cb4dfe907b5a4d" id="r_adbfc20129e42f61650cb4dfe907b5a4d"><td class="memItemLeft" align="right" valign="top"><a id="adbfc20129e42f61650cb4dfe907b5a4d" name="adbfc20129e42f61650cb4dfe907b5a4d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ReplaceGlobalValue</b> (long long GlobalRow, int VectorIndex, double ScalarValue)</td></tr>
<tr class="separator:adbfc20129e42f61650cb4dfe907b5a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af303f5ac189b48e723b5dcf44885d5ea" id="r_af303f5ac189b48e723b5dcf44885d5ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#af303f5ac189b48e723b5dcf44885d5ea">ReplaceGlobalValue</a> (int GlobalBlockRow, int BlockRowOffset, int VectorIndex, double ScalarValue)</td></tr>
<tr class="memdesc:af303f5ac189b48e723b5dcf44885d5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace current value at the specified (GlobalBlockRow, BlockRowOffset, VectorIndex) location with ScalarValue.  <br /></td></tr>
<tr class="separator:af303f5ac189b48e723b5dcf44885d5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963c53d87b4bf8dc53812c2a28fa7c13" id="r_a963c53d87b4bf8dc53812c2a28fa7c13"><td class="memItemLeft" align="right" valign="top"><a id="a963c53d87b4bf8dc53812c2a28fa7c13" name="a963c53d87b4bf8dc53812c2a28fa7c13"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ReplaceGlobalValue</b> (long long GlobalBlockRow, int BlockRowOffset, int VectorIndex, double ScalarValue)</td></tr>
<tr class="separator:a963c53d87b4bf8dc53812c2a28fa7c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f414bce90344534f2cd097017e30fc" id="r_a37f414bce90344534f2cd097017e30fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#a37f414bce90344534f2cd097017e30fc">SumIntoGlobalValue</a> (int GlobalRow, int VectorIndex, double ScalarValue)</td></tr>
<tr class="memdesc:a37f414bce90344534f2cd097017e30fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds ScalarValue to existing value at the specified (GlobalRow, VectorIndex) location.  <br /></td></tr>
<tr class="separator:a37f414bce90344534f2cd097017e30fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52da9ffcc480081c1c19af38231d9460" id="r_a52da9ffcc480081c1c19af38231d9460"><td class="memItemLeft" align="right" valign="top"><a id="a52da9ffcc480081c1c19af38231d9460" name="a52da9ffcc480081c1c19af38231d9460"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>SumIntoGlobalValue</b> (long long GlobalRow, int VectorIndex, double ScalarValue)</td></tr>
<tr class="separator:a52da9ffcc480081c1c19af38231d9460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80cf18d7ae082772ff6921d20a48579" id="r_af80cf18d7ae082772ff6921d20a48579"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#af80cf18d7ae082772ff6921d20a48579">SumIntoGlobalValue</a> (int GlobalBlockRow, int BlockRowOffset, int VectorIndex, double ScalarValue)</td></tr>
<tr class="memdesc:af80cf18d7ae082772ff6921d20a48579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds ScalarValue to existing value at the specified (GlobalBlockRow, BlockRowOffset, VectorIndex) location.  <br /></td></tr>
<tr class="separator:af80cf18d7ae082772ff6921d20a48579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efbc0e53c85d57908a1d893ade42fa5" id="r_a8efbc0e53c85d57908a1d893ade42fa5"><td class="memItemLeft" align="right" valign="top"><a id="a8efbc0e53c85d57908a1d893ade42fa5" name="a8efbc0e53c85d57908a1d893ade42fa5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>SumIntoGlobalValue</b> (long long GlobalBlockRow, int BlockRowOffset, int VectorIndex, double ScalarValue)</td></tr>
<tr class="separator:a8efbc0e53c85d57908a1d893ade42fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3024360d5db99d0d09b91aba5a7fb14" id="r_aa3024360d5db99d0d09b91aba5a7fb14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#aa3024360d5db99d0d09b91aba5a7fb14">ReplaceMyValue</a> (int MyRow, int VectorIndex, double ScalarValue)</td></tr>
<tr class="memdesc:aa3024360d5db99d0d09b91aba5a7fb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace current value at the specified (MyRow, VectorIndex) location with ScalarValue.  <br /></td></tr>
<tr class="separator:aa3024360d5db99d0d09b91aba5a7fb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff1175fcfdd9c534364d30e84c7a510" id="r_a7ff1175fcfdd9c534364d30e84c7a510"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#a7ff1175fcfdd9c534364d30e84c7a510">ReplaceMyValue</a> (int MyBlockRow, int BlockRowOffset, int VectorIndex, double ScalarValue)</td></tr>
<tr class="memdesc:a7ff1175fcfdd9c534364d30e84c7a510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace current value at the specified (MyBlockRow, BlockRowOffset, VectorIndex) location with ScalarValue.  <br /></td></tr>
<tr class="separator:a7ff1175fcfdd9c534364d30e84c7a510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7148321d9b58e03d17fbb4318fe11c6" id="r_ab7148321d9b58e03d17fbb4318fe11c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#ab7148321d9b58e03d17fbb4318fe11c6">SumIntoMyValue</a> (int MyRow, int VectorIndex, double ScalarValue)</td></tr>
<tr class="memdesc:ab7148321d9b58e03d17fbb4318fe11c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds ScalarValue to existing value at the specified (MyRow, VectorIndex) location.  <br /></td></tr>
<tr class="separator:ab7148321d9b58e03d17fbb4318fe11c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd0c020618f032772bd33e15338f39e" id="r_a0dd0c020618f032772bd33e15338f39e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#a0dd0c020618f032772bd33e15338f39e">SumIntoMyValue</a> (int MyBlockRow, int BlockRowOffset, int VectorIndex, double ScalarValue)</td></tr>
<tr class="memdesc:a0dd0c020618f032772bd33e15338f39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds ScalarValue to existing value at the specified (MyBlockRow, BlockRowOffset, VectorIndex) location.  <br /></td></tr>
<tr class="separator:a0dd0c020618f032772bd33e15338f39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f671d0d84d754bd103afc8dbfd5e01" id="r_ad6f671d0d84d754bd103afc8dbfd5e01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#ad6f671d0d84d754bd103afc8dbfd5e01">PutScalar</a> (double ScalarConstant)</td></tr>
<tr class="memdesc:ad6f671d0d84d754bd103afc8dbfd5e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize all values in a multi-vector with constant value.  <br /></td></tr>
<tr class="separator:ad6f671d0d84d754bd103afc8dbfd5e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4083f49c621624031157a1314218de" id="r_abc4083f49c621624031157a1314218de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#abc4083f49c621624031157a1314218de">Random</a> ()</td></tr>
<tr class="memdesc:abc4083f49c621624031157a1314218de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set multi-vector values to random numbers.  <br /></td></tr>
<tr class="separator:abc4083f49c621624031157a1314218de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Extraction methods</div></td></tr>
<tr class="memitem:ac8efbf138bbe2aae80d0182517e0c858" id="r_ac8efbf138bbe2aae80d0182517e0c858"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#ac8efbf138bbe2aae80d0182517e0c858">ExtractCopy</a> (double *A, int MyLDA) const</td></tr>
<tr class="memdesc:ac8efbf138bbe2aae80d0182517e0c858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put multi-vector values into user-provided two-dimensional array.  <br /></td></tr>
<tr class="separator:ac8efbf138bbe2aae80d0182517e0c858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501a65632630a8f3d76c2d41520d7ff5" id="r_a501a65632630a8f3d76c2d41520d7ff5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#a501a65632630a8f3d76c2d41520d7ff5">ExtractCopy</a> (double **ArrayOfPointers) const</td></tr>
<tr class="memdesc:a501a65632630a8f3d76c2d41520d7ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put multi-vector values into user-provided array of pointers.  <br /></td></tr>
<tr class="separator:a501a65632630a8f3d76c2d41520d7ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d513146280b1ad49b6cb0df0d999921" id="r_a4d513146280b1ad49b6cb0df0d999921"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#a4d513146280b1ad49b6cb0df0d999921">ExtractView</a> (double **A, int *MyLDA) const</td></tr>
<tr class="memdesc:a4d513146280b1ad49b6cb0df0d999921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set user-provided addresses of A and MyLDA.  <br /></td></tr>
<tr class="separator:a4d513146280b1ad49b6cb0df0d999921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b7e5bdad32070eba0c7585edd774de" id="r_a23b7e5bdad32070eba0c7585edd774de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#a23b7e5bdad32070eba0c7585edd774de">ExtractView</a> (double ***ArrayOfPointers) const</td></tr>
<tr class="memdesc:a23b7e5bdad32070eba0c7585edd774de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set user-provided addresses of ArrayOfPointers.  <br /></td></tr>
<tr class="separator:a23b7e5bdad32070eba0c7585edd774de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mathematical methods</div></td></tr>
<tr class="memitem:a42974c01bd60ededd0a1463e24505f0f" id="r_a42974c01bd60ededd0a1463e24505f0f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#a42974c01bd60ededd0a1463e24505f0f">Dot</a> (const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;A, double *Result) const</td></tr>
<tr class="memdesc:a42974c01bd60ededd0a1463e24505f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes dot product of each corresponding pair of vectors.  <br /></td></tr>
<tr class="separator:a42974c01bd60ededd0a1463e24505f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367cbac4464dbdc1666ee30d5f4420b9" id="r_a367cbac4464dbdc1666ee30d5f4420b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#a367cbac4464dbdc1666ee30d5f4420b9">Abs</a> (const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;A)</td></tr>
<tr class="memdesc:a367cbac4464dbdc1666ee30d5f4420b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts element-wise absolute values of input Multi-vector in target.  <br /></td></tr>
<tr class="separator:a367cbac4464dbdc1666ee30d5f4420b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd5ea6f0e1cf7742db18065f6d5e687" id="r_a2bd5ea6f0e1cf7742db18065f6d5e687"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#a2bd5ea6f0e1cf7742db18065f6d5e687">Reciprocal</a> (const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;A)</td></tr>
<tr class="memdesc:a2bd5ea6f0e1cf7742db18065f6d5e687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts element-wise reciprocal values of input Multi-vector in target.  <br /></td></tr>
<tr class="separator:a2bd5ea6f0e1cf7742db18065f6d5e687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193b83fb1fa361a3f61a5757fce34a14" id="r_a193b83fb1fa361a3f61a5757fce34a14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#a193b83fb1fa361a3f61a5757fce34a14">Scale</a> (double ScalarValue)</td></tr>
<tr class="memdesc:a193b83fb1fa361a3f61a5757fce34a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale the current values of a multi-vector, <em>this</em> = ScalarValue*<em>this</em>.  <br /></td></tr>
<tr class="separator:a193b83fb1fa361a3f61a5757fce34a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b18eb28e8bca53b5bd3f333f2880b1" id="r_a98b18eb28e8bca53b5bd3f333f2880b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#a98b18eb28e8bca53b5bd3f333f2880b1">Scale</a> (double ScalarA, const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;A)</td></tr>
<tr class="memdesc:a98b18eb28e8bca53b5bd3f333f2880b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace multi-vector values with scaled values of A, <em>this</em> = ScalarA*A.  <br /></td></tr>
<tr class="separator:a98b18eb28e8bca53b5bd3f333f2880b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d117790b9fef51615bda948baf4b503" id="r_a9d117790b9fef51615bda948baf4b503"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#a9d117790b9fef51615bda948baf4b503">Update</a> (double ScalarA, const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;A, double ScalarThis)</td></tr>
<tr class="memdesc:a9d117790b9fef51615bda948baf4b503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update multi-vector values with scaled values of A, <em>this</em> = ScalarThis*<em>this</em> + ScalarA*A.  <br /></td></tr>
<tr class="separator:a9d117790b9fef51615bda948baf4b503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73cd3a0b875cbd1424d35512c307873" id="r_ac73cd3a0b875cbd1424d35512c307873"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#ac73cd3a0b875cbd1424d35512c307873">Update</a> (double ScalarA, const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;A, double ScalarB, const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;B, double ScalarThis)</td></tr>
<tr class="memdesc:ac73cd3a0b875cbd1424d35512c307873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update multi-vector with scaled values of A and B, <em>this</em> = ScalarThis*<em>this</em> + ScalarA*A + ScalarB*B.  <br /></td></tr>
<tr class="separator:ac73cd3a0b875cbd1424d35512c307873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8791352f2435311ac74eb31217500301" id="r_a8791352f2435311ac74eb31217500301"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#a8791352f2435311ac74eb31217500301">Norm1</a> (double *Result) const</td></tr>
<tr class="memdesc:a8791352f2435311ac74eb31217500301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute 1-norm of each vector in multi-vector.  <br /></td></tr>
<tr class="separator:a8791352f2435311ac74eb31217500301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0a5f99517354b60527cef62dc9be61" id="r_abf0a5f99517354b60527cef62dc9be61"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#abf0a5f99517354b60527cef62dc9be61">Norm2</a> (double *Result) const</td></tr>
<tr class="memdesc:abf0a5f99517354b60527cef62dc9be61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute 2-norm of each vector in multi-vector.  <br /></td></tr>
<tr class="separator:abf0a5f99517354b60527cef62dc9be61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d17f235c6223338003ae728fd7b2d1" id="r_a14d17f235c6223338003ae728fd7b2d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#a14d17f235c6223338003ae728fd7b2d1">NormInf</a> (double *Result) const</td></tr>
<tr class="memdesc:a14d17f235c6223338003ae728fd7b2d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Inf-norm of each vector in multi-vector.  <br /></td></tr>
<tr class="separator:a14d17f235c6223338003ae728fd7b2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8aa7b2667683c7087ceffa9ed2f7aa" id="r_a5a8aa7b2667683c7087ceffa9ed2f7aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#a5a8aa7b2667683c7087ceffa9ed2f7aa">NormWeighted</a> (const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;Weights, double *Result) const</td></tr>
<tr class="memdesc:a5a8aa7b2667683c7087ceffa9ed2f7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Weighted 2-norm (RMS Norm) of each vector in multi-vector.  <br /></td></tr>
<tr class="separator:a5a8aa7b2667683c7087ceffa9ed2f7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e547756c3e47ec33e0c84199c4b7a98" id="r_a3e547756c3e47ec33e0c84199c4b7a98"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#a3e547756c3e47ec33e0c84199c4b7a98">MinValue</a> (double *Result) const</td></tr>
<tr class="memdesc:a3e547756c3e47ec33e0c84199c4b7a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute minimum value of each vector in multi-vector.  <br /></td></tr>
<tr class="separator:a3e547756c3e47ec33e0c84199c4b7a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2665de83872bb7eecf7915a4cc7cbce" id="r_ac2665de83872bb7eecf7915a4cc7cbce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#ac2665de83872bb7eecf7915a4cc7cbce">MaxValue</a> (double *Result) const</td></tr>
<tr class="memdesc:ac2665de83872bb7eecf7915a4cc7cbce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute maximum value of each vector in multi-vector.  <br /></td></tr>
<tr class="separator:ac2665de83872bb7eecf7915a4cc7cbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6199b28d1195c66c8c31b62e36163e3" id="r_ab6199b28d1195c66c8c31b62e36163e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#ab6199b28d1195c66c8c31b62e36163e3">MeanValue</a> (double *Result) const</td></tr>
<tr class="memdesc:ab6199b28d1195c66c8c31b62e36163e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute mean (average) value of each vector in multi-vector.  <br /></td></tr>
<tr class="separator:ab6199b28d1195c66c8c31b62e36163e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865636722de327e1b4f89e7a8153174d" id="r_a865636722de327e1b4f89e7a8153174d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#a865636722de327e1b4f89e7a8153174d">Multiply</a> (char TransA, char TransB, double ScalarAB, const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;A, const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;B, double ScalarThis)</td></tr>
<tr class="memdesc:a865636722de327e1b4f89e7a8153174d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix-Matrix multiplication, <em>this</em> = ScalarThis*<em>this</em> + ScalarAB*A*B.  <br /></td></tr>
<tr class="separator:a865636722de327e1b4f89e7a8153174d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e9a8b73fec0a60050fc8db0069b0c8" id="r_ae8e9a8b73fec0a60050fc8db0069b0c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#ae8e9a8b73fec0a60050fc8db0069b0c8">Multiply</a> (double ScalarAB, const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;A, const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;B, double ScalarThis)</td></tr>
<tr class="memdesc:ae8e9a8b73fec0a60050fc8db0069b0c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> with another, element-by-element.  <br /></td></tr>
<tr class="separator:ae8e9a8b73fec0a60050fc8db0069b0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9641adfac464747124c955f59474299" id="r_ae9641adfac464747124c955f59474299"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#ae9641adfac464747124c955f59474299">ReciprocalMultiply</a> (double ScalarAB, const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;A, const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;B, double ScalarThis)</td></tr>
<tr class="memdesc:ae9641adfac464747124c955f59474299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> by the reciprocal of another, element-by-element.  <br /></td></tr>
<tr class="separator:ae9641adfac464747124c955f59474299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Random number utilities</div></td></tr>
<tr class="memitem:ad251efbd05e2125090529c120c18281f" id="r_ad251efbd05e2125090529c120c18281f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#ad251efbd05e2125090529c120c18281f">SetSeed</a> (unsigned int Seed_in)</td></tr>
<tr class="memdesc:ad251efbd05e2125090529c120c18281f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set seed for Random function.  <br /></td></tr>
<tr class="separator:ad251efbd05e2125090529c120c18281f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3fe6ef3a5a9d5b567057b75e674801" id="r_abe3fe6ef3a5a9d5b567057b75e674801"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#abe3fe6ef3a5a9d5b567057b75e674801">Seed</a> ()</td></tr>
<tr class="memdesc:abe3fe6ef3a5a9d5b567057b75e674801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get seed from Random function.  <br /></td></tr>
<tr class="separator:abe3fe6ef3a5a9d5b567057b75e674801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Overloaded operators</div></td></tr>
<tr class="memitem:a58bee1de7a6522a5beecf885ea98392d" id="r_a58bee1de7a6522a5beecf885ea98392d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#a58bee1de7a6522a5beecf885ea98392d">operator=</a> (const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;Source)</td></tr>
<tr class="memdesc:a58bee1de7a6522a5beecf885ea98392d"><td class="mdescLeft">&#160;</td><td class="mdescRight">= Operator.  <br /></td></tr>
<tr class="separator:a58bee1de7a6522a5beecf885ea98392d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bc3f70fa2a7a8ffbdc64848edb27e8" id="r_ae5bc3f70fa2a7a8ffbdc64848edb27e8"><td class="memItemLeft" align="right" valign="top">double *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#ae5bc3f70fa2a7a8ffbdc64848edb27e8">operator[]</a> (int i)</td></tr>
<tr class="memdesc:ae5bc3f70fa2a7a8ffbdc64848edb27e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector access function.  <br /></td></tr>
<tr class="separator:ae5bc3f70fa2a7a8ffbdc64848edb27e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5b62357cd7de5fe74e1f958d96f757" id="r_afe5b62357cd7de5fe74e1f958d96f757"><td class="memItemLeft" align="right" valign="top">double *const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#afe5b62357cd7de5fe74e1f958d96f757">operator[]</a> (int i) const</td></tr>
<tr class="memdesc:afe5b62357cd7de5fe74e1f958d96f757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector access function.  <br /></td></tr>
<tr class="separator:afe5b62357cd7de5fe74e1f958d96f757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d61d910d1e91a25907bf1d2de2fce4" id="r_a31d61d910d1e91a25907bf1d2de2fce4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#a31d61d910d1e91a25907bf1d2de2fce4">operator()</a> (int i)</td></tr>
<tr class="memdesc:a31d61d910d1e91a25907bf1d2de2fce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector access function.  <br /></td></tr>
<tr class="separator:a31d61d910d1e91a25907bf1d2de2fce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23b47c2b3773b8b5b46e978d9d57bf9" id="r_af23b47c2b3773b8b5b46e978d9d57bf9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#af23b47c2b3773b8b5b46e978d9d57bf9">operator()</a> (int i) const</td></tr>
<tr class="memdesc:af23b47c2b3773b8b5b46e978d9d57bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector access function.  <br /></td></tr>
<tr class="separator:af23b47c2b3773b8b5b46e978d9d57bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Attribute access functions</div></td></tr>
<tr class="memitem:a1d29dedcbf070b11dfda5eb043c90b85" id="r_a1d29dedcbf070b11dfda5eb043c90b85"><td class="memItemLeft" align="right" valign="top"><a id="a1d29dedcbf070b11dfda5eb043c90b85" name="a1d29dedcbf070b11dfda5eb043c90b85"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>NumVectors</b> () const</td></tr>
<tr class="memdesc:a1d29dedcbf070b11dfda5eb043c90b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of vectors in the multi-vector. <br /></td></tr>
<tr class="separator:a1d29dedcbf070b11dfda5eb043c90b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c28ffe9039525b5b0d6531883250b47" id="r_a4c28ffe9039525b5b0d6531883250b47"><td class="memItemLeft" align="right" valign="top"><a id="a4c28ffe9039525b5b0d6531883250b47" name="a4c28ffe9039525b5b0d6531883250b47"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MyLength</b> () const</td></tr>
<tr class="memdesc:a4c28ffe9039525b5b0d6531883250b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the local vector length on the calling processor of vectors in the multi-vector. <br /></td></tr>
<tr class="separator:a4c28ffe9039525b5b0d6531883250b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028f1e908503ee1ccc174607c133877e" id="r_a028f1e908503ee1ccc174607c133877e"><td class="memItemLeft" align="right" valign="top"><a id="a028f1e908503ee1ccc174607c133877e" name="a028f1e908503ee1ccc174607c133877e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>GlobalLength</b> () const</td></tr>
<tr class="memdesc:a028f1e908503ee1ccc174607c133877e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the global vector length of vectors in the multi-vector. <br /></td></tr>
<tr class="separator:a028f1e908503ee1ccc174607c133877e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad066e6340b123ea9e9343fc4196b2a32" id="r_ad066e6340b123ea9e9343fc4196b2a32"><td class="memItemLeft" align="right" valign="top"><a id="ad066e6340b123ea9e9343fc4196b2a32" name="ad066e6340b123ea9e9343fc4196b2a32"></a>
long long&#160;</td><td class="memItemRight" valign="bottom"><b>GlobalLength64</b> () const</td></tr>
<tr class="memdesc:ad066e6340b123ea9e9343fc4196b2a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 64-bit global vector length of vectors in the multi-vector. <br /></td></tr>
<tr class="separator:ad066e6340b123ea9e9343fc4196b2a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6dc44dbc4f1a3918d26de947ab9d4c" id="r_a7c6dc44dbc4f1a3918d26de947ab9d4c"><td class="memItemLeft" align="right" valign="top"><a id="a7c6dc44dbc4f1a3918d26de947ab9d4c" name="a7c6dc44dbc4f1a3918d26de947ab9d4c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Stride</b> () const</td></tr>
<tr class="memdesc:a7c6dc44dbc4f1a3918d26de947ab9d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stride between vectors in the multi-vector (only meaningful if <a class="el" href="classEpetra__MultiVector.html#a5ecb80ded5c922ecb31f40ab558c7497" title="Returns true if this multi-vector has constant stride between vectors.">ConstantStride()</a> is true). <br /></td></tr>
<tr class="separator:a7c6dc44dbc4f1a3918d26de947ab9d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ecb80ded5c922ecb31f40ab558c7497" id="r_a5ecb80ded5c922ecb31f40ab558c7497"><td class="memItemLeft" align="right" valign="top"><a id="a5ecb80ded5c922ecb31f40ab558c7497" name="a5ecb80ded5c922ecb31f40ab558c7497"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ConstantStride</b> () const</td></tr>
<tr class="memdesc:a5ecb80ded5c922ecb31f40ab558c7497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this multi-vector has constant stride between vectors. <br /></td></tr>
<tr class="separator:a5ecb80ded5c922ecb31f40ab558c7497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1981df3338e57ffa7b6575c7ded6e1e" id="r_af1981df3338e57ffa7b6575c7ded6e1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#af1981df3338e57ffa7b6575c7ded6e1e">ReplaceMap</a> (const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;map)</td></tr>
<tr class="separator:af1981df3338e57ffa7b6575c7ded6e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">I/O methods</div></td></tr>
<tr class="memitem:aca9ec9c69b488ebebb60ca7626765877" id="r_aca9ec9c69b488ebebb60ca7626765877"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#aca9ec9c69b488ebebb60ca7626765877">Print</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:aca9ec9c69b488ebebb60ca7626765877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print method.  <br /></td></tr>
<tr class="separator:aca9ec9c69b488ebebb60ca7626765877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__DistObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__DistObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__DistObject.html">Epetra_DistObject</a></td></tr>
<tr class="memitem:aea928fbc32a281b5038a149bc7ff766a inherit pub_methods_classEpetra__DistObject" id="r_aea928fbc32a281b5038a149bc7ff766a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__DistObject.html#aea928fbc32a281b5038a149bc7ff766a">Epetra_DistObject</a> (const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;<a class="el" href="classEpetra__DistObject.html#a00702a53a4a8142f249639d254e760cd">Map</a>)</td></tr>
<tr class="memdesc:aea928fbc32a281b5038a149bc7ff766a inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic <a class="el" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi-vectors, vectors and matrices in pa...">Epetra_DistObject</a> constuctor.  <br /></td></tr>
<tr class="separator:aea928fbc32a281b5038a149bc7ff766a inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73d8a91a6389a526fc7e08a8a1b043b inherit pub_methods_classEpetra__DistObject" id="r_ac73d8a91a6389a526fc7e08a8a1b043b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__DistObject.html#ac73d8a91a6389a526fc7e08a8a1b043b">Epetra_DistObject</a> (const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;<a class="el" href="classEpetra__DistObject.html#a00702a53a4a8142f249639d254e760cd">Map</a>, const char *const <a class="el" href="classEpetra__Object.html#a1910d1c04e70ac482f7e377b271f6c26">Label</a>)</td></tr>
<tr class="separator:ac73d8a91a6389a526fc7e08a8a1b043b inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09204a59077097b73d3cf70e862feaf9 inherit pub_methods_classEpetra__DistObject" id="r_a09204a59077097b73d3cf70e862feaf9"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_DistObject</b> (const <a class="el" href="classEpetra__DistObject.html">Epetra_DistObject</a> &amp;Source)</td></tr>
<tr class="memdesc:a09204a59077097b73d3cf70e862feaf9 inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi-vectors, vectors and matrices in pa...">Epetra_DistObject</a> copy constructor. <br /></td></tr>
<tr class="separator:a09204a59077097b73d3cf70e862feaf9 inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41082a7526d3aa88f79d57805e5b9337 inherit pub_methods_classEpetra__DistObject" id="r_a41082a7526d3aa88f79d57805e5b9337"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_DistObject</b> ()</td></tr>
<tr class="memdesc:a41082a7526d3aa88f79d57805e5b9337 inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi-vectors, vectors and matrices in pa...">Epetra_DistObject</a> destructor. <br /></td></tr>
<tr class="separator:a41082a7526d3aa88f79d57805e5b9337 inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393f365177c485ab1c30f288514f9297 inherit pub_methods_classEpetra__DistObject" id="r_a393f365177c485ab1c30f288514f9297"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__DistObject.html#a393f365177c485ab1c30f288514f9297">Import</a> (const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;A, const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> &amp;Importer, <a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020f">Epetra_CombineMode</a> CombineMode, const <a class="el" href="classEpetra__OffsetIndex.html">Epetra_OffsetIndex</a> *Indexor=0)</td></tr>
<tr class="memdesc:a393f365177c485ab1c30f288514f9297 inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imports an <a class="el" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi-vectors, vectors and matrices in pa...">Epetra_DistObject</a> using the <a class="el" href="classEpetra__Import.html" title="Epetra_Import: This class builds an import object for efficient importing of off-processor elements.">Epetra_Import</a> object.  <br /></td></tr>
<tr class="separator:a393f365177c485ab1c30f288514f9297 inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac1b1da995e88db2ae67cc02ad37dc8 inherit pub_methods_classEpetra__DistObject" id="r_aeac1b1da995e88db2ae67cc02ad37dc8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__DistObject.html#aeac1b1da995e88db2ae67cc02ad37dc8">Import</a> (const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;A, const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> &amp;Exporter, <a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020f">Epetra_CombineMode</a> CombineMode, const <a class="el" href="classEpetra__OffsetIndex.html">Epetra_OffsetIndex</a> *Indexor=0)</td></tr>
<tr class="memdesc:aeac1b1da995e88db2ae67cc02ad37dc8 inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imports an <a class="el" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi-vectors, vectors and matrices in pa...">Epetra_DistObject</a> using the <a class="el" href="classEpetra__Export.html" title="Epetra_Export: This class builds an export object for efficient exporting of off-processor elements.">Epetra_Export</a> object.  <br /></td></tr>
<tr class="separator:aeac1b1da995e88db2ae67cc02ad37dc8 inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a69d5a64168c02fadfc6c55ecd5a1c inherit pub_methods_classEpetra__DistObject" id="r_a88a69d5a64168c02fadfc6c55ecd5a1c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__DistObject.html#a88a69d5a64168c02fadfc6c55ecd5a1c">Export</a> (const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;A, const <a class="el" href="classEpetra__Import.html">Epetra_Import</a> &amp;Importer, <a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020f">Epetra_CombineMode</a> CombineMode, const <a class="el" href="classEpetra__OffsetIndex.html">Epetra_OffsetIndex</a> *Indexor=0)</td></tr>
<tr class="memdesc:a88a69d5a64168c02fadfc6c55ecd5a1c inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports an <a class="el" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi-vectors, vectors and matrices in pa...">Epetra_DistObject</a> using the <a class="el" href="classEpetra__Import.html" title="Epetra_Import: This class builds an import object for efficient importing of off-processor elements.">Epetra_Import</a> object.  <br /></td></tr>
<tr class="separator:a88a69d5a64168c02fadfc6c55ecd5a1c inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c537c6cbcf366a986227496c6aa79ee inherit pub_methods_classEpetra__DistObject" id="r_a8c537c6cbcf366a986227496c6aa79ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__DistObject.html#a8c537c6cbcf366a986227496c6aa79ee">Export</a> (const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;A, const <a class="el" href="classEpetra__Export.html">Epetra_Export</a> &amp;Exporter, <a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020f">Epetra_CombineMode</a> CombineMode, const <a class="el" href="classEpetra__OffsetIndex.html">Epetra_OffsetIndex</a> *Indexor=0)</td></tr>
<tr class="memdesc:a8c537c6cbcf366a986227496c6aa79ee inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports an <a class="el" href="classEpetra__DistObject.html" title="Epetra_DistObject: A class for constructing and using dense multi-vectors, vectors and matrices in pa...">Epetra_DistObject</a> using the <a class="el" href="classEpetra__Export.html" title="Epetra_Export: This class builds an export object for efficient exporting of off-processor elements.">Epetra_Export</a> object.  <br /></td></tr>
<tr class="separator:a8c537c6cbcf366a986227496c6aa79ee inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00702a53a4a8142f249639d254e760cd inherit pub_methods_classEpetra__DistObject" id="r_a00702a53a4a8142f249639d254e760cd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__DistObject.html#a00702a53a4a8142f249639d254e760cd">Map</a> () const</td></tr>
<tr class="memdesc:a00702a53a4a8142f249639d254e760cd inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the address of the <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> for this multi-vector.  <br /></td></tr>
<tr class="separator:a00702a53a4a8142f249639d254e760cd inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2e2c38a27e224f15fce659e00fc9c0 inherit pub_methods_classEpetra__DistObject" id="r_aad2e2c38a27e224f15fce659e00fc9c0"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Comm</b> () const</td></tr>
<tr class="memdesc:aad2e2c38a27e224f15fce659e00fc9c0 inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the address of the <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> for this multi-vector. <br /></td></tr>
<tr class="separator:aad2e2c38a27e224f15fce659e00fc9c0 inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c1fa2bf7389cf67ea23d1e84343046 inherit pub_methods_classEpetra__DistObject" id="r_a04c1fa2bf7389cf67ea23d1e84343046"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>DistributedGlobal</b> () const</td></tr>
<tr class="memdesc:a04c1fa2bf7389cf67ea23d1e84343046 inherit pub_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this multi-vector is distributed global, i.e., not local replicated. <br /></td></tr>
<tr class="separator:a04c1fa2bf7389cf67ea23d1e84343046 inherit pub_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__Object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__Object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__Object.html">Epetra_Object</a></td></tr>
<tr class="memitem:a7676631aca0d619c4e8d3e877c2b87a2 inherit pub_methods_classEpetra__Object" id="r_a7676631aca0d619c4e8d3e877c2b87a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a7676631aca0d619c4e8d3e877c2b87a2">Epetra_Object</a> (int TracebackModeIn=-1, bool set_label=true)</td></tr>
<tr class="memdesc:a7676631aca0d619c4e8d3e877c2b87a2 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Constructor.  <br /></td></tr>
<tr class="separator:a7676631aca0d619c4e8d3e877c2b87a2 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf156d9c8874a2a455ec305826c7313f inherit pub_methods_classEpetra__Object" id="r_acf156d9c8874a2a455ec305826c7313f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#acf156d9c8874a2a455ec305826c7313f">Epetra_Object</a> (const char *const <a class="el" href="classEpetra__Object.html#a1910d1c04e70ac482f7e377b271f6c26">Label</a>, int TracebackModeIn=-1)</td></tr>
<tr class="memdesc:acf156d9c8874a2a455ec305826c7313f inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Constructor.  <br /></td></tr>
<tr class="separator:acf156d9c8874a2a455ec305826c7313f inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f8bd631f2a97276ea07cea8c9c7057 inherit pub_methods_classEpetra__Object" id="r_ac5f8bd631f2a97276ea07cea8c9c7057"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#ac5f8bd631f2a97276ea07cea8c9c7057">Epetra_Object</a> (const <a class="el" href="classEpetra__Object.html">Epetra_Object</a> &amp;Object)</td></tr>
<tr class="memdesc:ac5f8bd631f2a97276ea07cea8c9c7057 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Copy Constructor.  <br /></td></tr>
<tr class="separator:ac5f8bd631f2a97276ea07cea8c9c7057 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742c256d523738e458d0256f72ba9e4b inherit pub_methods_classEpetra__Object" id="r_a742c256d523738e458d0256f72ba9e4b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a742c256d523738e458d0256f72ba9e4b">~Epetra_Object</a> ()</td></tr>
<tr class="memdesc:a742c256d523738e458d0256f72ba9e4b inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Destructor.  <br /></td></tr>
<tr class="separator:a742c256d523738e458d0256f72ba9e4b inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff5c5266120410acbe6ccb63734b5c8 inherit pub_methods_classEpetra__Object" id="r_a9ff5c5266120410acbe6ccb63734b5c8"><td class="memItemLeft" align="right" valign="top">
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>ReportError</b> (const std::string Message, int ErrorCode) const</td></tr>
<tr class="memdesc:a9ff5c5266120410acbe6ccb63734b5c8 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error reporting method. <br /></td></tr>
<tr class="separator:a9ff5c5266120410acbe6ccb63734b5c8 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049c5235b19bd286f95914b547b9f528 inherit pub_methods_classEpetra__Object" id="r_a049c5235b19bd286f95914b547b9f528"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a049c5235b19bd286f95914b547b9f528">SetLabel</a> (const char *const <a class="el" href="classEpetra__Object.html#a1910d1c04e70ac482f7e377b271f6c26">Label</a>)</td></tr>
<tr class="memdesc:a049c5235b19bd286f95914b547b9f528 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Label definition using char *.  <br /></td></tr>
<tr class="separator:a049c5235b19bd286f95914b547b9f528 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1910d1c04e70ac482f7e377b271f6c26 inherit pub_methods_classEpetra__Object" id="r_a1910d1c04e70ac482f7e377b271f6c26"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a1910d1c04e70ac482f7e377b271f6c26">Label</a> () const</td></tr>
<tr class="memdesc:a1910d1c04e70ac482f7e377b271f6c26 inherit pub_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> Label access funtion.  <br /></td></tr>
<tr class="separator:a1910d1c04e70ac482f7e377b271f6c26 inherit pub_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__SrcDistObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__SrcDistObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a></td></tr>
<tr class="memitem:a9f7ce0515cfecef2d90543d0c572d3bc inherit pub_methods_classEpetra__SrcDistObject" id="r_a9f7ce0515cfecef2d90543d0c572d3bc"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_SrcDistObject</b> ()</td></tr>
<tr class="memdesc:a9f7ce0515cfecef2d90543d0c572d3bc inherit pub_methods_classEpetra__SrcDistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__SrcDistObject.html" title="Epetra_SrcDistObject: A class for supporting flexible source distributed objects for import/export op...">Epetra_SrcDistObject</a> destructor. <br /></td></tr>
<tr class="separator:a9f7ce0515cfecef2d90543d0c572d3bc inherit pub_methods_classEpetra__SrcDistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__CompObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__CompObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__CompObject.html">Epetra_CompObject</a></td></tr>
<tr class="memitem:a72d50bb3df3487828adb4d4b8f9a282b inherit pub_methods_classEpetra__CompObject" id="r_a72d50bb3df3487828adb4d4b8f9a282b"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_CompObject</b> ()</td></tr>
<tr class="memdesc:a72d50bb3df3487828adb4d4b8f9a282b inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic <a class="el" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes.">Epetra_CompObject</a> constuctor. <br /></td></tr>
<tr class="separator:a72d50bb3df3487828adb4d4b8f9a282b inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1109b4825ca8fa5043c57c83227c56 inherit pub_methods_classEpetra__CompObject" id="r_a3d1109b4825ca8fa5043c57c83227c56"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Epetra_CompObject</b> (const <a class="el" href="classEpetra__CompObject.html">Epetra_CompObject</a> &amp;Source)</td></tr>
<tr class="memdesc:a3d1109b4825ca8fa5043c57c83227c56 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes.">Epetra_CompObject</a> copy constructor. <br /></td></tr>
<tr class="separator:a3d1109b4825ca8fa5043c57c83227c56 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af670a39b6993246fe87fc4c4b9f00971 inherit pub_methods_classEpetra__CompObject" id="r_af670a39b6993246fe87fc4c4b9f00971"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_CompObject</b> ()</td></tr>
<tr class="memdesc:af670a39b6993246fe87fc4c4b9f00971 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes.">Epetra_CompObject</a> destructor. <br /></td></tr>
<tr class="separator:af670a39b6993246fe87fc4c4b9f00971 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665dd8befefacf0e5f188ea8a011bd80 inherit pub_methods_classEpetra__CompObject" id="r_a665dd8befefacf0e5f188ea8a011bd80"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetFlopCounter</b> (const <a class="el" href="classEpetra__Flops.html">Epetra_Flops</a> &amp;FlopCounter_in)</td></tr>
<tr class="memdesc:a665dd8befefacf0e5f188ea8a011bd80 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal <a class="el" href="classEpetra__Flops.html" title="Epetra_Flops: The Epetra Floating Point Operations Class.">Epetra_Flops()</a> pointer. <br /></td></tr>
<tr class="separator:a665dd8befefacf0e5f188ea8a011bd80 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac5e8ba25d3ff75dd93ee5d85f46c5b inherit pub_methods_classEpetra__CompObject" id="r_a0ac5e8ba25d3ff75dd93ee5d85f46c5b"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetFlopCounter</b> (const <a class="el" href="classEpetra__CompObject.html">Epetra_CompObject</a> &amp;CompObject)</td></tr>
<tr class="memdesc:a0ac5e8ba25d3ff75dd93ee5d85f46c5b inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal <a class="el" href="classEpetra__Flops.html" title="Epetra_Flops: The Epetra Floating Point Operations Class.">Epetra_Flops()</a> pointer to the flop counter of another <a class="el" href="classEpetra__CompObject.html" title="Epetra_CompObject: Functionality and data that is common to all computational classes.">Epetra_CompObject</a>. <br /></td></tr>
<tr class="separator:a0ac5e8ba25d3ff75dd93ee5d85f46c5b inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78028e410947150bba43f206d0c0b0ef inherit pub_methods_classEpetra__CompObject" id="r_a78028e410947150bba43f206d0c0b0ef"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UnsetFlopCounter</b> ()</td></tr>
<tr class="memdesc:a78028e410947150bba43f206d0c0b0ef inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal <a class="el" href="classEpetra__Flops.html" title="Epetra_Flops: The Epetra Floating Point Operations Class.">Epetra_Flops()</a> pointer to 0 (no flops counted). <br /></td></tr>
<tr class="separator:a78028e410947150bba43f206d0c0b0ef inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e1619549eb9d1b62a04172fedc77b7 inherit pub_methods_classEpetra__CompObject" id="r_a31e1619549eb9d1b62a04172fedc77b7"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classEpetra__Flops.html">Epetra_Flops</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetFlopCounter</b> () const</td></tr>
<tr class="memdesc:a31e1619549eb9d1b62a04172fedc77b7 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pointer to the <a class="el" href="classEpetra__Flops.html" title="Epetra_Flops: The Epetra Floating Point Operations Class.">Epetra_Flops()</a> object associated with this object, returns 0 if none. <br /></td></tr>
<tr class="separator:a31e1619549eb9d1b62a04172fedc77b7 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adff4c34d61377709fc8a17e99e3eae inherit pub_methods_classEpetra__CompObject" id="r_a4adff4c34d61377709fc8a17e99e3eae"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>ResetFlops</b> () const</td></tr>
<tr class="memdesc:a4adff4c34d61377709fc8a17e99e3eae inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the number of floating point operations to zero for <em>this</em> multi-vector. <br /></td></tr>
<tr class="separator:a4adff4c34d61377709fc8a17e99e3eae inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8326f0873a8866ac9f15f08f5ef31b0d inherit pub_methods_classEpetra__CompObject" id="r_a8326f0873a8866ac9f15f08f5ef31b0d"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><b>Flops</b> () const</td></tr>
<tr class="memdesc:a8326f0873a8866ac9f15f08f5ef31b0d inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of floating point operations with <em>this</em> multi-vector. <br /></td></tr>
<tr class="separator:a8326f0873a8866ac9f15f08f5ef31b0d inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac776bf8d9e68e57951ef766ec16e636b inherit pub_methods_classEpetra__CompObject" id="r_ac776bf8d9e68e57951ef766ec16e636b"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateFlops</b> (int Flops_in) const</td></tr>
<tr class="memdesc:ac776bf8d9e68e57951ef766ec16e636b inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment Flop count for <em>this</em> object. <br /></td></tr>
<tr class="separator:ac776bf8d9e68e57951ef766ec16e636b inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4373b39e384b424078818c6774ffb59a inherit pub_methods_classEpetra__CompObject" id="r_a4373b39e384b424078818c6774ffb59a"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateFlops</b> (long int Flops_in) const</td></tr>
<tr class="memdesc:a4373b39e384b424078818c6774ffb59a inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment Flop count for <em>this</em> object. <br /></td></tr>
<tr class="separator:a4373b39e384b424078818c6774ffb59a inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a2cf1d3a37d9e486edc64202ed42b2 inherit pub_methods_classEpetra__CompObject" id="r_a77a2cf1d3a37d9e486edc64202ed42b2"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateFlops</b> (long long Flops_in) const</td></tr>
<tr class="memdesc:a77a2cf1d3a37d9e486edc64202ed42b2 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment Flop count for <em>this</em> object. <br /></td></tr>
<tr class="separator:a77a2cf1d3a37d9e486edc64202ed42b2 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6480e644cf6c9a524ef839add22952 inherit pub_methods_classEpetra__CompObject" id="r_a4c6480e644cf6c9a524ef839add22952"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateFlops</b> (double Flops_in) const</td></tr>
<tr class="memdesc:a4c6480e644cf6c9a524ef839add22952 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment Flop count for <em>this</em> object. <br /></td></tr>
<tr class="separator:a4c6480e644cf6c9a524ef839add22952 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe126845543d91403abf3a50333fb891 inherit pub_methods_classEpetra__CompObject" id="r_abe126845543d91403abf3a50333fb891"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateFlops</b> (float Flops_in) const</td></tr>
<tr class="memdesc:abe126845543d91403abf3a50333fb891 inherit pub_methods_classEpetra__CompObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment Flop count for <em>this</em> object. <br /></td></tr>
<tr class="separator:abe126845543d91403abf3a50333fb891 inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb8e33c7b18538fa0c088a1dfe1216f inherit pub_methods_classEpetra__CompObject" id="r_a8bb8e33c7b18538fa0c088a1dfe1216f"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classEpetra__CompObject.html">Epetra_CompObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classEpetra__CompObject.html">Epetra_CompObject</a> &amp;src)</td></tr>
<tr class="separator:a8bb8e33c7b18538fa0c088a1dfe1216f inherit pub_methods_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEpetra__BLAS"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEpetra__BLAS')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEpetra__BLAS.html">Epetra_BLAS</a></td></tr>
<tr class="memitem:a8e4e2d564543a813e06462a599ed5b88 inherit pub_methods_classEpetra__BLAS" id="r_a8e4e2d564543a813e06462a599ed5b88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__BLAS.html#a8e4e2d564543a813e06462a599ed5b88">Epetra_BLAS</a> (void)</td></tr>
<tr class="memdesc:a8e4e2d564543a813e06462a599ed5b88 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> Constructor.  <br /></td></tr>
<tr class="separator:a8e4e2d564543a813e06462a599ed5b88 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a2dc7741eea3b947a11280c0ad7ba3 inherit pub_methods_classEpetra__BLAS" id="r_a40a2dc7741eea3b947a11280c0ad7ba3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__BLAS.html#a40a2dc7741eea3b947a11280c0ad7ba3">Epetra_BLAS</a> (const <a class="el" href="classEpetra__BLAS.html">Epetra_BLAS</a> &amp;BLAS)</td></tr>
<tr class="memdesc:a40a2dc7741eea3b947a11280c0ad7ba3 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> Copy Constructor.  <br /></td></tr>
<tr class="separator:a40a2dc7741eea3b947a11280c0ad7ba3 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cd61f7e045c7a41d75e4b073b116e2 inherit pub_methods_classEpetra__BLAS" id="r_a65cd61f7e045c7a41d75e4b073b116e2"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Epetra_BLAS</b> (void)</td></tr>
<tr class="memdesc:a65cd61f7e045c7a41d75e4b073b116e2 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> Destructor. <br /></td></tr>
<tr class="separator:a65cd61f7e045c7a41d75e4b073b116e2 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6e26cf6efd99af2a0a5090b732fab8 inherit pub_methods_classEpetra__BLAS" id="r_a2b6e26cf6efd99af2a0a5090b732fab8"><td class="memItemLeft" align="right" valign="top">
float&#160;</td><td class="memItemRight" valign="bottom"><b>ASUM</b> (const int N, const float *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a2b6e26cf6efd99af2a0a5090b732fab8 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> one norm function (SASUM). <br /></td></tr>
<tr class="separator:a2b6e26cf6efd99af2a0a5090b732fab8 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b10dd77bd77ae08ee2d4f797ccb38c inherit pub_methods_classEpetra__BLAS" id="r_a98b10dd77bd77ae08ee2d4f797ccb38c"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><b>ASUM</b> (const int N, const double *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a98b10dd77bd77ae08ee2d4f797ccb38c inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> one norm function (DASUM). <br /></td></tr>
<tr class="separator:a98b10dd77bd77ae08ee2d4f797ccb38c inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146020f20aa38d12a13a0240f4bd4d89 inherit pub_methods_classEpetra__BLAS" id="r_a146020f20aa38d12a13a0240f4bd4d89"><td class="memItemLeft" align="right" valign="top">
float&#160;</td><td class="memItemRight" valign="bottom"><b>DOT</b> (const int N, const float *X, const float *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:a146020f20aa38d12a13a0240f4bd4d89 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> dot product function (SDOT). <br /></td></tr>
<tr class="separator:a146020f20aa38d12a13a0240f4bd4d89 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d29ddf22e2dbc8cc4aa15920112ba6f inherit pub_methods_classEpetra__BLAS" id="r_a5d29ddf22e2dbc8cc4aa15920112ba6f"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><b>DOT</b> (const int N, const double *X, const double *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:a5d29ddf22e2dbc8cc4aa15920112ba6f inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> dot product function (DDOT). <br /></td></tr>
<tr class="separator:a5d29ddf22e2dbc8cc4aa15920112ba6f inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b602d1308905182ead57a14ce94dc4c inherit pub_methods_classEpetra__BLAS" id="r_a2b602d1308905182ead57a14ce94dc4c"><td class="memItemLeft" align="right" valign="top">
float&#160;</td><td class="memItemRight" valign="bottom"><b>NRM2</b> (const int N, const float *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a2b602d1308905182ead57a14ce94dc4c inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> norm function (SNRM2). <br /></td></tr>
<tr class="separator:a2b602d1308905182ead57a14ce94dc4c inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3915137d4a88e64be1b3b6fff0ae0ba8 inherit pub_methods_classEpetra__BLAS" id="r_a3915137d4a88e64be1b3b6fff0ae0ba8"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><b>NRM2</b> (const int N, const double *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a3915137d4a88e64be1b3b6fff0ae0ba8 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> norm function (DNRM2). <br /></td></tr>
<tr class="separator:a3915137d4a88e64be1b3b6fff0ae0ba8 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132159d7d231a9a9e36e9175cc9faf09 inherit pub_methods_classEpetra__BLAS" id="r_a132159d7d231a9a9e36e9175cc9faf09"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SCAL</b> (const int N, const float ALPHA, float *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a132159d7d231a9a9e36e9175cc9faf09 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> vector scale function (SSCAL) <br /></td></tr>
<tr class="separator:a132159d7d231a9a9e36e9175cc9faf09 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9cf3e5a447112125294b8988fe50124 inherit pub_methods_classEpetra__BLAS" id="r_ae9cf3e5a447112125294b8988fe50124"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SCAL</b> (const int N, const double ALPHA, double *X, const int INCX=1) const</td></tr>
<tr class="memdesc:ae9cf3e5a447112125294b8988fe50124 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> vector scale function (DSCAL) <br /></td></tr>
<tr class="separator:ae9cf3e5a447112125294b8988fe50124 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f43b364ff5e3627f983fe435b222ea5 inherit pub_methods_classEpetra__BLAS" id="r_a7f43b364ff5e3627f983fe435b222ea5"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>COPY</b> (const int N, const float *X, float *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:a7f43b364ff5e3627f983fe435b222ea5 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> vector copy function (SCOPY) <br /></td></tr>
<tr class="separator:a7f43b364ff5e3627f983fe435b222ea5 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f36b71efee7fc61fb8a3d5c8ce0cf0 inherit pub_methods_classEpetra__BLAS" id="r_a93f36b71efee7fc61fb8a3d5c8ce0cf0"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>COPY</b> (const int N, const double *X, double *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:a93f36b71efee7fc61fb8a3d5c8ce0cf0 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> vector scale function (DCOPY) <br /></td></tr>
<tr class="separator:a93f36b71efee7fc61fb8a3d5c8ce0cf0 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6412c2b4a56fbe2d0bbe94cc7a65e5f8 inherit pub_methods_classEpetra__BLAS" id="r_a6412c2b4a56fbe2d0bbe94cc7a65e5f8"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>IAMAX</b> (const int N, const float *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a6412c2b4a56fbe2d0bbe94cc7a65e5f8 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> arg maximum of absolute value function (ISAMAX) <br /></td></tr>
<tr class="separator:a6412c2b4a56fbe2d0bbe94cc7a65e5f8 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5532e66d0bd32b6ca19871bc007b6e16 inherit pub_methods_classEpetra__BLAS" id="r_a5532e66d0bd32b6ca19871bc007b6e16"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>IAMAX</b> (const int N, const double *X, const int INCX=1) const</td></tr>
<tr class="memdesc:a5532e66d0bd32b6ca19871bc007b6e16 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> arg maximum of absolute value function (IDAMAX) <br /></td></tr>
<tr class="separator:a5532e66d0bd32b6ca19871bc007b6e16 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05c457263f160300f80c638525a5e19 inherit pub_methods_classEpetra__BLAS" id="r_af05c457263f160300f80c638525a5e19"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>AXPY</b> (const int N, const float ALPHA, const float *X, float *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:af05c457263f160300f80c638525a5e19 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> vector update function (SAXPY) <br /></td></tr>
<tr class="separator:af05c457263f160300f80c638525a5e19 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3042fd0acc417128584ce36483dc079 inherit pub_methods_classEpetra__BLAS" id="r_ac3042fd0acc417128584ce36483dc079"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>AXPY</b> (const int N, const double ALPHA, const double *X, double *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:ac3042fd0acc417128584ce36483dc079 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> vector update function (DAXPY) <br /></td></tr>
<tr class="separator:ac3042fd0acc417128584ce36483dc079 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ad7f5429608aba90723eb46a426575 inherit pub_methods_classEpetra__BLAS" id="r_ae9ad7f5429608aba90723eb46a426575"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEMV</b> (const char TRANS, const int M, const int N, const float ALPHA, const float *A, const int LDA, const float *X, const float BETA, float *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:ae9ad7f5429608aba90723eb46a426575 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> matrix-vector multiply function (SGEMV) <br /></td></tr>
<tr class="separator:ae9ad7f5429608aba90723eb46a426575 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa69dbfc706abc19f3d441ffc07683c inherit pub_methods_classEpetra__BLAS" id="r_a0aa69dbfc706abc19f3d441ffc07683c"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEMV</b> (const char TRANS, const int M, const int N, const double ALPHA, const double *A, const int LDA, const double *X, const double BETA, double *Y, const int INCX=1, const int INCY=1) const</td></tr>
<tr class="memdesc:a0aa69dbfc706abc19f3d441ffc07683c inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> matrix-vector multiply function (DGEMV) <br /></td></tr>
<tr class="separator:a0aa69dbfc706abc19f3d441ffc07683c inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c5f255a3a03f9d3fa87aaa6cfb92ec inherit pub_methods_classEpetra__BLAS" id="r_a95c5f255a3a03f9d3fa87aaa6cfb92ec"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEMM</b> (const char TRANSA, const char TRANSB, const int M, const int N, const int K, const float ALPHA, const float *A, const int LDA, const float *B, const int LDB, const float BETA, float *C, const int LDC) const</td></tr>
<tr class="memdesc:a95c5f255a3a03f9d3fa87aaa6cfb92ec inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> matrix-matrix multiply function (SGEMM) <br /></td></tr>
<tr class="separator:a95c5f255a3a03f9d3fa87aaa6cfb92ec inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf93b9ef6ee2782cbbdc1e2ac00b5a2e inherit pub_methods_classEpetra__BLAS" id="r_acf93b9ef6ee2782cbbdc1e2ac00b5a2e"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>GEMM</b> (const char TRANSA, const char TRANSB, const int M, const int N, const int K, const double ALPHA, const double *A, const int LDA, const double *B, const int LDB, const double BETA, double *C, const int LDC) const</td></tr>
<tr class="memdesc:acf93b9ef6ee2782cbbdc1e2ac00b5a2e inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> matrix-matrix multiply function (DGEMM) <br /></td></tr>
<tr class="separator:acf93b9ef6ee2782cbbdc1e2ac00b5a2e inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa11c3c601b27c400568a60596434b4 inherit pub_methods_classEpetra__BLAS" id="r_a8fa11c3c601b27c400568a60596434b4"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYMM</b> (const char SIDE, const char UPLO, const int M, const int N, const float ALPHA, const float *A, const int LDA, const float *B, const int LDB, const float BETA, float *C, const int LDC) const</td></tr>
<tr class="memdesc:a8fa11c3c601b27c400568a60596434b4 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> symmetric matrix-matrix multiply function (SSYMM) <br /></td></tr>
<tr class="separator:a8fa11c3c601b27c400568a60596434b4 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ca61221b2acf0befef968748c6bb80 inherit pub_methods_classEpetra__BLAS" id="r_ad1ca61221b2acf0befef968748c6bb80"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYMM</b> (const char SIDE, const char UPLO, const int M, const int N, const double ALPHA, const double *A, const int LDA, const double *B, const int LDB, const double BETA, double *C, const int LDC) const</td></tr>
<tr class="memdesc:ad1ca61221b2acf0befef968748c6bb80 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> matrix-matrix multiply function (DSYMM) <br /></td></tr>
<tr class="separator:ad1ca61221b2acf0befef968748c6bb80 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2dcbf05331765f0ddb661460390a6e inherit pub_methods_classEpetra__BLAS" id="r_add2dcbf05331765f0ddb661460390a6e"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>TRMM</b> (const char SIDE, const char UPLO, const char TRANSA, const char DIAG, const int M, const int N, const float ALPHA, const float *A, const int LDA, float *B, const int LDB) const</td></tr>
<tr class="memdesc:add2dcbf05331765f0ddb661460390a6e inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> triangular matrix-matrix multiply function (STRMM) <br /></td></tr>
<tr class="separator:add2dcbf05331765f0ddb661460390a6e inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65212f8eee6597c24722b7bf2d54168b inherit pub_methods_classEpetra__BLAS" id="r_a65212f8eee6597c24722b7bf2d54168b"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>TRMM</b> (const char SIDE, const char UPLO, const char TRANSA, const char DIAG, const int M, const int N, const double ALPHA, const double *A, const int LDA, double *B, const int LDB) const</td></tr>
<tr class="memdesc:a65212f8eee6597c24722b7bf2d54168b inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEpetra__BLAS.html" title="Epetra_BLAS: The Epetra BLAS Wrapper Class.">Epetra_BLAS</a> triangular matrix-matrix multiply function (DTRMM) <br /></td></tr>
<tr class="separator:a65212f8eee6597c24722b7bf2d54168b inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd9f6cd122a04b0544b62f26761b885 inherit pub_methods_classEpetra__BLAS" id="r_a6fd9f6cd122a04b0544b62f26761b885"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYRK</b> (const char UPLO, const char TRANS, const int N, const int K, const float ALPHA, const float *A, const int LDA, const float BETA, float *C, const int LDC) const</td></tr>
<tr class="memdesc:a6fd9f6cd122a04b0544b62f26761b885 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eperta_BLAS symetric rank k funtion (ssyrk) <br /></td></tr>
<tr class="separator:a6fd9f6cd122a04b0544b62f26761b885 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a2d21fe184982d57544b23b66ba522 inherit pub_methods_classEpetra__BLAS" id="r_a97a2d21fe184982d57544b23b66ba522"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SYRK</b> (const char UPLO, const char TRANS, const int N, const int K, const double ALPHA, const double *A, const int LDA, const double BETA, double *C, const int LDC) const</td></tr>
<tr class="memdesc:a97a2d21fe184982d57544b23b66ba522 inherit pub_methods_classEpetra__BLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eperta_BLAS symetric rank k funtion (dsyrk) <br /></td></tr>
<tr class="separator:a97a2d21fe184982d57544b23b66ba522 inherit pub_methods_classEpetra__BLAS"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Expert-only unsupported methods</h2></td></tr>
<tr class="memitem:a12a02752d438e80a97d8fd829bd9ef5e" id="r_a12a02752d438e80a97d8fd829bd9ef5e"><td class="memItemLeft" align="right" valign="top"><a id="a12a02752d438e80a97d8fd829bd9ef5e" name="a12a02752d438e80a97d8fd829bd9ef5e"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>Values_</b></td></tr>
<tr class="separator:a12a02752d438e80a97d8fd829bd9ef5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea26a66b256ff1d75c9b3d0af70df68" id="r_a5ea26a66b256ff1d75c9b3d0af70df68"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__MultiVector.html#a5ea26a66b256ff1d75c9b3d0af70df68">ResetView</a> (double **ArrayOfPointers)</td></tr>
<tr class="memdesc:a5ea26a66b256ff1d75c9b3d0af70df68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the view of an existing multivector to point to new user data.  <br /></td></tr>
<tr class="separator:a5ea26a66b256ff1d75c9b3d0af70df68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3afa43a0232cac3d7cf11f77dfe5be" id="r_a7e3afa43a0232cac3d7cf11f77dfe5be"><td class="memItemLeft" align="right" valign="top"><a id="a7e3afa43a0232cac3d7cf11f77dfe5be" name="a7e3afa43a0232cac3d7cf11f77dfe5be"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>Values</b> () const</td></tr>
<tr class="memdesc:a7e3afa43a0232cac3d7cf11f77dfe5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to MultiVector values. <br /></td></tr>
<tr class="separator:a7e3afa43a0232cac3d7cf11f77dfe5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82a2e0e8a81bb1fe2ab9b544d327e4a" id="r_aa82a2e0e8a81bb1fe2ab9b544d327e4a"><td class="memItemLeft" align="right" valign="top"><a id="aa82a2e0e8a81bb1fe2ab9b544d327e4a" name="aa82a2e0e8a81bb1fe2ab9b544d327e4a"></a>
double **&#160;</td><td class="memItemRight" valign="bottom"><b>Pointers</b> () const</td></tr>
<tr class="memdesc:aa82a2e0e8a81bb1fe2ab9b544d327e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to individual vector pointers. <br /></td></tr>
<tr class="separator:aa82a2e0e8a81bb1fe2ab9b544d327e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33604409706b5e5a5bcbed3d6eb21d5" id="r_ae33604409706b5e5a5bcbed3d6eb21d5"><td class="memItemLeft" align="right" valign="top"><a id="ae33604409706b5e5a5bcbed3d6eb21d5" name="ae33604409706b5e5a5bcbed3d6eb21d5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Reduce</b> ()</td></tr>
<tr class="separator:ae33604409706b5e5a5bcbed3d6eb21d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860c69507551a6e08d0f7cd2b302d8b1" id="r_a860c69507551a6e08d0f7cd2b302d8b1"><td class="memItemLeft" align="right" valign="top"><a id="a860c69507551a6e08d0f7cd2b302d8b1" name="a860c69507551a6e08d0f7cd2b302d8b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Assign</b> (const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;rhs)</td></tr>
<tr class="separator:a860c69507551a6e08d0f7cd2b302d8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6126b3bf6e554285562ec5f74f76e1" id="r_a9e6126b3bf6e554285562ec5f74f76e1"><td class="memItemLeft" align="right" valign="top"><a id="a9e6126b3bf6e554285562ec5f74f76e1" name="a9e6126b3bf6e554285562ec5f74f76e1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>CheckInput</b> ()</td></tr>
<tr class="separator:a9e6126b3bf6e554285562ec5f74f76e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classEpetra__Object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classEpetra__Object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classEpetra__Object.html">Epetra_Object</a></td></tr>
<tr class="memitem:a3e039dae700d04726e0e78d73b69e7f6 inherit pub_static_methods_classEpetra__Object" id="r_a3e039dae700d04726e0e78d73b69e7f6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEpetra__Object.html#a3e039dae700d04726e0e78d73b69e7f6">SetTracebackMode</a> (int TracebackModeValue)</td></tr>
<tr class="memdesc:a3e039dae700d04726e0e78d73b69e7f6 inherit pub_static_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the <a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> error traceback report mode.  <br /></td></tr>
<tr class="separator:a3e039dae700d04726e0e78d73b69e7f6 inherit pub_static_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20914bd9b7bb7278ab332415c77ba999 inherit pub_static_methods_classEpetra__Object" id="r_a20914bd9b7bb7278ab332415c77ba999"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><b>GetTracebackMode</b> ()</td></tr>
<tr class="memdesc:a20914bd9b7bb7278ab332415c77ba999 inherit pub_static_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the <a class="el" href="classEpetra__Object.html" title="Epetra_Object: The base Epetra class.">Epetra_Object</a> error report mode. <br /></td></tr>
<tr class="separator:a20914bd9b7bb7278ab332415c77ba999 inherit pub_static_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661d6081fb13e1b4a4350faa88808f38 inherit pub_static_methods_classEpetra__Object" id="r_a661d6081fb13e1b4a4350faa88808f38"><td class="memItemLeft" align="right" valign="top">
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetTracebackStream</b> ()</td></tr>
<tr class="memdesc:a661d6081fb13e1b4a4350faa88808f38 inherit pub_static_methods_classEpetra__Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the output stream for error reporting. <br /></td></tr>
<tr class="separator:a661d6081fb13e1b4a4350faa88808f38 inherit pub_static_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classEpetra__Object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classEpetra__Object')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classEpetra__Object.html">Epetra_Object</a></td></tr>
<tr class="memitem:abcc693a0058b9910543df8c4ae76e5d9 inherit pub_static_attribs_classEpetra__Object" id="r_abcc693a0058b9910543df8c4ae76e5d9"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><b>TracebackMode</b></td></tr>
<tr class="separator:abcc693a0058b9910543df8c4ae76e5d9 inherit pub_static_attribs_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classEpetra__DistObject"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classEpetra__DistObject')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classEpetra__DistObject.html">Epetra_DistObject</a></td></tr>
<tr class="memitem:ab26ca2d3f9d20a850734f4af633e4135 inherit pro_methods_classEpetra__DistObject" id="r_ab26ca2d3f9d20a850734f4af633e4135"><td class="memItemLeft" align="right" valign="top">
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>DoTransfer</b> (const <a class="el" href="classEpetra__SrcDistObject.html">Epetra_SrcDistObject</a> &amp;A, <a class="el" href="Epetra__CombineMode_8h.html#aae659d58333dccaf8db7230bd834020f">Epetra_CombineMode</a> CombineMode, int NumSameIDs, int NumPermuteIDs, int NumRemoteIDs, int NumExportIDs, int *PermuteToLIDs, int *PermuteFromLIDs, int *RemoteLIDs, int *ExportLIDs, int &amp;LenExports, char *&amp;Exports, int &amp;LenImports, char *&amp;Imports, <a class="el" href="classEpetra__Distributor.html">Epetra_Distributor</a> &amp;Distor, bool DoReverse, const <a class="el" href="classEpetra__OffsetIndex.html">Epetra_OffsetIndex</a> *Indexor)</td></tr>
<tr class="memdesc:ab26ca2d3f9d20a850734f4af633e4135 inherit pro_methods_classEpetra__DistObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform actual transfer (redistribution) of data across memory images, using <a class="el" href="classEpetra__Distributor.html" title="Epetra_Distributor: The Epetra Gather/Scatter Setup Base Class.">Epetra_Distributor</a> object. <br /></td></tr>
<tr class="separator:ab26ca2d3f9d20a850734f4af633e4135 inherit pro_methods_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classEpetra__Object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classEpetra__Object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classEpetra__Object.html">Epetra_Object</a></td></tr>
<tr class="memitem:a4e3832c165d22a45d3dd6fecd16d91f4 inherit pro_methods_classEpetra__Object" id="r_a4e3832c165d22a45d3dd6fecd16d91f4"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (const int &amp;x) const</td></tr>
<tr class="separator:a4e3832c165d22a45d3dd6fecd16d91f4 inherit pro_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3f57c8b22b5b0df91400fca8447ab2 inherit pro_methods_classEpetra__Object" id="r_aaa3f57c8b22b5b0df91400fca8447ab2"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (const long long &amp;x) const</td></tr>
<tr class="separator:aaa3f57c8b22b5b0df91400fca8447ab2 inherit pro_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a2fa958fffb21a0479a19956185be1 inherit pro_methods_classEpetra__Object" id="r_ab8a2fa958fffb21a0479a19956185be1"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (const double &amp;x) const</td></tr>
<tr class="separator:ab8a2fa958fffb21a0479a19956185be1 inherit pro_methods_classEpetra__Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classEpetra__DistObject"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classEpetra__DistObject')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classEpetra__DistObject.html">Epetra_DistObject</a></td></tr>
<tr class="memitem:afe0876212b0bc64248080c7949cc2fe8 inherit pro_attribs_classEpetra__DistObject" id="r_afe0876212b0bc64248080c7949cc2fe8"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Map_</b></td></tr>
<tr class="separator:afe0876212b0bc64248080c7949cc2fe8 inherit pro_attribs_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b10439013b488908a69faf197b3720 inherit pro_attribs_classEpetra__DistObject" id="r_af6b10439013b488908a69faf197b3720"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classEpetra__Comm.html">Epetra_Comm</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Comm_</b></td></tr>
<tr class="separator:af6b10439013b488908a69faf197b3720 inherit pro_attribs_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55db06ab43cc8633cc98bda807b75052 inherit pro_attribs_classEpetra__DistObject" id="r_a55db06ab43cc8633cc98bda807b75052"><td class="memItemLeft" align="right" valign="top">
char *&#160;</td><td class="memItemRight" valign="bottom"><b>Exports_</b></td></tr>
<tr class="separator:a55db06ab43cc8633cc98bda807b75052 inherit pro_attribs_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c0a956075d9df8f96480a64695afef inherit pro_attribs_classEpetra__DistObject" id="r_ac2c0a956075d9df8f96480a64695afef"><td class="memItemLeft" align="right" valign="top">
char *&#160;</td><td class="memItemRight" valign="bottom"><b>Imports_</b></td></tr>
<tr class="separator:ac2c0a956075d9df8f96480a64695afef inherit pro_attribs_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa299778b21bd3310bfa8b91b1435f1d2 inherit pro_attribs_classEpetra__DistObject" id="r_aa299778b21bd3310bfa8b91b1435f1d2"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>LenExports_</b></td></tr>
<tr class="separator:aa299778b21bd3310bfa8b91b1435f1d2 inherit pro_attribs_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d50d714698b235360d6c9b8c457df4 inherit pro_attribs_classEpetra__DistObject" id="r_ab3d50d714698b235360d6c9b8c457df4"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>LenImports_</b></td></tr>
<tr class="separator:ab3d50d714698b235360d6c9b8c457df4 inherit pro_attribs_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9bc03c6fef4031fe9358c9e855e174 inherit pro_attribs_classEpetra__DistObject" id="r_a2a9bc03c6fef4031fe9358c9e855e174"><td class="memItemLeft" align="right" valign="top">
int *&#160;</td><td class="memItemRight" valign="bottom"><b>Sizes_</b></td></tr>
<tr class="separator:a2a9bc03c6fef4031fe9358c9e855e174 inherit pro_attribs_classEpetra__DistObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classEpetra__CompObject"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classEpetra__CompObject')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classEpetra__CompObject.html">Epetra_CompObject</a></td></tr>
<tr class="memitem:a4095552501f59c9dc407185a4944759f inherit pro_attribs_classEpetra__CompObject" id="r_a4095552501f59c9dc407185a4944759f"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classEpetra__Flops.html">Epetra_Flops</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>FlopCounter_</b></td></tr>
<tr class="separator:a4095552501f59c9dc407185a4944759f inherit pro_attribs_classEpetra__CompObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a>: A class for constructing and using dense multi-vectors, vectors and matrices in parallel. </p>
<p>The <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> class enables the construction and use of real-valued, double-precision dense vectors, multi-vectors, and matrices in a distributed memory environment. The dimensions and distribution of the dense multi-vectors is determined in part by a <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> object, a <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> (or <a class="el" href="classEpetra__LocalMap.html" title="Epetra_LocalMap: A class for replicating vectors and matrices across multiple processors.">Epetra_LocalMap</a> or <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a>) and the number of vectors passed to the constructors described below.</p>
<p>There are several concepts that important for understanding the <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> class:</p>
<ul>
<li>
Multi-vectors, Vectors and Matrices. <ul>
<li>
Vector - A list of real-valued, double-precision numbers. Also a multi-vector with one vector. </li>
<li>
Multi-Vector - A collection of one or more vectors, all having the same length and distribution. </li>
<li>
(Dense) Matrix - A special form of multi-vector such that stride in memory between any two consecutive vectors in the multi-vector is the same for all vectors. This is identical to a two-dimensional array in Fortran and plays an important part in high performance computations. </li>
</ul>
</li>
<li>
Distributed Global vs. Replicated Local. <ul>
<li>
Distributed Global Multi-vectors - In most instances, a multi-vector will be partitioned across multiple memory images associated with multiple processors. In this case, there is a unique copy of each element and elements are spread across all processors specified by the <a class="el" href="classEpetra__Comm.html" title="Epetra_Comm: The Epetra Communication Abstract Base Class.">Epetra_Comm</a> communicator. </li>
<li>
Replicated Local Multi-vectors - Some algorithms use multi-vectors that are too small to be distributed across all processors, the Hessenberg matrix in a GMRES computation. In other cases, such as with block iterative methods, block dot product functions produce small dense matrices that are required by all processors. Replicated local multi-vectors handle these types of situation. </li>
</ul>
</li>
<li>
Multi-vector Functions vs. Dense Matrix Functions. <ul>
<li>
Multi-vector functions - These functions operate simultaneously but independently on each vector in the multi-vector and produce individual results for each vector. </li>
<li>
Dense matrix functions - These functions operate on the multi-vector as a matrix, providing access to selected dense BLAS and LAPACK operations. </li>
</ul>
</li>
</ul>
<p><b>Constructing Epetra_MultiVectors</b></p>
<p>Except for the basic constructor and copy constructor, <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> constructors have two data access modes: </p><ol>
<li>
Copy mode - Allocates memory and makes a copy of the user-provided data. In this case, the user data is not needed after construction. </li>
<li>
View mode - Creates a "view" of the user data. In this case, the user data is required to remain intact for the life of the multi-vector. </li>
</ol>
<dl class="section warning"><dt>Warning</dt><dd>View mode is <em>extremely</em> dangerous from a data hiding perspective. Therefore, we strongly encourage users to develop code using Copy mode first and only use the View mode in a secondary optimization phase.</dd></dl>
<p>All <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> constructors require a map argument that describes the layout of elements on the parallel machine. Specifically, <code>map</code> is a <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a>, <a class="el" href="classEpetra__LocalMap.html" title="Epetra_LocalMap: A class for replicating vectors and matrices across multiple processors.">Epetra_LocalMap</a> or <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> object describing the desired memory layout for the multi-vector.</p>
<p>There are six different <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> constructors: </p><ul>
<li>
Basic - All values are zero. </li>
<li>
Copy - Copy an existing multi-vector. </li>
<li>
Copy from or make view of two-dimensional Fortran style array. </li>
<li>
Copy from or make view of an array of pointers. </li>
<li>
Copy or make view of a list of vectors from another <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> object. </li>
<li>
Copy or make view of a range of vectors from another <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> object. </li>
</ul>
<p><b>Extracting Data from Epetra_MultiVectors</b></p>
<p>Once a <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> is constructed, it is possible to extract a copy of the values or create a view of them.</p>
<dl class="section warning"><dt>Warning</dt><dd>ExtractView functions are <em>extremely</em> dangerous from a data hiding perspective. For both ExtractView fuctions, there is a corresponding ExtractCopy function. We strongly encourage users to develop code using ExtractCopy functions first and only use the ExtractView functions in a secondary optimization phase.</dd></dl>
<p>There are four Extract functions: </p><ul>
<li>
ExtractCopy - Copy values into a user-provided two-dimensional array. </li>
<li>
ExtractCopy - Copy values into a user-provided array of pointers. </li>
<li>
ExtractView - Set user-provided two-dimensional array parameters to point to <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> data. </li>
<li>
ExtractView - Set user-provided array of pointer parameters to point to <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> data. </li>
</ul>
<p><b>Vector, Matrix and Utility Functions</b></p>
<p>Once a <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> is constructed, a variety of mathematical functions can be applied to the individual vectors. Specifically: </p><ul>
<li>
Dot Products. </li>
<li>
Vector Updates. </li>
<li>
<em>p</em> Norms. </li>
<li>
Weighted Norms. </li>
<li>
Minimum, Maximum and Average Values. </li>
</ul>
<p>In addition, a matrix-matrix multiply function supports a variety of operations on any viable combination of global distributed and local replicated multi-vectors using calls to DGEMM, a high performance kernel for matrix operations. In the near future we will add support for calls to other selected BLAS and LAPACK functions.</p>
<p><b> Counting Floating Point Operations </b></p>
<p>Each <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> object keep track of the number of <em>serial</em> floating point operations performed using the specified object as the <em>this</em> argument to the function. The <a class="el" href="classEpetra__CompObject.html#a8326f0873a8866ac9f15f08f5ef31b0d" title="Returns the number of floating point operations with this multi-vector.">Flops()</a> function returns this number as a double precision number. Using this information, in conjunction with the <a class="el" href="classEpetra__Time.html" title="Epetra_Time: The Epetra Timing Class.">Epetra_Time</a> class, one can get accurate parallel performance numbers. The <a class="el" href="classEpetra__CompObject.html#a4adff4c34d61377709fc8a17e99e3eae" title="Resets the number of floating point operations to zero for this multi-vector.">ResetFlops()</a> function resets the floating point counter.</p>
<dl class="section warning"><dt>Warning</dt><dd>A <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a>, <a class="el" href="classEpetra__LocalMap.html" title="Epetra_LocalMap: A class for replicating vectors and matrices across multiple processors.">Epetra_LocalMap</a> or <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a> object is required for all <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> constructors. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aff75bed4ad99508ed7319460fe749d7c" name="aff75bed4ad99508ed7319460fe749d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff75bed4ad99508ed7319460fe749d7c">&#9670;&#160;</a></span>Epetra_MultiVector() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_MultiVector::Epetra_MultiVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;&#160;</td>
          <td class="paramname"><em>Map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumVectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zeroOut</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Basic <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> constuctor. </p>
<p>Creates a <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> object and, by default, fills with zero values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>Map - A <a class="el" href="classEpetra__LocalMap.html" title="Epetra_LocalMap: A class for replicating vectors and matrices across multiple processors.">Epetra_LocalMap</a>, <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> or <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Note that, because <a class="el" href="classEpetra__LocalMap.html" title="Epetra_LocalMap: A class for replicating vectors and matrices across multiple processors.">Epetra_LocalMap</a> derives from <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> and <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> derives from <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a>, this constructor works for all three types of Epetra map classes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>NumVectors - Number of vectors in multi-vector. </td></tr>
    <tr><td class="paramname">In</td><td>zeroOut - If <code>true</code> then the allocated memory will be zeroed out initialy. If <code>false</code> then this memory will not be touched which can be significantly faster. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a>. </dd></dl>

</div>
</div>
<a id="a39dd3af2515fd65193ccd0a21d02740f" name="a39dd3af2515fd65193ccd0a21d02740f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39dd3af2515fd65193ccd0a21d02740f">&#9670;&#160;</a></span>Epetra_MultiVector() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_MultiVector::Epetra_MultiVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a>&#160;</td>
          <td class="paramname"><em>CV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;&#160;</td>
          <td class="paramname"><em>Map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MyLDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumVectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set multi-vector values from two-dimensional array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>Epetra_DataAccess - Enumerated type set to Copy or View. </td></tr>
    <tr><td class="paramname">In</td><td>Map - A <a class="el" href="classEpetra__LocalMap.html" title="Epetra_LocalMap: A class for replicating vectors and matrices across multiple processors.">Epetra_LocalMap</a>, <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> or <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a>. </td></tr>
    <tr><td class="paramname">In</td><td>A - Pointer to an array of double precision numbers. The first vector starts at A. The second vector starts at A+MyLDA, the third at A+2*MyLDA, and so on. </td></tr>
    <tr><td class="paramname">In</td><td>MyLDA - The "Leading Dimension", or stride between vectors in memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This value refers to the stride on the calling processor. Thus it is a local quantity, not a global quantity. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>NumVectors - Number of vectors in multi-vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful.</dd></dl>
<p>See Detailed Description section for further discussion. </p>

</div>
</div>
<a id="a17605f4bf2fd5967169be3b4b56004df" name="a17605f4bf2fd5967169be3b4b56004df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17605f4bf2fd5967169be3b4b56004df">&#9670;&#160;</a></span>Epetra_MultiVector() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_MultiVector::Epetra_MultiVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a>&#160;</td>
          <td class="paramname"><em>CV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;&#160;</td>
          <td class="paramname"><em>Map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>ArrayOfPointers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumVectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set multi-vector values from array of pointers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>Epetra_DataAccess - Enumerated type set to Copy or View. </td></tr>
    <tr><td class="paramname">In</td><td>Map - A <a class="el" href="classEpetra__LocalMap.html" title="Epetra_LocalMap: A class for replicating vectors and matrices across multiple processors.">Epetra_LocalMap</a>, <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a> or <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a>. </td></tr>
    <tr><td class="paramname">In</td><td>ArrayOfPointers - An array of pointers such that ArrayOfPointers[i] points to the memory location containing ith vector to be copied. </td></tr>
    <tr><td class="paramname">In</td><td>NumVectors - Number of vectors in multi-vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful.</dd></dl>
<p>See Detailed Description section for further discussion. </p>

</div>
</div>
<a id="a996dbd09376c8eea018e8467b977f282" name="a996dbd09376c8eea018e8467b977f282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996dbd09376c8eea018e8467b977f282">&#9670;&#160;</a></span>Epetra_MultiVector() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_MultiVector::Epetra_MultiVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a>&#160;</td>
          <td class="paramname"><em>CV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumVectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set multi-vector values from list of vectors in an existing <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>Epetra_DataAccess - Enumerated type set to Copy or View. </td></tr>
    <tr><td class="paramname">In</td><td>Source - An existing fully constructed <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a>. </td></tr>
    <tr><td class="paramname">In</td><td>Indices - Integer list of the vectors to copy. </td></tr>
    <tr><td class="paramname">In</td><td>NumVectors - Number of vectors in multi-vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful.</dd></dl>
<p>See Detailed Description section for further discussion. </p>

</div>
</div>
<a id="aca53de28aec32b9c35b5e96a8c7e2503" name="aca53de28aec32b9c35b5e96a8c7e2503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca53de28aec32b9c35b5e96a8c7e2503">&#9670;&#160;</a></span>Epetra_MultiVector() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_MultiVector::Epetra_MultiVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Epetra__DataAccess_8h.html#ad1a985e79f94ad63030815a0d7d90928">Epetra_DataAccess</a>&#160;</td>
          <td class="paramname"><em>CV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>StartIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumVectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set multi-vector values from range of vectors in an existing <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>Epetra_DataAccess - Enumerated type set to Copy or View. </td></tr>
    <tr><td class="paramname">In</td><td>Source - An existing fully constructed <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a>. </td></tr>
    <tr><td class="paramname">In</td><td>StartIndex - First of the vectors to copy. </td></tr>
    <tr><td class="paramname">In</td><td>NumVectors - Number of vectors in multi-vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful.</dd></dl>
<p>See Detailed Description section for further discussion. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a367cbac4464dbdc1666ee30d5f4420b9" name="a367cbac4464dbdc1666ee30d5f4420b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367cbac4464dbdc1666ee30d5f4420b9">&#9670;&#160;</a></span>Abs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::Abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts element-wise absolute values of input Multi-vector in target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>A - Input Multi-vector. </td></tr>
    <tr><td class="paramname">Out</td><td><em>this</em> will contain the absolute values of the entries of A.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful.</dd></dl>
<p>Note: It is possible to use the same argument for A and <em>this</em>. </p>

</div>
</div>
<a id="a42974c01bd60ededd0a1463e24505f0f" name="a42974c01bd60ededd0a1463e24505f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42974c01bd60ededd0a1463e24505f0f">&#9670;&#160;</a></span>Dot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::Dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes dot product of each corresponding pair of vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>A - Multi-vector to be used with the "\e this" multivector. </td></tr>
    <tr><td class="paramname">Out</td><td>Result - Result[i] will contain the ith dot product result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="a501a65632630a8f3d76c2d41520d7ff5" name="a501a65632630a8f3d76c2d41520d7ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a501a65632630a8f3d76c2d41520d7ff5">&#9670;&#160;</a></span>ExtractCopy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::ExtractCopy </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>ArrayOfPointers</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put multi-vector values into user-provided array of pointers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Out</td><td>ArrayOfPointers - An array of pointers to memory space that will contain the multi-vector values, such that ArrayOfPointers[i] points to the memory location where the ith vector to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful.</dd></dl>
<p>See Detailed Description section for further discussion. </p>

</div>
</div>
<a id="ac8efbf138bbe2aae80d0182517e0c858" name="ac8efbf138bbe2aae80d0182517e0c858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8efbf138bbe2aae80d0182517e0c858">&#9670;&#160;</a></span>ExtractCopy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::ExtractCopy </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MyLDA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put multi-vector values into user-provided two-dimensional array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Out</td><td>A - Pointer to memory space that will contain the multi-vector values. The first vector will be copied to the memory pointed to by A. The second vector starts at A+MyLDA, the third at A+2*MyLDA, and so on. </td></tr>
    <tr><td class="paramname">In</td><td>MyLDA - The "Leading Dimension", or stride between vectors in memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This value refers to the stride on the calling processor. Thus it is a local quantity, not a global quantity.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful.</dd></dl>
<p>See Detailed Description section for further discussion. </p>

</div>
</div>
<a id="a23b7e5bdad32070eba0c7585edd774de" name="a23b7e5bdad32070eba0c7585edd774de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b7e5bdad32070eba0c7585edd774de">&#9670;&#160;</a></span>ExtractView() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::ExtractView </td>
          <td>(</td>
          <td class="paramtype">double ***&#160;</td>
          <td class="paramname"><em>ArrayOfPointers</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set user-provided addresses of ArrayOfPointers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ArrayOfPointers</td><td>(Out) - Address of array of pointers to memory space that will set to the multi-vector array of pointers, such that ArrayOfPointers[i] points to the memory location where the ith vector is located.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful.</dd></dl>
<p>See Detailed Description section for further discussion. </p>

</div>
</div>
<a id="a4d513146280b1ad49b6cb0df0d999921" name="a4d513146280b1ad49b6cb0df0d999921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d513146280b1ad49b6cb0df0d999921">&#9670;&#160;</a></span>ExtractView() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::ExtractView </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>MyLDA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set user-provided addresses of A and MyLDA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>(Out) - Address of a pointer to that will be set to point to the values of the multi-vector. The first vector will be at the memory pointed to by A. The second vector starts at A+MyLDA, the third at A+2*MyLDA, and so on. </td></tr>
    <tr><td class="paramname">MyLDA</td><td>(Out) - Address of the "Leading Dimension", or stride between vectors in memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This value refers to the stride on the calling processor. Thus it is a local quantity, not a global quantity.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful.</dd></dl>
<p>See Detailed Description section for further discussion. </p>

</div>
</div>
<a id="ac2665de83872bb7eecf7915a4cc7cbce" name="ac2665de83872bb7eecf7915a4cc7cbce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2665de83872bb7eecf7915a4cc7cbce">&#9670;&#160;</a></span>MaxValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::MaxValue </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Result</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute maximum value of each vector in multi-vector. </p>
<p>Note that the vector contents must be already initialized for this function to compute a well-defined result. The length of the vector need not be greater than zero on all processors. If length is greater than zero on any processor then a valid result will be computed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Out</td><td>Result - Result[i] contains maximum value of ith vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="ab6199b28d1195c66c8c31b62e36163e3" name="ab6199b28d1195c66c8c31b62e36163e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6199b28d1195c66c8c31b62e36163e3">&#9670;&#160;</a></span>MeanValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::MeanValue </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Result</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute mean (average) value of each vector in multi-vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Out</td><td>Result - Result[i] contains mean value of ith vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Map of the <em>this</em> multivector must have unique GIDs (UniqueGIDs() must return true).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="a3e547756c3e47ec33e0c84199c4b7a98" name="a3e547756c3e47ec33e0c84199c4b7a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e547756c3e47ec33e0c84199c4b7a98">&#9670;&#160;</a></span>MinValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::MinValue </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Result</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute minimum value of each vector in multi-vector. </p>
<p>Note that the vector contents must be already initialized for this function to compute a well-defined result. The length of the vector need not be greater than zero on all processors. If length is greater than zero on any processor then a valid result will be computed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Out</td><td>Result - Result[i] contains minimum value of ith vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="a865636722de327e1b4f89e7a8153174d" name="a865636722de327e1b4f89e7a8153174d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865636722de327e1b4f89e7a8153174d">&#9670;&#160;</a></span>Multiply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::Multiply </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>TransB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ScalarAB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ScalarThis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix-Matrix multiplication, <em>this</em> = ScalarThis*<em>this</em> + ScalarAB*A*B. </p>
<p>This function performs a variety of matrix-matrix multiply operations, interpreting the Epetra_MultiVectors (<em>this-aka</em> C , A and B) as 2D matrices. Variations are due to the fact that A, B and C can be local replicated or global distributed Epetra_MultiVectors and that we may or may not operate with the transpose of A and B. Possible cases are: </p><pre class="fragment">Total of 32 case (2^5).
Num
OPERATIONS                        case  Notes
1) C(local) = A^X(local) * B^X(local)  4   (X=Transpose or Not, No comm needed)
2) C(local) = A^T(distr) * B  (distr)  1   (2D dot product, replicate C)
3) C(distr) = A  (distr) * B^X(local)  2   (2D vector update, no comm needed)

Note that the following operations are not meaningful for
1D distributions:

1) C(local) = A^T(distr) * B^T(distr)  1
2) C(local) = A  (distr) * B^X(distr)  2
3) C(distr) = A^X(local) * B^X(local)  4
4) C(distr) = A^X(local) * B^X(distr)  4
5) C(distr) = A^T(distr) * B^X(local)  2
6) C(local) = A^X(distr) * B^X(local)  4
7) C(distr) = A^X(distr) * B^X(local)  4
8) C(local) = A^X(local) * B^X(distr)  4</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>TransA - Operate with the transpose of A if = 'T', else no transpose if = 'N'. </td></tr>
    <tr><td class="paramname">In</td><td>TransB - Operate with the transpose of B if = 'T', else no transpose if = 'N'.</td></tr>
    <tr><td class="paramname">In</td><td>ScalarAB - Scalar to multiply with A*B. </td></tr>
    <tr><td class="paramname">In</td><td>A - Multi-vector. </td></tr>
    <tr><td class="paramname">In</td><td>B - Multi-vector. </td></tr>
    <tr><td class="paramname">In</td><td>ScalarThis - Scalar to multiply with <em>this</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Map of the distributed multivectors must have unique GIDs (UniqueGIDs() must return true).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>{Each multi-vector A, B and <em>this</em> is checked if it has constant stride using the <a class="el" href="classEpetra__MultiVector.html#a5ecb80ded5c922ecb31f40ab558c7497" title="Returns true if this multi-vector has constant stride between vectors.">ConstantStride()</a> query function. If it does not have constant stride, a temporary copy is made and used for the computation. This activity is transparent to the user, except that there is memory and computation overhead. All temporary space is deleted prior to exit.} </dd></dl>

</div>
</div>
<a id="ae8e9a8b73fec0a60050fc8db0069b0c8" name="ae8e9a8b73fec0a60050fc8db0069b0c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e9a8b73fec0a60050fc8db0069b0c8">&#9670;&#160;</a></span>Multiply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::Multiply </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ScalarAB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ScalarThis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply a <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> with another, element-by-element. </p>
<p>This function supports diagonal matrix multiply. A is usually a single vector while B and <em>this</em> may have one or more columns. Note that B and <em>this</em> must have the same shape. A can be one vector or have the same shape as B. The actual computation is <em>this</em> = ScalarThis * <em>this</em> + ScalarAB * B @ A where @ denotes element-wise multiplication. </p>

</div>
</div>
<a id="a8791352f2435311ac74eb31217500301" name="a8791352f2435311ac74eb31217500301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8791352f2435311ac74eb31217500301">&#9670;&#160;</a></span>Norm1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::Norm1 </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Result</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute 1-norm of each vector in multi-vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Out</td><td>Result - Result[i] contains 1-norm of ith vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Map of the <em>this</em> multivector must have unique GIDs (UniqueGIDs() must return true).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="abf0a5f99517354b60527cef62dc9be61" name="abf0a5f99517354b60527cef62dc9be61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0a5f99517354b60527cef62dc9be61">&#9670;&#160;</a></span>Norm2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::Norm2 </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Result</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute 2-norm of each vector in multi-vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Out</td><td>Result - Result[i] contains 2-norm of ith vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Map of the <em>this</em> multivector must have unique GIDs (UniqueGIDs() must return true).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="a14d17f235c6223338003ae728fd7b2d1" name="a14d17f235c6223338003ae728fd7b2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d17f235c6223338003ae728fd7b2d1">&#9670;&#160;</a></span>NormInf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::NormInf </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Result</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Inf-norm of each vector in multi-vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Out</td><td>Result - Result[i] contains Inf-norm of ith vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="a5a8aa7b2667683c7087ceffa9ed2f7aa" name="a5a8aa7b2667683c7087ceffa9ed2f7aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a8aa7b2667683c7087ceffa9ed2f7aa">&#9670;&#160;</a></span>NormWeighted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::NormWeighted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Weighted 2-norm (RMS Norm) of each vector in multi-vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>Weights - Multi-vector of weights. If Weights contains a single vector, that vector will be used as the weights for all vectors of <em>this</em>. Otherwise, Weights should have the same number of vectors as <em>this</em>. </td></tr>
    <tr><td class="paramname">Out</td><td>Result - Result[i] contains the weighted 2-norm of ith vector. Specifically if we denote the ith vector in the multivector by <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$x$" src="form_4.png" width="8" height="6"/></picture>, and the ith weight vector by <picture><source srcset="form_5_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$w$" src="form_5.png" width="10" height="6"/></picture> and let j represent the jth entry of each vector, on return Result[i] will contain the following result: <p class="formulaDsp">
<picture><source srcset="form_6_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[\sqrt{(1/n)\sum_{j=1}^n(x_j/w_j)^2}\]" src="form_6.png" width="111" height="45"/></picture>
</p>
, where <picture><source srcset="form_7_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$n$" src="form_7.png" width="9" height="6"/></picture> is the global length of the vectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="a31d61d910d1e91a25907bf1d2de2fce4" name="a31d61d910d1e91a25907bf1d2de2fce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d61d910d1e91a25907bf1d2de2fce4">&#9670;&#160;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> *&amp; Epetra_MultiVector::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector access function. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> pointer to the ith vector in the multi-vector. </dd></dl>

</div>
</div>
<a id="af23b47c2b3773b8b5b46e978d9d57bf9" name="af23b47c2b3773b8b5b46e978d9d57bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23b47c2b3773b8b5b46e978d9d57bf9">&#9670;&#160;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEpetra__Vector.html">Epetra_Vector</a> *&amp; Epetra_MultiVector::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector access function. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classEpetra__Vector.html" title="Epetra_Vector: A class for constructing and using dense vectors on a parallel computer.">Epetra_Vector</a> pointer to the ith vector in the multi-vector. </dd></dl>

</div>
</div>
<a id="a58bee1de7a6522a5beecf885ea98392d" name="a58bee1de7a6522a5beecf885ea98392d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58bee1de7a6522a5beecf885ea98392d">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp; Epetra_MultiVector::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>= Operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>A - <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a>. </dd></dl>

</div>
</div>
<a id="ae5bc3f70fa2a7a8ffbdc64848edb27e8" name="ae5bc3f70fa2a7a8ffbdc64848edb27e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5bc3f70fa2a7a8ffbdc64848edb27e8">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double *&amp; Epetra_MultiVector::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector access function. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the array of doubles containing the local values of the ith vector in the multi-vector. </dd></dl>

</div>
</div>
<a id="afe5b62357cd7de5fe74e1f958d96f757" name="afe5b62357cd7de5fe74e1f958d96f757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe5b62357cd7de5fe74e1f958d96f757">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double *const  &amp; Epetra_MultiVector::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector access function. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the array of doubles containing the local values of the ith vector in the multi-vector. </dd></dl>

</div>
</div>
<a id="aca9ec9c69b488ebebb60ca7626765877" name="aca9ec9c69b488ebebb60ca7626765877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9ec9c69b488ebebb60ca7626765877">&#9670;&#160;</a></span>Print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Epetra_MultiVector::Print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print method. </p>

<p>Reimplemented from <a class="el" href="classEpetra__DistObject.html#afb80d48a0b6f974740aff376919ce107">Epetra_DistObject</a>.</p>

</div>
</div>
<a id="ad6f671d0d84d754bd103afc8dbfd5e01" name="ad6f671d0d84d754bd103afc8dbfd5e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f671d0d84d754bd103afc8dbfd5e01">&#9670;&#160;</a></span>PutScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::PutScalar </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ScalarConstant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize all values in a multi-vector with constant value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>ScalarConstant - Value to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="abc4083f49c621624031157a1314218de" name="abc4083f49c621624031157a1314218de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4083f49c621624031157a1314218de">&#9670;&#160;</a></span>Random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::Random </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set multi-vector values to random numbers. </p>
<p>MultiVector uses the random number generator provided by <a class="el" href="classEpetra__Util.html" title="Epetra_Util: The Epetra Util Wrapper Class.">Epetra_Util</a>. The multi-vector values will be set to random values on the interval (-1.0, 1.0).</p>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="a2bd5ea6f0e1cf7742db18065f6d5e687" name="a2bd5ea6f0e1cf7742db18065f6d5e687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd5ea6f0e1cf7742db18065f6d5e687">&#9670;&#160;</a></span>Reciprocal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::Reciprocal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts element-wise reciprocal values of input Multi-vector in target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>A - Input Multi-vector. </td></tr>
    <tr><td class="paramname">Out</td><td><em>this</em> will contain the element-wise reciprocal values of the entries of A.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. Returns 2 if some entry is too small, but not zero. Returns 1 if some entry is zero.</dd></dl>
<p>Note: It is possible to use the same argument for A and <em>this</em>. Also, if a given value of A is smaller than Epetra_DoubleMin (defined in Epetra_Epetra.h), but nonzero, then the return code is 2. If an entry is zero, the return code is 1. However, in all cases the reciprocal value is still used, even if a NaN is the result. </p>

</div>
</div>
<a id="ae9641adfac464747124c955f59474299" name="ae9641adfac464747124c955f59474299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9641adfac464747124c955f59474299">&#9670;&#160;</a></span>ReciprocalMultiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::ReciprocalMultiply </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ScalarAB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ScalarThis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply a <a class="el" href="classEpetra__MultiVector.html" title="Epetra_MultiVector: A class for constructing and using dense multi-vectors, vectors and matrices in p...">Epetra_MultiVector</a> by the reciprocal of another, element-by-element. </p>
<p>This function supports diagonal matrix scaling. A is usually a single vector while B and <em>this</em> may have one or more columns. Note that B and <em>this</em> must have the same shape. A can be one vector or have the same shape as B. The actual computation is <em>this</em> = ScalarThis * <em>this</em> + ScalarAB * B @ A where @ denotes element-wise division. </p>

</div>
</div>
<a id="af303f5ac189b48e723b5dcf44885d5ea" name="af303f5ac189b48e723b5dcf44885d5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af303f5ac189b48e723b5dcf44885d5ea">&#9670;&#160;</a></span>ReplaceGlobalValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::ReplaceGlobalValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>GlobalBlockRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>BlockRowOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>VectorIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ScalarValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace current value at the specified (GlobalBlockRow, BlockRowOffset, VectorIndex) location with ScalarValue. </p>
<p>Replaces the existing value for a single entry in the multivector. The specified global block row and block row offset must correspond to a GID owned by the map of the multivector on the calling processor. In other words, this method does not perform cross-processor communication.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>GlobalBlockRow - BlockRow of Multivector to modify in global index space. </td></tr>
    <tr><td class="paramname">In</td><td>BlockRowOffset - Offset into BlockRow of Multivector to modify in global index space. </td></tr>
    <tr><td class="paramname">In</td><td>VectorIndex - Vector within MultiVector that should to modify. </td></tr>
    <tr><td class="paramname">In</td><td>ScalarValue - Value to add to existing value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful, set to 1 if GlobalRow not associated with calling processor set to -1 if VectorIndex &gt;= <a class="el" href="classEpetra__MultiVector.html#a1d29dedcbf070b11dfda5eb043c90b85" title="Returns the number of vectors in the multi-vector.">NumVectors()</a>, set to -2 if BlockRowOffset is out-of-range. </dd></dl>

</div>
</div>
<a id="a74947cc0e0550e2f8c1c03b0135e263a" name="a74947cc0e0550e2f8c1c03b0135e263a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74947cc0e0550e2f8c1c03b0135e263a">&#9670;&#160;</a></span>ReplaceGlobalValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::ReplaceGlobalValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>GlobalRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>VectorIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ScalarValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace current value at the specified (GlobalRow, VectorIndex) location with ScalarValue. </p>
<p>Replaces the existing value for a single entry in the multivector. The specified global row must correspond to a GID owned by the map of the multivector on the calling processor. In other words, this method does not perform cross-processor communication.</p>
<p>If the map associated with this multivector is an <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a>, only the first point entry associated with the global row will be modified. To modify a different point entry, use the other version of this method</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>GlobalRow - Row of Multivector to modify in global index space. </td></tr>
    <tr><td class="paramname">In</td><td>VectorIndex - Vector within MultiVector that should to modify. </td></tr>
    <tr><td class="paramname">In</td><td>ScalarValue - Value to add to existing value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful, set to 1 if GlobalRow not associated with calling processor set to -1 if VectorIndex &gt;= <a class="el" href="classEpetra__MultiVector.html#a1d29dedcbf070b11dfda5eb043c90b85" title="Returns the number of vectors in the multi-vector.">NumVectors()</a>. </dd></dl>

</div>
</div>
<a id="af1981df3338e57ffa7b6575c7ded6e1e" name="af1981df3338e57ffa7b6575c7ded6e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1981df3338e57ffa7b6575c7ded6e1e">&#9670;&#160;</a></span>ReplaceMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::ReplaceMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEpetra__BlockMap.html">Epetra_BlockMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace map, only if new map has same point-structure as current map. return 0 if map is replaced, -1 if not. </p>

</div>
</div>
<a id="a7ff1175fcfdd9c534364d30e84c7a510" name="a7ff1175fcfdd9c534364d30e84c7a510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff1175fcfdd9c534364d30e84c7a510">&#9670;&#160;</a></span>ReplaceMyValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::ReplaceMyValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MyBlockRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>BlockRowOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>VectorIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ScalarValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace current value at the specified (MyBlockRow, BlockRowOffset, VectorIndex) location with ScalarValue. </p>
<p>Replaces the existing value for a single entry in the multivector. The specified local block row and block row offset must correspond to a GID owned by the map of the multivector on the calling processor. In other words, this method does not perform cross-processor communication.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>MyBlockRow - BlockRow of Multivector to modify in local index space. </td></tr>
    <tr><td class="paramname">In</td><td>BlockRowOffset - Offset into BlockRow of Multivector to modify in local index space. </td></tr>
    <tr><td class="paramname">In</td><td>VectorIndex - Vector within MultiVector that should to modify. </td></tr>
    <tr><td class="paramname">In</td><td>ScalarValue - Value to add to existing value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful, set to 1 if MyRow not associated with calling processor set to -1 if VectorIndex &gt;= <a class="el" href="classEpetra__MultiVector.html#a1d29dedcbf070b11dfda5eb043c90b85" title="Returns the number of vectors in the multi-vector.">NumVectors()</a>, set to -2 if BlockRowOffset is out-of-range. </dd></dl>

</div>
</div>
<a id="aa3024360d5db99d0d09b91aba5a7fb14" name="aa3024360d5db99d0d09b91aba5a7fb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3024360d5db99d0d09b91aba5a7fb14">&#9670;&#160;</a></span>ReplaceMyValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::ReplaceMyValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MyRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>VectorIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ScalarValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace current value at the specified (MyRow, VectorIndex) location with ScalarValue. </p>
<p>Replaces the existing value for a single entry in the multivector. The specified local row must correspond to a GID owned by the map of the multivector on the calling processor. In other words, this method does not perform cross-processor communication.</p>
<p>This method is intended for use with vectors based on an <a class="el" href="classEpetra__Map.html" title="Epetra_Map: A class for partitioning vectors and matrices.">Epetra_Map</a>. If used on a vector based on a non-trivial <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a>, this will update only block row 0, i.e.</p>
<p><a class="el" href="classEpetra__MultiVector.html#aa3024360d5db99d0d09b91aba5a7fb14" title="Replace current value at the specified (MyRow, VectorIndex) location with ScalarValue.">Epetra_MultiVector::ReplaceMyValue</a> ( MyRow, VectorIndex, ScalarValue ) is equivalent to: <a class="el" href="classEpetra__MultiVector.html#aa3024360d5db99d0d09b91aba5a7fb14" title="Replace current value at the specified (MyRow, VectorIndex) location with ScalarValue.">Epetra_MultiVector::ReplaceMyValue</a> ( 0, MyRow, VectorIndex, ScalarValue )</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>MyRow - Row of Multivector to modify in local index space. </td></tr>
    <tr><td class="paramname">In</td><td>VectorIndex - Vector within MultiVector that should to modify. </td></tr>
    <tr><td class="paramname">In</td><td>ScalarValue - Value to add to existing value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful, set to 1 if MyRow not associated with calling processor set to -1 if VectorIndex &gt;= <a class="el" href="classEpetra__MultiVector.html#a1d29dedcbf070b11dfda5eb043c90b85" title="Returns the number of vectors in the multi-vector.">NumVectors()</a>. </dd></dl>

</div>
</div>
<a id="a5ea26a66b256ff1d75c9b3d0af70df68" name="a5ea26a66b256ff1d75c9b3d0af70df68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea26a66b256ff1d75c9b3d0af70df68">&#9670;&#160;</a></span>ResetView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::ResetView </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>ArrayOfPointers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the view of an existing multivector to point to new user data. </p>
<p>Allows the (very) light-weight replacement of multivector values for an existing multivector that was constructed using an Epetra_DataAccess mode of View. No checking is performed to see if the array of values passed in contains valid data. It is assumed that the user has verified the integrity of data before calling this method. This method is useful for situations where a multivector is needed for use with an Epetra operator or matrix and the user is not passing in a multivector, or the multivector is being passed in with another map that is not exactly compatible with the operator, but has the correct number of entries.</p>
<p>This method is used by AztecOO and Ifpack in the matvec, and solve methods to improve performance and reduce repeated calls to constructors and destructors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ArrayOfPointers</td><td>Contains the array of pointers containing the multivector data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful, -1 if the multivector was not created as a View.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method is extremely dangerous and should only be used by experts. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classEpetra__Vector.html#a65e5d2d7669ad8a428ac4d01321ae851">Epetra_Vector::ResetView()</a>.</p>

</div>
</div>
<a id="a98b18eb28e8bca53b5bd3f333f2880b1" name="a98b18eb28e8bca53b5bd3f333f2880b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b18eb28e8bca53b5bd3f333f2880b1">&#9670;&#160;</a></span>Scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::Scale </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ScalarA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace multi-vector values with scaled values of A, <em>this</em> = ScalarA*A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>ScalarA - Scale value. </td></tr>
    <tr><td class="paramname">In</td><td>A - Multi-vector to copy. </td></tr>
    <tr><td class="paramname">Out</td><td><em>This</em> - Multi-vector with values overwritten by scaled values of A.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="a193b83fb1fa361a3f61a5757fce34a14" name="a193b83fb1fa361a3f61a5757fce34a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193b83fb1fa361a3f61a5757fce34a14">&#9670;&#160;</a></span>Scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::Scale </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ScalarValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scale the current values of a multi-vector, <em>this</em> = ScalarValue*<em>this</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>ScalarValue - Scale value. </td></tr>
    <tr><td class="paramname">Out</td><td><em>This</em> - Multi-vector with scaled values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="abe3fe6ef3a5a9d5b567057b75e674801" name="abe3fe6ef3a5a9d5b567057b75e674801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3fe6ef3a5a9d5b567057b75e674801">&#9670;&#160;</a></span>Seed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Epetra_MultiVector::Seed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get seed from Random function. </p>
<dl class="section return"><dt>Returns</dt><dd>Current random number seed. </dd></dl>

</div>
</div>
<a id="ad251efbd05e2125090529c120c18281f" name="ad251efbd05e2125090529c120c18281f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad251efbd05e2125090529c120c18281f">&#9670;&#160;</a></span>SetSeed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::SetSeed </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>Seed_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set seed for Random function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>Seed - Should be an integer on the interval (0, 2^31-1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="af80cf18d7ae082772ff6921d20a48579" name="af80cf18d7ae082772ff6921d20a48579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80cf18d7ae082772ff6921d20a48579">&#9670;&#160;</a></span>SumIntoGlobalValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::SumIntoGlobalValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>GlobalBlockRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>BlockRowOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>VectorIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ScalarValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds ScalarValue to existing value at the specified (GlobalBlockRow, BlockRowOffset, VectorIndex) location. </p>
<p>Sums the given value into the existing value for a single entry in the multivector. The specified global block row and block row offset must correspond to a GID owned by the map of the multivector on the calling processor. In other words, this method does not perform cross-processor communication.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>GlobalBlockRow - BlockRow of Multivector to modify in global index space. </td></tr>
    <tr><td class="paramname">In</td><td>BlockRowOffset - Offset into BlockRow of Multivector to modify in global index space. </td></tr>
    <tr><td class="paramname">In</td><td>VectorIndex - Vector within MultiVector that should to modify. </td></tr>
    <tr><td class="paramname">In</td><td>ScalarValue - Value to add to existing value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful, set to 1 if GlobalRow not associated with calling processor set to -1 if VectorIndex &gt;= <a class="el" href="classEpetra__MultiVector.html#a1d29dedcbf070b11dfda5eb043c90b85" title="Returns the number of vectors in the multi-vector.">NumVectors()</a>, set to -2 if BlockRowOffset is out-of-range. </dd></dl>

</div>
</div>
<a id="a37f414bce90344534f2cd097017e30fc" name="a37f414bce90344534f2cd097017e30fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f414bce90344534f2cd097017e30fc">&#9670;&#160;</a></span>SumIntoGlobalValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::SumIntoGlobalValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>GlobalRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>VectorIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ScalarValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds ScalarValue to existing value at the specified (GlobalRow, VectorIndex) location. </p>
<p>Sums the given value into the existing value for a single entry in the multivector. The specified global row must correspond to a GID owned by the map of the multivector on the calling processor. In other words, this method does not perform cross-processor communication.</p>
<p>If the map associated with this multivector is an <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a>, only the first point entry associated with the global row will be modified. To modify a different point entry, use the other version of this method</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>GlobalRow - Row of Multivector to modify in global index space. </td></tr>
    <tr><td class="paramname">In</td><td>VectorIndex - Vector within MultiVector that should to modify. </td></tr>
    <tr><td class="paramname">In</td><td>ScalarValue - Value to add to existing value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful, set to 1 if GlobalRow not associated with calling processor set to -1 if VectorIndex &gt;= <a class="el" href="classEpetra__MultiVector.html#a1d29dedcbf070b11dfda5eb043c90b85" title="Returns the number of vectors in the multi-vector.">NumVectors()</a>. </dd></dl>

</div>
</div>
<a id="a0dd0c020618f032772bd33e15338f39e" name="a0dd0c020618f032772bd33e15338f39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd0c020618f032772bd33e15338f39e">&#9670;&#160;</a></span>SumIntoMyValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::SumIntoMyValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MyBlockRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>BlockRowOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>VectorIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ScalarValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds ScalarValue to existing value at the specified (MyBlockRow, BlockRowOffset, VectorIndex) location. </p>
<p>Sums the given value into the existing value for a single entry in the multivector. The specified local block row and block row offset must correspond to a GID owned by the map of the multivector on the calling processor. In other words, this method does not perform cross-processor communication.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>MyBlockRow - BlockRow of Multivector to modify in local index space. </td></tr>
    <tr><td class="paramname">In</td><td>BlockRowOffset - Offset into BlockRow of Multivector to modify in local index space. </td></tr>
    <tr><td class="paramname">In</td><td>VectorIndex - Vector within MultiVector that should to modify. </td></tr>
    <tr><td class="paramname">In</td><td>ScalarValue - Value to add to existing value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful, set to 1 if MyRow not associated with calling processor set to -1 if VectorIndex &gt;= <a class="el" href="classEpetra__MultiVector.html#a1d29dedcbf070b11dfda5eb043c90b85" title="Returns the number of vectors in the multi-vector.">NumVectors()</a>, set to -2 if BlockRowOffset is out-of-range. </dd></dl>

</div>
</div>
<a id="ab7148321d9b58e03d17fbb4318fe11c6" name="ab7148321d9b58e03d17fbb4318fe11c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7148321d9b58e03d17fbb4318fe11c6">&#9670;&#160;</a></span>SumIntoMyValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::SumIntoMyValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MyRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>VectorIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ScalarValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds ScalarValue to existing value at the specified (MyRow, VectorIndex) location. </p>
<p>Sums the given value into the existing value for a single entry in the multivector. The specified local row must correspond to a GID owned by the map of the multivector on the calling processor. In other words, this method does not perform cross-processor communication.</p>
<p>If the map associated with this multivector is an <a class="el" href="classEpetra__BlockMap.html" title="Epetra_BlockMap: A class for partitioning block element vectors and matrices.">Epetra_BlockMap</a>, only the first point entry associated with the local row will be modified. To modify a different point entry, use the other version of this method</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>MyRow - Row of Multivector to modify in local index space. </td></tr>
    <tr><td class="paramname">In</td><td>VectorIndex - Vector within MultiVector that should to modify. </td></tr>
    <tr><td class="paramname">In</td><td>ScalarValue - Value to add to existing value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful, set to 1 if MyRow not associated with calling processor set to -1 if VectorIndex &gt;= <a class="el" href="classEpetra__MultiVector.html#a1d29dedcbf070b11dfda5eb043c90b85" title="Returns the number of vectors in the multi-vector.">NumVectors()</a>. </dd></dl>

</div>
</div>
<a id="ac73cd3a0b875cbd1424d35512c307873" name="ac73cd3a0b875cbd1424d35512c307873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac73cd3a0b875cbd1424d35512c307873">&#9670;&#160;</a></span>Update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::Update </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ScalarA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ScalarB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ScalarThis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update multi-vector with scaled values of A and B, <em>this</em> = ScalarThis*<em>this</em> + ScalarA*A + ScalarB*B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>ScalarA - Scale value for A. </td></tr>
    <tr><td class="paramname">In</td><td>A - Multi-vector to add. </td></tr>
    <tr><td class="paramname">In</td><td>ScalarB - Scale value for B. </td></tr>
    <tr><td class="paramname">In</td><td>B - Multi-vector to add. </td></tr>
    <tr><td class="paramname">In</td><td>ScalarThis - Scale value for <em>this</em>. </td></tr>
    <tr><td class="paramname">Out</td><td><em>This</em> - Multi-vector with updatede values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<a id="a9d117790b9fef51615bda948baf4b503" name="a9d117790b9fef51615bda948baf4b503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d117790b9fef51615bda948baf4b503">&#9670;&#160;</a></span>Update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Epetra_MultiVector::Update </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ScalarA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEpetra__MultiVector.html">Epetra_MultiVector</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ScalarThis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update multi-vector values with scaled values of A, <em>this</em> = ScalarThis*<em>this</em> + ScalarA*A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">In</td><td>ScalarA - Scale value for A. </td></tr>
    <tr><td class="paramname">In</td><td>A - Multi-vector to add. </td></tr>
    <tr><td class="paramname">In</td><td>ScalarThis - Scale value for <em>this</em>. </td></tr>
    <tr><td class="paramname">Out</td><td><em>This</em> - Multi-vector with updatede values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer error code, set to 0 if successful. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><b>Epetra_MultiVector.h</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 9 2025 20:37:14 for Epetra by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
